From 2091846905ad689e1919aafb41e176b855dd8e2f Mon Sep 17 00:00:00 2001
From: Taku Imaizumi <taku.imaizumi.bx@bp.renesas.com>
Date: Tue, 27 Oct 2015 21:05:37 +0900
Subject: [PATCH] add bl2 bl31 R-Car support

---
 Makefile                                        |   18 +-
 bl2/bl2.ld.S                                    |   11 +
 bl31/aarch64/bl31_entrypoint.S                  |   16 +-
 bl31/bl31.ld.S                                  |    4 +
 common/auth/rcar/rcar.mk                        |   34 +
 common/auth/rcar/rcarboot.c                     |  157 ++
 common/auth/rcar/rcarboot.h                     |   41 +
 common/tf_printf.c                              |    7 +
 include/lib/mmio.h                              |   12 +
 plat/renesas/rcar/aarch64/bl2_reset.S           |  426 +++
 plat/renesas/rcar/aarch64/rcar_common.c         |  262 ++
 plat/renesas/rcar/aarch64/rcar_helpers.S        |  379 +++
 plat/renesas/rcar/bl2_cpg_init.c                |  104 +
 plat/renesas/rcar/bl2_pfc_init.c                | 1398 +++++++++
 plat/renesas/rcar/bl2_phy_init.c                | 3452 +++++++++++++++++++++++
 plat/renesas/rcar/bl2_qos_init.c                |  614 ++++
 plat/renesas/rcar/bl2_rcar_setup.c              |  378 +++
 plat/renesas/rcar/bl2_sdram_init.c              | 2275 +++++++++++++++
 plat/renesas/rcar/bl2_secure_setting.c          |  468 +++
 plat/renesas/rcar/bl31_rcar_setup.c             |  269 ++
 plat/renesas/rcar/ddr/boot_init_dram.c          | 3371 ++++++++++++++++++++++
 plat/renesas/rcar/ddr/boot_init_dram.h          |   38 +
 plat/renesas/rcar/ddr/init_dram_tbl.h           | 1383 +++++++++
 plat/renesas/rcar/drivers/dma/dma_driver.c      |  193 ++
 plat/renesas/rcar/drivers/io/io_memdrv.c        |  237 ++
 plat/renesas/rcar/drivers/io/io_rcar.c          |  596 ++++
 plat/renesas/rcar/drivers/memdrv/rcar_console.S |   98 +
 plat/renesas/rcar/drivers/memdrv/rcar_printf.c  |  174 ++
 plat/renesas/rcar/drivers/memdrv/rcar_printf.h  |   43 +
 plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c      |  268 ++
 plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h      |   81 +
 plat/renesas/rcar/drivers/rpc/rpc_driver.c      |   83 +
 plat/renesas/rcar/drivers/scif/scif.S           |  198 ++
 plat/renesas/rcar/include/bl2_axi_register.h    |  272 ++
 plat/renesas/rcar/include/bl2_cpg_init.h        |   37 +
 plat/renesas/rcar/include/bl2_cpg_register.h    |  161 ++
 plat/renesas/rcar/include/bl2_cpg_write.h       |   45 +
 plat/renesas/rcar/include/bl2_dma_register.h    |   67 +
 plat/renesas/rcar/include/bl2_lifec_register.h  |  305 ++
 plat/renesas/rcar/include/bl2_pfc_init.h        |   37 +
 plat/renesas/rcar/include/bl2_phy_init.h        |  273 ++
 plat/renesas/rcar/include/bl2_qos_init.h        |   37 +
 plat/renesas/rcar/include/bl2_rpc_register.h    |   68 +
 plat/renesas/rcar/include/bl2_sdram_init.h      |   37 +
 plat/renesas/rcar/include/bl2_secure_setting.h  |   37 +
 plat/renesas/rcar/include/dma_driver.h          |   49 +
 plat/renesas/rcar/include/io_common.h           |   39 +
 plat/renesas/rcar/include/io_memdrv.h           |   39 +
 plat/renesas/rcar/include/io_rcar.h             |   39 +
 plat/renesas/rcar/include/plat_macros.S         |  105 +
 plat/renesas/rcar/include/platform.h            |  199 ++
 plat/renesas/rcar/include/platform_def.h        |  231 ++
 plat/renesas/rcar/include/rpc_driver.h          |   46 +
 plat/renesas/rcar/include/scif.h                |  145 +
 plat/renesas/rcar/platform.mk                   |  113 +
 plat/renesas/rcar/rcar_def.h                    |  257 ++
 plat/renesas/rcar/rcar_io_storage.c             |  327 +++
 plat/renesas/rcar/rcar_pm.c                     |  376 +++
 plat/renesas/rcar/rcar_private.h                |  162 ++
 plat/renesas/rcar/rcar_topology.c               |  223 ++
 plat/renesas/rcar/rcar_version.h                |   42 +
 tools/dummy_create/makefile                     |  103 +
 tools/dummy_create/sa0.c                        |   39 +
 tools/dummy_create/sa0.ld.S                     |   42 +
 tools/dummy_create/sa6.c                        |   51 +
 tools/dummy_create/sa6.ld.S                     |   52 +
 66 files changed, 21128 insertions(+), 15 deletions(-)
 create mode 100644 common/auth/rcar/rcar.mk
 create mode 100644 common/auth/rcar/rcarboot.c
 create mode 100644 common/auth/rcar/rcarboot.h
 create mode 100644 plat/renesas/rcar/aarch64/bl2_reset.S
 create mode 100644 plat/renesas/rcar/aarch64/rcar_common.c
 create mode 100644 plat/renesas/rcar/aarch64/rcar_helpers.S
 create mode 100644 plat/renesas/rcar/bl2_cpg_init.c
 create mode 100644 plat/renesas/rcar/bl2_pfc_init.c
 create mode 100644 plat/renesas/rcar/bl2_phy_init.c
 create mode 100644 plat/renesas/rcar/bl2_qos_init.c
 create mode 100644 plat/renesas/rcar/bl2_rcar_setup.c
 create mode 100644 plat/renesas/rcar/bl2_sdram_init.c
 create mode 100644 plat/renesas/rcar/bl2_secure_setting.c
 create mode 100644 plat/renesas/rcar/bl31_rcar_setup.c
 create mode 100644 plat/renesas/rcar/ddr/boot_init_dram.c
 create mode 100644 plat/renesas/rcar/ddr/boot_init_dram.h
 create mode 100644 plat/renesas/rcar/ddr/init_dram_tbl.h
 create mode 100644 plat/renesas/rcar/drivers/dma/dma_driver.c
 create mode 100644 plat/renesas/rcar/drivers/io/io_memdrv.c
 create mode 100644 plat/renesas/rcar/drivers/io/io_rcar.c
 create mode 100644 plat/renesas/rcar/drivers/memdrv/rcar_console.S
 create mode 100644 plat/renesas/rcar/drivers/memdrv/rcar_printf.c
 create mode 100644 plat/renesas/rcar/drivers/memdrv/rcar_printf.h
 create mode 100644 plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
 create mode 100644 plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h
 create mode 100644 plat/renesas/rcar/drivers/rpc/rpc_driver.c
 create mode 100644 plat/renesas/rcar/drivers/scif/scif.S
 create mode 100644 plat/renesas/rcar/include/bl2_axi_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_cpg_init.h
 create mode 100644 plat/renesas/rcar/include/bl2_cpg_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_cpg_write.h
 create mode 100644 plat/renesas/rcar/include/bl2_dma_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_lifec_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_pfc_init.h
 create mode 100644 plat/renesas/rcar/include/bl2_phy_init.h
 create mode 100644 plat/renesas/rcar/include/bl2_qos_init.h
 create mode 100644 plat/renesas/rcar/include/bl2_rpc_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_sdram_init.h
 create mode 100644 plat/renesas/rcar/include/bl2_secure_setting.h
 create mode 100644 plat/renesas/rcar/include/dma_driver.h
 create mode 100644 plat/renesas/rcar/include/io_common.h
 create mode 100644 plat/renesas/rcar/include/io_memdrv.h
 create mode 100644 plat/renesas/rcar/include/io_rcar.h
 create mode 100644 plat/renesas/rcar/include/plat_macros.S
 create mode 100644 plat/renesas/rcar/include/platform.h
 create mode 100644 plat/renesas/rcar/include/platform_def.h
 create mode 100644 plat/renesas/rcar/include/rpc_driver.h
 create mode 100644 plat/renesas/rcar/include/scif.h
 create mode 100644 plat/renesas/rcar/platform.mk
 create mode 100644 plat/renesas/rcar/rcar_def.h
 create mode 100644 plat/renesas/rcar/rcar_io_storage.c
 create mode 100644 plat/renesas/rcar/rcar_pm.c
 create mode 100644 plat/renesas/rcar/rcar_private.h
 create mode 100644 plat/renesas/rcar/rcar_topology.c
 create mode 100644 plat/renesas/rcar/rcar_version.h
 create mode 100644 tools/dummy_create/makefile
 create mode 100644 tools/dummy_create/sa0.c
 create mode 100644 tools/dummy_create/sa0.ld.S
 create mode 100644 tools/dummy_create/sa6.c
 create mode 100644 tools/dummy_create/sa6.ld.S

diff --git a/Makefile b/Makefile
index d38a283..0e6d399 100644
--- a/Makefile
+++ b/Makefile
@@ -306,6 +306,11 @@ CRTTOOLPATH		?=	tools/cert_create
 CRTTOOL			?=	${CRTTOOLPATH}/cert_create
 certtool:		${CRTTOOL}
 
+# Dummy Image Create
+DUMMYTOOLPATH		?=	tools/dummy_create
+DUMMYTOOL		?=	${DUMMYTOOLPATH}/dummy_create
+dummytool:		${DUMMYTOOL}
+
 # CoT generation tool default parameters
 TRUSTED_KEY_CERT	:=	${BUILD_PLAT}/trusted_key.crt
 
@@ -362,6 +367,7 @@ clean:
 			${Q}rm -rf ${BUILD_PLAT}
 			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH} clean
 			${Q}${MAKE} PLAT=${PLAT} --no-print-directory -C ${CRTTOOLPATH} clean
+			${Q}${MAKE} -C ${DUMMYTOOLPATH} clean
 
 realclean distclean:
 			@echo "  REALCLEAN"
@@ -369,6 +375,7 @@ realclean distclean:
 			${Q}rm -f ${CURDIR}/cscope.*
 			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH} clean
 			${Q}${MAKE} PLAT=${PLAT} --no-print-directory -C ${CRTTOOLPATH} clean
+			${Q}${MAKE} -C ${DUMMYTOOLPATH} clean
 
 checkcodebase:		locate-checkpatch
 			@echo "  CHECKING STYLE"
@@ -393,6 +400,10 @@ ${CRTTOOL}:
 ${FIPTOOL}:
 			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH}
 
+.PHONY: ${DUMMYTOOL}
+${DUMMYTOOL}:
+			${Q}${MAKE} -C ${DUMMYTOOLPATH}
+
 define match_goals
 $(strip $(foreach goal,$(1),$(filter $(goal),$(MAKECMDGOALS))))
 endef
@@ -531,6 +542,7 @@ define MAKE_BL
 	$(eval ELF        := $(BUILD_DIR)/bl$(1).elf)
 	$(eval DUMP       := $(BUILD_DIR)/bl$(1).dump)
 	$(eval BIN        := $(BUILD_PLAT)/bl$(1).bin)
+	$(eval SREC       := $(BUILD_PLAT)/bl$(1).srec)
 
 	$(eval $(call MAKE_OBJS,$(BUILD_DIR),$(SOURCES),$(1)))
 	$(eval $(call MAKE_LD,$(LINKERFILE),$(BL$(1)_LINKERFILE)))
@@ -557,8 +569,12 @@ $(BIN) : $(ELF)
 	@echo "Built $$@ successfully"
 	@echo
 
+$(SREC) : $(ELF)
+	@echo "  SREC    $$@"
+	$$(Q)$$(OC) -O srec $$< $$@
+
 .PHONY : bl$(1)
-bl$(1) : $(BUILD_DIR) $(BIN) $(DUMP)
+bl$(1) : $(BUILD_DIR) $(SREC) $(BIN) $(DUMP)
 
 all : bl$(1)
 
diff --git a/bl2/bl2.ld.S b/bl2/bl2.ld.S
index 9933339..41f1350 100644
--- a/bl2/bl2.ld.S
+++ b/bl2/bl2.ld.S
@@ -32,7 +32,11 @@
 
 OUTPUT_FORMAT(PLATFORM_LINKER_FORMAT)
 OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
+#if PLAT_rcar
+ENTRY(bl2_reset)
+#else
 ENTRY(bl2_entrypoint)
+#endif
 
 MEMORY {
     RAM (rwx): ORIGIN = BL2_BASE, LENGTH = BL2_LIMIT - BL2_BASE
@@ -47,7 +51,14 @@ SECTIONS
 
     ro . : {
         __RO_START__ = .;
+#if PLAT_rcar
+        *bl2_reset.o(.text*)
+#endif
         *bl2_entrypoint.o(.text*)
+#if PLAT_rcar
+        . = NEXT(ALIGN_VERSION);
+	*rcar_common.o(.version*)
+#endif
         *(.text*)
         *(.rodata*)
         *(.vectors)
diff --git a/bl31/aarch64/bl31_entrypoint.S b/bl31/aarch64/bl31_entrypoint.S
index 1777d26..c12d687 100644
--- a/bl31/aarch64/bl31_entrypoint.S
+++ b/bl31/aarch64/bl31_entrypoint.S
@@ -44,8 +44,7 @@
 func bl31_entrypoint
 	/* ---------------------------------------------------------------
 	 * Preceding bootloader has populated x0 with a pointer to a
-	 * 'bl31_params' structure & x1 with a pointer to platform
-	 * specific structure
+	 * 'bl31_params' structure & x1 to boot parameter
 	 * ---------------------------------------------------------------
 	 */
 #if !RESET_TO_BL31
@@ -63,17 +62,6 @@ func bl31_entrypoint
 	isb
 #endif
 
-	/* ---------------------------------------------
-	 * When RESET_TO_BL31 is true, perform any
-	 * processor specific actions upon reset e.g.
-	 * cache, tlb invalidations, errata workarounds
-	 * etc.
-	 * When RESET_TO_BL31 is false, perform any
-	 * processor specific actions which undo or are
-	 * in addition to the actions performed by the
-	 * reset handler in the Boot ROM (BL1).
-	 * ---------------------------------------------
-	 */
 	bl	reset_handler
 
 	/* ---------------------------------------------
@@ -136,7 +124,7 @@ func bl31_entrypoint
 	bic	w1, w1, #TFP_BIT
 	msr	cptr_el3, x1
 
-#if RESET_TO_BL31
+#if RESET_TO_BL31 || PLAT_rcar
 	/* -------------------------------------------------------
 	 * Will not return from this macro if it is a warm boot.
 	 * -------------------------------------------------------
diff --git a/bl31/bl31.ld.S b/bl31/bl31.ld.S
index 3327f31..089b31f 100644
--- a/bl31/bl31.ld.S
+++ b/bl31/bl31.ld.S
@@ -49,6 +49,10 @@ SECTIONS
     ro . : {
         __RO_START__ = .;
         *bl31_entrypoint.o(.text*)
+#if PLAT_rcar
+        . = NEXT(ALIGN_VERSION);
+        *rcar_common.o(.version*)
+#endif
         *(.text*)
         *(.rodata*)
 
diff --git a/common/auth/rcar/rcar.mk b/common/auth/rcar/rcar.mk
new file mode 100644
index 0000000..c2271e1
--- /dev/null
+++ b/common/auth/rcar/rcar.mk
@@ -0,0 +1,34 @@
+#
+# Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# Redistributions of source code must retain the above copyright notice, this
+# list of conditions and the following disclaimer.
+#
+# Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation
+# and/or other materials provided with the distribution.
+#
+# Neither the name of ARM nor the names of its contributors may be used
+# to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+
+BL2_SOURCES		+=	${RCARBOOT_SOURCES} 			\
+				common/auth/rcar/rcarboot.c
+
diff --git a/common/auth/rcar/rcarboot.c b/common/auth/rcar/rcarboot.c
new file mode 100644
index 0000000..48271c6
--- /dev/null
+++ b/common/auth/rcar/rcarboot.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stddef.h>
+
+#include <assert.h>
+#include <auth.h>
+#include <debug.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <mmio.h>
+
+#include "rcarboot.h"
+
+#if MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+#define RCAR_BOOT_KEY_CERT	(0xE6300C00U)
+#elif MASTER_BOOT_CPU == RCAR_BOOT_CR7
+#define RCAR_BOOT_KEY_CERT	(0xE6300400U)
+#endif
+#define RCAR_SBROM_API		(0xeb10dd64U)
+#define	RST_BASE		(0xE6160000U)
+#define	RST_MODEMR		(RST_BASE + 0x0060U)
+#define LIFEC_CC_LCS		(0xE6110028U)		/* cc_lcs  Life cycle state read */
+#define	MFISSOFTMDR		(0xE6260600U)		/* SOFTMD register */
+
+static SECURE_BOOT_API	sbrom_SecureBootAPI;
+
+static int32_t rcarboot_mod_verify(uint32_t id, uintptr_t obj, size_t len);
+static int32_t rcarboot_mod_init(void);
+#if !RCAR_SECURE_BOOT
+static int32_t local_verify(uint32_t a, uint32_t b, void *c);
+#endif
+
+/*
+ * Object verification function
+ *
+ * The id parameter will indicate the expected format of the object
+ * (certificate, image, etc).
+ *
+ * Return: 0 = success, Otherwise = error
+ */
+static int32_t rcarboot_mod_verify(uint32_t id, uintptr_t obj, size_t len)
+{
+	int32_t ret = 0;
+	uint32_t cert_addr;
+
+	switch (id) {
+#if IMAGE_BL2
+	case (uint32_t)AUTH_TRUSTED_KEY_CERT:
+	case (uint32_t)AUTH_BL31_KEY_CERT:
+	case (uint32_t)AUTH_BL32_KEY_CERT:
+	case (uint32_t)AUTH_BL33_KEY_CERT:
+	case (uint32_t)AUTH_BL31_IMG_CERT:
+	case (uint32_t)AUTH_BL32_IMG_CERT:
+	case (uint32_t)AUTH_BL33_IMG_CERT:
+		/* no check */
+		break;
+	case (uint32_t)AUTH_BL31_IMG:
+		ret = file_to_cert((const int8_t *)BL31_CERT_NAME, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+		}
+		break;
+	case (uint32_t)AUTH_BL32_IMG:
+		ret = file_to_cert((const int8_t *)BL32_CERT_NAME, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+		}
+		break;
+	case (uint32_t)AUTH_BL33_IMG:
+		ret = file_to_cert((const int8_t *)BL33_CERT_NAME, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+		}
+		break;
+#endif /* IMAGE_BL2 */
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+static int32_t local_verify(uint32_t a, uint32_t b, void *c)
+{
+	return 0;
+}
+
+/*
+ * Module initialization function
+ *
+ * Return: 0 = success, Otherwise = error
+ */
+static int32_t rcarboot_mod_init(void)
+{
+#if RCAR_SECURE_BOOT
+	uint32_t lcs = (mmio_read_32(LIFEC_CC_LCS) & 0x000000F0U) >> 4;
+	uint32_t md = (mmio_read_32(RST_MODEMR) & 0x00000020U) >> 5;
+	uint32_t softmd = (mmio_read_32(MFISSOFTMDR) & 0x00000001U);
+
+	/* default is Secure boot */
+	sbrom_SecureBootAPI = (SECURE_BOOT_API)RCAR_SBROM_API;
+
+	if (lcs == 0x5U) { /* LCS=Secure */
+		if (softmd == 0x1U) {
+			sbrom_SecureBootAPI = &local_verify; /* LCS=Secure + Normal boot (temp setting) */
+		}  /* else is LCS=Secure + Secure boot */
+	} else if (md != 0U) {
+		sbrom_SecureBootAPI = &local_verify; /* MD5=1 => LCS=CM/DM + Normal boot */
+	} /* else is MD5=0 => LCS=CM/DM + Secure boot */
+
+	if (sbrom_SecureBootAPI == &local_verify) {
+		NOTICE("BL2: Normal boot\n");
+	} else {
+		NOTICE("BL2: Secure boot\n");
+	}
+#else
+	sbrom_SecureBootAPI = &local_verify;
+	NOTICE("BL2: Normal boot\n");
+#endif
+	return 0;
+}
+
+const auth_mod_t auth_mod = {
+	.name = "RCarSecureBoot",
+	.init = &rcarboot_mod_init,
+	.verify = &rcarboot_mod_verify
+};
diff --git a/common/auth/rcar/rcarboot.h b/common/auth/rcar/rcarboot.h
new file mode 100644
index 0000000..61f51ea
--- /dev/null
+++ b/common/auth/rcar/rcarboot.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_RCARBOOT_H_
+#define RCAR_RCARBOOT_H_
+
+/* Define */
+typedef int32_t (*SECURE_BOOT_API)(uint32_t a, uint32_t b, void *c);
+
+/* Prototype */
+extern int32_t file_to_cert(const int8_t *filename, uint32_t *cert_addr);
+
+#endif /* RCAR_RCARBOOT_H_ */
diff --git a/common/tf_printf.c b/common/tf_printf.c
index c68b990..f48290e 100644
--- a/common/tf_printf.c
+++ b/common/tf_printf.c
@@ -31,6 +31,9 @@
 #include <stdarg.h>
 #include <stdint.h>
 
+#if (IMAGE_BL31 && PLAT_rcar)
+extern void	rcar_set_log_time(void);
+#endif
 /***********************************************************
  * The tf_printf implementation for all BL stages
  ***********************************************************/
@@ -79,6 +82,10 @@ void tf_printf(const char *fmt, ...)
 	uint64_t unum;
 	char *str;
 
+#if (IMAGE_BL31 && PLAT_rcar)
+	rcar_set_log_time();
+#endif
+
 	va_start(args, fmt);
 	while (*fmt) {
 		bit64 = 0;
diff --git a/include/lib/mmio.h b/include/lib/mmio.h
index cb37a1c..bae901a 100644
--- a/include/lib/mmio.h
+++ b/include/lib/mmio.h
@@ -43,6 +43,18 @@ static inline uint8_t mmio_read_8(uintptr_t addr)
 	return *(volatile uint8_t*)addr;
 }
 
+#if PLAT_rcar
+static inline void mmio_write_16(uintptr_t addr, uint16_t value)
+{
+	*(volatile uint16_t*)addr = value;
+}
+
+static inline uint16_t mmio_read_16(uintptr_t addr)
+{
+	return *(volatile uint16_t*)addr;
+}
+
+#endif
 static inline void mmio_write_32(uintptr_t addr, uint32_t value)
 {
 	*(volatile uint32_t*)addr = value;
diff --git a/plat/renesas/rcar/aarch64/bl2_reset.S b/plat/renesas/rcar/aarch64/bl2_reset.S
new file mode 100644
index 0000000..001ca94
--- /dev/null
+++ b/plat/renesas/rcar/aarch64/bl2_reset.S
@@ -0,0 +1,426 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <bl_common.h>
+#include <runtime_svc.h>
+#include "platform_def.h"
+
+
+#define	RST_BASE		(0xE6160000)
+#define	RST_CA53BAR2		(0x0034)
+#define	RST_CA57BAR2		(0x0024)
+#define	RST_CA53CPU0BARH	(0x0080)
+#define	RST_CA53CPU0BARL	(0x0084)
+#define	RST_CA53CPU1BARH	(0x0090)
+#define	RST_CA53CPU1BARL	(0x0094)
+#define	RST_CA53CPU2BARH	(0x00A0)
+#define	RST_CA53CPU2BARL	(0x00A4)
+#define	RST_CA53CPU3BARH	(0x00B0)
+#define	RST_CA53CPU3BARL	(0x00B4)
+#define	RST_CA57CPU0BARH	(0x00C0)
+#define	RST_CA57CPU0BARL	(0x00C4)
+#define	RST_CA57CPU1BARH	(0x00D0)
+#define	RST_CA57CPU1BARL	(0x00D4)
+#define	RST_CA57CPU2BARH	(0x00E0)
+#define	RST_CA57CPU2BARL	(0x00E4)
+#define	RST_CA57CPU3BARH	(0x00F0)
+#define	RST_CA57CPU3BARL	(0x00F4)
+
+#define	RST_BAR2_MASK		(0xFFFFFC00)
+#define	RST_BAR2_BAREN		(0x00000010)
+#define	RST_BAR2_VLD		(0x00000001)
+#define	RST_BAR2_SHIFT		(18-10)
+#define RST_CPUnBARH_SHIFT	(32)
+#define	RST_CPUnBARH_MASK	(0x000000FF)
+#define	RST_CPUnBARL_MASK	(0xFFFFFFFC)
+
+
+	.global	bl2_reset
+	.global	bl2_secondly_reset
+	.global	bl2_init_secondly_reset
+
+func bl2_reset
+    mov x0,  #0
+    mov x1,  #0
+    mov x2,  #0
+    mov x3,  #0
+    mov x4,  #0
+    mov x5,  #0
+    mov x6,  #0
+    mov x7,  #0
+    mov x8,  #0
+    mov x9,  #0
+    mov x10, #0
+    mov x11, #0
+    mov x12, #0
+    mov x13, #0
+    mov x14, #0
+    mov x15, #0
+    mov x16, #0
+    mov x17, #0
+    mov x18, #0
+    mov x19, #0
+    mov x20, #0
+    mov x21, #0
+    mov x22, #0
+    mov x23, #0
+    mov x24, #0
+    mov x25, #0
+    mov x26, #0
+    mov x27, #0
+    mov x28, #0
+    mov x29, #0
+    mov x30, #0
+
+	/* ---------------------------------------------
+	 * Set the CPU endianness before doing anything
+	 * that might involve memory reads or writes.
+	 * ---------------------------------------------
+	 */
+	mrs	x0, sctlr_el3
+	bic	x0, x0, #SCTLR_EE_BIT
+	msr	sctlr_el3, x0
+	isb
+
+	/* ---------------------------------------------
+	 * Set the exception vector to something sane.
+	 * ---------------------------------------------
+	 */
+	adr	x0, bl2_exceptions
+	msr	vbar_el3, x0
+	isb
+
+	/* ---------------------------------------------------------------------
+	 * The initial state of the Architectural feature trap register
+	 * (CPTR_EL3) is unknown and it must be set to a known state. All
+	 * feature traps are disabled. Some bits in this register are marked as
+	 * Reserved and should not be modified.
+	 *
+	 * CPTR_EL3.TCPAC: This causes a direct access to the CPACR_EL1 from EL1
+	 *  or the CPTR_EL2 from EL2 to trap to EL3 unless it is trapped at EL2.
+	 * CPTR_EL3.TTA: This causes access to the Trace functionality to trap
+	 *  to EL3 when executed from EL0, EL1, EL2, or EL3. If system register
+	 *  access to trace functionality is not supported, this bit is RES0.
+	 * CPTR_EL3.TFP: This causes instructions that access the registers
+	 *  associated with Floating Point and Advanced SIMD execution to trap
+	 *  to EL3 when executed from any exception level, unless trapped to EL1
+	 *  or EL2.
+	 * ---------------------------------------------------------------------
+	 */
+	mrs	x0, cptr_el3
+	bic	w0, w0, #TCPAC_BIT
+	bic	w0, w0, #TTA_BIT
+	bic	w0, w0, #TFP_BIT
+	msr	cptr_el3, x0
+
+	/* --------------------------------------------
+	 * Allocate a stack whose memory will be marked
+	 * as Normal-IS-WBWA when the MMU is enabled.
+	 * There is no risk of reading stale stack
+	 * memory after enabling the MMU as only the
+	 * primary cpu is running at the moment.
+	 * --------------------------------------------
+	 */
+	mrs	x0, mpidr_el1
+	bl	platform_set_stack
+
+	mov	x0, #(SCR_RES1_BITS | SCR_RW_BIT)
+	msr	scr_el3, x0
+
+	bl	bl2_init_secondly_reset
+
+	ldr	x0, =bl2_entrypoint
+	msr	elr_el3, x0
+	mov	x1, #(DISABLE_ALL_EXCEPTIONS << SPSR_DAIF_SHIFT) | (MODE_RW_64 << MODE_RW_SHIFT) | (MODE_EL1 << MODE_EL_SHIFT) | (MODE_SP_ELX << MODE_SP_SHIFT)
+	msr	spsr_el3, x1
+
+	adr	x1, BL2_MEM_INFO
+	mov	x0, #RUN_IMAGE
+
+	eret
+endfunc bl2_reset
+
+
+	.align	3
+BL2_MEM_INFO:					/* meminfo_t */
+	.quad	BL31_BASE			/* total_base */
+	.quad	(BL31_LIMIT - BL31_BASE)	/* total_size */
+	.quad	BL31_BASE			/* free_base */
+	.quad	(BL31_LIMIT - BL31_BASE)	/* free_size */
+
+
+	/* ---------------------------------------------
+	 * initialize secondly boot
+	 * ---------------------------------------------
+	 */
+func bl2_init_secondly_reset
+	adr	x0, bl2_secondly_reset
+	ldr	x1, =RCAR_SECRAM_BASE
+	mov	x2, #0				/* Number of copied bytes */
+	mov	x4, #(BL2_SECONDLY_RESET - bl2_secondly_reset)
+1:
+	ldr	w3, [x0, x2]
+	str	w3, [x1, x2]			/* copy secondly boot code */
+	add	x2, x2, #4
+	cmp	x4, x2
+	b.gt	1b
+
+	/* initialize Boot Address Registers */
+	ldr	x0, =RST_BASE
+
+	ldr	w1, =(RCAR_SECRAM_BASE & RST_CPUnBARL_MASK)
+	str	w1, [x0, #RST_CA53CPU0BARL]
+	str	wzr, [x0, #RST_CA53CPU0BARH]
+	str	w1, [x0, #RST_CA53CPU1BARL]
+	str	wzr, [x0, #RST_CA53CPU1BARH]
+	str	w1, [x0, #RST_CA53CPU2BARL]
+	str	wzr, [x0, #RST_CA53CPU2BARH]
+	str	w1, [x0, #RST_CA53CPU3BARL]
+	str	wzr, [x0, #RST_CA53CPU3BARH]
+	str	w1, [x0, #RST_CA57CPU0BARL]
+	str	wzr, [x0, #RST_CA57CPU0BARH]
+	str	w1, [x0, #RST_CA57CPU1BARL]
+	str	wzr, [x0, #RST_CA57CPU1BARH]
+	str	w1, [x0, #RST_CA57CPU2BARL]
+	str	wzr, [x0, #RST_CA57CPU2BARH]
+	str	w1, [x0, #RST_CA57CPU3BARL]
+	str	wzr, [x0, #RST_CA57CPU3BARH]
+
+	ret
+endfunc bl2_init_secondly_reset
+
+
+	/* ---------------------------------------------
+	 * secondly boot
+	 * ---------------------------------------------
+	 */
+func bl2_secondly_reset
+	mrs	x0, sctlr_el3
+	bic	x0, x0, #SCTLR_EE_BIT
+	msr	sctlr_el3, x0
+	isb
+
+	mrs	x0, cptr_el3
+	bic	w0, w0, #TCPAC_BIT
+	bic	w0, w0, #TTA_BIT
+	bic	w0, w0, #TFP_BIT
+	msr	cptr_el3, x0
+
+	mov_imm	x0, PARAMS_BASE			/* pointer to bl31_ep_info */
+	mov_imm	x2, BL31_BASE
+	mov x1, #0x00000001			/* warm boot */
+	br	x2				/* jump to BL31 */
+	nop
+	nop
+	nop
+BL2_SECONDLY_RESET:
+endfunc bl2_secondly_reset
+
+
+
+	.section	.vectors, "ax"; .align 11
+
+	/* -----------------------------------------------------
+	 * Very simple stackless exception handlers used by BL1.
+	 * -----------------------------------------------------
+	 */
+	.align	7
+bl2_exceptions:
+	/* -----------------------------------------------------
+	 * Current EL with SP0 : 0x0 - 0x200
+	 * -----------------------------------------------------
+	 */
+SynchronousExceptionSP0:
+	mov	x0, #SYNC_EXCEPTION_SP_EL0
+	bl	plat_report_exception
+	b	SynchronousExceptionSP0
+	check_vector_size SynchronousExceptionSP0
+
+	.align	7
+IrqSP0:
+	mov	x0, #IRQ_SP_EL0
+	bl	plat_report_exception
+	b	IrqSP0
+	check_vector_size IrqSP0
+
+	.align	7
+FiqSP0:
+	mov	x0, #FIQ_SP_EL0
+	bl	plat_report_exception
+	b	FiqSP0
+	check_vector_size FiqSP0
+
+	.align	7
+SErrorSP0:
+	mov	x0, #SERROR_SP_EL0
+	bl	plat_report_exception
+	b	SErrorSP0
+	check_vector_size SErrorSP0
+
+	/* -----------------------------------------------------
+	 * Current EL with SPx: 0x200 - 0x400
+	 * -----------------------------------------------------
+	 */
+	.align	7
+SynchronousExceptionSPx:
+	mov	x0, #SYNC_EXCEPTION_SP_ELX
+	bl	plat_report_exception
+	b	SynchronousExceptionSPx
+	check_vector_size SynchronousExceptionSPx
+
+	.align	7
+IrqSPx:
+	mov	x0, #IRQ_SP_ELX
+	bl	plat_report_exception
+	b	IrqSPx
+	check_vector_size IrqSPx
+
+	.align	7
+FiqSPx:
+	mov	x0, #FIQ_SP_ELX
+	bl	plat_report_exception
+	b	FiqSPx
+	check_vector_size FiqSPx
+
+	.align	7
+SErrorSPx:
+	mov	x0, #SERROR_SP_ELX
+	bl	plat_report_exception
+	b	SErrorSPx
+	check_vector_size SErrorSPx
+
+	/* -----------------------------------------------------
+	 * Lower EL using AArch64 : 0x400 - 0x600
+	 * -----------------------------------------------------
+	 */
+	.align	7
+SynchronousExceptionA64:
+	/* Enable the SError interrupt */
+	msr	daifclr, #DAIF_ABT_BIT
+
+	/* ------------------------------------------------
+	 * Only a single SMC exception from BL2 to ask
+	 * BL1 to pass EL3 control to BL31 is expected
+	 * here.
+	 * It expects X0 with RUN_IMAGE SMC function id
+	 * X1 with address of a entry_point_info_t structure
+	 * describing the BL3-1 entrypoint
+	 * ------------------------------------------------
+	 */
+	mov	x19, x0
+	mov	x20, x1
+
+	mrs	x0, esr_el3
+	ubfx	x1, x0, #ESR_EC_SHIFT, #ESR_EC_LENGTH
+	cmp	x1, #EC_AARCH64_SMC
+	b.ne	panic
+
+	mov	x0, #RUN_IMAGE
+	cmp	x19, x0
+	b.ne	panic
+
+	mov	x0, x20
+	ldp	x0, x1, [x20, #ENTRY_POINT_INFO_PC_OFFSET]
+	msr	elr_el3, x0
+	msr	spsr_el3, x1
+	ubfx	x0, x1, #MODE_EL_SHIFT, #2
+	cmp	x0, #MODE_EL3
+	b.ne	panic
+
+	ldp	x6, x7, [x20, #(ENTRY_POINT_INFO_ARGS_OFFSET + 0x30)]
+	ldp	x4, x5, [x20, #(ENTRY_POINT_INFO_ARGS_OFFSET + 0x20)]
+	ldp	x2, x3, [x20, #(ENTRY_POINT_INFO_ARGS_OFFSET + 0x10)]
+	ldp	x0, x1, [x20, #(ENTRY_POINT_INFO_ARGS_OFFSET + 0x0)]
+	eret
+
+panic:
+	mov	x0, #SYNC_EXCEPTION_AARCH64
+	bl	plat_report_exception
+
+	wfi
+	b	panic
+	check_vector_size SynchronousExceptionA64
+
+
+	.align	7
+IrqA64:
+	mov	x0, #IRQ_AARCH64
+	bl	plat_report_exception
+	b	IrqA64
+	check_vector_size IrqA64
+
+	.align	7
+FiqA64:
+	mov	x0, #FIQ_AARCH64
+	bl	plat_report_exception
+	b	FiqA64
+	check_vector_size FiqA64
+
+	.align	7
+SErrorA64:
+	mov	x0, #SERROR_AARCH64
+	bl	plat_report_exception
+	b   	SErrorA64
+	check_vector_size SErrorA64
+
+	/* -----------------------------------------------------
+	 * Lower EL using AArch32 : 0x600 - 0x800
+	 * -----------------------------------------------------
+	 */
+	.align	7
+SynchronousExceptionA32:
+	mov	x0, #SYNC_EXCEPTION_AARCH32
+	bl	plat_report_exception
+	b	SynchronousExceptionA32
+	check_vector_size SynchronousExceptionA32
+
+	.align	7
+IrqA32:
+	mov	x0, #IRQ_AARCH32
+	bl	plat_report_exception
+	b	IrqA32
+	check_vector_size IrqA32
+
+	.align	7
+FiqA32:
+	mov	x0, #FIQ_AARCH32
+	bl	plat_report_exception
+	b	FiqA32
+	check_vector_size FiqA32
+
+	.align	7
+SErrorA32:
+	mov	x0, #SERROR_AARCH32
+	bl	plat_report_exception
+	b	SErrorA32
+	check_vector_size SErrorA32
diff --git a/plat/renesas/rcar/aarch64/rcar_common.c b/plat/renesas/rcar/aarch64/rcar_common.c
new file mode 100644
index 0000000..9fec7fb
--- /dev/null
+++ b/plat/renesas/rcar/aarch64/rcar_common.c
@@ -0,0 +1,262 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <arch_helpers.h>
+#include <arm_gic.h>
+#include <bl_common.h>
+#include <cci.h>
+#include <debug.h>
+#include <mmio.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <xlat_tables.h>
+#include "../rcar_def.h"
+#include "../rcar_private.h"
+#include "../rcar_version.h"
+
+const uint8_t version_of_renesas[VER_SIZE] __attribute__((__section__(".version"))) = VERSION_OF_RENESAS;
+
+#define MAP_SHARED_RAM	MAP_REGION_FLAT(RCAR_SHARED_MEM_BASE,		\
+					RCAR_SHARED_MEM_SIZE,		\
+					MT_MEMORY | MT_RW | MT_SECURE)
+
+#define MAP_FLASH0	MAP_REGION_FLAT(FLASH0_BASE,			\
+					FLASH0_SIZE,			\
+					MT_MEMORY | MT_RO | MT_SECURE)
+
+#define MAP_DRAM1_NS	MAP_REGION_FLAT(DRAM1_NS_BASE,			\
+					DRAM1_NS_SIZE,			\
+					MT_MEMORY | MT_RW | MT_NS)
+
+#define MAP_BL32_MEM	MAP_REGION_FLAT(BL32_BASE,		\
+					BL32_LIMIT - BL32_BASE,		\
+					MT_MEMORY | MT_RW | MT_SECURE)
+
+#define MAP_DEVICE_RCAR	MAP_REGION_FLAT(DEVICE_RCAR_BASE,		\
+					DEVICE_RCAR_SIZE,		\
+					MT_DEVICE | MT_RW | MT_SECURE)
+
+#define MAP_ATFW_MAIL	MAP_REGION_FLAT(RCAR_BL31_MAIL_BASE,		\
+					RCAR_BL31_MAIL_SIZE,		\
+					MT_MEMORY | MT_RW | MT_SECURE)
+
+#define MAP_ATFW_LOG	MAP_REGION_FLAT(RCAR_BL31_LOG_BASE,		\
+					RCAR_BL31_LOG_SIZE,		\
+					MT_MEMORY | MT_RW | MT_SECURE)
+
+/*
+ * Table of regions for various BL stages to map using the MMU.
+ * This doesn't include TZRAM as the 'mem_layout' argument passed to
+ * configure_mmu_elx() will give the available subset of that,
+ */
+#if IMAGE_BL1
+const mmap_region_t rcar_mmap[] = {
+	MAP_SHARED_RAM,
+	MAP_FLASH0,
+	MAP_DEVICE0,
+	MAP_DEVICE1,
+	{	0}
+};
+#endif
+#if IMAGE_BL2
+const mmap_region_t rcar_mmap[] = {
+	MAP_SHARED_RAM,
+	MAP_FLASH0,
+	MAP_DRAM1_NS,
+	MAP_BL32_MEM,
+	MAP_DEVICE_RCAR,
+	{	0}
+};
+#endif
+#if IMAGE_BL31
+const mmap_region_t rcar_mmap[] = {
+	MAP_SHARED_RAM,
+	MAP_ATFW_MAIL,
+	MAP_ATFW_LOG,
+	MAP_DEVICE_RCAR,
+	{	0}
+};
+#endif
+#if IMAGE_BL32
+const mmap_region_t rcar_mmap[] = {
+	MAP_DEVICE0,
+	MAP_DEVICE1,
+	{	0}
+};
+#endif
+
+CASSERT(ARRAY_SIZE(rcar_mmap) + RCAR_BL_REGIONS \
+		<= MAX_MMAP_REGIONS, assert_max_mmap_regions);
+
+/*******************************************************************************
+ * Macro generating the code for the function setting up the pagetables as per
+ * the platform memory map & initialize the mmu, for the given exception level
+ ******************************************************************************/
+#if USE_COHERENT_MEM
+#define DEFINE_CONFIGURE_MMU_EL(_el)				\
+	void rcar_configure_mmu_el##_el(unsigned long total_base,	\
+				   unsigned long total_size,		\
+				   unsigned long ro_start,		\
+				   unsigned long ro_limit,		\
+				   unsigned long coh_start,		\
+				   unsigned long coh_limit)		\
+	{								\
+		mmap_add_region(total_base, total_base,			\
+				total_size,				\
+				MT_MEMORY | MT_RW | MT_SECURE);		\
+		mmap_add_region(ro_start, ro_start,			\
+				ro_limit - ro_start,			\
+				MT_MEMORY | MT_RO | MT_SECURE);		\
+		mmap_add_region(coh_start, coh_start,			\
+				coh_limit - coh_start,			\
+				MT_DEVICE | MT_RW | MT_SECURE);		\
+		mmap_add(rcar_mmap);					\
+		init_xlat_tables();					\
+									\
+		enable_mmu_el##_el(0);					\
+	}
+#else
+#define DEFINE_CONFIGURE_MMU_EL(_el)				\
+	void rcar_configure_mmu_el##_el(unsigned long total_base,	\
+				   unsigned long total_size,		\
+				   unsigned long ro_start,		\
+				   unsigned long ro_limit)		\
+	{								\
+		mmap_add_region(total_base, total_base,			\
+				total_size,				\
+				MT_MEMORY | MT_RW | MT_SECURE);		\
+		mmap_add_region(ro_start, ro_start,			\
+				ro_limit - ro_start,			\
+				MT_MEMORY | MT_RO | MT_SECURE);		\
+		mmap_add(rcar_mmap);					\
+		init_xlat_tables();					\
+									\
+		enable_mmu_el##_el(0);					\
+	}
+#endif
+
+/* Define EL1 and EL3 variants of the function initialising the MMU */
+DEFINE_CONFIGURE_MMU_EL(1)
+DEFINE_CONFIGURE_MMU_EL(3)
+
+#if (IMAGE_BL2)
+extern int32_t file_to_cert(const int8_t *filename, uint32_t *cert_addr);
+extern void get_info_from_cert(uint64_t cert_addr, uint32_t *size, uint32_t *dest_addr);
+#endif
+
+unsigned long plat_get_ns_image_entrypoint(void)
+{
+#if (IMAGE_BL2)
+	int32_t ret;
+	uint32_t cert_addr;
+	uint32_t l_image_size;
+	uint32_t dest_addr;
+	ret = file_to_cert((const int8_t *)BL33_CERT_NAME, &cert_addr);
+	if (0 == ret) {
+		get_info_from_cert((uint64_t) cert_addr, &l_image_size, &dest_addr);
+	} else {
+		ERROR("%s : cert file load error", __func__);
+		dest_addr = NS_IMAGE_OFFSET;
+	}
+	return dest_addr;
+#else
+	return NS_IMAGE_OFFSET;
+#endif
+}
+
+uint64_t plat_get_syscnt_freq(void)
+{
+	uint64_t counter_base_frequency;
+
+	/* Read the frequency from Frequency modes table */
+	counter_base_frequency = mmio_read_32(ARM_SYS_CNTCTL_BASE + (uint32_t)CNTFID_OFF);
+
+	/* The first entry of the frequency modes table must not be 0 */
+	if (counter_base_frequency == 0U) {
+		panic();
+	}
+
+	return counter_base_frequency;
+}
+
+/* Map of CCI masters with the slave interfaces they are connected */
+static const int cci_map[] = {
+	CCI500_CLUSTER0_SL_IFACE_IX,
+	CCI500_CLUSTER1_SL_IFACE_IX
+};
+
+void rcar_cci_init(void)
+{
+	/*
+	 * Initialize CCI-500 driver
+	 */
+	cci_init(RCAR_CCI_BASE, cci_map, ARRAY_SIZE(cci_map));
+}
+
+void rcar_cci_enable(void)
+{
+	cci_enable_snoop_dvm_reqs((unsigned int)MPIDR_AFFLVL1_VAL(read_mpidr()));
+}
+
+void rcar_cci_disable(void)
+{
+	cci_disable_snoop_dvm_reqs((unsigned int)MPIDR_AFFLVL1_VAL(read_mpidr()));
+}
+
+	/*******************************************************************************
+	 * Gets SPSR for BL32 entry
+	 ******************************************************************************/
+uint32_t rcar_get_spsr_for_bl32_entry(void)
+{
+	/*
+	 * The Secure Payload Dispatcher service is responsible for
+	 * setting the SPSR prior to entry into the BL32 image.
+	 */
+	return 0U;
+}
+
+/*******************************************************************************
+ * Gets SPSR for BL33 entry
+ ******************************************************************************/
+#define	BL33_EL1	0
+#define	BL33_EL2	1
+
+uint32_t rcar_get_spsr_for_bl33_entry(void)
+{
+#if (RCAR_BL33_EXECUTION_EL == BL33_EL1)
+	return (uint32_t)SPSR_64(MODE_EL1, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS);
+#elif (RCAR_BL33_EXECUTION_EL == BL33_EL2)
+	return (uint32_t)SPSR_64(MODE_EL2, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS);
+#else
+#error
+#endif
+}
diff --git a/plat/renesas/rcar/aarch64/rcar_helpers.S b/plat/renesas/rcar/aarch64/rcar_helpers.S
new file mode 100644
index 0000000..33d5743
--- /dev/null
+++ b/plat/renesas/rcar/aarch64/rcar_helpers.S
@@ -0,0 +1,379 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <bl_common.h>
+#include <cortex_a57.h>
+#include <platform_def.h>
+#include "../rcar_def.h"
+
+
+	.globl	platform_get_entrypoint
+	.globl	plat_secondary_cold_boot_setup
+	.globl	platform_mem_init
+	.globl	plat_report_exception
+	.globl	platform_is_primary_cpu
+	.globl	plat_crash_console_init
+	.globl	plat_crash_console_putc
+	.globl	plat_reset_handler
+
+	.extern	platform_set_stack
+	.extern	rcar_log_init
+	.extern	tf_printf
+
+	.extern	rcar_boot_kind_flag[data]
+
+.section	.rodata.errorlog,	"aS"
+error_log_data:
+	.asciz	"[Error log is in plat_secondary_cold_setup]",""
+
+	/* -----------------------------------------------------
+	 * void plat_secondary_cold_boot_setup (void);
+	 *
+	 * This function performs log output from the address of
+	 * error_log_data and go to cb_panic.
+	 * -----------------------------------------------------
+	 */
+func plat_secondary_cold_boot_setup
+	/*
+	 * If timer is enabled, do not clear the freq register
+	 */
+	mrs	x0, CNTP_CTL_EL0
+	mov	x1, #1
+	and	x2, x0, x1
+	cbnz	x2, log_output		/* timer is enabled			*/
+	/*
+	 * Timer is disabled, then clear the freq register
+	 */
+	mov	x0, #0
+	msr	CNTFRQ_EL0, x0
+log_output:
+	bl	platform_set_stack	/* set stack pointer			*/
+	bl	rcar_log_init		/* log area initialize			*/
+	ldr	x0, =error_log_data	/* argument of tf_printf function	*/
+	bl	tf_printf		/* log output				*/
+cb_panic:
+	b	cb_panic
+endfunc plat_secondary_cold_boot_setup
+
+
+	/* -----------------------------------------------------
+	 * void platform_get_entrypoint (unsigned int mpid);
+	 *
+	 * Main job of this routine is to distinguish between
+	 * a cold and warm boot.
+	 * On a cold boot the secondaries first wait for the
+	 * platform to be initialized after which they are
+	 * hotplugged in. The primary proceeds to perform the
+	 * platform initialization.
+	 * On a warm boot, each cpu jumps to the address in its
+	 * mailbox.
+	 *
+	 * TODO: Not a good idea to save lr in a temp reg
+	 * -----------------------------------------------------
+	 */
+func platform_get_entrypoint
+	mov	x9, x30 /* lr */
+
+	/*
+	 * format of x21
+	 *	4	3	2	1	0
+	 *	---------------------------------
+	 *	|	|	|	|	|
+	 *	|   reset info	|   boot kind	|
+	 *	|	|	|	|	|
+	 *	---------------------------------
+	 *	00 : Usual	| 00 : Cold boot
+	 *	01 : Unusual	| 01 : Warm boot
+	 *	10 : Reserved	| 10 : Reserved
+	 *	11 : Reserved	| 11 : Reserved
+	 *
+	 */
+
+	/*
+	 * Check the reset info
+	 */
+	and	x1, x21, #0x000c	/* Get the reset info				*/
+	cmp	x1, #0x0008		/* Is reset info "10:Reserved" ?		*/
+	beq	el3_panic
+	cmp	x1, #0x000c		/* Is reset info "11:Reserved" ?		*/
+	beq	el3_panic
+	/*										*/
+	/* Check the boot kind								*/
+	/*										*/
+	and	x1, x21, #0x0003	/* Get the boot kind				*/
+	cmp	x1, #0x0002		/* Is boot kind "10:Reserved" ?			*/
+	beq	el3_panic
+	cmp	x1, #0x0003		/* Is boot kind "11:Reserved" ?			*/
+	beq	el3_panic
+	/*										*/
+	/* warm boot or cold boot							*/
+	/*										*/
+	and	x1, x21, #1		/* warm boot ?					*/
+	cmp	x1, #0			/* If x1 is 0 then cold boot			*/
+	bne	warm_reset		/* bit0 of x1 is 1 then warm boot		*/
+	/*										*/
+	/* Cold boot									*/
+	/*										*/
+	mov	x0, #0
+	b	exit
+
+warm_reset:
+	/* ---------------------------------------------
+	 * A per-cpu mailbox is maintained in the tru-
+	 * sted SDRAM. Its flushed out of the caches
+	 * after every update using normal memory so
+	 * its safe to read it here with SO attributes
+	 * ---------------------------------------------
+	 */
+	ldr	x10, =MBOX_BASE		/* top of mailbox address -> x10		*/
+	bl	platform_get_core_pos	/* restore cpu no to x0 as CA53=0-3, CA57=4-7	*/
+	lsl	x0, x0, #CACHE_WRITEBACK_SHIFT	/* 6bit left shift			*/
+					/* because mailbox size is 0x40 byte per cpu	*/
+	ldr	x0, [x10, x0]		/* top address of mailbox is entrypoint		*/
+	cbz	x0, _panic		/* If warm boot and entrypoint is 0 then panic	*/
+exit:
+	ret	x9
+_panic:	b	_panic
+endfunc platform_get_entrypoint
+
+
+	/* -----------------------------------------------------
+	 * void platform_mem_init (void);
+	 *
+	 * Zero out the mailbox registers in the shared memory
+	 * and set the rcar_boot_kind_flag.
+	 * The mmu is turned off right now and only the primary can
+	 * ever execute this code. Secondaries will read the
+	 * mailboxes using SO accesses.
+	 * -----------------------------------------------------
+	 */
+func platform_mem_init
+	ldr	x0, =MBOX_BASE
+	mov	w1, #PLATFORM_CORE_COUNT
+loop:
+	str	xzr, [x0], #CACHE_WRITEBACK_GRANULE
+	subs	w1, w1, #1
+	b.gt	loop
+	/* for R-Car Gen3		*/
+	ldr	x0, =rcar_boot_kind_flag
+	str	w21, [x0]
+	ret
+endfunc platform_mem_init
+
+	/* ---------------------------------------------
+	 * void plat_report_exception(unsigned int type)
+	 * Function to report an unhandled exception
+	 * with platform-specific means.
+	 * ---------------------------------------------
+	 */
+func plat_report_exception
+	mrs	x1, CurrentEl
+
+	str	w0, [x1]
+	ret
+endfunc plat_report_exception
+
+	/*
+	 *	Starting CPU is ...
+	 *		MD7=1 and MD6=1 of MODEMR	: CortexR7
+	 *		MD7=1 and MD6=0 of MODEMR	: Reserved
+	 *		MD7=0 and MD6=1 of MODEMR	: CortexA53
+	 *		MD7=0 and MD6=0 of MODEMR	: CortexA57
+	 *
+	 *	Information of MPIDR_EL1
+	 *		affinity level 1(bit15-8) = 1	: CortexA53
+	 *		affinity level 1(bit15-8) = 0	: CortexA57
+	 *
+	 */
+
+func platform_is_primary_cpu
+	/*
+	 * Get MD6 and MD7 of MODEMR, then move MD6 to bit0 and move MD7 to bit1 of x1
+	 */
+	ldr	x1, =RCAR_MODEMR_A		/* x1 <- address of MODEMR register	*/
+	ldr	x2, [x1]			/* Get the data of MODEMR -> x2		*/
+	mov	x1, #0x00c0			/* move MD6(0x0040) and MD7(0x0080)	*/
+	and	x1, x2, x1			/* Get MD6 and MD7 information -> x1	*/
+	lsr	x1, x1, #6			/* MD6->bit0, MD7->bit1			*/
+	/*
+	 * Get data of affinity level 1 of MPIDR_EL1, then move data to bit7-0 of x2
+	 */
+	mov	x2, #MPIDR_CLUSTER_MASK		/* MPIDR_CLUSTER_MASK=0xFF00 -> x2	*/
+	and	x2, x0, x2			/* Get the affinity level 1 -> x2	*/
+	lsr	x2, x2, #MPIDR_AFFINITY_BITS	/* affinity level 1 -> bit7-0 of x2	*/
+	/*
+	 * Check the starting CPU by MD7
+	 */
+	mov	x3, #0x0002			/* for test the MD7			*/
+	and	x3, x1, x3			/* MD7 information -> x3(0 or not)	*/
+	cbnz	x3, primary_check		/* Starting CPU is CortexR7		*/
+	/*
+	 * CA53 check
+	 */
+	mov	x3, #0x0003			/* MD6 and MD7				*/
+	and	x3, x1, x3
+	cmp	x3, #0x0001			/* If starting CPU is CortexA53		*/
+	bne	checkCA57			/*  is not then branch to check CA57	*/
+	cmp	x2, #0x0001			/* If affinity level 1 is CortexA53	*/
+	beq	primary_check			/*  CPU is CortexA53			*/
+	b	platform_is_secondary		/* It is secondary			*/
+	/*
+	 * CA57 check
+	 */
+checkCA57:
+	cmp	x3, #0x0000			/* If starting CPU is CortexA57		*/
+	bne	platform_is_secondary
+	cmp	x2, #0x0000			/* If affinity level 1 is CortexA57	*/
+	beq	primary_check			/*  CPU is CortexA57			*/
+	/*
+	 * This CPU is secondary
+	 */
+platform_is_secondary:
+	mov	x0, #0				/* This cpu is secondary		*/
+	b	primary_check_exit		/* return				*/
+primary_check:
+	and	x0, x0, # MPIDR_CPU_MASK	/* Get the bit7-0 of MPIDR_EL1 -> x0	*/
+	cmp	x0, #RCAR_PRIMARY_CPU		/* x0 = 0 (primary CPU)?		*/
+	cset	x0, eq				/* If x0 is 0 carry bit set		*/
+primary_check_exit:
+	ret
+endfunc platform_is_primary_cpu
+
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_init(void)
+	 * Function to initialize log area
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_init
+	mov	x1, sp
+	mov_imm	x2, RCAR_CRASH_STACK
+	mov	sp, x2
+	str	x1, [sp, #-16]!
+	str	x30, [sp, #-16]!
+	bl	console_core_init
+	ldr	x30, [sp], #16
+	ldr	x1, [sp], #16
+	mov	sp, x1
+	ret
+endfunc plat_crash_console_init
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_putc(int c)
+	 * Function to store a character to log area
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_putc
+	mov	x1, sp
+	mov_imm	x2, RCAR_CRASH_STACK
+	mov	sp, x2
+	str	x1, [sp, #-16]!
+	str	x30, [sp, #-16]!
+	str	x3, [sp, #-16]!
+	str	x4, [sp, #-16]!
+	str	x5, [sp, #-16]!
+	bl	console_core_putc
+	ldr	x5, [sp], #16
+	ldr	x4, [sp], #16
+	ldr	x3, [sp], #16
+	ldr	x30, [sp], #16
+	ldr	x1, [sp], #16
+	mov	sp, x1
+	ret
+endfunc plat_crash_console_putc
+
+
+	/* --------------------------------------------------------------------
+	 * void plat_reset_handler(void);
+	 *
+	 * Before adding code in this function, refer to the guidelines in
+	 * docs/firmware-design.md to determine whether the code should reside
+	 * within the FIRST_RESET_HANDLER_CALL block or not.
+	 *
+	 * For R-Car H3:
+	 * - Set the L2 Tag RAM latency to 2 (i.e. 3 cycles) for Cortex-A57
+	 * - Set the L2 Data setup latency to 1 (i.e. 1 cycles) for Cortex-A57
+	 * - Set the L2 Data RAM latency to 3 (i.e. 4 cycles) for Cortex-A57
+	 *
+	 * --------------------------------------------------------------------
+	 */
+func plat_reset_handler
+	/* --------------------------------------------------------------------
+	 * Determine whether this code is running on R-Car H3 or R-Car M3.
+	 * Keep this information in x2.
+	 * --------------------------------------------------------------------
+	 */
+	/*
+	 * On R-Car H3:  x2 := 0
+	 * On R-Car M3:  x2 := 1
+	 */
+	mov	x2, #0		/* set R-Car H3 */
+
+	/* --------------------------------------------------------------------
+	 * Determine whether this code is executed on a Cortex-A53 or on a
+	 * Cortex-A57 core.
+	 * --------------------------------------------------------------------
+	 */
+	mrs	x0, midr_el1
+	ubfx	x1, x0, MIDR_PN_SHIFT, #12
+	cmp     w1, #((CORTEX_A57_MIDR >> MIDR_PN_SHIFT) & MIDR_PN_MASK)
+	b.eq	A57
+
+	ret
+
+A57:
+	/* --------------------------------------------------------------------
+	 * Cortex-A57 specific settings
+	 * --------------------------------------------------------------------
+	 */
+	mrs	x0, L2CTLR_EL1		/* Get data from L2CTLR_EL1		*/
+	cbnz	x2, apply_l2_ram_latencies	/* If M3 then return		*/
+	/*
+	 * On R-Car H3
+	 *
+	 * L2 Tag RAM latency is bit8-6 of L2CTLR_EL1
+	 * L2 Data RAM setup is bit5 of L2CTLR_EL1
+	 * L2 Data RAM latency is bit2-0 of L2CTLR_EL1
+	 */
+	mov	x1, #0x1e7		/* for clear bit of L2 RAM		*/
+	neg	x1, x1			/* ~(0x1e7) -> x1			*/
+	and	x0, x0, x1		/* clear bit of L2 RAM -> x0		*/
+	orr	x0, x0, #0x2 << 6  	/* L2 Tag RAM latency (3 cycles)	*/
+	orr	x0, x0, #0x1 << 5  	/* L2 Data RAM setup (1 cycle)		*/
+	orr	x0, x0, #0x3       	/* L2 Data RAM latency (4 cycles)	*/
+	msr     L2CTLR_EL1, x0		/* Store data to L2CTLR_EL1		*/
+
+apply_l2_ram_latencies:
+
+	ret
+endfunc plat_reset_handler
diff --git a/plat/renesas/rcar/bl2_cpg_init.c b/plat/renesas/rcar/bl2_cpg_init.c
new file mode 100644
index 0000000..48846c4
--- /dev/null
+++ b/plat/renesas/rcar/bl2_cpg_init.c
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "bl2_cpg_register.h"
+#include "bl2_cpg_write.h"
+#include "bl2_cpg_init.h"
+#include "mmio.h"
+
+typedef struct {
+	uint32_t	adr;
+	uint32_t	val;
+} reg_setting_t;
+
+static const reg_setting_t reg_setting[] = {
+
+	/* CPG (SECURITY) registers */
+
+	/* Secure Module Stop Control Register 0 */
+	{SCMSTPCR0,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 1 */
+	{SCMSTPCR1,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 2 */
+	{SCMSTPCR2,		0xEBFDFFFFU},
+	/* Secure Module Stop Control Register 3 */
+	{SCMSTPCR3,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 4 */
+	{SCMSTPCR4,		0x7FFFFFFFU},
+	/* Secure Module Stop Control Register 5 */
+	{SCMSTPCR5,		0xBFFFFFFFU},
+	/* Secure Module Stop Control Register 6 */
+	{SCMSTPCR6,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 7 */
+	{SCMSTPCR7,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 8 */
+	{SCMSTPCR8,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 9 */
+	{SCMSTPCR9,		0xFFFDFFFFU},
+	/* Secure Module Stop Control Register 10 */
+	{SCMSTPCR10,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 11 */
+	{SCMSTPCR11,		0xFFFFFFFFU},
+	/* Secure Software Reset Access Enable Control Register 0 */
+	{SCSRSTECR0,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 1 */
+	{SCSRSTECR1,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 2 */
+	{SCSRSTECR2,		0x14020000U},
+	/* Secure Software Reset Access Enable Control Register 3 */
+	{SCSRSTECR3,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 4 */
+	{SCSRSTECR4,		0x80000003U},
+	/* Secure Software Reset Access Enable Control Register 5 */
+	{SCSRSTECR5,		0x40000000U},
+	/* Secure Software Reset Access Enable Control Register 6 */
+	{SCSRSTECR6,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 7 */
+	{SCSRSTECR7,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 8 */
+	{SCSRSTECR8,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 9 */
+	{SCSRSTECR9,		0x00020000U},
+	/* Secure Software Reset Access Enable Control Register 10 */
+	{SCSRSTECR10,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 11 */
+	{SCSRSTECR11,		0x00000000U}
+};
+
+void bl2_cpg_init(void)
+{
+	uint32_t	i,
+			ie = sizeof(reg_setting) / sizeof(reg_setting_t);
+
+	for (i = 0; i < ie; i++) {
+		cpg_write(reg_setting[i].adr, reg_setting[i].val);
+	}
+}
diff --git a/plat/renesas/rcar/bl2_pfc_init.c b/plat/renesas/rcar/bl2_pfc_init.c
new file mode 100644
index 0000000..f58f6a8
--- /dev/null
+++ b/plat/renesas/rcar/bl2_pfc_init.c
@@ -0,0 +1,1398 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>		/* for uint32_t */
+#include <mmio.h>
+#include "bl2_pfc_init.h"
+
+
+/* GPIO base address */
+#define	GPIO_BASE		(0xE6050000U)
+
+/* GPIO registers */
+#define	GPIO_IOINTSEL0		(GPIO_BASE + 0x0000U)
+#define	GPIO_INOUTSEL0		(GPIO_BASE + 0x0004U)
+#define	GPIO_OUTDT0		(GPIO_BASE + 0x0008U)
+#define	GPIO_INDT0		(GPIO_BASE + 0x000CU)
+#define	GPIO_INTDT0		(GPIO_BASE + 0x0010U)
+#define	GPIO_INTCLR0		(GPIO_BASE + 0x0014U)
+#define	GPIO_INTMSK0		(GPIO_BASE + 0x0018U)
+#define	GPIO_MSKCLR0		(GPIO_BASE + 0x001CU)
+#define	GPIO_POSNEG0		(GPIO_BASE + 0x0020U)
+#define	GPIO_EDGLEVEL0		(GPIO_BASE + 0x0024U)
+#define	GPIO_FILONOFF0		(GPIO_BASE + 0x0028U)
+#define	GPIO_INTMSKS0		(GPIO_BASE + 0x0038U)
+#define	GPIO_MSKCLRS0		(GPIO_BASE + 0x003CU)
+#define	GPIO_OUTDTSEL0		(GPIO_BASE + 0x0040U)
+#define	GPIO_OUTDTH0		(GPIO_BASE + 0x0044U)
+#define	GPIO_OUTDTL0		(GPIO_BASE + 0x0048U)
+#define	GPIO_BOTHEDGE0		(GPIO_BASE + 0x004CU)
+#define	GPIO_IOINTSEL1		(GPIO_BASE + 0x1000U)
+#define	GPIO_INOUTSEL1		(GPIO_BASE + 0x1004U)
+#define	GPIO_OUTDT1		(GPIO_BASE + 0x1008U)
+#define	GPIO_INDT1		(GPIO_BASE + 0x100CU)
+#define	GPIO_INTDT1		(GPIO_BASE + 0x1010U)
+#define	GPIO_INTCLR1		(GPIO_BASE + 0x1014U)
+#define	GPIO_INTMSK1		(GPIO_BASE + 0x1018U)
+#define	GPIO_MSKCLR1		(GPIO_BASE + 0x101CU)
+#define	GPIO_POSNEG1		(GPIO_BASE + 0x1020U)
+#define	GPIO_EDGLEVEL1		(GPIO_BASE + 0x1024U)
+#define	GPIO_FILONOFF1		(GPIO_BASE + 0x1028U)
+#define	GPIO_INTMSKS1		(GPIO_BASE + 0x1038U)
+#define	GPIO_MSKCLRS1		(GPIO_BASE + 0x103CU)
+#define	GPIO_OUTDTSEL1		(GPIO_BASE + 0x1040U)
+#define	GPIO_OUTDTH1		(GPIO_BASE + 0x1044U)
+#define	GPIO_OUTDTL1		(GPIO_BASE + 0x1048U)
+#define	GPIO_BOTHEDGE1		(GPIO_BASE + 0x104CU)
+#define	GPIO_IOINTSEL2		(GPIO_BASE + 0x2000U)
+#define	GPIO_INOUTSEL2		(GPIO_BASE + 0x2004U)
+#define	GPIO_OUTDT2		(GPIO_BASE + 0x2008U)
+#define	GPIO_INDT2		(GPIO_BASE + 0x200CU)
+#define	GPIO_INTDT2		(GPIO_BASE + 0x2010U)
+#define	GPIO_INTCLR2		(GPIO_BASE + 0x2014U)
+#define	GPIO_INTMSK2		(GPIO_BASE + 0x2018U)
+#define	GPIO_MSKCLR2		(GPIO_BASE + 0x201CU)
+#define	GPIO_POSNEG2		(GPIO_BASE + 0x2020U)
+#define	GPIO_EDGLEVEL2		(GPIO_BASE + 0x2024U)
+#define	GPIO_FILONOFF2		(GPIO_BASE + 0x2028U)
+#define	GPIO_INTMSKS2		(GPIO_BASE + 0x2038U)
+#define	GPIO_MSKCLRS2		(GPIO_BASE + 0x203CU)
+#define	GPIO_OUTDTSEL2		(GPIO_BASE + 0x2040U)
+#define	GPIO_OUTDTH2		(GPIO_BASE + 0x2044U)
+#define	GPIO_OUTDTL2		(GPIO_BASE + 0x2048U)
+#define	GPIO_BOTHEDGE2		(GPIO_BASE + 0x204CU)
+#define	GPIO_IOINTSEL3		(GPIO_BASE + 0x3000U)
+#define	GPIO_INOUTSEL3		(GPIO_BASE + 0x3004U)
+#define	GPIO_OUTDT3		(GPIO_BASE + 0x3008U)
+#define	GPIO_INDT3		(GPIO_BASE + 0x300CU)
+#define	GPIO_INTDT3		(GPIO_BASE + 0x3010U)
+#define	GPIO_INTCLR3		(GPIO_BASE + 0x3014U)
+#define	GPIO_INTMSK3		(GPIO_BASE + 0x3018U)
+#define	GPIO_MSKCLR3		(GPIO_BASE + 0x301CU)
+#define	GPIO_POSNEG3		(GPIO_BASE + 0x3020U)
+#define	GPIO_EDGLEVEL3		(GPIO_BASE + 0x3024U)
+#define	GPIO_FILONOFF3		(GPIO_BASE + 0x3028U)
+#define	GPIO_INTMSKS3		(GPIO_BASE + 0x3038U)
+#define	GPIO_MSKCLRS3		(GPIO_BASE + 0x303CU)
+#define	GPIO_OUTDTSEL3		(GPIO_BASE + 0x3040U)
+#define	GPIO_OUTDTH3		(GPIO_BASE + 0x3044U)
+#define	GPIO_OUTDTL3		(GPIO_BASE + 0x3048U)
+#define	GPIO_BOTHEDGE3		(GPIO_BASE + 0x304CU)
+#define	GPIO_IOINTSEL4		(GPIO_BASE + 0x4000U)
+#define	GPIO_INOUTSEL4		(GPIO_BASE + 0x4004U)
+#define	GPIO_OUTDT4		(GPIO_BASE + 0x4008U)
+#define	GPIO_INDT4		(GPIO_BASE + 0x400CU)
+#define	GPIO_INTDT4		(GPIO_BASE + 0x4010U)
+#define	GPIO_INTCLR4		(GPIO_BASE + 0x4014U)
+#define	GPIO_INTMSK4		(GPIO_BASE + 0x4018U)
+#define	GPIO_MSKCLR4		(GPIO_BASE + 0x401CU)
+#define	GPIO_POSNEG4		(GPIO_BASE + 0x4020U)
+#define	GPIO_EDGLEVEL4		(GPIO_BASE + 0x4024U)
+#define	GPIO_FILONOFF4		(GPIO_BASE + 0x4028U)
+#define	GPIO_INTMSKS4		(GPIO_BASE + 0x4038U)
+#define	GPIO_MSKCLRS4		(GPIO_BASE + 0x403CU)
+#define	GPIO_OUTDTSEL4		(GPIO_BASE + 0x4040U)
+#define	GPIO_OUTDTH4		(GPIO_BASE + 0x4044U)
+#define	GPIO_OUTDTL4		(GPIO_BASE + 0x4048U)
+#define	GPIO_BOTHEDGE4		(GPIO_BASE + 0x404CU)
+#define	GPIO_IOINTSEL5		(GPIO_BASE + 0x5000U)
+#define	GPIO_INOUTSEL5		(GPIO_BASE + 0x5004U)
+#define	GPIO_OUTDT5		(GPIO_BASE + 0x5008U)
+#define	GPIO_INDT5		(GPIO_BASE + 0x500CU)
+#define	GPIO_INTDT5		(GPIO_BASE + 0x5010U)
+#define	GPIO_INTCLR5		(GPIO_BASE + 0x5014U)
+#define	GPIO_INTMSK5		(GPIO_BASE + 0x5018U)
+#define	GPIO_MSKCLR5		(GPIO_BASE + 0x501CU)
+#define	GPIO_POSNEG5		(GPIO_BASE + 0x5020U)
+#define	GPIO_EDGLEVEL5		(GPIO_BASE + 0x5024U)
+#define	GPIO_FILONOFF5		(GPIO_BASE + 0x5028U)
+#define	GPIO_INTMSKS5		(GPIO_BASE + 0x5038U)
+#define	GPIO_MSKCLRS5		(GPIO_BASE + 0x503CU)
+#define	GPIO_OUTDTSEL5		(GPIO_BASE + 0x5040U)
+#define	GPIO_OUTDTH5		(GPIO_BASE + 0x5044U)
+#define	GPIO_OUTDTL5		(GPIO_BASE + 0x5048U)
+#define	GPIO_BOTHEDGE5		(GPIO_BASE + 0x504CU)
+#define	GPIO_IOINTSEL6		(GPIO_BASE + 0x5400U)
+#define	GPIO_INOUTSEL6		(GPIO_BASE + 0x5404U)
+#define	GPIO_OUTDT6		(GPIO_BASE + 0x5408U)
+#define	GPIO_INDT6		(GPIO_BASE + 0x540CU)
+#define	GPIO_INTDT6		(GPIO_BASE + 0x5410U)
+#define	GPIO_INTCLR6		(GPIO_BASE + 0x5414U)
+#define	GPIO_INTMSK6		(GPIO_BASE + 0x5418U)
+#define	GPIO_MSKCLR6		(GPIO_BASE + 0x541CU)
+#define	GPIO_POSNEG6		(GPIO_BASE + 0x5420U)
+#define	GPIO_EDGLEVEL6		(GPIO_BASE + 0x5424U)
+#define	GPIO_FILONOFF6		(GPIO_BASE + 0x5428U)
+#define	GPIO_INTMSKS6		(GPIO_BASE + 0x5438U)
+#define	GPIO_MSKCLRS6		(GPIO_BASE + 0x543CU)
+#define	GPIO_OUTDTSEL6		(GPIO_BASE + 0x5440U)
+#define	GPIO_OUTDTH6		(GPIO_BASE + 0x5444U)
+#define	GPIO_OUTDTL6		(GPIO_BASE + 0x5448U)
+#define	GPIO_BOTHEDGE6		(GPIO_BASE + 0x544CU)
+#define	GPIO_IOINTSEL7		(GPIO_BASE + 0x5800U)
+#define	GPIO_INOUTSEL7		(GPIO_BASE + 0x5804U)
+#define	GPIO_OUTDT7		(GPIO_BASE + 0x5808U)
+#define	GPIO_INDT7		(GPIO_BASE + 0x580CU)
+#define	GPIO_INTDT7		(GPIO_BASE + 0x5810U)
+#define	GPIO_INTCLR7		(GPIO_BASE + 0x5814U)
+#define	GPIO_INTMSK7		(GPIO_BASE + 0x5818U)
+#define	GPIO_MSKCLR7		(GPIO_BASE + 0x581CU)
+#define	GPIO_POSNEG7		(GPIO_BASE + 0x5820U)
+#define	GPIO_EDGLEVEL7		(GPIO_BASE + 0x5824U)
+#define	GPIO_FILONOFF7		(GPIO_BASE + 0x5828U)
+#define	GPIO_INTMSKS7		(GPIO_BASE + 0x5838U)
+#define	GPIO_MSKCLRS7		(GPIO_BASE + 0x583CU)
+#define	GPIO_OUTDTSEL7		(GPIO_BASE + 0x5840U)
+#define	GPIO_OUTDTH7		(GPIO_BASE + 0x5844U)
+#define	GPIO_OUTDTL7		(GPIO_BASE + 0x5848U)
+#define	GPIO_BOTHEDGE7		(GPIO_BASE + 0x584CU)
+
+
+/* Pin functon base address */
+#define	PFC_BASE		(0xE6060000U)
+
+/* Pin functon registers */
+#define	PFC_PMMR		(PFC_BASE + 0x0000U)
+#define PFC_GPSR0		(PFC_BASE + 0x0100U)
+#define PFC_GPSR1		(PFC_BASE + 0x0104U)
+#define PFC_GPSR2		(PFC_BASE + 0x0108U)
+#define PFC_GPSR3		(PFC_BASE + 0x010CU)
+#define PFC_GPSR4		(PFC_BASE + 0x0110U)
+#define	PFC_GPSR5		(PFC_BASE + 0x0114U)
+#define	PFC_GPSR6		(PFC_BASE + 0x0118U)
+#define	PFC_GPSR7		(PFC_BASE + 0x011CU)
+#define	PFC_IPSR0		(PFC_BASE + 0x0200U)
+#define	PFC_IPSR1		(PFC_BASE + 0x0204U)
+#define	PFC_IPSR2		(PFC_BASE + 0x0208U)
+#define	PFC_IPSR3		(PFC_BASE + 0x020CU)
+#define	PFC_IPSR4		(PFC_BASE + 0x0210U)
+#define	PFC_IPSR5		(PFC_BASE + 0x0214U)
+#define	PFC_IPSR6		(PFC_BASE + 0x0218U)
+#define	PFC_IPSR7		(PFC_BASE + 0x021CU)
+#define	PFC_IPSR8		(PFC_BASE + 0x0220U)
+#define	PFC_IPSR9		(PFC_BASE + 0x0224U)
+#define	PFC_IPSR10		(PFC_BASE + 0x0228U)
+#define	PFC_IPSR11		(PFC_BASE + 0x022CU)
+#define	PFC_IPSR12		(PFC_BASE + 0x0230U)
+#define	PFC_IPSR13		(PFC_BASE + 0x0234U)
+#define	PFC_IPSR14		(PFC_BASE + 0x0238U)
+#define	PFC_IPSR15		(PFC_BASE + 0x023CU)
+#define	PFC_IPSR16		(PFC_BASE + 0x0240U)
+#define	PFC_IPSR17		(PFC_BASE + 0x0244U)
+#define PFC_DRVCTRL0		(PFC_BASE + 0x0300U)
+#define PFC_DRVCTRL1		(PFC_BASE + 0x0304U)
+#define PFC_DRVCTRL2		(PFC_BASE + 0x0308U)
+#define PFC_DRVCTRL3		(PFC_BASE + 0x030CU)
+#define PFC_DRVCTRL4		(PFC_BASE + 0x0310U)
+#define PFC_DRVCTRL5		(PFC_BASE + 0x0314U)
+#define PFC_DRVCTRL6		(PFC_BASE + 0x0318U)
+#define PFC_DRVCTRL7		(PFC_BASE + 0x031CU)
+#define PFC_DRVCTRL8		(PFC_BASE + 0x0320U)
+#define PFC_DRVCTRL9		(PFC_BASE + 0x0324U)
+#define PFC_DRVCTRL10		(PFC_BASE + 0x0328U)
+#define PFC_DRVCTRL11		(PFC_BASE + 0x032CU)
+#define PFC_DRVCTRL12		(PFC_BASE + 0x0330U)
+#define PFC_DRVCTRL13		(PFC_BASE + 0x0334U)
+#define PFC_DRVCTRL14		(PFC_BASE + 0x0338U)
+#define PFC_DRVCTRL15		(PFC_BASE + 0x033CU)
+#define PFC_DRVCTRL16		(PFC_BASE + 0x0340U)
+#define PFC_DRVCTRL17		(PFC_BASE + 0x0344U)
+#define PFC_DRVCTRL18		(PFC_BASE + 0x0348U)
+#define PFC_DRVCTRL19		(PFC_BASE + 0x034CU)
+#define PFC_DRVCTRL20		(PFC_BASE + 0x0350U)
+#define PFC_DRVCTRL21		(PFC_BASE + 0x0354U)
+#define PFC_DRVCTRL22		(PFC_BASE + 0x0358U)
+#define PFC_DRVCTRL23		(PFC_BASE + 0x035CU)
+#define PFC_DRVCTRL24		(PFC_BASE + 0x0360U)
+#define PFC_POCCTRL0		(PFC_BASE + 0x0380U)
+#define	PFC_TDSELCTRL0		(PFC_BASE + 0x03C0U)
+#define	PFC_IOCTRL		(PFC_BASE + 0x03E0U)
+#define	PFC_TSREG		(PFC_BASE + 0x03E4U)
+#define	PFC_PUEN0		(PFC_BASE + 0x0400U)
+#define	PFC_PUEN1		(PFC_BASE + 0x0404U)
+#define	PFC_PUEN2		(PFC_BASE + 0x0408U)
+#define	PFC_PUEN3		(PFC_BASE + 0x040CU)
+#define	PFC_PUEN4		(PFC_BASE + 0x0410U)
+#define	PFC_PUEN5		(PFC_BASE + 0x0414U)
+#define	PFC_PUEN6		(PFC_BASE + 0x0418U)
+#define	PFC_PUD0		(PFC_BASE + 0x0440U)
+#define	PFC_PUD1		(PFC_BASE + 0x0444U)
+#define	PFC_PUD2		(PFC_BASE + 0x0448U)
+#define	PFC_PUD3		(PFC_BASE + 0x044CU)
+#define	PFC_PUD4		(PFC_BASE + 0x0450U)
+#define	PFC_PUD5		(PFC_BASE + 0x0454U)
+#define	PFC_PUD6		(PFC_BASE + 0x0458U)
+#define	PFC_MOD_SEL0		(PFC_BASE + 0x0500U)
+#define	PFC_MOD_SEL1		(PFC_BASE + 0x0504U)
+#define	PFC_MOD_SEL2		(PFC_BASE + 0x0508U)
+
+#define	GPSR0_D15		((uint32_t)1U << 15U)
+#define	GPSR0_D14		((uint32_t)1U << 14U)
+#define	GPSR0_D13		((uint32_t)1U << 13U)
+#define	GPSR0_D12		((uint32_t)1U << 12U)
+#define	GPSR0_D11		((uint32_t)1U << 11U)
+#define	GPSR0_D10		((uint32_t)1U << 10U)
+#define	GPSR0_D9		((uint32_t)1U << 9U)
+#define	GPSR0_D8		((uint32_t)1U << 8U)
+#define	GPSR0_D7		((uint32_t)1U << 7U)
+#define	GPSR0_D6		((uint32_t)1U << 6U)
+#define	GPSR0_D5		((uint32_t)1U << 5U)
+#define	GPSR0_D4		((uint32_t)1U << 4U)
+#define	GPSR0_D3		((uint32_t)1U << 3U)
+#define	GPSR0_D2		((uint32_t)1U << 2U)
+#define	GPSR0_D1		((uint32_t)1U << 1U)
+#define	GPSR0_D0		((uint32_t)1U << 0U)
+#define	GPSR1_EX_WAIT0_A	((uint32_t)1U << 27U)
+#define	GPSR1_WE1		((uint32_t)1U << 26U)
+#define	GPSR1_WE0		((uint32_t)1U << 25U)
+#define	GPSR1_RD_WR		((uint32_t)1U << 24U)
+#define	GPSR1_RD		((uint32_t)1U << 23U)
+#define	GPSR1_BS		((uint32_t)1U << 22U)
+#define	GPSR1_CS1_A26		((uint32_t)1U << 21U)
+#define	GPSR1_CS0		((uint32_t)1U << 20U)
+#define	GPSR1_A19		((uint32_t)1U << 19U)
+#define	GPSR1_A18		((uint32_t)1U << 18U)
+#define	GPSR1_A17		((uint32_t)1U << 17U)
+#define	GPSR1_A16		((uint32_t)1U << 16U)
+#define	GPSR1_A15		((uint32_t)1U << 15U)
+#define	GPSR1_A14		((uint32_t)1U << 14U)
+#define	GPSR1_A13		((uint32_t)1U << 13U)
+#define	GPSR1_A12		((uint32_t)1U << 12U)
+#define	GPSR1_A11		((uint32_t)1U << 11U)
+#define	GPSR1_A10		((uint32_t)1U << 10U)
+#define	GPSR1_A9		((uint32_t)1U << 9U)
+#define	GPSR1_A8		((uint32_t)1U << 8U)
+#define	GPSR1_A7		((uint32_t)1U << 7U)
+#define	GPSR1_A6		((uint32_t)1U << 6U)
+#define	GPSR1_A5		((uint32_t)1U << 5U)
+#define	GPSR1_A4		((uint32_t)1U << 4U)
+#define	GPSR1_A3		((uint32_t)1U << 3U)
+#define	GPSR1_A2		((uint32_t)1U << 2U)
+#define	GPSR1_A1		((uint32_t)1U << 1U)
+#define	GPSR1_A0		((uint32_t)1U << 0U)
+#define	GPSR2_AVB_AVTP_CAPTURE_A	((uint32_t)1U << 14U)
+#define	GPSR2_AVB_AVTP_MATCH_A	((uint32_t)1U << 13U)
+#define	GPSR2_AVB_LINK		((uint32_t)1U << 12U)
+#define	GPSR2_AVB_PHY_INT	((uint32_t)1U << 11U)
+#define	GPSR2_AVB_MAGIC		((uint32_t)1U << 10U)
+#define	GPSR2_AVB_MDC		((uint32_t)1U << 9U)
+#define	GPSR2_PWM2_A		((uint32_t)1U << 8U)
+#define	GPSR2_PWM1_A		((uint32_t)1U << 7U)
+#define	GPSR2_PWM0		((uint32_t)1U << 6U)
+#define	GPSR2_IRQ5		((uint32_t)1U << 5U)
+#define	GPSR2_IRQ4		((uint32_t)1U << 4U)
+#define	GPSR2_IRQ3		((uint32_t)1U << 3U)
+#define	GPSR2_IRQ2		((uint32_t)1U << 2U)
+#define	GPSR2_IRQ1		((uint32_t)1U << 1U)
+#define	GPSR2_IRQ0		((uint32_t)1U << 0U)
+#define	GPSR3_SD1_WP		((uint32_t)1U << 15U)
+#define	GPSR3_SD1_CD		((uint32_t)1U << 14U)
+#define	GPSR3_SD0_WP		((uint32_t)1U << 13U)
+#define	GPSR3_SD0_CD		((uint32_t)1U << 12U)
+#define	GPSR3_SD1_DAT3		((uint32_t)1U << 11U)
+#define	GPSR3_SD1_DAT2		((uint32_t)1U << 10U)
+#define	GPSR3_SD1_DAT1		((uint32_t)1U << 9U)
+#define	GPSR3_SD1_DAT0		((uint32_t)1U << 8U)
+#define	GPSR3_SD1_CMD		((uint32_t)1U << 7U)
+#define	GPSR3_SD1_CLK		((uint32_t)1U << 6U)
+#define	GPSR3_SD0_DAT3		((uint32_t)1U << 5U)
+#define	GPSR3_SD0_DAT2		((uint32_t)1U << 4U)
+#define	GPSR3_SD0_DAT1		((uint32_t)1U << 3U)
+#define	GPSR3_SD0_DAT0		((uint32_t)1U << 2U)
+#define	GPSR3_SD0_CMD		((uint32_t)1U << 1U)
+#define	GPSR3_SD0_CLK		((uint32_t)1U << 0U)
+#define	GPSR4_SD3_DS		((uint32_t)1U << 17U)
+#define	GPSR4_SD3_DAT7		((uint32_t)1U << 16U)
+#define	GPSR4_SD3_DAT6		((uint32_t)1U << 15U)
+#define	GPSR4_SD3_DAT5		((uint32_t)1U << 14U)
+#define	GPSR4_SD3_DAT4		((uint32_t)1U << 13U)
+#define	GPSR4_SD3_DAT3		((uint32_t)1U << 12U)
+#define	GPSR4_SD3_DAT2		((uint32_t)1U << 11U)
+#define	GPSR4_SD3_DAT1		((uint32_t)1U << 10U)
+#define	GPSR4_SD3_DAT0		((uint32_t)1U << 9U)
+#define	GPSR4_SD3_CMD		((uint32_t)1U << 8U)
+#define	GPSR4_SD3_CLK		((uint32_t)1U << 7U)
+#define	GPSR4_SD2_DS		((uint32_t)1U << 6U)
+#define	GPSR4_SD2_DAT3		((uint32_t)1U << 5U)
+#define	GPSR4_SD2_DAT2		((uint32_t)1U << 4U)
+#define	GPSR4_SD2_DAT1		((uint32_t)1U << 3U)
+#define	GPSR4_SD2_DAT0		((uint32_t)1U << 2U)
+#define	GPSR4_SD2_CMD		((uint32_t)1U << 1U)
+#define	GPSR4_SD2_CLK		((uint32_t)1U << 0U)
+#define	GPSR5_MLB_DAT		((uint32_t)1U << 25U)
+#define	GPSR5_MLB_SIG		((uint32_t)1U << 24U)
+#define	GPSR5_MLB_CLK		((uint32_t)1U << 23U)
+#define	GPSR5_MSIOF0_RXD	((uint32_t)1U << 22U)
+#define	GPSR5_MSIOF0_SS2	((uint32_t)1U << 21U)
+#define	GPSR5_MSIOF0_TXD	((uint32_t)1U << 20U)
+#define	GPSR5_MSIOF0_SS1	((uint32_t)1U << 19U)
+#define	GPSR5_MSIOF0_SYNC	((uint32_t)1U << 18U)
+#define	GPSR5_MSIOF0_SCK	((uint32_t)1U << 17U)
+#define	GPSR5_HRTS0		((uint32_t)1U << 16U)
+#define	GPSR5_HCTS0		((uint32_t)1U << 15U)
+#define	GPSR5_HTX0		((uint32_t)1U << 14U)
+#define	GPSR5_HRX0		((uint32_t)1U << 13U)
+#define	GPSR5_HSCK0		((uint32_t)1U << 12U)
+#define	GPSR5_RX2_A		((uint32_t)1U << 11U)
+#define	GPSR5_TX2_A		((uint32_t)1U << 10U)
+#define	GPSR5_SCK2		((uint32_t)1U << 9U)
+#define	GPSR5_RTS1_TANS		((uint32_t)1U << 8U)
+#define	GPSR5_CTS1		((uint32_t)1U << 7U)
+#define	GPSR5_TX1_A		((uint32_t)1U << 6U)
+#define	GPSR5_RX1_A		((uint32_t)1U << 5U)
+#define	GPSR5_RTS0_TANS		((uint32_t)1U << 4U)
+#define	GPSR5_CTS0		((uint32_t)1U << 3U)
+#define	GPSR5_TX0		((uint32_t)1U << 2U)
+#define	GPSR5_RX0		((uint32_t)1U << 1U)
+#define	GPSR5_SCK0		((uint32_t)1U << 0U)
+#define	GPSR6_USB31_OVC		((uint32_t)1U << 31U)
+#define	GPSR6_USB31_PWEN	((uint32_t)1U << 30U)
+#define	GPSR6_USB30_OVC		((uint32_t)1U << 29U)
+#define	GPSR6_USB30_PWEN	((uint32_t)1U << 28U)
+#define	GPSR6_USB1_OVC		((uint32_t)1U << 27U)
+#define	GPSR6_USB1_PWEN		((uint32_t)1U << 26U)
+#define	GPSR6_USB0_OVC		((uint32_t)1U << 25U)
+#define	GPSR6_USB0_PWEN		((uint32_t)1U << 24U)
+#define	GPSR6_AUDIO_CLKB_B	((uint32_t)1U << 23U)
+#define	GPSR6_AUDIO_CLKA_A	((uint32_t)1U << 22U)
+#define	GPSR6_SSI_SDATA9_A	((uint32_t)1U << 21U)
+#define	GPSR6_SSI_SDATA8	((uint32_t)1U << 20U)
+#define	GPSR6_SSI_SDATA7	((uint32_t)1U << 19U)
+#define	GPSR6_SSI_WS78		((uint32_t)1U << 18U)
+#define	GPSR6_SSI_SCK78		((uint32_t)1U << 17U)
+#define	GPSR6_SSI_SDATA6	((uint32_t)1U << 16U)
+#define	GPSR6_SSI_WS6		((uint32_t)1U << 15U)
+#define	GPSR6_SSI_SCK6		((uint32_t)1U << 14U)
+#define	GPSR6_SSI_SDATA5	((uint32_t)1U << 13U)
+#define	GPSR6_SSI_WS5		((uint32_t)1U << 12U)
+#define	GPSR6_SSI_SCK5		((uint32_t)1U << 11U)
+#define	GPSR6_SSI_SDATA4	((uint32_t)1U << 10U)
+#define	GPSR6_SSI_WS4		((uint32_t)1U << 9U)
+#define	GPSR6_SSI_SCK4		((uint32_t)1U << 8U)
+#define	GPSR6_SSI_SDATA3	((uint32_t)1U << 7U)
+#define	GPSR6_SSI_WS34		((uint32_t)1U << 6U)
+#define	GPSR6_SSI_SCK34		((uint32_t)1U << 5U)
+#define	GPSR6_SSI_SDATA2_A	((uint32_t)1U << 4U)
+#define	GPSR6_SSI_SDATA1_A	((uint32_t)1U << 3U)
+#define	GPSR6_SSI_SDATA0	((uint32_t)1U << 2U)
+#define	GPSR6_SSI_WS0129	((uint32_t)1U << 1U)
+#define	GPSR6_SSI_SCK0129	((uint32_t)1U << 0U)
+#define	GPSR7_HDMI1_CEC		((uint32_t)1U << 3U)
+#define	GPSR7_HDMI0_CEC		((uint32_t)1U << 2U)
+#define	GPSR7_AVS2		((uint32_t)1U << 1U)
+#define	GPSR7_AVS1		((uint32_t)1U << 0U)
+
+#define	IPSR_28_FUNC(x)		((uint32_t)(x) << 28U)
+#define	IPSR_24_FUNC(x)		((uint32_t)(x) << 24U)
+#define	IPSR_20_FUNC(x)		((uint32_t)(x) << 20U)
+#define	IPSR_16_FUNC(x)		((uint32_t)(x) << 16U)
+#define	IPSR_12_FUNC(x)		((uint32_t)(x) << 12U)
+#define	IPSR_8_FUNC(x)		((uint32_t)(x) << 8U)
+#define	IPSR_4_FUNC(x)		((uint32_t)(x) << 4U)
+#define	IPSR_0_FUNC(x)		((uint32_t)(x) << 0U)
+
+#define	POC_SD3_DS_33V		((uint32_t)1U << 29U)
+#define	POC_SD3_DAT7_33V	((uint32_t)1U << 28U)
+#define	POC_SD3_DAT6_33V	((uint32_t)1U << 27U)
+#define	POC_SD3_DAT5_33V	((uint32_t)1U << 26U)
+#define	POC_SD3_DAT4_33V	((uint32_t)1U << 25U)
+#define	POC_SD3_DAT3_33V	((uint32_t)1U << 24U)
+#define	POC_SD3_DAT2_33V	((uint32_t)1U << 23U)
+#define	POC_SD3_DAT1_33V	((uint32_t)1U << 22U)
+#define	POC_SD3_DAT0_33V	((uint32_t)1U << 21U)
+#define	POC_SD3_CMD_33V		((uint32_t)1U << 20U)
+#define	POC_SD3_CLK_33V		((uint32_t)1U << 19U)
+#define	POC_SD2_DS_33V		((uint32_t)1U << 18U)
+#define	POC_SD2_DAT3_33V	((uint32_t)1U << 17U)
+#define	POC_SD2_DAT2_33V	((uint32_t)1U << 16U)
+#define	POC_SD2_DAT1_33V	((uint32_t)1U << 15U)
+#define	POC_SD2_DAT0_33V	((uint32_t)1U << 14U)
+#define	POC_SD2_CMD_33V		((uint32_t)1U << 13U)
+#define	POC_SD2_CLK_33V		((uint32_t)1U << 12U)
+#define	POC_SD1_DAT3_33V	((uint32_t)1U << 11U)
+#define	POC_SD1_DAT2_33V	((uint32_t)1U << 10U)
+#define	POC_SD1_DAT1_33V	((uint32_t)1U << 9U)
+#define	POC_SD1_DAT0_33V	((uint32_t)1U << 8U)
+#define	POC_SD1_CMD_33V		((uint32_t)1U << 7U)
+#define	POC_SD1_CLK_33V		((uint32_t)1U << 6U)
+#define	POC_SD0_DAT3_33V	((uint32_t)1U << 5U)
+#define	POC_SD0_DAT2_33V	((uint32_t)1U << 4U)
+#define	POC_SD0_DAT1_33V	((uint32_t)1U << 3U)
+#define	POC_SD0_DAT0_33V	((uint32_t)1U << 2U)
+#define	POC_SD0_CMD_33V		((uint32_t)1U << 1U)
+#define	POC_SD0_CLK_33V		((uint32_t)1U << 0U)
+
+#define	DRVCTRL0_QSPI0_SPCLK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL0_QSPI0_MOSI_IO0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL0_QSPI0_MISO_IO1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL0_QSPI0_IO2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL0_QSPI0_IO3(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL0_QSPI0_SSL(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL0_QSPI1_SPCLK(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL0_QSPI1_MOSI_IO0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL1_QSPI1_MISO_IO1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL1_QSPI1_IO2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL1_QSPI1_IO3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL1_QSPI1_SS(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL1_RPC_INT(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL1_RPC_WP(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL1_RPC_RESET(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL1_AVB_RX_CTL(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL2_AVB_RXC(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL2_AVB_RD0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL2_AVB_RD1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL2_AVB_RD2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL2_AVB_RD3(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL2_AVB_TX_CTL(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL2_AVB_TXC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL2_AVB_TD0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL3_AVB_TD1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL3_AVB_TD2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL3_AVB_TD3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL3_AVB_TXCREFCLK(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL3_AVB_MDIO(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL3_AVB_MDC(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL3_AVB_MAGIC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL3_AVB_PHY_INT(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL4_AVB_LINK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL4_AVB_AVTP_MATCH(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL4_AVB_AVTP_CAPTURE(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL4_IRQ0(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL4_IRQ1(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL4_IRQ2(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL4_IRQ3(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL4_IRQ4(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL5_IRQ5(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL5_PWM0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL5_PWM1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL5_PWM2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL5_A0(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL5_A1(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL5_A2(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL5_A3(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL6_A4(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL6_A5(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL6_A6(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL6_A7(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL6_A8(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL6_A9(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL6_A10(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL6_A11(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL7_A12(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL7_A13(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL7_A14(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL7_A15(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL7_A16(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL7_A17(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL7_A18(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL7_A19(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL8_CLKOUT(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL8_CS0(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL8_CS1_A2(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL8_BS(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL8_RD(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL8_RD_W(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL8_WE0(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL8_WE1(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL9_EX_WAIT0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL9_PRESETOU(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL9_D0(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL9_D1(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL9_D2(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL9_D3(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL9_D4(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL9_D5(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL10_D6(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL10_D7(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL10_D8(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL10_D9(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL10_D10(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL10_D11(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL10_D12(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL10_D13(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL11_D14(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL11_D15(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL11_AVS1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL11_AVS2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL11_HDMI0_CEC(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL11_HDMI1_CEC(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL11_DU_DOTCLKIN0(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL11_DU_DOTCLKIN1(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL12_DU_DOTCLKIN2(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL12_DU_DOTCLKIN3(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL12_DU_FSCLKST(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL12_DU_TMS(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL13_TDO(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL13_ASEBRK(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL13_SD0_CLK(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL13_SD0_CMD(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL13_SD0_DAT0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL13_SD0_DAT1(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL13_SD0_DAT2(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL13_SD0_DAT3(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL14_SD1_CLK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL14_SD1_CMD(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL14_SD1_DAT0(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL14_SD1_DAT1(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL14_SD1_DAT2(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL14_SD1_DAT3(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL14_SD2_CLK(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL14_SD2_CMD(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL15_SD2_DAT0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL15_SD2_DAT1(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL15_SD2_DAT2(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL15_SD2_DAT3(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL15_SD2_DS(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL15_SD3_CLK(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL15_SD3_CMD(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL15_SD3_DAT0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL16_SD3_DAT1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL16_SD3_DAT2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL16_SD3_DAT3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL16_SD3_DAT4(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL16_SD3_DAT5(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL16_SD3_DAT6(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL16_SD3_DAT7(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL16_SD3_DS(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL17_SD0_CD(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL17_SD0_WP(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL17_SD1_CD(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL17_SD1_WP(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL17_SCK0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL17_RX0(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL17_TX0(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL17_CTS0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL18_RTS0_TANS(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL18_RX1(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL18_TX1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL18_CTS1(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL18_RTS1_TANS(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL18_SCK2(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL18_TX2(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL18_RX2(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL19_HSCK0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL19_HRX0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL19_HTX0(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL19_HCTS0(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL19_HRTS0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL19_MSIOF0_SCK(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL19_MSIOF0_SYNC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL19_MSIOF0_SS1(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL20_MSIOF0_TXD(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL20_MSIOF0_SS2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL20_MSIOF0_RXD(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL20_MLB_CLK(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL20_MLB_SIG(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL20_MLB_DAT(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL20_MLB_REF(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL20_SSI_SCK0129(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL21_SSI_WS0129(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL21_SSI_SDATA0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL21_SSI_SDATA1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL21_SSI_SDATA2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL21_SSI_SCK34(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL21_SSI_WS34(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL21_SSI_SDATA3(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL21_SSI_SCK4(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL22_SSI_WS4(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL22_SSI_SDATA4(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL22_SSI_SCK5(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL22_SSI_WS5(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL22_SSI_SDATA5(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL22_SSI_SCK6(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL22_SSI_WS6(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL22_SSI_SDATA6(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL23_SSI_SCK78(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL23_SSI_WS78(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL23_SSI_SDATA7(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL23_SSI_SDATA8(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL23_SSI_SDATA9(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL23_AUDIO_CLKA(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL23_AUDIO_CLKB(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL23_USB0_PWEN(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL24_USB0_OVC(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL24_USB1_PWEN(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL24_USB1_OVC(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL24_USB30_PWEN(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL24_USB30_OVC(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL24_USB31_PWEN(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL24_USB31_OVC(x)	((uint32_t)(x) << 4U)
+
+#define	MOD_SEL0_MSIOF3_A	((uint32_t)0U << 29U)
+#define	MOD_SEL0_MSIOF3_B	((uint32_t)1U << 29U)
+#define	MOD_SEL0_MSIOF3_C	((uint32_t)2U << 29U)
+#define	MOD_SEL0_MSIOF3_D	((uint32_t)3U << 29U)
+#define	MOD_SEL0_MSIOF2_A	((uint32_t)0U << 27U)
+#define	MOD_SEL0_MSIOF2_B	((uint32_t)1U << 27U)
+#define	MOD_SEL0_MSIOF2_C	((uint32_t)2U << 27U)
+#define	MOD_SEL0_MSIOF2_D	((uint32_t)3U << 27U)
+#define	MOD_SEL0_MSIOF1_A	((uint32_t)0U << 24U)
+#define	MOD_SEL0_MSIOF1_B	((uint32_t)1U << 24U)
+#define	MOD_SEL0_MSIOF1_C	((uint32_t)2U << 24U)
+#define	MOD_SEL0_MSIOF1_D	((uint32_t)3U << 24U)
+#define	MOD_SEL0_MSIOF1_E	((uint32_t)4U << 24U)
+#define	MOD_SEL0_MSIOF1_F	((uint32_t)5U << 24U)
+#define	MOD_SEL0_MSIOF1_G	((uint32_t)6U << 24U)
+#define	MOD_SEL0_LBSC_A		((uint32_t)0U << 23U)
+#define	MOD_SEL0_LBSC_B		((uint32_t)1U << 23U)
+#define	MOD_SEL0_IEBUS_A	((uint32_t)0U << 22U)
+#define	MOD_SEL0_IEBUS_B	((uint32_t)1U << 22U)
+#define	MOD_SEL0_I2C6_A		((uint32_t)0U << 20U)
+#define	MOD_SEL0_I2C6_B		((uint32_t)1U << 20U)
+#define	MOD_SEL0_I2C6_C		((uint32_t)2U << 20U)
+#define	MOD_SEL0_I2C2_A		((uint32_t)0U << 19U)
+#define	MOD_SEL0_I2C2_B		((uint32_t)1U << 19U)
+#define	MOD_SEL0_I2C1_A		((uint32_t)0U << 18U)
+#define	MOD_SEL0_I2C1_B		((uint32_t)1U << 18U)
+#define	MOD_SEL0_HSCIF4_A	((uint32_t)0U << 17U)
+#define	MOD_SEL0_HSCIF4_B	((uint32_t)1U << 17U)
+#define	MOD_SEL0_HSCIF3_A	((uint32_t)0U << 15U)
+#define	MOD_SEL0_HSCIF3_B	((uint32_t)1U << 15U)
+#define	MOD_SEL0_HSCIF3_C	((uint32_t)2U << 15U)
+#define	MOD_SEL0_HSCIF3_D	((uint32_t)3U << 15U)
+#define	MOD_SEL0_HSCIF2_A	((uint32_t)0U << 14U)
+#define	MOD_SEL0_HSCIF2_B	((uint32_t)1U << 14U)
+#define	MOD_SEL0_HSCIF1_A	((uint32_t)0U << 13U)
+#define	MOD_SEL0_HSCIF1_B	((uint32_t)1U << 13U)
+#define	MOD_SEL0_FSO_B		((uint32_t)1U << 12U)
+#define	MOD_SEL0_FM_A		((uint32_t)0U << 11U)
+#define	MOD_SEL0_FM_B		((uint32_t)1U << 11U)
+#define	MOD_SEL0_ETHERAVB_A	((uint32_t)0U << 10U)
+#define	MOD_SEL0_ETHERAVB_B	((uint32_t)1U << 10U)
+#define	MOD_SEL0_DRIF3_A	((uint32_t)0U << 9U)
+#define	MOD_SEL0_DRIF3_B	((uint32_t)1U << 9U)
+#define	MOD_SEL0_DRIF2_A	((uint32_t)0U << 8U)
+#define	MOD_SEL0_DRIF2_B	((uint32_t)1U << 8U)
+#define	MOD_SEL0_DRIF1_A	((uint32_t)0U << 6U)
+#define	MOD_SEL0_DRIF1_B	((uint32_t)1U << 6U)
+#define	MOD_SEL0_DRIF1_C	((uint32_t)2U << 6U)
+#define	MOD_SEL0_DRIF0_A	((uint32_t)0U << 4U)
+#define	MOD_SEL0_DRIF0_B	((uint32_t)1U << 4U)
+#define	MOD_SEL0_DRIF0_C	((uint32_t)2U << 4U)
+#define	MOD_SEL0_CANFD0_A	((uint32_t)0U << 3U)
+#define	MOD_SEL0_CANFD0_B	((uint32_t)1U << 3U)
+#define	MOD_SEL0_ADG_A		((uint32_t)0U << 1U)
+#define	MOD_SEL0_ADG_B		((uint32_t)1U << 1U)
+#define	MOD_SEL0_ADG_C		((uint32_t)2U << 1U)
+#define	MOD_SEL0_ADG_D		((uint32_t)3U << 1U)
+#define	MOD_SEL0_5LINE_A	((uint32_t)0U << 0U)
+#define	MOD_SEL0_5LINE_B	((uint32_t)1U << 0U)
+#define	MOD_SEL1_TSIF1_A	((uint32_t)0U << 30U)
+#define	MOD_SEL1_TSIF1_B	((uint32_t)1U << 30U)
+#define	MOD_SEL1_TSIF1_C	((uint32_t)2U << 30U)
+#define	MOD_SEL1_TSIF1_D	((uint32_t)3U << 30U)
+#define	MOD_SEL1_TSIF0_A	((uint32_t)0U << 27U)
+#define	MOD_SEL1_TSIF0_B	((uint32_t)1U << 27U)
+#define	MOD_SEL1_TSIF0_C	((uint32_t)2U << 27U)
+#define	MOD_SEL1_TSIF0_D	((uint32_t)3U << 27U)
+#define	MOD_SEL1_TSIF0_E	((uint32_t)4U << 27U)
+#define	MOD_SEL1_TIMER_TMU_A	((uint32_t)0U << 26U)
+#define	MOD_SEL1_TIMER_TMU_B	((uint32_t)1U << 26U)
+#define	MOD_SEL1_SSP1_1_A	((uint32_t)0U << 24U)
+#define	MOD_SEL1_SSP1_1_B	((uint32_t)1U << 24U)
+#define	MOD_SEL1_SSP1_1_C	((uint32_t)2U << 24U)
+#define	MOD_SEL1_SSP1_1_D	((uint32_t)3U << 24U)
+#define	MOD_SEL1_SSP1_0_A	((uint32_t)0U << 21U)
+#define	MOD_SEL1_SSP1_0_B	((uint32_t)1U << 21U)
+#define	MOD_SEL1_SSP1_0_C	((uint32_t)2U << 21U)
+#define	MOD_SEL1_SSP1_0_D	((uint32_t)3U << 21U)
+#define	MOD_SEL1_SSP1_0_E	((uint32_t)4U << 21U)
+#define	MOD_SEL1_SSI_A		((uint32_t)0U << 20U)
+#define	MOD_SEL1_SSI_B		((uint32_t)1U << 20U)
+#define	MOD_SEL1_SPEED_PULSE_IF_A	((uint32_t)0U << 19U)
+#define	MOD_SEL1_SPEED_PULSE_IF_B	((uint32_t)1U << 19U)
+#define	MOD_SEL1_SIMCARD_A	((uint32_t)0U << 17U)
+#define	MOD_SEL1_SIMCARD_B	((uint32_t)1U << 17U)
+#define	MOD_SEL1_SIMCARD_C	((uint32_t)2U << 17U)
+#define	MOD_SEL1_SIMCARD_D	((uint32_t)3U << 17U)
+#define	MOD_SEL1_SDHI2_A	((uint32_t)0U << 16U)
+#define	MOD_SEL1_SDHI2_B	((uint32_t)1U << 16U)
+#define	MOD_SEL1_SCIF4_A	((uint32_t)0U << 14U)
+#define	MOD_SEL1_SCIF4_B	((uint32_t)1U << 14U)
+#define	MOD_SEL1_SCIF4_C	((uint32_t)2U << 14U)
+#define	MOD_SEL1_SCIF3_A	((uint32_t)0U << 13U)
+#define	MOD_SEL1_SCIF3_B	((uint32_t)1U << 13U)
+#define	MOD_SEL1_SCIF2_A	((uint32_t)0U << 12U)
+#define	MOD_SEL1_SCIF2_B	((uint32_t)1U << 12U)
+#define	MOD_SEL1_SCIF1_A	((uint32_t)0U << 11U)
+#define	MOD_SEL1_SCIF1_B	((uint32_t)1U << 11U)
+#define	MOD_SEL1_SCIF_A		((uint32_t)0U << 10U)
+#define	MOD_SEL1_SCIF_B		((uint32_t)1U << 10U)
+#define	MOD_SEL1_REMOCON_A	((uint32_t)0U << 9U)
+#define	MOD_SEL1_REMOCON_B	((uint32_t)1U << 9U)
+#define	MOD_SEL1_RDS_A		((uint32_t)0U << 7U)
+#define	MOD_SEL1_RDS_B		((uint32_t)1U << 7U)
+#define	MOD_SEL1_RDS_C		((uint32_t)2U << 7U)
+#define	MOD_SEL1_RCAN0_A	((uint32_t)0U << 6U)
+#define	MOD_SEL1_RCAN0_B	((uint32_t)1U << 6U)
+#define	MOD_SEL1_PWM6_A		((uint32_t)0U << 5U)
+#define	MOD_SEL1_PWM6_B		((uint32_t)1U << 5U)
+#define	MOD_SEL1_PWM5_A		((uint32_t)0U << 4U)
+#define	MOD_SEL1_PWM5_B		((uint32_t)1U << 4U)
+#define	MOD_SEL1_PWM4_A		((uint32_t)0U << 3U)
+#define	MOD_SEL1_PWM4_B		((uint32_t)1U << 3U)
+#define	MOD_SEL1_PWM3_A		((uint32_t)0U << 2U)
+#define	MOD_SEL1_PWM3_B		((uint32_t)1U << 2U)
+#define	MOD_SEL1_PWM2_A		((uint32_t)0U << 1U)
+#define	MOD_SEL1_PWM2_B		((uint32_t)1U << 1U)
+#define	MOD_SEL1_PWM1_A		((uint32_t)0U << 0U)
+#define	MOD_SEL1_PWM1_B		((uint32_t)1U << 0U)
+#define	MOD_SEL2_I2C_5_A	((uint32_t)0U << 31U)
+#define	MOD_SEL2_I2C_5_B	((uint32_t)1U << 31U)
+#define	MOD_SEL2_I2C_3_A	((uint32_t)0U << 30U)
+#define	MOD_SEL2_I2C_3_B	((uint32_t)1U << 30U)
+#define	MOD_SEL2_I2C_0_A	((uint32_t)0U << 29U)
+#define	MOD_SEL2_I2C_0_B	((uint32_t)1U << 29U)
+#define	MOD_SEL2_VSP_A		((uint32_t)0U << 1U)
+#define	MOD_SEL2_VSP_B		((uint32_t)1U << 1U)
+#define	MOD_SEL2_VSP_C		((uint32_t)2U << 1U)
+#define	MOD_SEL2_VSP_D		((uint32_t)3U << 1U)
+#define	MOD_SEL2_VIN4_A		((uint32_t)0U << 0U)
+#define	MOD_SEL2_VIN4_B		((uint32_t)1U << 0U)
+
+#if 0
+#define	PFC_GPSR5_SCIF2_MASK	((uint32_t)3U << 10U)
+#define	PFC_GPSR5_IP05_7_4	((uint32_t)1U << 11U)
+#define	PFC_GPSR5_IP05_3_0	((uint32_t)1U << 10U)
+#define	PFC_GPSR5_SCIF2_DATA	(PFC_GPSR5_IP05_7_4 + PFC_GPSR5_IP05_3_0)
+
+#define	PFC_IPSR12_SCIF2_MASK	((uint32_t)255U << 0U)
+#define	PFC_IPSR12_RX2_A	((uint32_t)0U << 4U)
+#define	PFC_IPSR12_TX2_A	((uint32_t)0U << 0U)
+#define	PFC_IPSR12_SCIF2_DATA	(IPSR12_RX2_A + IPSR12_TX2_A)
+
+#define	PFC_MOD_SEL1_SCIF2_MASK	((uint32_t)1U << 12U)
+#define	PFC_MOD_SEL1_SCIF2_A	((uint32_t)0U << 12U)
+#endif
+
+
+static void pfc_reg_write(uint32_t addr, uint32_t data);
+
+static void pfc_reg_write(uint32_t addr, uint32_t data)
+{
+	mmio_write_32(PFC_PMMR, ~data);
+	mmio_write_32((uintptr_t)addr, data);
+}
+
+
+void bl2_pfc_init(void)
+{
+#if 0
+	uint32_t	data;
+
+	/* SCIF2 */
+	data = mmio_read_32(PFC_MOD_SEL1);
+	/* sel_scif2 function = RX2_A/TX_2A, Pin = RX2_A/TX2_A */
+	data &= ~PFC_MOD_SEL1_SCIF2_MASK;
+	mmio_write_32(PFC_PMMR, ~data);
+	mmio_write_32(PFC_MOD_SEL1, data);
+
+	data = mmio_read_32(PFC_IPSR12);
+	/* IP12[7:4]=H'0(RX2_A), IP12[3:0]=H'0(TX_2A) */
+	data &= ~PFC_IPSR12_SCIF2_MASK;
+	mmio_write_32(PFC_PMMR, ~data);
+	mmio_write_32(PFC_IPSR12, data);
+
+	data = mmio_read_32(PFC_GPSR5);
+	data &= ~PFC_GPSR5_SCIF2_MASK;
+	data |= PFC_GPSR5_SCIF2_DATA;
+	mmio_write_32(PFC_PMMR, ~data);
+	mmio_write_32(PFC_GPSR5, data);
+#endif
+
+	/* initialize module select */
+	pfc_reg_write(PFC_MOD_SEL0, MOD_SEL0_MSIOF3_A
+				  | MOD_SEL0_MSIOF2_A
+				  | MOD_SEL0_MSIOF1_A
+				  | MOD_SEL0_LBSC_A
+				  | MOD_SEL0_IEBUS_A
+				  | MOD_SEL0_I2C6_A
+				  | MOD_SEL0_I2C2_A
+				  | MOD_SEL0_I2C1_A
+				  | MOD_SEL0_HSCIF4_A
+				  | MOD_SEL0_HSCIF3_A
+				  | MOD_SEL0_HSCIF2_A
+				  | MOD_SEL0_HSCIF1_A
+				  | MOD_SEL0_FM_A
+				  | MOD_SEL0_ETHERAVB_A
+				  | MOD_SEL0_DRIF3_A
+				  | MOD_SEL0_DRIF2_A
+				  | MOD_SEL0_DRIF1_A
+				  | MOD_SEL0_DRIF0_A
+				  | MOD_SEL0_CANFD0_A
+				  | MOD_SEL0_ADG_A
+				  | MOD_SEL0_5LINE_A);
+	pfc_reg_write(PFC_MOD_SEL1, MOD_SEL1_TSIF1_A
+				  | MOD_SEL1_TSIF0_A
+				  | MOD_SEL1_TIMER_TMU_A
+				  | MOD_SEL1_SSP1_1_A
+				  | MOD_SEL1_SSP1_0_A
+				  | MOD_SEL1_SSI_A
+				  | MOD_SEL1_SPEED_PULSE_IF_A
+				  | MOD_SEL1_SIMCARD_A
+				  | MOD_SEL1_SDHI2_A
+				  | MOD_SEL1_SCIF4_A
+				  | MOD_SEL1_SCIF3_A
+				  | MOD_SEL1_SCIF2_A
+				  | MOD_SEL1_SCIF1_A
+				  | MOD_SEL1_SCIF_A
+				  | MOD_SEL1_REMOCON_A
+				  | MOD_SEL1_RDS_A
+				  | MOD_SEL1_RCAN0_A
+				  | MOD_SEL1_PWM6_A
+				  | MOD_SEL1_PWM5_A
+				  | MOD_SEL1_PWM4_A
+				  | MOD_SEL1_PWM3_A
+				  | MOD_SEL1_PWM2_A
+				  | MOD_SEL1_PWM1_A);
+	pfc_reg_write(PFC_MOD_SEL2, MOD_SEL2_I2C_5_A
+				  | MOD_SEL2_I2C_3_A
+				  | MOD_SEL2_I2C_0_A
+				  | MOD_SEL2_VSP_A
+				  | MOD_SEL2_VIN4_A);
+
+	/* initialize peripheral function select */
+	pfc_reg_write(PFC_IPSR0, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR1, IPSR_28_FUNC(6)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(3)
+			       | IPSR_8_FUNC(3)
+			       | IPSR_4_FUNC(3)
+			       | IPSR_0_FUNC(3));
+	pfc_reg_write(PFC_IPSR2, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(6)
+			       | IPSR_20_FUNC(6)
+			       | IPSR_16_FUNC(6)
+			       | IPSR_12_FUNC(6)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(6)
+			       | IPSR_0_FUNC(6));
+	pfc_reg_write(PFC_IPSR3, IPSR_28_FUNC(6)
+			       | IPSR_24_FUNC(6)
+			       | IPSR_20_FUNC(6)
+			       | IPSR_16_FUNC(6)
+			       | IPSR_12_FUNC(6)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR4, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(6)
+			       | IPSR_0_FUNC(6));
+	pfc_reg_write(PFC_IPSR5, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR6, IPSR_28_FUNC(6)
+			       | IPSR_24_FUNC(6)
+			       | IPSR_20_FUNC(6)
+			       | IPSR_16_FUNC(6)
+			       | IPSR_12_FUNC(6)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR7, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(6)
+			       | IPSR_0_FUNC(6));
+	pfc_reg_write(PFC_IPSR8, IPSR_28_FUNC(1)
+			       | IPSR_24_FUNC(1)
+			       | IPSR_20_FUNC(1)
+			       | IPSR_16_FUNC(1)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR9, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR10, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(4)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(1)
+				| IPSR_0_FUNC(1));
+	pfc_reg_write(PFC_IPSR11, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(4)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR12, IPSR_28_FUNC(8)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(3)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR13, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(3)
+				| IPSR_0_FUNC(8));
+	pfc_reg_write(PFC_IPSR14, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR15, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(1)
+				| IPSR_0_FUNC(1));
+	pfc_reg_write(PFC_IPSR16, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(1)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR17, IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+
+	/* initialize GPIO/perihperal function select */
+	pfc_reg_write(PFC_GPSR0, GPSR0_D15
+			       | GPSR0_D14
+			       | GPSR0_D13
+			       | GPSR0_D12
+			       | GPSR0_D11
+			       | GPSR0_D10
+			       | GPSR0_D9
+			       | GPSR0_D8);
+	pfc_reg_write(PFC_GPSR1, GPSR1_EX_WAIT0_A
+			       | GPSR1_A19
+			       | GPSR1_A18
+			       | GPSR1_A17
+			       | GPSR1_A16
+			       | GPSR1_A15
+			       | GPSR1_A14
+			       | GPSR1_A13
+			       | GPSR1_A12
+			       | GPSR1_A7
+			       | GPSR1_A6
+			       | GPSR1_A5
+			       | GPSR1_A4
+			       | GPSR1_A3
+			       | GPSR1_A2
+			       | GPSR1_A1
+			       | GPSR1_A0);
+	pfc_reg_write(PFC_GPSR2, GPSR2_AVB_AVTP_CAPTURE_A
+			       | GPSR2_AVB_AVTP_MATCH_A
+			       | GPSR2_AVB_LINK
+			       | GPSR2_AVB_PHY_INT
+			       | GPSR2_AVB_MDC
+			       | GPSR2_PWM2_A
+			       | GPSR2_PWM1_A
+			       | GPSR2_IRQ5
+			       | GPSR2_IRQ4
+			       | GPSR2_IRQ3
+			       | GPSR2_IRQ2
+			       | GPSR2_IRQ1
+			       | GPSR2_IRQ0);
+	pfc_reg_write(PFC_GPSR3, GPSR3_SD0_WP
+			       | GPSR3_SD0_CD
+			       | GPSR3_SD1_DAT3
+			       | GPSR3_SD1_DAT2
+			       | GPSR3_SD1_DAT1
+			       | GPSR3_SD1_DAT0
+			       | GPSR3_SD0_DAT3
+			       | GPSR3_SD0_DAT2
+			       | GPSR3_SD0_DAT1
+			       | GPSR3_SD0_DAT0
+			       | GPSR3_SD0_CMD
+			       | GPSR3_SD0_CLK);
+	pfc_reg_write(PFC_GPSR4, GPSR4_SD3_DAT7
+			       | GPSR4_SD3_DAT6
+			       | GPSR4_SD3_DAT3
+			       | GPSR4_SD3_DAT2
+			       | GPSR4_SD3_DAT1
+			       | GPSR4_SD3_DAT0
+			       | GPSR4_SD3_CMD
+			       | GPSR4_SD3_CLK
+			       | GPSR4_SD2_DS
+			       | GPSR4_SD2_DAT3
+			       | GPSR4_SD2_DAT2
+			       | GPSR4_SD2_DAT1
+			       | GPSR4_SD2_DAT0
+			       | GPSR4_SD2_CMD
+			       | GPSR4_SD2_CLK);
+	pfc_reg_write(PFC_GPSR5, GPSR5_MSIOF0_SS2
+			       | GPSR5_MSIOF0_SS1
+			       | GPSR5_MSIOF0_SYNC
+			       | GPSR5_HRTS0
+			       | GPSR5_HCTS0
+			       | GPSR5_HTX0
+			       | GPSR5_HRX0
+			       | GPSR5_HSCK0
+			       | GPSR5_RX2_A
+			       | GPSR5_TX2_A
+			       | GPSR5_SCK2
+			       | GPSR5_RTS1_TANS
+			       | GPSR5_CTS1
+			       | GPSR5_TX1_A
+			       | GPSR5_RX1_A
+			       | GPSR5_RTS0_TANS
+			       | GPSR5_SCK0);
+	pfc_reg_write(PFC_GPSR6, GPSR6_USB30_OVC
+			       | GPSR6_USB30_PWEN
+			       | GPSR6_USB1_OVC
+			       | GPSR6_USB1_PWEN
+			       | GPSR6_USB0_OVC
+			       | GPSR6_USB0_PWEN
+			       | GPSR6_AUDIO_CLKB_B
+			       | GPSR6_AUDIO_CLKA_A
+			       | GPSR6_SSI_SDATA8
+			       | GPSR6_SSI_SDATA7
+			       | GPSR6_SSI_WS78
+			       | GPSR6_SSI_SCK78
+			       | GPSR6_SSI_WS6
+			       | GPSR6_SSI_SCK6
+			       | GPSR6_SSI_SDATA4
+			       | GPSR6_SSI_WS4
+			       | GPSR6_SSI_SCK4
+			       | GPSR6_SSI_SDATA1_A
+			       | GPSR6_SSI_SDATA0
+			       | GPSR6_SSI_WS0129
+			       | GPSR6_SSI_SCK0129);
+	pfc_reg_write(PFC_GPSR7, GPSR7_HDMI1_CEC
+			       | GPSR7_HDMI0_CEC
+			       | GPSR7_AVS2
+			       | GPSR7_AVS1);
+
+	/* initialize POC control register */
+	pfc_reg_write(PFC_POCCTRL0, POC_SD3_DS_33V
+				  | POC_SD3_DAT7_33V
+				  | POC_SD3_DAT6_33V
+				  | POC_SD3_DAT5_33V
+				  | POC_SD3_DAT4_33V
+				  | POC_SD3_DAT3_33V
+				  | POC_SD3_DAT2_33V
+				  | POC_SD3_DAT1_33V
+				  | POC_SD3_DAT0_33V
+				  | POC_SD3_CMD_33V
+				  | POC_SD3_CLK_33V
+				  | POC_SD0_DAT3_33V
+				  | POC_SD0_DAT2_33V
+				  | POC_SD0_DAT1_33V
+				  | POC_SD0_DAT0_33V
+				  | POC_SD0_CMD_33V
+				  | POC_SD0_CLK_33V);
+
+	/* initialize DRV control register */
+	pfc_reg_write(PFC_DRVCTRL0, DRVCTRL0_QSPI0_SPCLK(3)
+				  | DRVCTRL0_QSPI0_MOSI_IO0(3)
+				  | DRVCTRL0_QSPI0_MISO_IO1(3)
+				  | DRVCTRL0_QSPI0_IO2(3)
+				  | DRVCTRL0_QSPI0_IO3(3)
+				  | DRVCTRL0_QSPI0_SSL(3)
+				  | DRVCTRL0_QSPI1_SPCLK(3)
+				  | DRVCTRL0_QSPI1_MOSI_IO0(3));
+	pfc_reg_write(PFC_DRVCTRL1, DRVCTRL1_QSPI1_MISO_IO1(3)
+				  | DRVCTRL1_QSPI1_IO2(3)
+				  | DRVCTRL1_QSPI1_IO3(3)
+				  | DRVCTRL1_QSPI1_SS(3)
+				  | DRVCTRL1_RPC_INT(3)
+				  | DRVCTRL1_RPC_WP(3)
+				  | DRVCTRL1_RPC_RESET(3)
+				  | DRVCTRL1_AVB_RX_CTL(7));
+	pfc_reg_write(PFC_DRVCTRL2, DRVCTRL2_AVB_RXC(7)
+				  | DRVCTRL2_AVB_RD0(7)
+				  | DRVCTRL2_AVB_RD1(7)
+				  | DRVCTRL2_AVB_RD2(7)
+				  | DRVCTRL2_AVB_RD3(7)
+				  | DRVCTRL2_AVB_TX_CTL(7)
+				  | DRVCTRL2_AVB_TXC(7)
+				  | DRVCTRL2_AVB_TD0(7));
+	pfc_reg_write(PFC_DRVCTRL3, DRVCTRL3_AVB_TD1(7)
+				  | DRVCTRL3_AVB_TD2(7)
+				  | DRVCTRL3_AVB_TD3(7)
+				  | DRVCTRL3_AVB_TXCREFCLK(7)
+				  | DRVCTRL3_AVB_MDIO(7)
+				  | DRVCTRL3_AVB_MDC(7)
+				  | DRVCTRL3_AVB_MAGIC(7)
+				  | DRVCTRL3_AVB_PHY_INT(7));
+	pfc_reg_write(PFC_DRVCTRL4, DRVCTRL4_AVB_LINK(7)
+				  | DRVCTRL4_AVB_AVTP_MATCH(7)
+				  | DRVCTRL4_AVB_AVTP_CAPTURE(7)
+				  | DRVCTRL4_IRQ0(7)
+				  | DRVCTRL4_IRQ1(7)
+				  | DRVCTRL4_IRQ2(7)
+				  | DRVCTRL4_IRQ3(7)
+				  | DRVCTRL4_IRQ4(7));
+	pfc_reg_write(PFC_DRVCTRL5, DRVCTRL5_IRQ5(7)
+				  | DRVCTRL5_PWM0(7)
+				  | DRVCTRL5_PWM1(7)
+				  | DRVCTRL5_PWM2(7)
+				  | DRVCTRL5_A0(7)
+				  | DRVCTRL5_A1(7)
+				  | DRVCTRL5_A2(7)
+				  | DRVCTRL5_A3(7));
+	pfc_reg_write(PFC_DRVCTRL6, DRVCTRL6_A4(7)
+				  | DRVCTRL6_A5(7)
+				  | DRVCTRL6_A6(7)
+				  | DRVCTRL6_A7(7)
+				  | DRVCTRL6_A8(7)
+				  | DRVCTRL6_A9(7)
+				  | DRVCTRL6_A10(7)
+				  | DRVCTRL6_A11(7));
+	pfc_reg_write(PFC_DRVCTRL7, DRVCTRL7_A12(7)
+				  | DRVCTRL7_A13(7)
+				  | DRVCTRL7_A14(7)
+				  | DRVCTRL7_A15(7)
+				  | DRVCTRL7_A16(7)
+				  | DRVCTRL7_A17(7)
+				  | DRVCTRL7_A18(7)
+				  | DRVCTRL7_A19(7));
+	pfc_reg_write(PFC_DRVCTRL8, DRVCTRL8_CLKOUT(7)
+				  | DRVCTRL8_CS0(7)
+				  | DRVCTRL8_CS1_A2(7)
+				  | DRVCTRL8_BS(7)
+				  | DRVCTRL8_RD(7)
+				  | DRVCTRL8_RD_W(7)
+				  | DRVCTRL8_WE0(7)
+				  | DRVCTRL8_WE1(7));
+	pfc_reg_write(PFC_DRVCTRL9, DRVCTRL9_EX_WAIT0(7)
+				  | DRVCTRL9_PRESETOU(7)
+				  | DRVCTRL9_D0(7)
+				  | DRVCTRL9_D1(7)
+				  | DRVCTRL9_D2(7)
+				  | DRVCTRL9_D3(7)
+				  | DRVCTRL9_D4(7)
+				  | DRVCTRL9_D5(7));
+	pfc_reg_write(PFC_DRVCTRL10, DRVCTRL10_D6(7)
+				   | DRVCTRL10_D7(7)
+				   | DRVCTRL10_D8(7)
+				   | DRVCTRL10_D9(7)
+				   | DRVCTRL10_D10(7)
+				   | DRVCTRL10_D11(7)
+				   | DRVCTRL10_D12(7)
+				   | DRVCTRL10_D13(7));
+	pfc_reg_write(PFC_DRVCTRL11, DRVCTRL11_D14(7)
+				   | DRVCTRL11_D15(7)
+				   | DRVCTRL11_AVS1(7)
+				   | DRVCTRL11_AVS2(7)
+				   | DRVCTRL11_HDMI0_CEC(7)
+				   | DRVCTRL11_HDMI1_CEC(7)
+				   | DRVCTRL11_DU_DOTCLKIN0(3)
+				   | DRVCTRL11_DU_DOTCLKIN1(3));
+	pfc_reg_write(PFC_DRVCTRL12, DRVCTRL12_DU_DOTCLKIN2(3)
+				   | DRVCTRL12_DU_DOTCLKIN3(3)
+				   | DRVCTRL12_DU_FSCLKST(3)
+				   | DRVCTRL12_DU_TMS(3));
+	pfc_reg_write(PFC_DRVCTRL13, DRVCTRL13_TDO(3)
+				   | DRVCTRL13_ASEBRK(3)
+				   | DRVCTRL13_SD0_CLK(7)
+				   | DRVCTRL13_SD0_CMD(7)
+				   | DRVCTRL13_SD0_DAT0(7)
+				   | DRVCTRL13_SD0_DAT1(7)
+				   | DRVCTRL13_SD0_DAT2(7)
+				   | DRVCTRL13_SD0_DAT3(7));
+	pfc_reg_write(PFC_DRVCTRL14, DRVCTRL14_SD1_CLK(7)
+				   | DRVCTRL14_SD1_CMD(7)
+				   | DRVCTRL14_SD1_DAT0(7)
+				   | DRVCTRL14_SD1_DAT1(7)
+				   | DRVCTRL14_SD1_DAT2(7)
+				   | DRVCTRL14_SD1_DAT3(7)
+				   | DRVCTRL14_SD2_CLK(7)
+				   | DRVCTRL14_SD2_CMD(7));
+	pfc_reg_write(PFC_DRVCTRL15, DRVCTRL15_SD2_DAT0(7)
+				   | DRVCTRL15_SD2_DAT1(7)
+				   | DRVCTRL15_SD2_DAT2(7)
+				   | DRVCTRL15_SD2_DAT3(7)
+				   | DRVCTRL15_SD2_DS(7)
+				   | DRVCTRL15_SD3_CLK(7)
+				   | DRVCTRL15_SD3_CMD(7)
+				   | DRVCTRL15_SD3_DAT0(7));
+	pfc_reg_write(PFC_DRVCTRL16, DRVCTRL16_SD3_DAT1(7)
+				   | DRVCTRL16_SD3_DAT2(7)
+				   | DRVCTRL16_SD3_DAT3(7)
+				   | DRVCTRL16_SD3_DAT4(7)
+				   | DRVCTRL16_SD3_DAT5(7)
+				   | DRVCTRL16_SD3_DAT6(7)
+				   | DRVCTRL16_SD3_DAT7(7)
+				   | DRVCTRL16_SD3_DS(7));
+	pfc_reg_write(PFC_DRVCTRL17,DRVCTRL17_SD0_CD(7)
+				   | DRVCTRL17_SD0_WP(7)
+				   | DRVCTRL17_SD1_CD(7)
+				   | DRVCTRL17_SD1_WP(7)
+				   | DRVCTRL17_SCK0(7)
+				   | DRVCTRL17_RX0(7)
+				   | DRVCTRL17_TX0(7)
+				   | DRVCTRL17_CTS0(7));
+	pfc_reg_write(PFC_DRVCTRL18, DRVCTRL18_RTS0_TANS(7)
+				   | DRVCTRL18_RX1(7)
+				   | DRVCTRL18_TX1(7)
+				   | DRVCTRL18_CTS1(7)
+				   | DRVCTRL18_RTS1_TANS(7)
+				   | DRVCTRL18_SCK2(7)
+				   | DRVCTRL18_TX2(7)
+				   | DRVCTRL18_RX2(7));
+	pfc_reg_write(PFC_DRVCTRL19, DRVCTRL19_HSCK0(7)
+				   | DRVCTRL19_HRX0(7)
+				   | DRVCTRL19_HTX0(7)
+				   | DRVCTRL19_HCTS0(7)
+				   | DRVCTRL19_HRTS0(7)
+				   | DRVCTRL19_MSIOF0_SCK(7)
+				   | DRVCTRL19_MSIOF0_SYNC(7)
+				   | DRVCTRL19_MSIOF0_SS1(7));
+	pfc_reg_write(PFC_DRVCTRL20, DRVCTRL20_MSIOF0_TXD(7)
+				   | DRVCTRL20_MSIOF0_SS2(7)
+				   | DRVCTRL20_MSIOF0_RXD(7)
+				   | DRVCTRL20_MLB_CLK(7)
+				   | DRVCTRL20_MLB_SIG(7)
+				   | DRVCTRL20_MLB_DAT(7)
+				   | DRVCTRL20_MLB_REF(7)
+				   | DRVCTRL20_SSI_SCK0129(7));
+	pfc_reg_write(PFC_DRVCTRL21, DRVCTRL21_SSI_WS0129(7)
+				   | DRVCTRL21_SSI_SDATA0(7)
+				   | DRVCTRL21_SSI_SDATA1(7)
+				   | DRVCTRL21_SSI_SDATA2(7)
+				   | DRVCTRL21_SSI_SCK34(7)
+				   | DRVCTRL21_SSI_WS34(7)
+				   | DRVCTRL21_SSI_SDATA3(7)
+				   | DRVCTRL21_SSI_SCK4(7));
+	pfc_reg_write(PFC_DRVCTRL22, DRVCTRL22_SSI_WS4(7)
+				   | DRVCTRL22_SSI_SDATA4(7)
+				   | DRVCTRL22_SSI_SCK5(7)
+				   | DRVCTRL22_SSI_WS5(7)
+				   | DRVCTRL22_SSI_SDATA5(7)
+				   | DRVCTRL22_SSI_SCK6(7)
+				   | DRVCTRL22_SSI_WS6(7)
+				   | DRVCTRL22_SSI_SDATA6(7));
+	pfc_reg_write(PFC_DRVCTRL23, DRVCTRL23_SSI_SCK78(7)
+				   | DRVCTRL23_SSI_WS78(7)
+				   | DRVCTRL23_SSI_SDATA7(7)
+				   | DRVCTRL23_SSI_SDATA8(7)
+				   | DRVCTRL23_SSI_SDATA9(7)
+				   | DRVCTRL23_AUDIO_CLKA(7)
+				   | DRVCTRL23_AUDIO_CLKB(7)
+				   | DRVCTRL23_USB0_PWEN(7));
+	pfc_reg_write(PFC_DRVCTRL24, DRVCTRL24_USB0_OVC(7)
+				   | DRVCTRL24_USB1_PWEN(7)
+				   | DRVCTRL24_USB1_OVC(7)
+				   | DRVCTRL24_USB30_PWEN(7)
+				   | DRVCTRL24_USB30_OVC(7)
+				   | DRVCTRL24_USB31_PWEN(7)
+				   | DRVCTRL24_USB31_OVC(7));
+
+	/* initialize LSI pin pull-up/down control */
+	pfc_reg_write(PFC_PUD0,0x00005FBFU);
+	pfc_reg_write(PFC_PUD1,0x00300FFEU);
+	pfc_reg_write(PFC_PUD2,0x330001E6U);
+	pfc_reg_write(PFC_PUD3,0x000002E0U);
+	pfc_reg_write(PFC_PUD4,0xFFFFFF00U);
+	pfc_reg_write(PFC_PUD5,0x7F5FFF87U);
+	pfc_reg_write(PFC_PUD6,0x00000055U);
+
+	/* initialize LSI pin pull-enable register */
+	pfc_reg_write(PFC_PUEN0,0x00000FFFU);
+	pfc_reg_write(PFC_PUEN1,0x00100234U);
+	pfc_reg_write(PFC_PUEN2,0x000004C4U);
+	pfc_reg_write(PFC_PUEN3,0x00000200U);
+	pfc_reg_write(PFC_PUEN4,0x3E000000U);
+	pfc_reg_write(PFC_PUEN5,0x1F000805U);
+	pfc_reg_write(PFC_PUEN6,0x00000006U);
+
+	/* initialize positive/negative logic select */
+	mmio_write_32(GPIO_POSNEG0, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG1, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG2, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG3, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG4, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG5, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG6, 0x00000000U);
+
+	/* initialize general IO/interrupt switching */
+	mmio_write_32(GPIO_IOINTSEL0, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL1, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL2, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL3, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL4, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL5, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL6, 0x00000000U);
+
+	/* initialize general output register */
+	mmio_write_32(GPIO_OUTDT1, 0x00000000U);
+	mmio_write_32(GPIO_OUTDT2, 0x00000400U);
+	mmio_write_32(GPIO_OUTDT3, 0x0000C000U);
+	mmio_write_32(GPIO_OUTDT5, 0x00000006U);
+	mmio_write_32(GPIO_OUTDT6, 0x00003880U);
+
+	/* initialize general input/output switching */
+	mmio_write_32(GPIO_INOUTSEL0, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL1, 0x01000A00U);
+	mmio_write_32(GPIO_INOUTSEL2, 0x00000400U);
+	mmio_write_32(GPIO_INOUTSEL3, 0x0000C000U);
+	mmio_write_32(GPIO_INOUTSEL4, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL5, 0x0000020EU);
+	mmio_write_32(GPIO_INOUTSEL6, 0x00013880U);
+}
diff --git a/plat/renesas/rcar/bl2_phy_init.c b/plat/renesas/rcar/bl2_phy_init.c
new file mode 100644
index 0000000..40f422b
--- /dev/null
+++ b/plat/renesas/rcar/bl2_phy_init.c
@@ -0,0 +1,3452 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <mmio.h>
+#include <arch_helpers.h>
+#include "bl2_phy_init.h"
+
+
+#define	DBSC_BASE		(0xE6790000U)
+#define	DBSC_DBPDRGA(x)		((uintptr_t)(DBSC_BASE + 0x0624U + ((x) * 0x40U)))
+#define	DBSC_DBPDRGD(x)		((uintptr_t)(DBSC_BASE + 0x0628U + ((x) * 0x40U)))
+
+#define	RST_BASE		(0xE6160000U)
+#define	RST_MODEMR		(RST_BASE + 0x0060U)
+#define	MODEMR_MD19		((uint32_t)1U << 19U)
+#define	MODEMR_MD17		((uint32_t)1U << 17U)
+#define MODEMR_DDR_CLOCK_MASK	((uint32_t)(~(MODEMR_MD19 | MODEMR_MD17)))
+#define MODEMR_DDR_CLOCK_3200	(0x00000000U)
+#define MODEMR_DDR_CLOCK_1600	((uint32_t)(MODEMR_MD19 | MODEMR_MD17))
+
+#define BITW_01	(0x00000001U)	/* 1 */
+#define BITW_02	(0x00000003U)	/* 2 */
+#define BITW_03	(0x00000007U)	/* 3 */
+#define BITW_04	(0x0000000FU)	/* 4 */
+#define BITW_05	(0x0000001FU)	/* 5 */
+#define BITW_06	(0x0000003FU)	/* 6 */
+#define BITW_07	(0x0000007FU)	/* 7 */
+#define BITW_08	(0x000000FFU)	/* 8 */
+#define BITW_09	(0x000001FFU)	/* 9 */
+#define BITW_10	(0x000003FFU)	/* 10 */
+#define BITW_11	(0x000007FFU)	/* 11 */
+#define BITW_12	(0x00000FFFU)	/* 12 */
+#define BITW_13	(0x00001FFFU)	/* 13 */
+#define BITW_14	(0x00003FFFU)	/* 14 */
+#define BITW_15	(0x00007FFFU)	/* 15 */
+#define BITW_16	(0x0000FFFFU)	/* 16 */
+#define BITW_17	(0x0001FFFFU)	/* 17 */
+#define BITW_18	(0x0003FFFFU)	/* 18 */
+#define BITW_19	(0x0007FFFFU)	/* 19 */
+#define BITW_20	(0x000FFFFFU)	/* 20 */
+#define BITW_21	(0x001FFFFFU)	/* 21 */
+#define BITW_22	(0x003FFFFFU)	/* 22 */
+#define BITW_23	(0x007FFFFFU)	/* 23 */
+#define BITW_24	(0x00FFFFFFU)	/* 24 */
+#define BITW_25	(0x01FFFFFFU)	/* 25 */
+#define BITW_26	(0x03FFFFFFU)	/* 26 */
+#define BITW_27	(0x07FFFFFFU)	/* 27 */
+#define BITW_28	(0x0FFFFFFFU)	/* 28 */
+#define BITW_29	(0x1FFFFFFFU)	/* 29 */
+#define BITW_30	(0x3FFFFFFFU)	/* 30 */
+#define BITW_31	(0x7FFFFFFFU)	/* 31 */
+#define BITW_32	(0xFFFFFFFFU)	/* 32 */
+
+typedef struct {
+	uint16_t	reg;
+	uint8_t		lsb;
+	uint32_t	bit_width;
+}DDR_PHY_REG_T;
+
+
+static const uint32_t DDR_PHY_1600[827] =
+{
+	0x000004F0U,  /* PHY_SW_WRDQ0_SHIFT_0:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_0:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_0:RW:0:11:=0x04f0 */
+	0x00000000U,  /* PHY_SW_WRDQ4_SHIFT_0:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_0:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_0:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_0:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_SW_WRDM_SHIFT_0:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_0:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_0:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_0:RW:0:5:=0x00 */
+	0x00000100U,  /* PHY_DQ_TSEL_ENABLE_0:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_0:RW:0:4:=0x00 */
+	0x01665555U,  /* PHY_DQS_TSEL_ENABLE_0:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_0:RW:0:24:=0x665555 */
+	0x02665555U,  /* PHY_TWO_CYC_PREAMBLE_0:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_0:RW:0:24:=0x665555 */
+	0x00010F00U,  /* PHY_PER_CS_TRAINING_INDEX_0:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_0:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_0:RW:8:2:=0x0f PHY_DBI_MODE_0:RW:0:1:=0x00 */
+	0x04000100U,  /* PHY_LP4_BOOT_RPTR_UPDATE_0:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_0:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_0:RW:0:2:=0x00 */
+	0x00000133U,  /* PHY_LPBK_CONTROL_0:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_0:RW:0:10:=0x0133 */
+	0x000700C0U,  /* SC_PHY_SNAP_OBS_REGS_0:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_0:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_0:RW:0:10:=0x00c0 */
+	0x00CC0201U,  /* PHY_GATE_SMPL1_SLAVE_DELAY_0:RW:16:9:=0x00cc PHY_LPDDR_TYPE_0:RW:8:2:=0x02 PHY_LPDDR_0:RW:0:1:=0x01 */
+	0x00030066U,  /* ON_FLY_GATE_ADJUST_EN_0:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_0:RW:0:9:=0x0066 */
+	0x00000000U,  /* PHY_GATE_TRACKING_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_PST_AMBLE_0:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT9_0:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT10_0:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT11_0:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQ_ENC_OBS_SELECT_0:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_0:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_0:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_0:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_SELECT_0:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_0:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_0:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_0:RW:0:4:=0x00 */
+	0x04080000U,  /* PHY_WRLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_0:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_0:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_0:RW:0:1:=0x00 */
+	0x04080400U,  /* PHY_RDLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_0:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_0:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_0:RW:0:6:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_DATA_MASK_0:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_0:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_0:RW:0:2:=0x00 */
+	0x32103210U,  /* PHY_RDLVL_DATA_SWIZZLE_0:RW:0:32:=0x32103210 */
+	0x00C00708U,  /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_0:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_0:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_0:RW:0:6:=0x08 */
+	0x0001000CU,  /* PHY_WDQLVL_CLR_PREV_RESULTS_0:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_0:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_0:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_0:RW:0:4:=0x0c */
+	0x00000100U,  /* PHY_WDQLVL_DATADM_MASK_0:RW:0:9:=0x0100 */
+	0x55555555U,  /* PHY_USER_PATT0_0:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT1_0:RW:0:32:=0xAAAAAAAA */
+	0x55555555U,  /* PHY_USER_PATT2_0:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT3_0:RW:0:32:=0xAAAAAAAA */
+	0x00005555U,  /* PHY_USER_PATT4_0:RW:0:16:=0x5555 */
+	0x76543210U,  /* PHY_DQ_SWIZZLING_0:RW:0:32:=0x76543210 */
+	0x00000001U,  /* PHY_FIFO_PTR_OBS_0:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_0:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_0:RW:0:1:=0x01 */
+	0x00000000U,  /* PHY_LPBK_RESULT_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_0:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_0:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_0:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_0:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_0:RD:0:8:=0x00 */
+	0x00000000U,  /* PHY_WR_SHIFT_OBS_0:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_0:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_0:RD:0:7:=0x00 */
+	0x00000000U,  /* PHY_WRLVL_HARD1_DELAY_OBS_0:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_0:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_WRLVL_STATUS_OBS_0:RD:0:17:=0x000000 */
+	0x00000000U,  /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_0:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_0:RD:0:9:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_HARD0_DELAY_OBS_0:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_0:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_STATUS_OBS_0:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_0:RD:0:14:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_0:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_0:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_0:RD:0:2:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_STATUS_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_WDQLVL_DQDM_TE_DLY_OBS_0:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_0:RD:0:11:=0x0000 */
+	0x00000000U,  /* PHY_WDQLVL_STATUS_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_MODE_0:RW:0:18:=0x000000 */
+	0x00000000U,  /* PHY_DDL_TEST_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_TEST_MSTR_DLY_OBS_0:RD:0:32:=0x00000000 */
+	0x00200000U,  /* PHY_RX_CAL_SAMPLE_WAIT_0:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_0:RW:8:1:=0x00 SC_PHY_RX_CAL_START_0:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_RX_CAL_DQ1_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ3_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ5_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ7_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQS_0:RW+:16:12:=0x0000 PHY_RX_CAL_DM_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_OBS_0:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_0:RW+:0:12:=0x0000 */
+	0x02800280U,  /* PHY_CLK_WRDQ1_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ3_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ5_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ7_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x00000280U,  /* PHY_CLK_WRDQS_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x00000000U,  /* PHY_RDDQ1_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ3_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ5_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ7_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00040109U,  /* PHY_WRITE_PATH_LAT_ADD_0:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_0:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_0:RW+:0:10:=0x0109 */
+	0x000001D0U,  /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_0:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_0:RW+:0:10:=0x01d0 */
+	0x07000000U,  /* PHY_GTLVL_LAT_ADJ_START_0:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_0:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_0:RW+:0:1:=0x00 */
+	0x00000200U,  /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_0:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_0:RW+:0:11:=0x0200 */
+	0x41315141U,  /* PHY_DQS_OE_TIMING_0:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_0:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_0:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_0:RW+:0:8:=0x41 */
+	0xC0013150U,  /* PHY_DQ_IE_TIMING_0:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_0:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_0:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_0:RW+:0:8:=0x50 */
+	0x0E0000C0U,  /* PHY_RDDATA_EN_DLY_0:RW+:24:4:=0x0e PHY_IE_MODE_0:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_0:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_0:RW+:0:8:=0xc0 */
+	0x0010000CU,  /* PHY_MASTER_DELAY_START_0:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_0:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_0:RW+:0:4:=0x0c */
+	0x0C064208U,  /* PHY_WRLVL_DLY_STEP_0:RW+:24:4:=0x0c PHY_RPTR_UPDATE_0:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_0:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_0:RW+:0:6:=0x08 */
+	0x000F0C18U,  /* PHY_GTLVL_RESP_WAIT_CNT_0:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_0:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_0:RW+:0:5:=0x18 */
+	0x01000140U,  /* PHY_GTLVL_FINAL_STEP_0:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_0:RW+:0:10:=0x0140 */
+	0x00000C20U,  /* PHY_RDLVL_DLY_STEP_0:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_0:RW+:0:8:=0x20 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x000004F0U,  /* PHY_SW_WRDQ0_SHIFT_1:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_1:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:0:11:=0x04f0 */
+	0x00000000U,  /* PHY_SW_WRDQ4_SHIFT_1:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_1:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_1:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_1:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_SW_WRDM_SHIFT_1:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_1:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_1:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_1:RW:0:5:=0x00 */
+	0x00000100U,  /* PHY_DQ_TSEL_ENABLE_1:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_1:RW:0:4:=0x00 */
+	0x01665555U,  /* PHY_DQS_TSEL_ENABLE_1:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_1:RW:0:24:=0x665555 */
+	0x02665555U,  /* PHY_TWO_CYC_PREAMBLE_1:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_1:RW:0:24:=0x665555 */
+	0x00010F00U,  /* PHY_PER_CS_TRAINING_INDEX_1:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_1:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_1:RW:8:2:=0x0f PHY_DBI_MODE_1:RW:0:1:=0x00 */
+	0x04000100U,  /* PHY_LP4_BOOT_RPTR_UPDATE_1:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_1:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_1:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_1:RW:0:2:=0x00 */
+	0x00000133U,  /* PHY_LPBK_CONTROL_1:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_1:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_1:RW:0:10:=0x0133 */
+	0x000700C0U,  /* SC_PHY_SNAP_OBS_REGS_1:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_1:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_1:RW:0:10:=0x00c0 */
+	0x00CC0201U,  /* PHY_GATE_SMPL1_SLAVE_DELAY_1:RW:16:9:=0x00cc PHY_LPDDR_TYPE_1:RW:8:2:=0x02 PHY_LPDDR_1:RW:0:1:=0x01 */
+	0x00030066U,  /* ON_FLY_GATE_ADJUST_EN_1:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_1:RW:0:9:=0x0066 */
+	0x00000000U,  /* PHY_GATE_TRACKING_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_PST_AMBLE_1:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT9_1:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT10_1:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT11_1:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQ_ENC_OBS_SELECT_1:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_1:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_1:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_1:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_SELECT_1:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_1:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_1:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_1:RW:0:4:=0x00 */
+	0x04080000U,  /* PHY_WRLVL_UPDT_WAIT_CNT_1:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_1:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_1:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_1:RW:0:1:=0x00 */
+	0x04080400U,  /* PHY_RDLVL_UPDT_WAIT_CNT_1:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_1:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_1:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_1:RW:0:6:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_DATA_MASK_1:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_1:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_1:RW:0:2:=0x00 */
+	0x32103210U,  /* PHY_RDLVL_DATA_SWIZZLE_1:RW:0:32:=0x32103210 */
+	0x00C00708U,  /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_1:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_1:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_1:RW:0:6:=0x08 */
+	0x0001000CU,  /* PHY_WDQLVL_CLR_PREV_RESULTS_1:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_1:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_1:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_1:RW:0:4:=0x0c */
+	0x00000100U,  /* PHY_WDQLVL_DATADM_MASK_1:RW:0:9:=0x0100 */
+	0x55555555U,  /* PHY_USER_PATT0_1:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT1_1:RW:0:32:=0xAAAAAAAA */
+	0x55555555U,  /* PHY_USER_PATT2_1:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT3_1:RW:0:32:=0xAAAAAAAA */
+	0x00005555U,  /* PHY_USER_PATT4_1:RW:0:16:=0x5555 */
+	0x76543210U,  /* PHY_DQ_SWIZZLING_1:RW:0:32:=0x76543210 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_1:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_1:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_1:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LPBK_RESULT_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_1:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_1:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_1:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_1:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_1:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_1:RD:0:8:=0x00 */
+	0x00000000U,  /* PHY_WR_SHIFT_OBS_1:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_1:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_1:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_1:RD:0:7:=0x00 */
+	0x00000000U,  /* PHY_WRLVL_HARD1_DELAY_OBS_1:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_1:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_WRLVL_STATUS_OBS_1:RD:0:17:=0x000000 */
+	0x00000000U,  /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_1:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_1:RD:0:9:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_HARD0_DELAY_OBS_1:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_1:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_STATUS_OBS_1:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_1:RD:0:14:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_1:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_1:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_1:RD:0:2:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_STATUS_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_WDQLVL_DQDM_TE_DLY_OBS_1:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_1:RD:0:11:=0x0000 */
+	0x00000000U,  /* PHY_WDQLVL_STATUS_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_MODE_1:RW:0:18:=0x000000 */
+	0x00000000U,  /* PHY_DDL_TEST_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_TEST_MSTR_DLY_OBS_1:RD:0:32:=0x00000000 */
+	0x00200000U,  /* PHY_RX_CAL_SAMPLE_WAIT_1:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_1:RW:8:1:=0x00 SC_PHY_RX_CAL_START_1:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_RX_CAL_DQ1_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ3_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ5_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ7_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQS_1:RW+:16:12:=0x0000 PHY_RX_CAL_DM_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_OBS_1:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_1:RW+:0:12:=0x0000 */
+	0x02800280U,  /* PHY_CLK_WRDQ1_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ3_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ5_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ7_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x00000280U,  /* PHY_CLK_WRDQS_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x00000000U,  /* PHY_RDDQ1_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ3_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ5_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ7_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00040109U,  /* PHY_WRITE_PATH_LAT_ADD_1:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_1:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_1:RW+:0:10:=0x0109 */
+	0x000001D0U,  /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_1:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_1:RW+:0:10:=0x01d0 */
+	0x07000000U,  /* PHY_GTLVL_LAT_ADJ_START_1:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_1:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_1:RW+:0:1:=0x00 */
+	0x00000200U,  /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_1:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_1:RW+:0:11:=0x0200 */
+	0x41315141U,  /* PHY_DQS_OE_TIMING_1:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_1:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_1:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_1:RW+:0:8:=0x41 */
+	0xC0013150U,  /* PHY_DQ_IE_TIMING_1:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_1:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_1:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_1:RW+:0:8:=0x50 */
+	0x0E0000C0U,  /* PHY_RDDATA_EN_DLY_1:RW+:24:4:=0x0e PHY_IE_MODE_1:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_1:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_1:RW+:0:8:=0xc0 */
+	0x0010000CU,  /* PHY_MASTER_DELAY_START_1:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_1:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_1:RW+:0:4:=0x0c */
+	0x0C064208U,  /* PHY_WRLVL_DLY_STEP_1:RW+:24:4:=0x0c PHY_RPTR_UPDATE_1:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_1:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_1:RW+:0:6:=0x08 */
+	0x000F0C18U,  /* PHY_GTLVL_RESP_WAIT_CNT_1:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_1:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_1:RW+:0:5:=0x18 */
+	0x01000140U,  /* PHY_GTLVL_FINAL_STEP_1:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_1:RW+:0:10:=0x0140 */
+	0x00000C20U,  /* PHY_RDLVL_DLY_STEP_1:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_1:RW+:0:8:=0x20 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x000004F0U,  /* PHY_SW_WRDQ0_SHIFT_2:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_2:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_2:RW:0:11:=0x04f0 */
+	0x00000000U,  /* PHY_SW_WRDQ4_SHIFT_2:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_2:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_2:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_2:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_SW_WRDM_SHIFT_2:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_2:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_2:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_2:RW:0:5:=0x00 */
+	0x00000100U,  /* PHY_DQ_TSEL_ENABLE_2:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_2:RW:0:4:=0x00 */
+	0x01665555U,  /* PHY_DQS_TSEL_ENABLE_2:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_2:RW:0:24:=0x665555 */
+	0x02665555U,  /* PHY_TWO_CYC_PREAMBLE_2:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_2:RW:0:24:=0x665555 */
+	0x00010F00U,  /* PHY_PER_CS_TRAINING_INDEX_2:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_2:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_2:RW:8:2:=0x0f PHY_DBI_MODE_2:RW:0:1:=0x00 */
+	0x04000100U,  /* PHY_LP4_BOOT_RPTR_UPDATE_2:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_2:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_2:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_2:RW:0:2:=0x00 */
+	0x00000133U,  /* PHY_LPBK_CONTROL_2:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_2:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_2:RW:0:10:=0x0133 */
+	0x000700C0U,  /* SC_PHY_SNAP_OBS_REGS_2:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_2:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_2:RW:0:10:=0x00c0 */
+	0x00CC0201U,  /* PHY_GATE_SMPL1_SLAVE_DELAY_2:RW:16:9:=0x00cc PHY_LPDDR_TYPE_2:RW:8:2:=0x02 PHY_LPDDR_2:RW:0:1:=0x01 */
+	0x00030066U,  /* ON_FLY_GATE_ADJUST_EN_2:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_2:RW:0:9:=0x0066 */
+	0x00000000U,  /* PHY_GATE_TRACKING_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_PST_AMBLE_2:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT9_2:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT10_2:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT11_2:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQ_ENC_OBS_SELECT_2:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_2:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_2:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_2:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_SELECT_2:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_2:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_2:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_2:RW:0:4:=0x00 */
+	0x04080000U,  /* PHY_WRLVL_UPDT_WAIT_CNT_2:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_2:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_2:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_2:RW:0:1:=0x00 */
+	0x04080400U,  /* PHY_RDLVL_UPDT_WAIT_CNT_2:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_2:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_2:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_2:RW:0:6:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_DATA_MASK_2:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_2:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_2:RW:0:2:=0x00 */
+	0x32103210U,  /* PHY_RDLVL_DATA_SWIZZLE_2:RW:0:32:=0x32103210 */
+	0x00C00708U,  /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_2:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_2:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_2:RW:0:6:=0x08 */
+	0x0001000CU,  /* PHY_WDQLVL_CLR_PREV_RESULTS_2:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_2:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_2:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_2:RW:0:4:=0x0c */
+	0x00000100U,  /* PHY_WDQLVL_DATADM_MASK_2:RW:0:9:=0x0100 */
+	0x55555555U,  /* PHY_USER_PATT0_2:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT1_2:RW:0:32:=0xAAAAAAAA */
+	0x55555555U,  /* PHY_USER_PATT2_2:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT3_2:RW:0:32:=0xAAAAAAAA */
+	0x00005555U,  /* PHY_USER_PATT4_2:RW:0:16:=0x5555 */
+	0x76543210U,  /* PHY_DQ_SWIZZLING_2:RW:0:32:=0x76543210 */
+	0x00000001U,  /* PHY_FIFO_PTR_OBS_2:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_2:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_2:RW:0:1:=0x01 */
+	0x00000000U,  /* PHY_LPBK_RESULT_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_2:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_2:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_2:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_2:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_2:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_2:RD:0:8:=0x00 */
+	0x00000000U,  /* PHY_WR_SHIFT_OBS_2:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_2:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_2:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_2:RD:0:7:=0x00 */
+	0x00000000U,  /* PHY_WRLVL_HARD1_DELAY_OBS_2:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_2:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_WRLVL_STATUS_OBS_2:RD:0:17:=0x000000 */
+	0x00000000U,  /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_2:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_2:RD:0:9:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_HARD0_DELAY_OBS_2:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_2:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_STATUS_OBS_2:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_2:RD:0:14:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_2:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_2:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_2:RD:0:2:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_STATUS_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_WDQLVL_DQDM_TE_DLY_OBS_2:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_2:RD:0:11:=0x0000 */
+	0x00000000U,  /* PHY_WDQLVL_STATUS_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_MODE_2:RW:0:18:=0x000000 */
+	0x00000000U,  /* PHY_DDL_TEST_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_TEST_MSTR_DLY_OBS_2:RD:0:32:=0x00000000 */
+	0x00200000U,  /* PHY_RX_CAL_SAMPLE_WAIT_2:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_2:RW:8:1:=0x00 SC_PHY_RX_CAL_START_2:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_RX_CAL_DQ1_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ3_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ5_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ7_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQS_2:RW+:16:12:=0x0000 PHY_RX_CAL_DM_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_OBS_2:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_2:RW+:0:12:=0x0000 */
+	0x02800280U,  /* PHY_CLK_WRDQ1_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ3_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ5_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ7_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x00000280U,  /* PHY_CLK_WRDQS_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x00000000U,  /* PHY_RDDQ1_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ3_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ5_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ7_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00040109U,  /* PHY_WRITE_PATH_LAT_ADD_2:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_2:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_2:RW+:0:10:=0x0109 */
+	0x000001D0U,  /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_2:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_2:RW+:0:10:=0x01d0 */
+	0x07000000U,  /* PHY_GTLVL_LAT_ADJ_START_2:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_2:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_2:RW+:0:1:=0x00 */
+	0x00000200U,  /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_2:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_2:RW+:0:11:=0x0200 */
+	0x41315141U,  /* PHY_DQS_OE_TIMING_2:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_2:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_2:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_2:RW+:0:8:=0x41 */
+	0xC0013150U,  /* PHY_DQ_IE_TIMING_2:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_2:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_2:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_2:RW+:0:8:=0x50 */
+	0x0E0000C0U,  /* PHY_RDDATA_EN_DLY_2:RW+:24:4:=0x0e PHY_IE_MODE_2:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_2:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_2:RW+:0:8:=0xc0 */
+	0x0010000CU,  /* PHY_MASTER_DELAY_START_2:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_2:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_2:RW+:0:4:=0x0c */
+	0x0C064208U,  /* PHY_WRLVL_DLY_STEP_2:RW+:24:4:=0x0c PHY_RPTR_UPDATE_2:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_2:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_2:RW+:0:6:=0x08 */
+	0x000F0C18U,  /* PHY_GTLVL_RESP_WAIT_CNT_2:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_2:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_2:RW+:0:5:=0x18 */
+	0x01000140U,  /* PHY_GTLVL_FINAL_STEP_2:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_2:RW+:0:10:=0x0140 */
+	0x00000C20U,  /* PHY_RDLVL_DLY_STEP_2:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_2:RW+:0:8:=0x20 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x000004F0U,  /* PHY_SW_WRDQ0_SHIFT_3:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_3:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_3:RW:0:11:=0x04f0 */
+	0x00000000U,  /* PHY_SW_WRDQ4_SHIFT_3:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_3:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_3:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_3:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_SW_WRDM_SHIFT_3:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_3:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_3:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_3:RW:0:5:=0x00 */
+	0x00000100U,  /* PHY_DQ_TSEL_ENABLE_3:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_3:RW:0:4:=0x00 */
+	0x01665555U,  /* PHY_DQS_TSEL_ENABLE_3:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_3:RW:0:24:=0x665555 */
+	0x02665555U,  /* PHY_TWO_CYC_PREAMBLE_3:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_3:RW:0:24:=0x665555 */
+	0x00010F00U,  /* PHY_PER_CS_TRAINING_INDEX_3:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_3:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_3:RW:8:2:=0x0f PHY_DBI_MODE_3:RW:0:1:=0x00 */
+	0x04000100U,  /* PHY_LP4_BOOT_RPTR_UPDATE_3:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_3:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_3:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_3:RW:0:2:=0x00 */
+	0x00000133U,  /* PHY_LPBK_CONTROL_3:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_3:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_3:RW:0:10:=0x0133 */
+	0x000700C0U,  /* SC_PHY_SNAP_OBS_REGS_3:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_3:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_3:RW:0:10:=0x00c0 */
+	0x00CC0201U,  /* PHY_GATE_SMPL1_SLAVE_DELAY_3:RW:16:9:=0x00cc PHY_LPDDR_TYPE_3:RW:8:2:=0x02 PHY_LPDDR_3:RW:0:1:=0x01 */
+	0x00030066U,  /* ON_FLY_GATE_ADJUST_EN_3:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_3:RW:0:9:=0x0066 */
+	0x00000000U,  /* PHY_GATE_TRACKING_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_PST_AMBLE_3:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT9_3:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT10_3:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT11_3:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQ_ENC_OBS_SELECT_3:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_3:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_3:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_3:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_SELECT_3:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_3:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_3:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_3:RW:0:4:=0x00 */
+	0x04080000U,  /* PHY_WRLVL_UPDT_WAIT_CNT_3:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_3:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_3:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_3:RW:0:1:=0x00 */
+	0x04080400U,  /* PHY_RDLVL_UPDT_WAIT_CNT_3:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_3:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_3:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_3:RW:0:6:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_DATA_MASK_3:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_3:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_3:RW:0:2:=0x00 */
+	0x32103210U,  /* PHY_RDLVL_DATA_SWIZZLE_3:RW:0:32:=0x32103210 */
+	0x00C00708U,  /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_3:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_3:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_3:RW:0:6:=0x08 */
+	0x0001000CU,  /* PHY_WDQLVL_CLR_PREV_RESULTS_3:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_3:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_3:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_3:RW:0:4:=0x0c */
+	0x00000100U,  /* PHY_WDQLVL_DATADM_MASK_3:RW:0:9:=0x0100 */
+	0x55555555U,  /* PHY_USER_PATT0_3:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT1_3:RW:0:32:=0xAAAAAAAA */
+	0x55555555U,  /* PHY_USER_PATT2_3:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT3_3:RW:0:32:=0xAAAAAAAA */
+	0x00005555U,  /* PHY_USER_PATT4_3:RW:0:16:=0x5555 */
+	0x76543210U,  /* PHY_DQ_SWIZZLING_3:RW:0:32:=0x76543210 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_3:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_3:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_3:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LPBK_RESULT_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_3:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_3:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_3:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_3:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_3:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_3:RD:0:8:=0x00 */
+	0x00000000U,  /* PHY_WR_SHIFT_OBS_3:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_3:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_3:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_3:RD:0:7:=0x00 */
+	0x00000000U,  /* PHY_WRLVL_HARD1_DELAY_OBS_3:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_3:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_WRLVL_STATUS_OBS_3:RD:0:17:=0x000000 */
+	0x00000000U,  /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_3:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_3:RD:0:9:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_HARD0_DELAY_OBS_3:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_3:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_STATUS_OBS_3:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_3:RD:0:14:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_3:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_3:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_3:RD:0:2:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_STATUS_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_WDQLVL_DQDM_TE_DLY_OBS_3:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_3:RD:0:11:=0x0000 */
+	0x00000000U,  /* PHY_WDQLVL_STATUS_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_MODE_3:RW:0:18:=0x000000 */
+	0x00000000U,  /* PHY_DDL_TEST_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_TEST_MSTR_DLY_OBS_3:RD:0:32:=0x00000000 */
+	0x00200000U,  /* PHY_RX_CAL_SAMPLE_WAIT_3:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_3:RW:8:1:=0x00 SC_PHY_RX_CAL_START_3:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_RX_CAL_DQ1_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ3_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ5_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ7_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQS_3:RW+:16:12:=0x0000 PHY_RX_CAL_DM_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_OBS_3:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_3:RW+:0:12:=0x0000 */
+	0x02800280U,  /* PHY_CLK_WRDQ1_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ3_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ5_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ7_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x00000280U,  /* PHY_CLK_WRDQS_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x00000000U,  /* PHY_RDDQ1_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ3_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ5_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ7_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U,  /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00040109U,  /* PHY_WRITE_PATH_LAT_ADD_3:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_3:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_3:RW+:0:10:=0x0109 */
+	0x000001D0U,  /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_3:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_3:RW+:0:10:=0x01d0 */
+	0x07000000U,  /* PHY_GTLVL_LAT_ADJ_START_3:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_3:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_3:RW+:0:1:=0x00 */
+	0x00000200U,  /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_3:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_3:RW+:0:11:=0x0200 */
+	0x41315141U,  /* PHY_DQS_OE_TIMING_3:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_3:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_3:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_3:RW+:0:8:=0x41 */
+	0xC0013150U,  /* PHY_DQ_IE_TIMING_3:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_3:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_3:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_3:RW+:0:8:=0x50 */
+	0x0E0000C0U,  /* PHY_RDDATA_EN_DLY_3:RW+:24:4:=0x0e PHY_IE_MODE_3:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_3:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_3:RW+:0:8:=0xc0 */
+	0x0010000CU,  /* PHY_MASTER_DELAY_START_3:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_3:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_3:RW+:0:4:=0x0c */
+	0x0C064208U,  /* PHY_WRLVL_DLY_STEP_3:RW+:24:4:=0x0c PHY_RPTR_UPDATE_3:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_3:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_3:RW+:0:6:=0x08 */
+	0x000F0C18U,  /* PHY_GTLVL_RESP_WAIT_CNT_3:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_3:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_3:RW+:0:5:=0x18 */
+	0x01000140U,  /* PHY_GTLVL_FINAL_STEP_3:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_3:RW+:0:10:=0x0140 */
+	0x00000C20U,  /* PHY_RDLVL_DLY_STEP_3:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_3:RW+:0:8:=0x20 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /* PHY_ADR3_SW_WRADDR_SHIFT_0:RW+:24:5:=0x00 PHY_ADR2_SW_WRADDR_SHIFT_0:RW+:16:5:=0x00 PHY_ADR1_SW_WRADDR_SHIFT_0:RW+:8:5:=0x00 PHY_ADR0_SW_WRADDR_SHIFT_0:RW+:0:5:=0x00 */
+	0x00000000U,  /* PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_0:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_0:RW+:8:5:=0x00 PHY_ADR4_SW_WRADDR_SHIFT_0:RW+:0:5:=0x00 */
+	0x00000000U,  /* SC_PHY_ADR_MANUAL_CLEAR_0:WR:8:3:=0x00 PHY_ADR_CLK_BYPASS_OVERRIDE_0:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_ADR_LPBK_RESULT_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_SLAVE_LOOP_CNT_UPDATE_0:RW:24:3:=0x00 PHY_ADR_MASTER_DLY_LOCK_OBS_0:RD:8:10:=0x0000 PHY_ADR_MASTER_DLY_LOCK_OBS_SELECT_0:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_ADR_LPBK_CONTROL_0:RW:24:6:=0x00 PHY_ADR_TSEL_ENABLE_0:RW:16:1:=0x00 SC_PHY_ADR_SNAP_OBS_REGS_0:WR:8:1:=0x00 PHY_ADR_SLV_DLY_ENC_OBS_SELECT_0:RW:0:3:=0x00 */
+	0x00000002U,  /* PHY_ADR_IE_MODE_0:RW:16:1:=0x00 PHY_ADR_WRADDR_SHIFT_OBS_0:RD:8:3:=0x00 PHY_ADR_TYPE_0:RW:0:2:=0x02 */
+	0x00000000U,  /* PHY_ADR_DDL_MODE_0:RW:0:15:=0x0000 */
+	0x00000000U,  /* PHY_ADR_DDL_TEST_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_DDL_TEST_MSTR_DLY_OBS_0:RD:0:32:=0x00000000 */
+	0x00400320U,  /* PHY_ADR_CALVL_COARSE_DLY_0:RW:16:11:=0x0040 PHY_ADR_CALVL_START_0:RW:0:11:=0x0320 */
+	0x00000040U,  /* PHY_ADR_CALVL_QTR_0:RW:0:11:=0x0040 */
+	0x00DCBA98U,  /* PHY_ADR_CALVL_SWIZZLE0_0_0:RW:0:24:=0xdcba98 */
+	0x00000000U,  /* PHY_ADR_CALVL_SWIZZLE1_0_0:RW:0:24:=0x000000 */
+	0x00DCBA98U,  /* PHY_ADR_CALVL_SWIZZLE0_1_0:RW:0:24:=0xdcba98 */
+	0x01000000U,  /* PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000 */
+	0x00020010U,  /* PHY_ADR_CALVL_RESP_WAIT_CNT_0:RW:24:4:=0x00 PHY_ADR_CALVL_CAPTURE_CNT_0:RW:16:4:=0x02 PHY_ADR_CALVL_NUM_PATTERNS_0:RW:8:2:=0x00 PHY_ADR_CALVL_RANK_CTRL_0:RW:0:5:=0x10 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS_SELECT_0:RW:24:3:=0x00 SC_PHY_ADR_CALVL_ERROR_CLR_0:WR:16:1:=0x00 SC_PHY_ADR_CALVL_DEBUG_CONT_0:WR:8:1:=0x00 PHY_ADR_CALVL_DEBUG_MODE_0:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS0_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS1_0:RD:0:32:=0x00000000 */
+	0x00002A01U,  /* PHY_ADR_CALVL_FG_0_0:RW:8:20:=0x00002A PHY_ADR_CALVL_RESULT_0:RW:0:1:=0x01 */
+	0x00000015U,  /* PHY_ADR_CALVL_BG_0_0:RW:0:20:=0x000015 */
+	0x00000015U,  /* PHY_ADR_CALVL_FG_1_0:RW:0:20:=0x000015 */
+	0x0000002AU,  /* PHY_ADR_CALVL_BG_1_0:RW:0:20:=0x00002a */
+	0x00000033U,  /* PHY_ADR_CALVL_FG_2_0:RW:0:20:=0x000033 */
+	0x0000000CU,  /* PHY_ADR_CALVL_BG_2_0:RW:0:20:=0x00000c */
+	0x0000000CU,  /* PHY_ADR_CALVL_FG_3_0:RW:0:20:=0x00000c */
+	0x00000033U,  /* PHY_ADR_CALVL_BG_3_0:RW:0:20:=0x000033 */
+	0x00543210U,  /* PHY_ADR_ADDR_SEL_0:RW:0:24:=0x543210 */
+	0x003F0000U,  /* PHY_ADR_SEG_MASK_0:RW:24:6:=0x00 PHY_ADR_BIT_MASK_0:RW:16:6:=0x3f PHY_ADR_LP4_BOOT_SLV_DELAY_0:RW:0:10:=0x0000 */
+	0x0000003FU,  /* PHY_ADR_CALVL_TRAIN_MASK_0:RW:0:6:=0x3f */
+	0x00030055U,  /* PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55 */
+	0x03000300U,  /* PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300 */
+	0x03000300U,  /* PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300 */
+	0x00000300U,  /* PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300 */
+	0x42080010U,  /* PHY_ADR_MASTER_DELAY_WAIT_0:RW+:24:8:=0x42 PHY_ADR_MASTER_DELAY_STEP_0:RW+:16:6:=0x08 PHY_ADR_MASTER_DELAY_START_0:RW+:0:10:=0x0010 */
+	0x00000003U,  /* PHY_ADR_CALVL_DLY_STEP_0:RW+:0:4:=0x03 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x04040404U,  /* PHY_ADR3_SW_WRADDR_SHIFT_1:RW+:24:5:=0x04 PHY_ADR2_SW_WRADDR_SHIFT_1:RW+:16:5:=0x04 PHY_ADR1_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR0_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04 */
+	0x00000404U,  /* PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR4_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04 */
+	0x00000000U,  /* SC_PHY_ADR_MANUAL_CLEAR_1:WR:8:3:=0x00 PHY_ADR_CLK_BYPASS_OVERRIDE_1:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_ADR_LPBK_RESULT_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_SLAVE_LOOP_CNT_UPDATE_1:RW:24:3:=0x00 PHY_ADR_MASTER_DLY_LOCK_OBS_1:RD:8:10:=0x0000 PHY_ADR_MASTER_DLY_LOCK_OBS_SELECT_1:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_ADR_LPBK_CONTROL_1:RW:24:6:=0x00 PHY_ADR_TSEL_ENABLE_1:RW:16:1:=0x00 SC_PHY_ADR_SNAP_OBS_REGS_1:WR:8:1:=0x00 PHY_ADR_SLV_DLY_ENC_OBS_SELECT_1:RW:0:3:=0x00 */
+	0x00000002U,  /* PHY_ADR_IE_MODE_1:RW:16:1:=0x00 PHY_ADR_WRADDR_SHIFT_OBS_1:RD:8:3:=0x00 PHY_ADR_TYPE_1:RW:0:2:=0x02 */
+	0x00000000U,  /* PHY_ADR_DDL_MODE_1:RW:0:15:=0x0000 */
+	0x00000000U,  /* PHY_ADR_DDL_TEST_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_DDL_TEST_MSTR_DLY_OBS_1:RD:0:32:=0x00000000 */
+	0x00400320U,  /* PHY_ADR_CALVL_COARSE_DLY_1:RW:16:11:=0x0040 PHY_ADR_CALVL_START_1:RW:0:11:=0x0320 */
+	0x00000040U,  /* PHY_ADR_CALVL_QTR_1:RW:0:11:=0x0040 */
+	0x00000000U,  /* PHY_ADR_CALVL_SWIZZLE0_0_1:RW:0:24:=0x000000 */
+	0x00000000U,  /* PHY_ADR_CALVL_SWIZZLE1_0_1:RW:0:24:=0x000000 */
+	0x00000000U,  /* PHY_ADR_CALVL_SWIZZLE0_1_1:RW:0:24:=0x000000 */
+	0x01000000U,  /* PHY_ADR_CALVL_DEVICE_MAP_1:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_1:RW:0:24:=0x000000 */
+	0x00020010U,  /* PHY_ADR_CALVL_RESP_WAIT_CNT_1:RW:24:4:=0x00 PHY_ADR_CALVL_CAPTURE_CNT_1:RW:16:4:=0x02 PHY_ADR_CALVL_NUM_PATTERNS_1:RW:8:2:=0x00 PHY_ADR_CALVL_RANK_CTRL_1:RW:0:5:=0x10 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS_SELECT_1:RW:24:3:=0x00 SC_PHY_ADR_CALVL_ERROR_CLR_1:WR:16:1:=0x00 SC_PHY_ADR_CALVL_DEBUG_CONT_1:WR:8:1:=0x00 PHY_ADR_CALVL_DEBUG_MODE_1:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS0_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS1_1:RD:0:32:=0x00000000 */
+	0x00002A01U,  /* PHY_ADR_CALVL_FG_0_1:RW:8:20:=0x00002A PHY_ADR_CALVL_RESULT_1:RW:0:1:=0x01 */
+	0x00000015U,  /* PHY_ADR_CALVL_BG_0_1:RW:0:20:=0x000015 */
+	0x00000015U,  /* PHY_ADR_CALVL_FG_1_1:RW:0:20:=0x000015 */
+	0x0000002AU,  /* PHY_ADR_CALVL_BG_1_1:RW:0:20:=0x00002a */
+	0x00000033U,  /* PHY_ADR_CALVL_FG_2_1:RW:0:20:=0x000033 */
+	0x0000000CU,  /* PHY_ADR_CALVL_BG_2_1:RW:0:20:=0x00000c */
+	0x0000000CU,  /* PHY_ADR_CALVL_FG_3_1:RW:0:20:=0x00000c */
+	0x00000033U,  /* PHY_ADR_CALVL_BG_3_1:RW:0:20:=0x000033 */
+	0x00000000U,  /* PHY_ADR_ADDR_SEL_1:RW:0:24:=0x000000 */
+	0x00000000U,  /* PHY_ADR_SEG_MASK_1:RW:24:6:=0x00 PHY_ADR_BIT_MASK_1:RW:16:6:=0x00 PHY_ADR_LP4_BOOT_SLV_DELAY_1:RW:0:10:=0x0000 */
+	0x00000000U,  /* PHY_ADR_CALVL_TRAIN_MASK_1:RW:0:6:=0x00 */
+	0x00030055U,  /* PHY_ADR0_CLK_WR_SLAVE_DELAY_1:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_1:RW+:0:8:=0x55 */
+	0x03000300U,  /* PHY_ADR2_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x03000300U,  /* PHY_ADR4_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x00000300U,  /* PHY_ADR_SW_MASTER_MODE_1:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x42080010U,  /* PHY_ADR_MASTER_DELAY_WAIT_1:RW+:24:8:=0x42 PHY_ADR_MASTER_DELAY_STEP_1:RW+:16:6:=0x08 PHY_ADR_MASTER_DELAY_START_1:RW+:0:10:=0x0010 */
+	0x00000003U,  /* PHY_ADR_CALVL_DLY_STEP_1:RW+:0:4:=0x03 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000001U,  /* PHY_SW_GRP_SHIFT_1:RW+:24:5:=0x00 PHY_SW_GRP_SHIFT_0:RW+:16:5:=0x00 PHY_FREQ_SEL_INDEX:RW:8:2:=0x00 PHY_FREQ_SEL_MULTICAST_EN:RW_D:0:1:=0x01 */
+	0x00000000U,  /* PHY_GRP_BYPASS_SLAVE_DELAY:RW:16:11:=0x0000 PHY_SW_GRP_SHIFT_3:RW+:8:5:=0x00 PHY_SW_GRP_SHIFT_2:RW+:0:5:=0x00 */
+	0x01000005U,  /* PHY_LP4_BOOT_DISABLE:RW:24:1:=0x01 SC_PHY_MANUAL_UPDATE:WR:16:1:=0x00 PHY_GRP_BYPASS_OVERRIDE:RW:8:1:=0x00 PHY_SW_GRP_BYPASS_SHIFT:RW:0:5:=0x05 */
+	0x04003101U,  /* PHY_CSLVL_START:RW:16:11:=0x0400 PHY_CSLVL_CS_MAP:RW:8:4:=0x31 PHY_CSLVL_ENABLE:RW:0:1:=0x01 */
+	0x00020040U,  /* PHY_CSLVL_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_QTR:RW:0:11:=0x0040 */
+	0x00020055U,  /* PHY_CSLVL_DEBUG_MODE:RW:24:1:=0x00 PHY_CSLVL_COARSE_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_COARSE_DLY:RW:0:11:=0x0055 */
+	0x00000000U,  /* SC_PHY_CSLVL_ERROR_CLR:WR:8:1:=0x00 SC_PHY_CSLVL_DEBUG_CONT:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_CSLVL_OBS0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_CSLVL_OBS1:RD:0:32:=0x00000000 */
+	0x00000050U,  /* PHY_GRP_SHIFT_OBS_SELECT:RW:24:5:=0x00 PHY_GRP_SLV_DLY_ENC_OBS_SELECT:RW:8:10:=0x0000 PHY_CALVL_CS_MAP:RW:0:8:=0x50 */
+	0x00000000U,  /* PHY_ADRCTL_SLAVE_LOOP_CNT_UPDATE:RW:24:3:=0x00 PHY_GRP_SHIFT_OBS:RD:16:3:=0x00 PHY_GRP_SLV_DLY_ENC_OBS:RD:0:10:=0x0000 */
+	0x01010100U,  /* PHY_LP4_ACTIVE:RW:24:1:=0x01 PHY_ADRCTL_LPDDR:RW:16:1:=0x01 PHY_DFI_PHYUPD_TYPE:RW:8:2:=0x01 PHY_ADRCTL_SNAP_OBS_REGS:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_CONTINUOUS_CLK_CAL_UPDATE:RW:24:1:=0x00 PHY_UPDATE_CLK_CAL_VALUES:RW:16:1:=0x00 PHY_CALVL_RESULT_MASK:RW:8:2:=0x00 PHY_LPDDR3_CS:RW_D:0:1:=0x00 */
+	0x00001102U,  /* PHY_PLL_CTRL:RW+:0:13:=0x1102 */
+	0x00000000U,  /* PHY_PLL_BYPASS:RW+:0:5:=0x00 */
+	0x00010000U,  /* PHY_PAD_VREF_CTRL_DQ_0:RW+:8:14:=0x0100 PHY_LOW_FREQ_SEL:RW+:0:1:=0x00 */
+	0x01000100U,  /* PHY_PAD_VREF_CTRL_DQ_2:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_1:RW+:0:14:=0x0100 */
+	0x01000100U,  /* PHY_PAD_VREF_CTRL_AC:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_3:RW+:0:14:=0x0100 */
+	0x00030003U,  /* PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03 */
+	0x03000300U,  /* PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x00000300U,  /* PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300 */
+	0x00001B02U,  /* PHY_PLL_CTRL_OVERRIDE:RW:16:16:=0x0000 PHY_LP4_BOOT_PLL_CTRL:RW:0:13:=0x1b02 */
+	0x00000064U,  /* PHY_PLL_OBS_0:RD:8:16:=0x0000 PHY_PLL_WAIT:RW:0:8:=0x64 */
+	0x00000000U,  /* PHY_PLL_OBS_2:RD:16:16:=0x0000 PHY_PLL_OBS_1:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_PLL_OBS_4:RD:16:16:=0x0000 PHY_PLL_OBS_3:RD:0:16:=0x0000 */
+	0x00010503U,  /* PHY_LP_WAKEUP:RW:24:4:=0x00 PHY_LP4_BOOT_LOW_FREQ_SEL:RW:16:1:=0x01 PHY_TCKSRE_WAIT:RW:8:4:=0x05 PHY_PLL_TESTOUT_SEL:RW:0:3:=0x03 */
+	0x00041100U,  /* PHY_PAD_FDBK_DRIVE:RW+:8:18:=0x000411 PHY_TDFI_PHY_WRDELAY:RW:0:1:=0x00 */
+	0x00400040U,  /* PHY_PAD_DQS_DRIVE:RW+:16:12:=0x0040 PHY_PAD_DATA_DRIVE:RW+:0:10:=0x0040 */
+	0x00000411U,  /* PHY_PAD_ADDR_DRIVE:RW+:0:18:=0x000411 */
+	0x00000411U,  /* PHY_PAD_CLK_DRIVE:RW+:0:20:=0x000411 */
+	0x00004410U,  /* PHY_PAD_FDBK_TERM:RW+:0:18:=0x004410 */
+	0x00004410U,  /* PHY_PAD_DATA_TERM:RW+:0:17:=0x004410 */
+	0x00004410U,  /* PHY_PAD_DQS_TERM:RW+:0:17:=0x004410 */
+	0x00004410U,  /* PHY_PAD_ADDR_TERM:RW+:0:18:=0x004410 */
+	0x00004410U,  /* PHY_PAD_CLK_TERM:RW+:0:18:=0x004410 */
+	0x00000411U,  /* PHY_PAD_CKE_DRIVE:RW+:0:18:=0x000411 */
+	0x00004410U,  /* PHY_PAD_CKE_TERM:RW+:0:18:=0x004410 */
+	0x00000411U,  /* PHY_PAD_RST_DRIVE:RW+:0:18:=0x000411 */
+	0x00004410U,  /* PHY_PAD_RST_TERM:RW+:0:18:=0x004410 */
+	0x00000411U,  /* PHY_PAD_CS_DRIVE:RW+:0:18:=0x000411 */
+	0x00004410U,  /* PHY_PAD_CS_TERM:RW+:0:18:=0x004410 */
+	0x00000000U,  /* PHY_ADRCTL_RX_CAL:RW:0:25:=0x00000000 */
+	0x00000000U,  /* PHY_ADRCTL_LP3_RX_CAL:RW:0:25:=0x00000000 */
+	0x00000000U,  /* PHY_TST_CLK_PAD_CTRL:RW:0:32:=0x00000000 */
+	0x64000000U,  /* PHY_CAL_MODE_0:RW:24:8:=0x64 PHY_TST_CLK_PAD_CTRL2:RW:0:23:=0x000000 */
+	0x00000000U,  /* PHY_CAL_START_0:WR:8:1:=0x00 PHY_CAL_CLEAR_0:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_CAL_INTERVAL_COUNT_0:RW:0:32:=0x00000000 */
+	0x00000108U,  /* PHY_CAL_CLK_SELECT_0:RW:8:3:=0x01 PHY_CAL_SAMPLE_WAIT_0:RW:0:8:=0x08 */
+	0x00000000U,  /* PHY_CAL_RESULT_OBS_0:RD:0:24:=0x000000 */
+	0x00000000U,  /* PHY_CAL_RESULT2_OBS_0:RD:0:24:=0x000000 */
+	0x00000000U,  /* PHY_AC_LPBK_ERR_CLEAR:WR:24:1:=0x00 PHY_ADRCTL_MANUAL_UPDATE:WR:16:1:=0x00 PHY_PAD_ATB_CTRL:RW:0:16:=0x0000 */
+	0x00000000U,  /* PHY_AC_LPBK_OBS_SELECT:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_AC_LPBK_ENABLE:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_AC_LPBK_CONTROL:RW:0:9:=0x0000 */
+	0x00000000U,  /* PHY_AC_LPBK_RESULT_OBS:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_AC_CLK_LPBK_CONTROL:RW:24:6:=0x00 PHY_AC_CLK_LPBK_ENABLE:RW:8:16:=0x0000 PHY_AC_CLK_LPBK_OBS_SELECT:RW:0:4:=0x00 */
+	0x00000000U,  /* PHY_AC_CLK_LPBK_RESULT_OBS:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_DDL_AC_ENABLE:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_AC_MODE:RW:0:11:=0x0000 */
+};
+
+static const uint32_t DDR_PI_1600[181] =
+{
+	0x00000B00U,  /* PI_VERSION:RD:16:16:=0x0000 PI_DRAM_CLASS:RW:8:4:=0x0b PI_START:RW:0:1:=0x00 */
+	0x00000100U,  /* PI_TCMD_GAP:RW:16:16:=0x0000 PI_INIT_LVL_EN:RW:8:1:=0x01 PI_NORMAL_LVL_SEQ:RW:0:1:=0x00 */
+	0x00000118U,  /* PI_TDFI_PHYMSTR_MAX_F0:RW:0:32:=0x00000118 */
+	0x0000008CU,  /* PI_TDFI_PHYMSTR_RESP_F0:RW:0:16:=0x008c */
+	0x00001840U,  /* PI_TDFI_PHYMSTR_MAX_F1:RW:0:32:=0x00001840 */
+	0x00000C20U,  /* PI_TDFI_PHYMSTR_RESP_F1:RW:0:16:=0x0c20 */
+	0x00006098U,  /* PI_TDFI_PHYMSTR_MAX_F2:RW:0:32:=0x00006098 */
+	0x008C304CU,  /* PI_TDFI_PHYUPD_RESP_F0:RW:16:16:=0x008c PI_TDFI_PHYMSTR_RESP_F2:RW:0:16:=0x304c */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE0_F0:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE1_F0:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE2_F0:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE3_F0:RW:0:32:=0x00000200 */
+	0x00000C20U,  /* PI_TDFI_PHYUPD_RESP_F1:RW:0:16:=0x0c20 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE0_F1:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE1_F1:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE2_F1:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE3_F1:RW:0:32:=0x00000200 */
+	0x0000304CU,  /* PI_TDFI_PHYUPD_RESP_F2:RW:0:16:=0x304c */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE0_F2:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE1_F2:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE2_F2:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE3_F2:RW:0:32:=0x00000200 */
+	0x00010000U,  /* PI_EXIT_AFTER_INIT_CALVL:RW_D:16:1:=0x01 PI_CONTROL_ERROR_STATUS:RD:0:9:=0x0000 */
+	0x00000007U,  /* PI_FREQ_MAP:RW:0:32:=0x00000007 */
+	0x01000001U,  /* PI_POWER_ON_SEQ_END_ARRAY:RW:24:8:=0x01 PI_POWER_ON_SEQ_BYPASS_ARRAY:RW:16:8:=0x00 PI_INIT_DFS_CALVL_ONLY:RW:8:1:=0x00 PI_INIT_WORK_FREQ:RW:0:5:=0x01 */
+	0x00000000U,  /* PI_SEQ1_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ1_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ2_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ2_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ3_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ3_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ4_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ4_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ5_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ5_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ6_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ6_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ7_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ7_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ8_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ8_PAT_MASK:RW:0:28:=0x00000000 */
+	0x0F000101U,  /* PI_CS_MAP:RW:24:4:=0x0f RESERVED:RW:16:1:=0x00 PI_SW_RST_N:RW_D:8:1:=0x01 PI_WDT_DISABLE:RW_D:0:1:=0x01 */
+	0x08492D25U,  /* PI_TMRR:RW:24:4:=0x08 PI_TDELAY_RDWR_2_BUS_IDLE_F2:RW:16:8:=0x49 PI_TDELAY_RDWR_2_BUS_IDLE_F1:RW:8:8:=0x2d PI_TDELAY_RDWR_2_BUS_IDLE_F0:RW:0:8:=0x25 */
+	0x14060C04U,  /* PI_CASLAT_LIN_F1:RW:24:7:=0x14 PI_WRLAT_F1:RW:16:6:=0x06 PI_CASLAT_LIN_F0:RW:8:7:=0x0c PI_WRLAT_F0:RW:0:6:=0x04 */
+	0x0002380EU,  /* PI_AREFRESH:WR:24:1:=0x00 PI_PREAMBLE_SUPPORT:RW:16:2:=0x02 PI_CASLAT_LIN_F2:RW:8:7:=0x38 PI_WRLAT_F2:RW:0:6:=0x0e */
+	0x00460003U,  /* PI_TREF_F0:RW:16:16:=0x0046 PI_TRFC_F0:RW:0:10:=0x0003 */
+	0x06100034U,  /* PI_TREF_F1:RW:16:16:=0x0610 PI_TRFC_F1:RW:0:10:=0x0034 */
+	0x182600CFU,  /* PI_TREF_F2:RW:16:16:=0x1826 PI_TRFC_F2:RW:0:10:=0x00cf */
+	0x00000005U,  /* PI_SWLVL_OP_DONE:RD:24:1:=0x00 PI_SWLVL_LOAD:WR:16:1:=0x00 PI_TREF_INTERVAL:RW:0:16:=0x0005 */
+	0x00000000U,  /* PI_SW_WRLVL_RESP_3:RD:24:1:=0x00 PI_SW_WRLVL_RESP_2:RD:16:1:=0x00 PI_SW_WRLVL_RESP_1:RD:8:1:=0x00 PI_SW_WRLVL_RESP_0:RD:0:1:=0x00 */
+	0x00000000U,  /* PI_SW_RDLVL_RESP_3:RD:24:2:=0x00 PI_SW_RDLVL_RESP_2:RD:16:2:=0x00 PI_SW_RDLVL_RESP_1:RD:8:2:=0x00 PI_SW_RDLVL_RESP_0:RD:0:2:=0x00 */
+	0x00000000U,  /* PI_SWLVL_EXIT:WR:24:1:=0x00 PI_SWLVL_START:WR:16:1:=0x00 PI_SW_LEVELING_MODE:RW:8:3:=0x00 PI_SW_CALVL_RESP_0:RD:0:2:=0x00 */
+	0x00000000U,  /* PI_SWLVL_WR_SLICE_1:WR:24:1:=0x00 PI_SW_WDQLVL_RESP_0:RD:16:2:=0x00 PI_SWLVL_RD_SLICE_0:WR:8:1:=0x00 PI_SWLVL_WR_SLICE_0:WR:0:1:=0x00 */
+	0x00000000U,  /* PI_SWLVL_RD_SLICE_2:WR:24:1:=0x00 PI_SWLVL_WR_SLICE_2:WR:16:1:=0x00 PI_SW_WDQLVL_RESP_1:RD:8:2:=0x00 PI_SWLVL_RD_SLICE_1:WR:0:1:=0x00 */
+	0x00000000U,  /* PI_SW_WDQLVL_RESP_3:RD:24:2:=0x00 PI_SWLVL_RD_SLICE_3:WR:16:1:=0x00 PI_SWLVL_WR_SLICE_3:WR:8:1:=0x00 PI_SW_WDQLVL_RESP_2:RD:0:2:=0x00 */
+	0x00000000U,  /* PI_SWLVL_SM2_RD:WR:24:1:=0x00 PI_SWLVL_SM2_WR:WR:16:1:=0x00 PI_SWLVL_SM2_START:WR:8:1:=0x00 PI_SW_WDQLVL_VREF:RW:0:7:=0x00 */
+	0x01000000U,  /* PI_16BIT_DRAM_CONNECT:RW_D:24:1:=0x01 PI_SRE_PERIOD_EN:RW:16:1:=0x00 PI_DFS_PERIOD_EN:RW:8:1:=0x00 PI_SEQUENTIAL_LVL_REQ:WR:0:1:=0x00 */
+	0x00040404U,  /* PI_WRLVL_REQ:WR:24:1:=0x00 PI_TDFI_CTRL_DELAY_F2:RW_D:16:4:=0x04 PI_TDFI_CTRL_DELAY_F1:RW_D:8:4:=0x04 PI_TDFI_CTRL_DELAY_F0:RW_D:0:4:=0x04 */
+	0x01280A00U,  /* PI_WRLVL_EN:RW:24:2:=0x01 PI_WLMRD:RW:16:6:=0x28 PI_WLDQSEN:RW:8:6:=0x0a PI_WRLVL_CS:RW:0:2:=0x00 */
+	0x00000000U,  /* PI_WRLVL_ON_SREF_EXIT:RW:24:1:=0x00 PI_WRLVL_PERIODIC:RW:16:1:=0x00 PI_WRLVL_INTERVAL:RW:0:16:=0x0000 */
+	0x00030000U,  /* PI_WRLVL_ERROR_STATUS:RD:24:2:=0x00 PI_WRLVL_CS_MAP:RW:16:4:=0x03 PI_WRLVL_ROTATE:RW:8:1:=0x00 PI_WRLVL_RESP_MASK:RW:0:4:=0x00 */
+	0x00001403U,  /* PI_TDFI_WRLVL_WW:RW:8:10:=0x0014 PI_TDFI_WRLVL_EN:RW:0:8:=0x03 */
+	0x00000000U,  /* PI_TDFI_WRLVL_RESP:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PI_TDFI_WRLVL_MAX:RW:0:32:=0x00000000 */
+	0x00060102U,  /* PI_TODTL_2CMD_F0:RW:24:8:=0x00 PI_WRLVL_EN_DEASSERT_2_MRR:RW:16:5:=0x06 PI_WRLVL_MRR_DQ_RETURN_HIZ:RW:8:1:=0x01 PI_WRLVL_STROBE_NUM:RW:0:5:=0x02 */
+	0x00010001U,  /* PI_TODTL_2CMD_F2:RW:24:8:=0x00 PI_ODT_EN_F1:RW:16:1:=0x01 PI_TODTL_2CMD_F1:RW:8:8:=0x00 PI_ODT_EN_F0:RW:0:1:=0x01 */
+	0x01000101U,  /* PI_ODT_RD_MAP_CS0:RW:24:4:=0x01 PI_TODTH_RD:RW:16:4:=0x00 PI_TODTH_WR:RW:8:4:=0x01 PI_ODT_EN_F2:RW:0:1:=0x01 */
+	0x04020201U,  /* PI_ODT_RD_MAP_CS2:RW:24:4:=0x04 PI_ODT_WR_MAP_CS1:RW:16:4:=0x02 PI_ODT_RD_MAP_CS1:RW:8:4:=0x02 PI_ODT_WR_MAP_CS0:RW:0:4:=0x01 */
+	0x00080804U,  /* PI_EN_ODT_ASSERT_EXCEPT_RD:RW:24:1:=0x00 PI_ODT_WR_MAP_CS3:RW:16:4:=0x08 PI_ODT_RD_MAP_CS3:RW:8:4:=0x08 PI_ODT_WR_MAP_CS2:RW:0:4:=0x04 */
+	0x00000000U,  /* PI_TODTON_MIN_F1:RW:24:4:=0x00 PI_ODTLON_F1:RW:16:4:=0x00 PI_TODTON_MIN_F0:RW:8:4:=0x00 PI_ODTLON_F0:RW:0:4:=0x00 */
+	0x04030000U,  /* PI_WR_TO_ODTH_F1:RW:24:6:=0x04 PI_WR_TO_ODTH_F0:RW:16:6:=0x03 PI_TODTON_MIN_F2:RW:8:4:=0x00 PI_ODTLON_F2:RW:0:4:=0x00 */
+	0x15070408U,  /* PI_RD_TO_ODTH_F2:RW:24:6:=0x15 PI_RD_TO_ODTH_F1:RW:16:6:=0x07 PI_RD_TO_ODTH_F0:RW:8:6:=0x04 PI_WR_TO_ODTH_F2:RW:0:6:=0x08 */
+	0x00000000U,  /* PI_RDLVL_SEQ_EN:RW:24:4:=0x00 PI_RDLVL_CS:RW:16:2:=0x00 PI_RDLVL_GATE_REQ:WR:8:1:=0x00 PI_RDLVL_REQ:WR:0:1:=0x00 */
+	0x00000000U,  /* PI_RDLVL_GATE_PERIODIC:RW:24:1:=0x00 PI_RDLVL_ON_SREF_EXIT:RW:16:1:=0x00 PI_RDLVL_PERIODIC:RW:8:1:=0x00 PI_RDLVL_GATE_SEQ_EN:RW:0:4:=0x00 */
+	0x00000000U,  /* PI_RDLVL_GATE_ROTATE:RW:24:1:=0x00 PI_RDLVL_ROTATE:RW:16:1:=0x00 RESERVED:RW:8:1:=0x00 PI_RDLVL_GATE_ON_SREF_EXIT:RW:0:1:=0x00 */
+	0x001E0303U,  /* PI_TDFI_RDLVL_RR:RW:16:10:=0x001e PI_RDLVL_GATE_CS_MAP:RW:8:4:=0x03 PI_RDLVL_CS_MAP:RW:0:4:=0x03 */
+	0x00000000U,  /* PI_TDFI_RDLVL_RESP:RW:0:32:=0x00000000 */
+	0x01010300U,  /* PI_RDLVL_GATE_EN:RW:24:2:=0x01 PI_RDLVL_EN:RW:16:2:=0x01 PI_TDFI_RDLVL_EN:RW:8:8:=0x03 PI_RDLVL_RESP_MASK:RW:0:4:=0x00 */
+	0x00000000U,  /* PI_TDFI_RDLVL_MAX:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PI_RDLVL_INTERVAL:RW:8:16:=0x0000 PI_RDLVL_ERROR_STATUS:RD:0:2:=0x00 */
+	0x01000000U,  /* PI_RDLVL_PATTERN_NUM:RW:24:4:=0x01 PI_RDLVL_PATTERN_START:RW:16:4:=0x00 PI_RDLVL_GATE_INTERVAL:RW:0:16:=0x0000 */
+	0x00010101U,  /* PI_REG_DIMM_ENABLE:RW:24:1:=0x00 PI_RD_PREAMBLE_TRAINING_EN:RW:16:1:=0x01 PI_RDLVL_GATE_STROBE_NUM:RW:8:5:=0x01 PI_RDLVL_STROBE_NUM:RW:0:5:=0x01 */
+	0x000E0705U,  /* PI_TDFI_RDDATA_EN:RD:24:7:=0x00 PI_RDLAT_ADJ_F2:RW:16:7:=0x0e PI_RDLAT_ADJ_F1:RW:8:7:=0x07 PI_RDLAT_ADJ_F0:RW:0:7:=0x05 */
+	0x000C0402U,  /* PI_TDFI_PHY_WRLAT:RD:24:7:=0x00 PI_WRLAT_ADJ_F2:RW:16:7:=0x0c PI_WRLAT_ADJ_F1:RW:8:7:=0x04 PI_WRLAT_ADJ_F0:RW:0:7:=0x02 */
+	0x02060301U,  /* PI_TDFI_PHY_WRDATA:RW:24:3:=0x02 PI_TDFI_WRCSLAT_F2:RW:16:7:=0x06 PI_TDFI_WRCSLAT_F1:RW:8:7:=0x03 PI_TDFI_WRCSLAT_F0:RW:0:7:=0x01 */
+	0x00000000U,  /* RESERVED:RW:24:4:=0x00 RESERVED:RW:16:1:=0x00 PI_CALVL_CS:RW:8:2:=0x00 PI_CALVL_REQ:WR:0:1:=0x00 */
+	0x00000003U,  /* PI_CALVL_ROTATE:RW:24:1:=0x00 PI_CALVL_ON_SREF_EXIT:RW:16:1:=0x00 PI_CALVL_PERIODIC:RW:8:1:=0x00 PI_CALVL_SEQ_EN:RW:0:2:=0x03 */
+	0x0018170FU,  /* PI_TDFI_CALVL_CC_F0:RW:16:10:=0x0018 PI_TDFI_CALVL_EN:RW:8:8:=0x17 PI_CALVL_CS_MAP:RW:0:4:=0x0f */
+	0x001C0006U,  /* PI_TDFI_CALVL_CC_F1:RW:16:10:=0x001c PI_TDFI_CALVL_CAPTURE_F0:RW:0:10:=0x0006 */
+	0x0028000AU,  /* PI_TDFI_CALVL_CC_F2:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F1:RW:0:10:=0x000a */
+	0x00000016U,  /* PI_TDFI_CALVL_CAPTURE_F2:RW:0:10:=0x0016 */
+	0x00000000U,  /* PI_TDFI_CALVL_RESP:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PI_TDFI_CALVL_MAX:RW:0:32:=0x00000000 */
+	0x00000100U,  /* PI_CALVL_ERROR_STATUS:RD:16:2:=0x00 PI_CALVL_EN:RW:8:2:=0x01 PI_CALVL_RESP_MASK:RW:0:1:=0x00 */
+	0x140A0000U,  /* PI_TCAMRD:RW:24:6:=0x14 PI_TCACKEL:RW:16:5:=0x0a PI_CALVL_INTERVAL:RW:0:16:=0x0000 */
+	0x0005010AU,  /* PI_TCAENT_F0:RW:16:14:=0x0005 PI_TMRZ_F0:RW:8:5:=0x01 PI_TCACKEH:RW:0:5:=0x0a */
+	0x03006401U,  /* PI_TMRZ_F2:RW:24:5:=0x03 PI_TCAENT_F1:RW:8:14:=0x0064 PI_TMRZ_F1:RW:0:5:=0x01 */
+	0x010A018DU,  /* PI_CA_TRAIN_VREF_EN:RW:24:1:=0x01 PI_TCAEXT:RW:16:5:=0x0a PI_TCAENT_F2:RW:0:14:=0x018d */
+	0x00060100U,  /* PI_TVREF_SHORT_F0:RW:16:10:=0x0006 PI_TDFI_CASEL_F0:RW:8:5:=0x01 PI_TDFI_CACSCA_F0:RW:0:5:=0x00 */
+	0x01000006U,  /* PI_TDFI_CASEL_F1:RW:24:5:=0x01 PI_TDFI_CACSCA_F1:RW:16:5:=0x00 PI_TVREF_LONG_F0:RW:0:10:=0x0006 */
+	0x00650065U,  /* PI_TVREF_LONG_F1:RW:16:10:=0x0065 PI_TVREF_SHORT_F1:RW:0:10:=0x0065 */
+	0x018E0100U,  /* PI_TVREF_SHORT_F2:RW:16:10:=0x018e PI_TDFI_CASEL_F2:RW:8:5:=0x01 PI_TDFI_CACSCA_F2:RW:0:5:=0x00 */
+	0x1E1A018EU,  /* PI_CALVL_VREF_INITIAL_STOP_POINT:RW:24:7:=0x1e PI_CALVL_VREF_INITIAL_START_POINT:RW:16:7:=0x1a PI_TVREF_LONG_F2:RW:0:10:=0x018e */
+	0x10010204U,  /* PI_TDFI_INIT_START_MIN:RW:24:8:=0x10 PI_CALVL_VREF_DELTA:RW:16:4:=0x01 PI_CALVL_VREF_NORMAL_STEPSIZE:RW:8:4:=0x02 PI_CALVL_VREF_INITIAL_STEPSIZE:RW:0:4:=0x04 */
+	0x09060605U,  /* PI_TDFI_CALVL_STROBE_F2:RW:24:4:=0x09 PI_TDFI_CALVL_STROBE_F1:RW:16:4:=0x06 PI_TDFI_CALVL_STROBE_F0:RW:8:4:=0x06 PI_TDFI_INIT_COMPLETE_MIN:RW:0:8:=0x05 */
+	0x20000202U,  /* PI_TDFI_INIT_START_F0:RW:24:8:=0x20 PI_SW_CA_TRAIN_VREF:RW:16:7:=0x00 PI_CALVL_STROBE_NUM:RW:8:5:=0x02 PI_TCKCKEH:RW:0:4:=0x02 */
+	0x00201000U,  /* PI_TDFI_INIT_START_F1:RW:16:8:=0x20 PI_TDFI_INIT_COMPLETE_F0:RW:0:16:=0x1000 */
+	0x00201000U,  /* PI_TDFI_INIT_START_F2:RW:16:8:=0x20 PI_TDFI_INIT_COMPLETE_F1:RW:0:16:=0x1000 */
+	0x04041000U,  /* PI_INIT_STARTORCOMPLETE_2_CLKDISABLE:RW:24:8:=0x04 PI_CLKDISABLE_2_INIT_START:RW:16:8:=0x04 PI_TDFI_INIT_COMPLETE_F2:RW:0:16:=0x1000 */
+	0x0C020100U,  /* PI_TCKEHDQS_F1:RW:24:6:=0x0c PI_TCKEHDQS_F0:RW:16:6:=0x02 PI_REFRESH_BETWEEN_SEGMENT_DISABLE:RW_D:8:1:=0x01 PI_DRAM_CLK_DISABLE_DEASSERT_SEL:RW:0:1:=0x00 */
+	0x00010118U,  /* PI_WDQLVL_BST_NUM:RW:16:3:=0x01 PI_WDQLVL_VREF_EN:RW:8:1:=0x01 PI_TCKEHDQS_F2:RW:0:6:=0x18 */
+	0x004B004AU,  /* PI_TDFI_WDQLVL_RW:RW:16:10:=0x004b PI_TDFI_WDQLVL_WR:RW:0:10:=0x004a */
+	0x1A0F0000U,  /* PI_WDQLVL_VREF_INITIAL_START_POINT:RW:24:7:=0x1a PI_WDQLVL_CS_MAP:RW:16:4:=0x0f PI_WDQLVL_ROTATE:RW:8:1:=0x00 PI_WDQLVL_RESP_MASK:RW:0:4:=0x00 */
+	0x0102041EU,  /* PI_WDQLVL_VREF_DELTA:RW:24:4:=0x01 PI_WDQLVL_VREF_NORMAL_STEPSIZE:RW:16:5:=0x02 PI_WDQLVL_VREF_INITIAL_STEPSIZE:RW:8:5:=0x04 PI_WDQLVL_VREF_INITIAL_STOP_POINT:RW:0:7:=0x1e */
+	0x34000000U,  /* PI_TDFI_WDQLVL_EN:RW:24:8:=0x34 PI_WDQLVL_CS:RW:16:2:=0x00 PI_WDQLVL_REQ:WR:8:1:=0x00 PI_WDQLVL_PERIODIC:RW:0:1:=0x00 */
+	0x00000000U,  /* PI_TDFI_WDQLVL_RESP:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PI_TDFI_WDQLVL_MAX:RW:0:32:=0x00000000 */
+	0x00010000U,  /* PI_WDQLVL_ON_SREF_EXIT:RW:24:1:=0x00 PI_WDQLVL_EN:RW:16:2:=0x01 PI_WDQLVL_INTERVAL:RW:0:16:=0x0000 */
+	0x31000000U,  /* PI_MR3_DATA_F0_0:RW+:24:8:=0x31 PI_MR2_DATA_F0_0:RW+:16:8:=0x00 PI_MR1_DATA_F0_0:RW+:8:8:=0x00 PI_WDQLVL_ERROR_STATUS:RD:0:2:=0x00 */
+	0x104D4D00U,  /* PI_MR1_DATA_F1_0:RW+:24:8:=0x10 PI_MR14_DATA_F0_0:RW+:16:8:=0x4d PI_MR12_DATA_F0_0:RW+:8:8:=0x4d PI_MR11_DATA_F0_0:RW+:0:8:=0x00 */
+	0x4D003109U,  /* PI_MR12_DATA_F1_0:RW+:24:8:=0x4d PI_MR11_DATA_F1_0:RW+:16:8:=0x00 PI_MR3_DATA_F1_0:RW+:8:8:=0x31 PI_MR2_DATA_F1_0:RW+:0:8:=0x09 */
+	0x312D504DU,  /* PI_MR3_DATA_F2_0:RW+:24:8:=0x31 PI_MR2_DATA_F2_0:RW+:16:8:=0x2d PI_MR1_DATA_F2_0:RW+:8:8:=0x50 PI_MR14_DATA_F1_0:RW+:0:8:=0x4d */
+	0x004D4D00U,  /* PI_MR13_DATA_0:RW+:24:8:=0x00 PI_MR14_DATA_F2_0:RW+:16:8:=0x4d PI_MR12_DATA_F2_0:RW+:8:8:=0x4d PI_MR11_DATA_F2_0:RW+:0:8:=0x00 */
+	0x00310000U,  /* PI_MR11_DATA_F0_1:RW+:24:8:=0x00 PI_MR3_DATA_F0_1:RW+:16:8:=0x31 PI_MR2_DATA_F0_1:RW+:8:8:=0x00 PI_MR1_DATA_F0_1:RW+:0:8:=0x00 */
+	0x09104D4DU,  /* PI_MR2_DATA_F1_1:RW+:24:8:=0x09 PI_MR1_DATA_F1_1:RW+:16:8:=0x10 PI_MR14_DATA_F0_1:RW+:8:8:=0x4d PI_MR12_DATA_F0_1:RW+:0:8:=0x4d */
+	0x4D4D0031U,  /* PI_MR14_DATA_F1_1:RW+:24:8:=0x4d PI_MR12_DATA_F1_1:RW+:16:8:=0x4d PI_MR11_DATA_F1_1:RW+:8:8:=0x00 PI_MR3_DATA_F1_1:RW+:0:8:=0x31 */
+	0x00312D50U,  /* PI_MR11_DATA_F2_1:RW+:24:8:=0x00 PI_MR3_DATA_F2_1:RW+:16:8:=0x31 PI_MR2_DATA_F2_1:RW+:8:8:=0x2d PI_MR1_DATA_F2_1:RW+:0:8:=0x50 */
+	0x00004D4DU,  /* PI_MR1_DATA_F0_2:RW+:24:8:=0x00 PI_MR13_DATA_1:RW+:16:8:=0x00 PI_MR14_DATA_F2_1:RW+:8:8:=0x4d PI_MR12_DATA_F2_1:RW+:0:8:=0x4d */
+	0x4D003100U,  /* PI_MR12_DATA_F0_2:RW+:24:8:=0x4d PI_MR11_DATA_F0_2:RW+:16:8:=0x00 PI_MR3_DATA_F0_2:RW+:8:8:=0x31 PI_MR2_DATA_F0_2:RW+:0:8:=0x00 */
+	0x3109104DU,  /* PI_MR3_DATA_F1_2:RW+:24:8:=0x31 PI_MR2_DATA_F1_2:RW+:16:8:=0x09 PI_MR1_DATA_F1_2:RW+:8:8:=0x10 PI_MR14_DATA_F0_2:RW+:0:8:=0x4d */
+	0x504D4D00U,  /* PI_MR1_DATA_F2_2:RW+:24:8:=0x50 PI_MR14_DATA_F1_2:RW+:16:8:=0x4d PI_MR12_DATA_F1_2:RW+:8:8:=0x4d PI_MR11_DATA_F1_2:RW+:0:8:=0x00 */
+	0x4D00312DU,  /* PI_MR12_DATA_F2_2:RW+:24:8:=0x4d PI_MR11_DATA_F2_2:RW+:16:8:=0x00 PI_MR3_DATA_F2_2:RW+:8:8:=0x31 PI_MR2_DATA_F2_2:RW+:0:8:=0x2d */
+	0x0000004DU,  /* PI_MR2_DATA_F0_3:RW+:24:8:=0x00 PI_MR1_DATA_F0_3:RW+:16:8:=0x00 PI_MR13_DATA_2:RW+:8:8:=0x00 PI_MR14_DATA_F2_2:RW+:0:8:=0x4d */
+	0x4D4D0031U,  /* PI_MR14_DATA_F0_3:RW+:24:8:=0x4d PI_MR12_DATA_F0_3:RW+:16:8:=0x4d PI_MR11_DATA_F0_3:RW+:8:8:=0x00 PI_MR3_DATA_F0_3:RW+:0:8:=0x31 */
+	0x00310910U,  /* PI_MR11_DATA_F1_3:RW+:24:8:=0x00 PI_MR3_DATA_F1_3:RW+:16:8:=0x31 PI_MR2_DATA_F1_3:RW+:8:8:=0x09 PI_MR1_DATA_F1_3:RW+:0:8:=0x10 */
+	0x2D504D4DU,  /* PI_MR2_DATA_F2_3:RW+:24:8:=0x2d PI_MR1_DATA_F2_3:RW+:16:8:=0x50 PI_MR14_DATA_F1_3:RW+:8:8:=0x4d PI_MR12_DATA_F1_3:RW+:0:8:=0x4d */
+	0x4D4D0031U,  /* PI_MR14_DATA_F2_3:RW+:24:8:=0x4d PI_MR12_DATA_F2_3:RW+:16:8:=0x4d PI_MR11_DATA_F2_3:RW+:8:8:=0x00 PI_MR3_DATA_F2_3:RW+:0:8:=0x31 */
+	0x00020000U,  /* PI_ROW_DIFF:RW:16:3:=0x02 PI_BANK_DIFF:RW:8:2:=0x00 PI_MR13_DATA_3:RW+:0:8:=0x00 */
+	0x00640005U,  /* PI_TFC_F1:RW:16:10:=0x0064 PI_TFC_F0:RW:0:10:=0x0005 */
+	0x0808018DU,  /* PI_TRTP_F0:RW:24:4:=0x08 PI_TCCD:RW:16:5:=0x08 PI_TFC_F2:RW:0:10:=0x018d */
+	0x04060403U,  /* PI_TWR_F0:RW:24:6:=0x04 PI_TWTR_F0:RW:16:6:=0x06 PI_TRCD_F0:RW:8:8:=0x04 PI_TRP_F0:RW:0:8:=0x03 */
+	0x03000578U,  /* PI_TRAS_MIN_F0:RW:24:8:=0x03 PI_TRAS_MAX_F0:RW:0:17:=0x000578 */
+	0x0A0A2001U,  /* PI_TMRW_F0:RW:24:8:=0x0a PI_TMRD_F0:RW:16:6:=0x0a PI_TCCDMW_F0:RW:8:6:=0x20 PI_TDQSCK_MAX_F0:RW:0:4:=0x01 */
+	0x06080908U,  /* PI_TWTR_F1:RW:24:6:=0x06 PI_TRCD_F1:RW:16:8:=0x08 PI_TRP_F1:RW:8:8:=0x09 PI_TRTP_F1:RW:0:4:=0x08 */
+	0x006D600AU,  /* PI_TRAS_MAX_F1:RW:8:17:=0x006d60 PI_TWR_F1:RW:0:6:=0x0a */
+	0x0A200211U,  /* PI_TMRD_F1:RW:24:6:=0x0a PI_TCCDMW_F1:RW:16:6:=0x20 PI_TDQSCK_MAX_F1:RW:8:4:=0x02 PI_TRAS_MIN_F1:RW:0:8:=0x11 */
+	0x1D220C0AU,  /* PI_TRCD_F2:RW:24:8:=0x1d PI_TRP_F2:RW:16:8:=0x22 PI_TRTP_F2:RW:8:4:=0x0c PI_TMRW_F1:RW:0:8:=0x0a */
+	0x00001F12U,  /* PI_TWR_F2:RW:8:6:=0x1f PI_TWTR_F2:RW:0:6:=0x12 */
+	0x4301B207U,  /* PI_TRAS_MIN_F2:RW:24:8:=0x43 PI_TRAS_MAX_F2:RW:0:17:=0x01b207 */
+	0x0A172006U,  /* PI_TMRW_F2:RW:24:8:=0x0a PI_TMRD_F2:RW:16:6:=0x17 PI_TCCDMW_F2:RW:8:6:=0x20 PI_TDQSCK_MAX_F2:RW:0:4:=0x06 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00000000U,  /* PI_INT_STATUS:RD:0:17:=0x000000 */
+	0x00000000U,  /* PI_INT_ACK:WR:0:16:=0x0000 */
+	0x00000000U,  /* PI_INT_MASK:RW:0:17:=0x000000 */
+	0x00000000U,  /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_ADDR:RD:0:34:=0x00000000 */
+	0x01000400U,  /* PI_CTRLUPD_REQ_PER_AREF_EN:RW:24:1:=0x01 PI_LONG_COUNT_MASK:RW:16:5:=0x00 PI_BSTLEN:RW_D:8:5:=0x04 PI_BIST_FAIL_ADDR:RD:0:34:=0x00 */
+	0x00008C00U,  /* PI_TDFI_CTRLUPD_MAX_F0:RW:8:16:=0x008c PI_TDFI_CTRLUPD_MIN:RD:0:4:=0x00 */
+	0x00000578U,  /* PI_TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x00000578 */
+	0x00000C20U,  /* PI_TDFI_CTRLUPD_MAX_F1:RW:0:16:=0x0c20 */
+	0x00007940U,  /* PI_TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x00007940 */
+	0x0000304CU,  /* PI_TDFI_CTRLUPD_MAX_F2:RW:0:16:=0x304c */
+	0x0001E2F8U,  /* PI_TDFI_CTRLUPD_INTERVAL_F2:RW:0:32:=0x0001e2f8 */
+	0x08000000U,  /* PI_ADDR_SPACE:RW:24:6:=0x08 PI_BIST_RESULT:RD:16:2:=0x00 PI_BIST_GO:WR:8:1:=0x00 PI_UPDATE_ERROR_STATUS:RD:0:7:=0x00 */
+	0x00000100U,  /* PI_BIST_ADDR_CHECK:RW:8:1:=0x01 PI_BIST_DATA_CHECK:RW:0:1:=0x00 */
+	0x00000000U,  /* PI_BIST_START_ADDRESS:RW:0:34:=0x00000000 */
+	0x00000000U,  /* PI_BIST_START_ADDRESS:RW:0:34:=0x00 */
+	0x00000000U,  /* PI_BIST_DATA_MASK:RW:0:64:=0x00000000 */
+	0x00000000U,  /* PI_BIST_DATA_MASK:RW:0:64:=0x00000000 */
+	0x00000001U,  /* PI_COL_DIFF:RW:0:4:=0x01 */
+};
+
+
+/* 2015/07/20 suresh regconfig */
+static const uint32_t DDR_PHY_suresh[827] =
+{
+	0x000004F0U, /* PHY_SW_WRDQ0_SHIFT_0:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_0:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_0:RW:0:11:=0x04f0 */
+	0x00000000U, /* PHY_SW_WRDQ4_SHIFT_0:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_0:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_0:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_0:RW:0:5:=0x00 */
+	0x00000000U, /* PHY_SW_WRDM_SHIFT_0:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_0:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_0:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_0:RW:0:5:=0x00 */
+	0x00000300U, /* PHY_DQ_TSEL_ENABLE_0:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_0:RW:0:4:=0x00 */
+	0x030e6E0EU, /* PHY_DQS_TSEL_ENABLE_0:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_0:RW:0:24:=0x665555 */
+	0x020e6E0EU, /* PHY_TWO_CYC_PREAMBLE_0:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_0:RW:0:24:=0x665555 */
+	0x00010F00U, /* PHY_PER_CS_TRAINING_INDEX_0:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_0:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_0:RW:8:2:=0x0f PHY_DBI_MODE_0:RW:0:1:=0x00 */
+	0x04000100U, /* PHY_LP4_BOOT_RPTR_UPDATE_0:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_0:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_0:RW:0:2:=0x00 */
+	0x00000133U, /* PHY_LPBK_CONTROL_0:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_0:RW:0:10:=0x0133 */
+	0x000700C0U, /* SC_PHY_SNAP_OBS_REGS_0:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_0:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_0:RW:0:10:=0x00c0 */
+	0x00CC0201U, /* PHY_GATE_SMPL1_SLAVE_DELAY_0:RW:16:9:=0x00cc PHY_LPDDR_TYPE_0:RW:8:2:=0x02 PHY_LPDDR_0:RW:0:1:=0x01 */
+	0x00030066U, /* ON_FLY_GATE_ADJUST_EN_0:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_0:RW:0:9:=0x0066 */
+	0x00000000U, /* PHY_GATE_TRACKING_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_PST_AMBLE_0:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT9_0:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT10_0:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT11_0:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_RDDQ_ENC_OBS_SELECT_0:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_0:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_0:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_0:RW:0:3:=0x00 */
+	0x00000000U, /* PHY_FIFO_PTR_OBS_SELECT_0:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_0:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_0:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_0:RW:0:4:=0x00 */
+	0x04080000U, /* PHY_WRLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_0:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_0:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_0:RW:0:1:=0x00 */
+	0x04080a04U, /* PHY_RDLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_0:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_0:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_0:RW:0:6:=0x00 */
+	0x00000000U, /* PHY_RDLVL_DATA_MASK_0:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_0:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_0:RW:0:2:=0x00 */
+	0x32103210U, /* PHY_RDLVL_DATA_SWIZZLE_0:RW:0:32:=0x32103210 */
+	0x00C00208U, /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_0:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_0:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_0:RW:0:6:=0x08 */
+	0x0001000CU, /* PHY_WDQLVL_CLR_PREV_RESULTS_0:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_0:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_0:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_0:RW:0:4:=0x0c */
+	0x00000100U, /* PHY_WDQLVL_DATADM_MASK_0:RW:0:9:=0x0100 */
+	0x55555555U, /* PHY_USER_PATT0_0:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU, /* PHY_USER_PATT1_0:RW:0:32:=0xAAAAAAAA */
+	0x55555555U, /* PHY_USER_PATT2_0:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU, /* PHY_USER_PATT3_0:RW:0:32:=0xAAAAAAAA */
+	0x00005555U, /* PHY_USER_PATT4_0:RW:0:16:=0x5555 */
+	0x76543210U, /* PHY_DQ_SWIZZLING_0:RW:0:32:=0x76543210 */
+	0x00000001U, /* PHY_FIFO_PTR_OBS_0:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_0:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_0:RW:0:1:=0x01 */
+	0x00000000U, /* PHY_LPBK_RESULT_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_0:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_0:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_0:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_0:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_0:RD:0:8:=0x00 */
+	0x00000000U, /* PHY_WR_SHIFT_OBS_0:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_0:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_0:RD:0:7:=0x00 */
+	0x00000000U, /* PHY_WRLVL_HARD1_DELAY_OBS_0:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_0:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_WRLVL_STATUS_OBS_0:RD:0:17:=0x000000 */
+	0x00000000U, /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_0:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_0:RD:0:9:=0x0000 */
+	0x00000000U, /* PHY_GTLVL_HARD0_DELAY_OBS_0:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_0:RD:0:16:=0x0000 */
+	0x00000000U, /* PHY_GTLVL_STATUS_OBS_0:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_0:RD:0:14:=0x0000 */
+	0x00000000U, /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_0:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_0:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_0:RD:0:2:=0x00 */
+	0x00000000U, /* PHY_RDLVL_STATUS_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_WDQLVL_DQDM_TE_DLY_OBS_0:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_0:RD:0:11:=0x0000 */
+	0x00000000U, /* PHY_WDQLVL_STATUS_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_DDL_MODE_0:RW:0:18:=0x000000 */
+	0x00000000U, /* PHY_DDL_TEST_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_DDL_TEST_MSTR_DLY_OBS_0:RD:0:32:=0x00000000 */
+	0x00200000U, /* PHY_RX_CAL_SAMPLE_WAIT_0:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_0:RW:8:1:=0x00 SC_PHY_RX_CAL_START_0:WR:0:1:=0x00 */
+	0x00000000U, /* PHY_RX_CAL_DQ1_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_0:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ3_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_0:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ5_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_0:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ7_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_0:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQS_0:RW+:16:12:=0x0000 PHY_RX_CAL_DM_0:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_OBS_0:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_0:RW+:0:12:=0x0000 */
+	0x02800280U, /* PHY_CLK_WRDQ1_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x02800280U, /* PHY_CLK_WRDQ3_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x02800280U, /* PHY_CLK_WRDQ5_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x02800280U, /* PHY_CLK_WRDQ7_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x00000280U, /* PHY_CLK_WRDQS_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x00000000U, /* PHY_RDDQ1_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ3_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ5_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ7_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00A000A0U, /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0 */
+	0x00040109U, /* PHY_WRITE_PATH_LAT_ADD_0:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_0:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_0:RW+:0:10:=0x0109 */
+	0x000001D0U, /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_0:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_0:RW+:0:10:=0x01d0 */
+	0x03000000U, /* PHY_GTLVL_LAT_ADJ_START_0:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_0:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_0:RW+:0:1:=0x00 */
+	0x00000200U, /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_0:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_0:RW+:0:11:=0x0200 */
+	0x41415141U, /* PHY_DQS_OE_TIMING_0:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_0:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_0:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_0:RW+:0:8:=0x41 */
+	0xC0014150U, /* PHY_DQ_IE_TIMING_0:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_0:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_0:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_0:RW+:0:8:=0x50 */
+	0x0E0000C0U, /* PHY_RDDATA_EN_DLY_0:RW+:24:4:=0x0e PHY_IE_MODE_0:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_0:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_0:RW+:0:8:=0xc0 */
+	0x0010000CU, /* PHY_MASTER_DELAY_START_0:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_0:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_0:RW+:0:4:=0x0c */
+	0x0C064208U, /* PHY_WRLVL_DLY_STEP_0:RW+:24:4:=0x0c PHY_RPTR_UPDATE_0:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_0:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_0:RW+:0:6:=0x08 */
+	0x000F0C18U, /* PHY_GTLVL_RESP_WAIT_CNT_0:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_0:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_0:RW+:0:5:=0x18 */
+	0x01000140U, /* PHY_GTLVL_FINAL_STEP_0:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_0:RW+:0:10:=0x0140 */
+	0x00000C20U, /* PHY_RDLVL_DLY_STEP_0:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_0:RW+:0:8:=0x20 */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x000004F0U, /* PHY_SW_WRDQ0_SHIFT_1:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_1:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:0:11:=0x04f0 */
+	0x00000000U, /* PHY_SW_WRDQ4_SHIFT_1:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_1:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_1:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_1:RW:0:5:=0x00 */
+	0x00000000U, /* PHY_SW_WRDM_SHIFT_1:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_1:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_1:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_1:RW:0:5:=0x00 */
+	0x00000300U, /* PHY_DQ_TSEL_ENABLE_1:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_1:RW:0:4:=0x00 */
+	0x030E6E0EU, /* PHY_DQS_TSEL_ENABLE_1:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_1:RW:0:24:=0x665555 */
+	0x020E6E0EU, /* PHY_TWO_CYC_PREAMBLE_1:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_1:RW:0:24:=0x665555 */
+	0x00010F00U, /* PHY_PER_CS_TRAINING_INDEX_1:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_1:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_1:RW:8:2:=0x0f PHY_DBI_MODE_1:RW:0:1:=0x00 */
+	0x04000100U, /* PHY_LP4_BOOT_RPTR_UPDATE_1:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_1:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_1:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_1:RW:0:2:=0x00 */
+	0x00000133U, /* PHY_LPBK_CONTROL_1:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_1:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_1:RW:0:10:=0x0133 */
+	0x000700C0U, /* SC_PHY_SNAP_OBS_REGS_1:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_1:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_1:RW:0:10:=0x00c0 */
+	0x00CC0201U, /* PHY_GATE_SMPL1_SLAVE_DELAY_1:RW:16:9:=0x00cc PHY_LPDDR_TYPE_1:RW:8:2:=0x02 PHY_LPDDR_1:RW:0:1:=0x01 */
+	0x00030066U, /* ON_FLY_GATE_ADJUST_EN_1:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_1:RW:0:9:=0x0066 */
+	0x00000000U, /* PHY_GATE_TRACKING_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_PST_AMBLE_1:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT9_1:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT10_1:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT11_1:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_RDDQ_ENC_OBS_SELECT_1:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_1:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_1:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_1:RW:0:3:=0x00 */
+	0x00000000U, /* PHY_FIFO_PTR_OBS_SELECT_1:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_1:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_1:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_1:RW:0:4:=0x00 */
+	0x04080000U, /* PHY_WRLVL_UPDT_WAIT_CNT_1:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_1:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_1:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_1:RW:0:1:=0x00 */
+	0x04080a04U, /* PHY_RDLVL_UPDT_WAIT_CNT_1:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_1:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_1:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_1:RW:0:6:=0x00 */
+	0x00000000U, /* PHY_RDLVL_DATA_MASK_1:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_1:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_1:RW:0:2:=0x00 */
+	0x32103210U, /* PHY_RDLVL_DATA_SWIZZLE_1:RW:0:32:=0x32103210 */
+	0x00C00208U, /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_1:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_1:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_1:RW:0:6:=0x08 */
+	0x0001000CU, /* PHY_WDQLVL_CLR_PREV_RESULTS_1:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_1:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_1:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_1:RW:0:4:=0x0c */
+	0x00000100U, /* PHY_WDQLVL_DATADM_MASK_1:RW:0:9:=0x0100 */
+	0x55555555U, /* PHY_USER_PATT0_1:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU, /* PHY_USER_PATT1_1:RW:0:32:=0xAAAAAAAA */
+	0x55555555U, /* PHY_USER_PATT2_1:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU, /* PHY_USER_PATT3_1:RW:0:32:=0xAAAAAAAA */
+	0x00005555U, /* PHY_USER_PATT4_1:RW:0:16:=0x5555 */
+	0x76543210U, /* PHY_DQ_SWIZZLING_1:RW:0:32:=0x76543210 */
+	0x00000000U, /* PHY_FIFO_PTR_OBS_1:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_1:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_1:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_LPBK_RESULT_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_1:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_1:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_1:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_1:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_1:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_1:RD:0:8:=0x00 */
+	0x00000000U, /* PHY_WR_SHIFT_OBS_1:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_1:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_1:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_1:RD:0:7:=0x00 */
+	0x00000000U, /* PHY_WRLVL_HARD1_DELAY_OBS_1:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_1:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_WRLVL_STATUS_OBS_1:RD:0:17:=0x000000 */
+	0x00000000U, /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_1:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_1:RD:0:9:=0x0000 */
+	0x00000000U, /* PHY_GTLVL_HARD0_DELAY_OBS_1:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_1:RD:0:16:=0x0000 */
+	0x00000000U, /* PHY_GTLVL_STATUS_OBS_1:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_1:RD:0:14:=0x0000 */
+	0x00000000U, /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_1:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_1:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_1:RD:0:2:=0x00 */
+	0x00000000U, /* PHY_RDLVL_STATUS_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_WDQLVL_DQDM_TE_DLY_OBS_1:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_1:RD:0:11:=0x0000 */
+	0x00000000U, /* PHY_WDQLVL_STATUS_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_DDL_MODE_1:RW:0:18:=0x000000 */
+	0x00000000U, /* PHY_DDL_TEST_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_DDL_TEST_MSTR_DLY_OBS_1:RD:0:32:=0x00000000 */
+	0x00200000U, /* PHY_RX_CAL_SAMPLE_WAIT_1:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_1:RW:8:1:=0x00 SC_PHY_RX_CAL_START_1:WR:0:1:=0x00 */
+	0x00000000U, /* PHY_RX_CAL_DQ1_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_1:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ3_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_1:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ5_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_1:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ7_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_1:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQS_1:RW+:16:12:=0x0000 PHY_RX_CAL_DM_1:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_OBS_1:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_1:RW+:0:12:=0x0000 */
+	0x02800280U, /* PHY_CLK_WRDQ1_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x02800280U, /* PHY_CLK_WRDQ3_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x02800280U, /* PHY_CLK_WRDQ5_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x02800280U, /* PHY_CLK_WRDQ7_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x00000280U, /* PHY_CLK_WRDQS_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x00000000U, /* PHY_RDDQ1_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ3_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ5_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ7_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00A000A0U, /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0 */
+	0x00040109U, /* PHY_WRITE_PATH_LAT_ADD_1:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_1:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_1:RW+:0:10:=0x0109 */
+	0x000001D0U, /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_1:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_1:RW+:0:10:=0x01d0 */
+	0x03000000U, /* PHY_GTLVL_LAT_ADJ_START_1:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_1:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_1:RW+:0:1:=0x00 */
+	0x00000200U, /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_1:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_1:RW+:0:11:=0x0200 */
+	0x41415141U, /* PHY_DQS_OE_TIMING_1:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_1:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_1:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_1:RW+:0:8:=0x41 */
+	0xC0014150U, /* PHY_DQ_IE_TIMING_1:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_1:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_1:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_1:RW+:0:8:=0x50 */
+	0x0E0000C0U, /* PHY_RDDATA_EN_DLY_1:RW+:24:4:=0x0e PHY_IE_MODE_1:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_1:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_1:RW+:0:8:=0xc0 */
+	0x0010000CU, /* PHY_MASTER_DELAY_START_1:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_1:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_1:RW+:0:4:=0x0c */
+	0x0C064208U, /* PHY_WRLVL_DLY_STEP_1:RW+:24:4:=0x0c PHY_RPTR_UPDATE_1:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_1:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_1:RW+:0:6:=0x08 */
+	0x000F0C18U, /* PHY_GTLVL_RESP_WAIT_CNT_1:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_1:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_1:RW+:0:5:=0x18 */
+	0x01000140U, /* PHY_GTLVL_FINAL_STEP_1:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_1:RW+:0:10:=0x0140 */
+	0x00000C20U, /* PHY_RDLVL_DLY_STEP_1:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_1:RW+:0:8:=0x20 */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x000004F0U, /* PHY_SW_WRDQ0_SHIFT_2:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_2:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_2:RW:0:11:=0x04f0 */
+	0x00000000U, /* PHY_SW_WRDQ4_SHIFT_2:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_2:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_2:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_2:RW:0:5:=0x00 */
+	0x00000000U, /* PHY_SW_WRDM_SHIFT_2:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_2:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_2:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_2:RW:0:5:=0x00 */
+	0x00000300U, /* PHY_DQ_TSEL_ENABLE_2:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_2:RW:0:4:=0x00 */
+	0x030E6E0EU, /* PHY_DQS_TSEL_ENABLE_2:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_2:RW:0:24:=0x665555 */
+	0x020E6E0EU, /* PHY_TWO_CYC_PREAMBLE_2:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_2:RW:0:24:=0x665555 */
+	0x00010F00U, /* PHY_PER_CS_TRAINING_INDEX_2:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_2:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_2:RW:8:2:=0x0f PHY_DBI_MODE_2:RW:0:1:=0x00 */
+	0x04000100U, /* PHY_LP4_BOOT_RPTR_UPDATE_2:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_2:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_2:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_2:RW:0:2:=0x00 */
+	0x00000133U, /* PHY_LPBK_CONTROL_2:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_2:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_2:RW:0:10:=0x0133 */
+	0x000700C0U, /* SC_PHY_SNAP_OBS_REGS_2:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_2:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_2:RW:0:10:=0x00c0 */
+	0x00CC0201U, /* PHY_GATE_SMPL1_SLAVE_DELAY_2:RW:16:9:=0x00cc PHY_LPDDR_TYPE_2:RW:8:2:=0x02 PHY_LPDDR_2:RW:0:1:=0x01 */
+	0x00030066U, /* ON_FLY_GATE_ADJUST_EN_2:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_2:RW:0:9:=0x0066 */
+	0x00000000U, /* PHY_GATE_TRACKING_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_PST_AMBLE_2:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT9_2:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT10_2:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT11_2:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_RDDQ_ENC_OBS_SELECT_2:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_2:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_2:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_2:RW:0:3:=0x00 */
+	0x00000000U, /* PHY_FIFO_PTR_OBS_SELECT_2:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_2:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_2:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_2:RW:0:4:=0x00 */
+	0x04080000U, /* PHY_WRLVL_UPDT_WAIT_CNT_2:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_2:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_2:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_2:RW:0:1:=0x00 */
+	0x04080a04U, /* PHY_RDLVL_UPDT_WAIT_CNT_2:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_2:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_2:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_2:RW:0:6:=0x00 */
+	0x00000000U, /* PHY_RDLVL_DATA_MASK_2:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_2:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_2:RW:0:2:=0x00 */
+	0x32103210U, /* PHY_RDLVL_DATA_SWIZZLE_2:RW:0:32:=0x32103210 */
+	0x00C00208U, /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_2:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_2:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_2:RW:0:6:=0x08 */
+	0x0001000CU, /* PHY_WDQLVL_CLR_PREV_RESULTS_2:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_2:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_2:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_2:RW:0:4:=0x0c */
+	0x00000100U, /* PHY_WDQLVL_DATADM_MASK_2:RW:0:9:=0x0100 */
+	0x55555555U, /* PHY_USER_PATT0_2:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU, /* PHY_USER_PATT1_2:RW:0:32:=0xAAAAAAAA */
+	0x55555555U, /* PHY_USER_PATT2_2:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU, /* PHY_USER_PATT3_2:RW:0:32:=0xAAAAAAAA */
+	0x00005555U, /* PHY_USER_PATT4_2:RW:0:16:=0x5555 */
+	0x76543210U, /* PHY_DQ_SWIZZLING_2:RW:0:32:=0x76543210 */
+	0x00000001U, /* PHY_FIFO_PTR_OBS_2:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_2:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_2:RW:0:1:=0x01 */
+	0x00000000U, /* PHY_LPBK_RESULT_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_2:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_2:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_2:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_2:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_2:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_2:RD:0:8:=0x00 */
+	0x00000000U, /* PHY_WR_SHIFT_OBS_2:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_2:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_2:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_2:RD:0:7:=0x00 */
+	0x00000000U, /* PHY_WRLVL_HARD1_DELAY_OBS_2:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_2:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_WRLVL_STATUS_OBS_2:RD:0:17:=0x000000 */
+	0x00000000U, /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_2:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_2:RD:0:9:=0x0000 */
+	0x00000000U, /* PHY_GTLVL_HARD0_DELAY_OBS_2:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_2:RD:0:16:=0x0000 */
+	0x00000000U, /* PHY_GTLVL_STATUS_OBS_2:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_2:RD:0:14:=0x0000 */
+	0x00000000U, /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_2:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_2:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_2:RD:0:2:=0x00 */
+	0x00000000U, /* PHY_RDLVL_STATUS_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_WDQLVL_DQDM_TE_DLY_OBS_2:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_2:RD:0:11:=0x0000 */
+	0x00000000U, /* PHY_WDQLVL_STATUS_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_DDL_MODE_2:RW:0:18:=0x000000 */
+	0x00000000U, /* PHY_DDL_TEST_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_DDL_TEST_MSTR_DLY_OBS_2:RD:0:32:=0x00000000 */
+	0x00200000U, /* PHY_RX_CAL_SAMPLE_WAIT_2:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_2:RW:8:1:=0x00 SC_PHY_RX_CAL_START_2:WR:0:1:=0x00 */
+	0x00000000U, /* PHY_RX_CAL_DQ1_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_2:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ3_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_2:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ5_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_2:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ7_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_2:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQS_2:RW+:16:12:=0x0000 PHY_RX_CAL_DM_2:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_OBS_2:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_2:RW+:0:12:=0x0000 */
+	0x02C702C5U, /* PHY_CLK_WRDQ1_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02C702C5U, /* PHY_CLK_WRDQ3_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02C402C3U, /* PHY_CLK_WRDQ5_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02C702C7U, /* PHY_CLK_WRDQ7_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x001e02C5U, /* PHY_CLK_WRDQS_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x00000000U, /* PHY_RDDQ1_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ3_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ5_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ7_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00A000A0U, /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0 */
+	0x00040109U, /* PHY_WRITE_PATH_LAT_ADD_2:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_2:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_2:RW+:0:10:=0x0109 */
+	0x000001D0U, /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_2:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_2:RW+:0:10:=0x01d0 */
+	0x03000000U, /* PHY_GTLVL_LAT_ADJ_START_2:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_2:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_2:RW+:0:1:=0x00 */
+	0x00000200U, /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_2:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_2:RW+:0:11:=0x0200 */
+	0x41415141U, /* PHY_DQS_OE_TIMING_2:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_2:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_2:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_2:RW+:0:8:=0x41 */
+	0xC0014150U, /* PHY_DQ_IE_TIMING_2:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_2:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_2:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_2:RW+:0:8:=0x50 */
+	0x0E0000C0U, /* PHY_RDDATA_EN_DLY_2:RW+:24:4:=0x0e PHY_IE_MODE_2:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_2:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_2:RW+:0:8:=0xc0 */
+	0x0010000CU, /* PHY_MASTER_DELAY_START_2:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_2:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_2:RW+:0:4:=0x0c */
+	0x0C064208U, /* PHY_WRLVL_DLY_STEP_2:RW+:24:4:=0x0c PHY_RPTR_UPDATE_2:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_2:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_2:RW+:0:6:=0x08 */
+	0x000F0C18U, /* PHY_GTLVL_RESP_WAIT_CNT_2:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_2:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_2:RW+:0:5:=0x18 */
+	0x01000140U, /* PHY_GTLVL_FINAL_STEP_2:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_2:RW+:0:10:=0x0140 */
+	0x00000C20U, /* PHY_RDLVL_DLY_STEP_2:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_2:RW+:0:8:=0x20 */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x000004F0U, /* PHY_SW_WRDQ0_SHIFT_3:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_3:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_3:RW:0:11:=0x04f0 */
+	0x00000000U, /* PHY_SW_WRDQ4_SHIFT_3:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_3:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_3:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_3:RW:0:5:=0x00 */
+	0x00000000U, /* PHY_SW_WRDM_SHIFT_3:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_3:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_3:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_3:RW:0:5:=0x00 */
+	0x00000300U, /* PHY_DQ_TSEL_ENABLE_3:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_3:RW:0:4:=0x00 */
+	0x030E6E0EU, /* PHY_DQS_TSEL_ENABLE_3:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_3:RW:0:24:=0x665555 */
+	0x020E6E0EU, /* PHY_TWO_CYC_PREAMBLE_3:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_3:RW:0:24:=0x665555 */
+	0x00010F00U, /* PHY_PER_CS_TRAINING_INDEX_3:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_3:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_3:RW:8:2:=0x0f PHY_DBI_MODE_3:RW:0:1:=0x00 */
+	0x04000100U, /* PHY_LP4_BOOT_RPTR_UPDATE_3:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_3:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_3:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_3:RW:0:2:=0x00 */
+	0x00000133U, /* PHY_LPBK_CONTROL_3:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_3:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_3:RW:0:10:=0x0133 */
+	0x000700C0U, /* SC_PHY_SNAP_OBS_REGS_3:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_3:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_3:RW:0:10:=0x00c0 */
+	0x00CC0201U, /* PHY_GATE_SMPL1_SLAVE_DELAY_3:RW:16:9:=0x00cc PHY_LPDDR_TYPE_3:RW:8:2:=0x02 PHY_LPDDR_3:RW:0:1:=0x01 */
+	0x00030066U, /* ON_FLY_GATE_ADJUST_EN_3:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_3:RW:0:9:=0x0066 */
+	0x00000000U, /* PHY_GATE_TRACKING_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_PST_AMBLE_3:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT9_3:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT10_3:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_LP4_RDLVL_PATT11_3:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_RDDQ_ENC_OBS_SELECT_3:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_3:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_3:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_3:RW:0:3:=0x00 */
+	0x00000000U, /* PHY_FIFO_PTR_OBS_SELECT_3:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_3:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_3:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_3:RW:0:4:=0x00 */
+	0x04080000U, /* PHY_WRLVL_UPDT_WAIT_CNT_3:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_3:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_3:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_3:RW:0:1:=0x00 */
+	0x04080a04U, /* PHY_RDLVL_UPDT_WAIT_CNT_3:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_3:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_3:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_3:RW:0:6:=0x00 */
+	0x00000000U, /* PHY_RDLVL_DATA_MASK_3:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_3:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_3:RW:0:2:=0x00 */
+	0x32103210U, /* PHY_RDLVL_DATA_SWIZZLE_3:RW:0:32:=0x32103210 */
+	0x00C00208U, /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_3:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_3:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_3:RW:0:6:=0x08 */
+	0x0001000CU, /* PHY_WDQLVL_CLR_PREV_RESULTS_3:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_3:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_3:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_3:RW:0:4:=0x0c */
+	0x00000100U, /* PHY_WDQLVL_DATADM_MASK_3:RW:0:9:=0x0100 */
+	0x55555555U, /* PHY_USER_PATT0_3:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU, /* PHY_USER_PATT1_3:RW:0:32:=0xAAAAAAAA */
+	0x55555555U, /* PHY_USER_PATT2_3:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU, /* PHY_USER_PATT3_3:RW:0:32:=0xAAAAAAAA */
+	0x00005555U, /* PHY_USER_PATT4_3:RW:0:16:=0x5555 */
+	0x76543210U, /* PHY_DQ_SWIZZLING_3:RW:0:32:=0x76543210 */
+	0x00000000U, /* PHY_FIFO_PTR_OBS_3:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_3:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_3:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_LPBK_RESULT_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_3:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_3:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_3:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_3:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_3:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_3:RD:0:8:=0x00 */
+	0x00000000U, /* PHY_WR_SHIFT_OBS_3:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_3:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_3:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_3:RD:0:7:=0x00 */
+	0x00000000U, /* PHY_WRLVL_HARD1_DELAY_OBS_3:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_3:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_WRLVL_STATUS_OBS_3:RD:0:17:=0x000000 */
+	0x00000000U, /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_3:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_3:RD:0:9:=0x0000 */
+	0x00000000U, /* PHY_GTLVL_HARD0_DELAY_OBS_3:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_3:RD:0:16:=0x0000 */
+	0x00000000U, /* PHY_GTLVL_STATUS_OBS_3:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_3:RD:0:14:=0x0000 */
+	0x00000000U, /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_3:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_3:RD:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_3:RD:0:2:=0x00 */
+	0x00000000U, /* PHY_RDLVL_STATUS_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_WDQLVL_DQDM_TE_DLY_OBS_3:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_3:RD:0:11:=0x0000 */
+	0x00000000U, /* PHY_WDQLVL_STATUS_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_DDL_MODE_3:RW:0:18:=0x000000 */
+	0x00000000U, /* PHY_DDL_TEST_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_DDL_TEST_MSTR_DLY_OBS_3:RD:0:32:=0x00000000 */
+	0x00200000U, /* PHY_RX_CAL_SAMPLE_WAIT_3:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_3:RW:8:1:=0x00 SC_PHY_RX_CAL_START_3:WR:0:1:=0x00 */
+	0x00000000U, /* PHY_RX_CAL_DQ1_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_3:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ3_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_3:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ5_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_3:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQ7_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_3:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_DQS_3:RW+:16:12:=0x0000 PHY_RX_CAL_DM_3:RW+:0:12:=0x0000 */
+	0x00000000U, /* PHY_RX_CAL_OBS_3:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_3:RW+:0:12:=0x0000 */
+
+	0x02C702C5U, /* PHY_CLK_WRDQ1_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02C702C5U, /* PHY_CLK_WRDQ3_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02C402C3U, /* PHY_CLK_WRDQ5_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02C702C7U, /* PHY_CLK_WRDQ7_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x001e02C5U, /* PHY_CLK_WRDQS_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+
+	0x00000000U, /* PHY_RDDQ1_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ3_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ5_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00000000U, /* PHY_RDDQ7_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00A000A0U, /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00A000A0U, /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0 */
+	0x00040109U, /* PHY_WRITE_PATH_LAT_ADD_3:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_3:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_3:RW+:0:10:=0x0109 */
+	0x000001D0U, /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_3:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_3:RW+:0:10:=0x01d0 */
+	0x03000000U, /* PHY_GTLVL_LAT_ADJ_START_3:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_3:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_3:RW+:0:1:=0x00 */
+	0x00000200U, /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_3:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_3:RW+:0:11:=0x0200 */
+	0x41415141U, /* PHY_DQS_OE_TIMING_3:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_3:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_3:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_3:RW+:0:8:=0x41 */
+	0xC0014150U, /* PHY_DQ_IE_TIMING_3:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_3:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_3:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_3:RW+:0:8:=0x50 */
+	0x0E0000C0U, /* PHY_RDDATA_EN_DLY_3:RW+:24:4:=0x0e PHY_IE_MODE_3:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_3:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_3:RW+:0:8:=0xc0 */
+	0x0010000CU, /* PHY_MASTER_DELAY_START_3:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_3:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_3:RW+:0:4:=0x0c */
+	0x0C064208U, /* PHY_WRLVL_DLY_STEP_3:RW+:24:4:=0x0c PHY_RPTR_UPDATE_3:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_3:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_3:RW+:0:6:=0x08 */
+	0x000F0C18U, /* PHY_GTLVL_RESP_WAIT_CNT_3:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_3:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_3:RW+:0:5:=0x18 */
+	0x01000140U, /* PHY_GTLVL_FINAL_STEP_3:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_3:RW+:0:10:=0x0140 */
+	0x00000C20U, /* PHY_RDLVL_DLY_STEP_3:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_3:RW+:0:8:=0x20 */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* PHY_ADR3_SW_WRADDR_SHIFT_0:RW+:24:5:=0x00 PHY_ADR2_SW_WRADDR_SHIFT_0:RW+:16:5:=0x00 PHY_ADR1_SW_WRADDR_SHIFT_0:RW+:8:5:=0x00 PHY_ADR0_SW_WRADDR_SHIFT_0:RW+:0:5:=0x00 */
+	0x00000000U, /* PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_0:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_0:RW+:8:5:=0x00 PHY_ADR4_SW_WRADDR_SHIFT_0:RW+:0:5:=0x00 */
+	0x00000000U, /* SC_PHY_ADR_MANUAL_CLEAR_0:WR:8:3:=0x00 PHY_ADR_CLK_BYPASS_OVERRIDE_0:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_ADR_LPBK_RESULT_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_ADR_SLAVE_LOOP_CNT_UPDATE_0:RW:24:3:=0x00 PHY_ADR_MASTER_DLY_LOCK_OBS_0:RD:8:10:=0x0000 PHY_ADR_MASTER_DLY_LOCK_OBS_SELECT_0:RW:0:3:=0x00 */
+	0x00000000U, /* PHY_ADR_LPBK_CONTROL_0:RW:24:6:=0x00 PHY_ADR_TSEL_ENABLE_0:RW:16:1:=0x00 SC_PHY_ADR_SNAP_OBS_REGS_0:WR:8:1:=0x00 PHY_ADR_SLV_DLY_ENC_OBS_SELECT_0:RW:0:3:=0x00 */
+	0x00000002U, /* PHY_ADR_IE_MODE_0:RW:16:1:=0x00 PHY_ADR_WRADDR_SHIFT_OBS_0:RD:8:3:=0x00 PHY_ADR_TYPE_0:RW:0:2:=0x02 */
+	0x00000000U, /* PHY_ADR_DDL_MODE_0:RW:0:15:=0x0000 */
+	0x00000000U, /* PHY_ADR_DDL_TEST_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_ADR_DDL_TEST_MSTR_DLY_OBS_0:RD:0:32:=0x00000000 */
+	0x00400320U, /* PHY_ADR_CALVL_COARSE_DLY_0:RW:16:11:=0x0040 PHY_ADR_CALVL_START_0:RW:0:11:=0x0320 */
+	0x00000040U, /* PHY_ADR_CALVL_QTR_0:RW:0:11:=0x0040 */
+	0x00DCBA98U, /* PHY_ADR_CALVL_SWIZZLE0_0_0:RW:0:24:=0xdcba98 */
+	0x00000000U, /* PHY_ADR_CALVL_SWIZZLE1_0_0:RW:0:24:=0x000000 */
+	0x00DCBA98U, /* PHY_ADR_CALVL_SWIZZLE0_1_0:RW:0:24:=0xdcba98 */
+	0x01000000U, /* PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000 */
+	0x00020010U, /* PHY_ADR_CALVL_RESP_WAIT_CNT_0:RW:24:4:=0x00 PHY_ADR_CALVL_CAPTURE_CNT_0:RW:16:4:=0x02 PHY_ADR_CALVL_NUM_PATTERNS_0:RW:8:2:=0x00 PHY_ADR_CALVL_RANK_CTRL_0:RW:0:5:=0x10 */
+	0x00000000U, /* PHY_ADR_CALVL_OBS_SELECT_0:RW:24:3:=0x00 SC_PHY_ADR_CALVL_ERROR_CLR_0:WR:16:1:=0x00 SC_PHY_ADR_CALVL_DEBUG_CONT_0:WR:8:1:=0x00 PHY_ADR_CALVL_DEBUG_MODE_0:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_ADR_CALVL_OBS0_0:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_ADR_CALVL_OBS1_0:RD:0:32:=0x00000000 */
+	0x00002A01U, /* PHY_ADR_CALVL_FG_0_0:RW:8:20:=0x00002A PHY_ADR_CALVL_RESULT_0:RW:0:1:=0x01 */
+	0x00000015U, /* PHY_ADR_CALVL_BG_0_0:RW:0:20:=0x000015 */
+	0x00000015U, /* PHY_ADR_CALVL_FG_1_0:RW:0:20:=0x000015 */
+	0x0000002AU, /* PHY_ADR_CALVL_BG_1_0:RW:0:20:=0x00002a */
+	0x00000033U, /* PHY_ADR_CALVL_FG_2_0:RW:0:20:=0x000033 */
+	0x0000000CU, /* PHY_ADR_CALVL_BG_2_0:RW:0:20:=0x00000c */
+	0x0000000CU, /* PHY_ADR_CALVL_FG_3_0:RW:0:20:=0x00000c */
+	0x00000033U, /* PHY_ADR_CALVL_BG_3_0:RW:0:20:=0x000033 */
+	0x00543210U, /* PHY_ADR_ADDR_SEL_0:RW:0:24:=0x543210 */
+	0x003F0000U, /* PHY_ADR_SEG_MASK_0:RW:24:6:=0x00 PHY_ADR_BIT_MASK_0:RW:16:6:=0x3f PHY_ADR_LP4_BOOT_SLV_DELAY_0:RW:0:10:=0x0000 */
+	0x0000003FU, /* PHY_ADR_CALVL_TRAIN_MASK_0:RW:0:6:=0x3f */
+	0x0002c06EU, /* PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55 */
+	0x02c002c0U, /* PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300 */
+	0x02c002c0U, /* PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300 */
+	0x000002c0U, /* PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300 */
+	0x42080010U, /* PHY_ADR_MASTER_DELAY_WAIT_0:RW+:24:8:=0x42 PHY_ADR_MASTER_DELAY_STEP_0:RW+:16:6:=0x08 PHY_ADR_MASTER_DELAY_START_0:RW+:0:10:=0x0010 */
+	0x00000003U, /* PHY_ADR_CALVL_DLY_STEP_0:RW+:0:4:=0x03 */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x04040404U, /* PHY_ADR3_SW_WRADDR_SHIFT_1:RW+:24:5:=0x04 PHY_ADR2_SW_WRADDR_SHIFT_1:RW+:16:5:=0x04 PHY_ADR1_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR0_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04 */
+	0x00000404U, /* PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR4_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04 */
+	0x00000000U, /* SC_PHY_ADR_MANUAL_CLEAR_1:WR:8:3:=0x00 PHY_ADR_CLK_BYPASS_OVERRIDE_1:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_ADR_LPBK_RESULT_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_ADR_SLAVE_LOOP_CNT_UPDATE_1:RW:24:3:=0x00 PHY_ADR_MASTER_DLY_LOCK_OBS_1:RD:8:10:=0x0000 PHY_ADR_MASTER_DLY_LOCK_OBS_SELECT_1:RW:0:3:=0x00 */
+	0x00000000U, /* PHY_ADR_LPBK_CONTROL_1:RW:24:6:=0x00 PHY_ADR_TSEL_ENABLE_1:RW:16:1:=0x00 SC_PHY_ADR_SNAP_OBS_REGS_1:WR:8:1:=0x00 PHY_ADR_SLV_DLY_ENC_OBS_SELECT_1:RW:0:3:=0x00 */
+	0x00000002U, /* PHY_ADR_IE_MODE_1:RW:16:1:=0x00 PHY_ADR_WRADDR_SHIFT_OBS_1:RD:8:3:=0x00 PHY_ADR_TYPE_1:RW:0:2:=0x02 */
+	0x00000000U, /* PHY_ADR_DDL_MODE_1:RW:0:15:=0x0000 */
+	0x00000000U, /* PHY_ADR_DDL_TEST_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_ADR_DDL_TEST_MSTR_DLY_OBS_1:RD:0:32:=0x00000000 */
+	0x00400320U, /* PHY_ADR_CALVL_COARSE_DLY_1:RW:16:11:=0x0040 PHY_ADR_CALVL_START_1:RW:0:11:=0x0320 */
+	0x00000040U, /* PHY_ADR_CALVL_QTR_1:RW:0:11:=0x0040 */
+	0x00000000U, /* PHY_ADR_CALVL_SWIZZLE0_0_1:RW:0:24:=0x000000 */
+	0x00000000U, /* PHY_ADR_CALVL_SWIZZLE1_0_1:RW:0:24:=0x000000 */
+	0x00000000U, /* PHY_ADR_CALVL_SWIZZLE0_1_1:RW:0:24:=0x000000 */
+	0x01000000U, /* PHY_ADR_CALVL_DEVICE_MAP_1:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_1:RW:0:24:=0x000000 */
+	0x00020010U, /* PHY_ADR_CALVL_RESP_WAIT_CNT_1:RW:24:4:=0x00 PHY_ADR_CALVL_CAPTURE_CNT_1:RW:16:4:=0x02 PHY_ADR_CALVL_NUM_PATTERNS_1:RW:8:2:=0x00 PHY_ADR_CALVL_RANK_CTRL_1:RW:0:5:=0x10 */
+	0x00000000U, /* PHY_ADR_CALVL_OBS_SELECT_1:RW:24:3:=0x00 SC_PHY_ADR_CALVL_ERROR_CLR_1:WR:16:1:=0x00 SC_PHY_ADR_CALVL_DEBUG_CONT_1:WR:8:1:=0x00 PHY_ADR_CALVL_DEBUG_MODE_1:RW:0:1:=0x00 */
+	0x00000000U, /* PHY_ADR_CALVL_OBS0_1:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_ADR_CALVL_OBS1_1:RD:0:32:=0x00000000 */
+	0x00002A01U, /* PHY_ADR_CALVL_FG_0_1:RW:8:20:=0x00002A PHY_ADR_CALVL_RESULT_1:RW:0:1:=0x01 */
+	0x00000015U, /* PHY_ADR_CALVL_BG_0_1:RW:0:20:=0x000015 */
+	0x00000015U, /* PHY_ADR_CALVL_FG_1_1:RW:0:20:=0x000015 */
+	0x0000002AU, /* PHY_ADR_CALVL_BG_1_1:RW:0:20:=0x00002a */
+	0x00000033U, /* PHY_ADR_CALVL_FG_2_1:RW:0:20:=0x000033 */
+	0x0000000CU, /* PHY_ADR_CALVL_BG_2_1:RW:0:20:=0x00000c */
+	0x0000000CU, /* PHY_ADR_CALVL_FG_3_1:RW:0:20:=0x00000c */
+	0x00000033U, /* PHY_ADR_CALVL_BG_3_1:RW:0:20:=0x000033 */
+	0x00000000U, /* PHY_ADR_ADDR_SEL_1:RW:0:24:=0x000000 */
+	0x00000000U, /* PHY_ADR_SEG_MASK_1:RW:24:6:=0x00 PHY_ADR_BIT_MASK_1:RW:16:6:=0x00 PHY_ADR_LP4_BOOT_SLV_DELAY_1:RW:0:10:=0x0000 */
+	0x00000000U, /* PHY_ADR_CALVL_TRAIN_MASK_1:RW:0:6:=0x00 */
+	0x0003006EU, /* PHY_ADR0_CLK_WR_SLAVE_DELAY_1:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_1:RW+:0:8:=0x55 */
+	0x03000300U, /* PHY_ADR2_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x03000300U, /* PHY_ADR4_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x00000300U, /* PHY_ADR_SW_MASTER_MODE_1:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x42080010U, /* PHY_ADR_MASTER_DELAY_WAIT_1:RW+:24:8:=0x42 PHY_ADR_MASTER_DELAY_STEP_1:RW+:16:6:=0x08 PHY_ADR_MASTER_DELAY_START_1:RW+:0:10:=0x0010 */
+	0x00000003U, /* PHY_ADR_CALVL_DLY_STEP_1:RW+:0:4:=0x03 */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000000U, /* */
+	0x00000001U, /* PHY_SW_GRP_SHIFT_1:RW+:24:5:=0x00 PHY_SW_GRP_SHIFT_0:RW+:16:5:=0x00 PHY_FREQ_SEL_INDEX:RW:8:2:=0x00 PHY_FREQ_SEL_MULTICAST_EN:RW_D:0:1:=0x01 */
+	0x00000000U, /* PHY_GRP_BYPASS_SLAVE_DELAY:RW:16:11:=0x0000 PHY_SW_GRP_SHIFT_3:RW+:8:5:=0x00 PHY_SW_GRP_SHIFT_2:RW+:0:5:=0x00 */
+	0x00000005U, /* PHY_LP4_BOOT_DISABLE:RW:24:1:=0x01 SC_PHY_MANUAL_UPDATE:WR:16:1:=0x00 PHY_GRP_BYPASS_OVERRIDE:RW:8:1:=0x00 PHY_SW_GRP_BYPASS_SHIFT:RW:0:5:=0x05 */
+	0x04003100U, /* PHY_CSLVL_START:RW:16:11:=0x0400 PHY_CSLVL_CS_MAP:RW:8:4:=0x31 PHY_CSLVL_ENABLE:RW:0:1:=0x01 */
+	0x00020040U, /* PHY_CSLVL_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_QTR:RW:0:11:=0x0040 */
+	0x00020055U, /* PHY_CSLVL_DEBUG_MODE:RW:24:1:=0x00 PHY_CSLVL_COARSE_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_COARSE_DLY:RW:0:11:=0x0055 */
+	0x00000000U, /* SC_PHY_CSLVL_ERROR_CLR:WR:8:1:=0x00 SC_PHY_CSLVL_DEBUG_CONT:WR:0:1:=0x00 */
+	0x00000000U, /* PHY_CSLVL_OBS0:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_CSLVL_OBS1:RD:0:32:=0x00000000 */
+	0x00000050U, /* PHY_GRP_SHIFT_OBS_SELECT:RW:24:5:=0x00 PHY_GRP_SLV_DLY_ENC_OBS_SELECT:RW:8:10:=0x0000 PHY_CALVL_CS_MAP:RW:0:8:=0x50 */
+	0x00000000U, /* PHY_ADRCTL_SLAVE_LOOP_CNT_UPDATE:RW:24:3:=0x00 PHY_GRP_SHIFT_OBS:RD:16:3:=0x00 PHY_GRP_SLV_DLY_ENC_OBS:RD:0:10:=0x0000 */
+	0x01010100U, /* PHY_LP4_ACTIVE:RW:24:1:=0x01 PHY_ADRCTL_LPDDR:RW:16:1:=0x01 PHY_DFI_PHYUPD_TYPE:RW:8:2:=0x01 PHY_ADRCTL_SNAP_OBS_REGS:WR:0:1:=0x00 */
+	0x00000000U, /* PHY_CONTINUOUS_CLK_CAL_UPDATE:RW:24:1:=0x00 PHY_UPDATE_CLK_CAL_VALUES:RW:16:1:=0x00 PHY_CALVL_RESULT_MASK:RW:8:2:=0x00 PHY_LPDDR3_CS:RW_D:0:1:=0x00 */
+	0x00001102U, /* PHY_PLL_CTRL:RW+:0:13:=0x1102 */
+	0x00000000U, /* PHY_PLL_BYPASS:RW+:0:5:=0x00 */
+	0x000D0000U, /* PHY_PAD_VREF_CTRL_DQ_0:RW+:8:14:=0x0100 PHY_LOW_FREQ_SEL:RW+:0:1:=0x00 */
+	0x0D000D00U, /* PHY_PAD_VREF_CTRL_DQ_2:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_1:RW+:0:14:=0x0100 */
+	0x0D000D00U, /* PHY_PAD_VREF_CTRL_AC:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_3:RW+:0:14:=0x0100 */
+	0x0002c003U, /* PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03 */
+	0x02c002c0U, /* PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x000002c0U, /* PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300 */
+	0x00001102U, /* PHY_PLL_CTRL_OVERRIDE:RW:16:16:=0x0000 PHY_LP4_BOOT_PLL_CTRL:RW:0:13:=0x1b02 */
+	0x00000064U, /* PHY_PLL_OBS_0:RD:8:16:=0x0000 PHY_PLL_WAIT:RW:0:8:=0x64 */
+	0x00000000U, /* PHY_PLL_OBS_2:RD:16:16:=0x0000 PHY_PLL_OBS_1:RD:0:16:=0x0000 */
+	0x00000000U, /* PHY_PLL_OBS_4:RD:16:16:=0x0000 PHY_PLL_OBS_3:RD:0:16:=0x0000 */
+	0x00010503U, /* PHY_LP_WAKEUP:RW:24:4:=0x00 PHY_LP4_BOOT_LOW_FREQ_SEL:RW:16:1:=0x01 PHY_TCKSRE_WAIT:RW:8:4:=0x05 PHY_PLL_TESTOUT_SEL:RW:0:3:=0x03 */
+	0x027F6E00U, /* PHY_PAD_FDBK_DRIVE:RW+:8:18:=0x000411 PHY_TDFI_PHY_WRDELAY:RW:0:1:=0x00 */
+	0x047F027FU, /* PHY_PAD_DQS_DRIVE:RW+:16:12:=0x0040 PHY_PAD_DATA_DRIVE:RW+:0:10:=0x0040 */
+	0x00027F6EU, /* PHY_PAD_ADDR_DRIVE:RW+:0:18:=0x000411 */
+	0x00047F6EU, /* PHY_PAD_CLK_DRIVE:RW+:0:20:=0x000411 */
+	0x00030F68U, /* PHY_PAD_FDBK_TERM:RW+:0:18:=0x004410 //PVTP = 0x28, PVTN=0x3d, PVTr=0x10 */
+	0x00010F68U, /* PHY_PAD_DATA_TERM:RW+:0:17:=0x004410 */
+	0x00010F68U, /* PHY_PAD_DQS_TERM:RW+:0:17:=0x004410 */
+	0x00010F68U, /* PHY_PAD_ADDR_TERM:RW+:0:18:=0x004410 */
+	0x00010F68U, /* PHY_PAD_CLK_TERM:RW+:0:18:=0x004410 */
+	0x00027F6EU, /* PHY_PAD_CKE_DRIVE:RW+:0:18:=0x000411 */
+	0x00010F68U, /* PHY_PAD_CKE_TERM:RW+:0:18:=0x004410 */
+	0x00027F6EU, /* PHY_PAD_RST_DRIVE:RW+:0:18:=0x000411 */
+	0x00010F68U, /* PHY_PAD_RST_TERM:RW+:0:18:=0x004410 */
+	0x00027F6EU, /* PHY_PAD_CS_DRIVE:RW+:0:18:=0x000411 */
+	0x00010F68U, /* PHY_PAD_CS_TERM:RW+:0:18:=0x004410 */
+	0x00000000U, /* PHY_ADRCTL_RX_CAL:RW:0:25:=0x00000000 */
+	0x00000000U, /* PHY_ADRCTL_LP3_RX_CAL:RW:0:25:=0x00000000 */
+	0x00000000U, /* PHY_TST_CLK_PAD_CTRL:RW:0:32:=0x00000000 */
+	0x65000000U, /* PHY_CAL_MODE_0:RW:24:8:=0x64 PHY_TST_CLK_PAD_CTRL2:RW:0:23:=0x000000 */
+	0x00000000U, /* PHY_CAL_START_0:WR:8:1:=0x00 PHY_CAL_CLEAR_0:WR:0:1:=0x00 */
+	0x00000000U, /* PHY_CAL_INTERVAL_COUNT_0:RW:0:32:=0x00000000 */
+	0x00000608U, /* PHY_CAL_CLK_SELECT_0:RW:8:3:=0x01 PHY_CAL_SAMPLE_WAIT_0:RW:0:8:=0x08 */
+	0x00000000U, /* PHY_CAL_RESULT_OBS_0:RD:0:24:=0x000000 */
+	0x00000000U, /* PHY_CAL_RESULT2_OBS_0:RD:0:24:=0x000000 */
+	0x00000000U, /* PHY_AC_LPBK_ERR_CLEAR:WR:24:1:=0x00 PHY_ADRCTL_MANUAL_UPDATE:WR:16:1:=0x00 PHY_PAD_ATB_CTRL:RW:0:16:=0x0000 */
+	0x00000000U, /* PHY_AC_LPBK_OBS_SELECT:RW:0:5:=0x00 */
+	0x00000000U, /* PHY_AC_LPBK_ENABLE:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_AC_LPBK_CONTROL:RW:0:9:=0x0000 */
+	0x00000000U, /* PHY_AC_LPBK_RESULT_OBS:RD:0:32:=0x00000000 */
+	0x00000000U, /* PHY_AC_CLK_LPBK_CONTROL:RW:24:6:=0x00 PHY_AC_CLK_LPBK_ENABLE:RW:8:16:=0x0000 PHY_AC_CLK_LPBK_OBS_SELECT:RW:0:4:=0x00 */
+	0x00000000U, /* PHY_AC_CLK_LPBK_RESULT_OBS:RD:0:16:=0x0000 */
+	0x00000000U, /* PHY_DDL_AC_ENABLE:RW:0:32:=0x00000000 */
+	0x00000000U, /* PHY_DDL_AC_MODE:RW:0:11:=0x0000 */
+};
+
+
+static const uint32_t DDR_PI_suresh[181] =
+{
+	0x00000B00U, /* PI_VERSION:RD:16:16:=0x0000 PI_DRAM_CLASS:RW:8:4:=0x0b PI_START:RW:0:1:=0x00 */
+	0x00000100U, /* PI_TCMD_GAP:RW:16:16:=0x0000 PI_INIT_LVL_EN:RW:8:1:=0x01 PI_NORMAL_LVL_SEQ:RW:0:1:=0x00 */
+	0x00000118U, /* PI_TDFI_PHYMSTR_MAX_F0:RW:0:32:=0x00000118 */
+	0x0000008CU, /* PI_TDFI_PHYMSTR_RESP_F0:RW:0:16:=0x008c */
+	0x00006098U, /* PI_TDFI_PHYMSTR_MAX_F1:RW:0:32:=0x00006098 */
+	0x0000304CU, /* PI_TDFI_PHYMSTR_RESP_F1:RW:0:16:=0x304c */
+	0x00006098U, /* PI_TDFI_PHYMSTR_MAX_F2:RW:0:32:=0x00006098 */
+	0x008C304CU, /* PI_TDFI_PHYUPD_RESP_F0:RW:16:16:=0x008c PI_TDFI_PHYMSTR_RESP_F2:RW:0:16:=0x304c */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE0_F0:RW:0:32:=0x00000200 */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE1_F0:RW:0:32:=0x00000200 */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE2_F0:RW:0:32:=0x00000200 */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE3_F0:RW:0:32:=0x00000200 */
+	0x0000304CU, /* PI_TDFI_PHYUPD_RESP_F1:RW:0:16:=0x304c */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE0_F1:RW:0:32:=0x00000200 */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE1_F1:RW:0:32:=0x00000200 */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE2_F1:RW:0:32:=0x00000200 */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE3_F1:RW:0:32:=0x00000200 */
+	0x0000304CU, /* PI_TDFI_PHYUPD_RESP_F2:RW:0:16:=0x304c */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE0_F2:RW:0:32:=0x00000200 */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE1_F2:RW:0:32:=0x00000200 */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE2_F2:RW:0:32:=0x00000200 */
+	0x00000200U, /* PI_TDFI_PHYUPD_TYPE3_F2:RW:0:32:=0x00000200 */
+	0x00010000U, /* PI_EXIT_AFTER_INIT_CALVL:RW_D:16:1:=0x01 PI_CONTROL_ERROR_STATUS:RD:0:9:=0x0000 */
+	0x00000005U, /* PI_FREQ_MAP:RW:0:32:=0x00000007 */
+	0x01000002U, /* PI_POWER_ON_SEQ_END_ARRAY:RW:24:8:=0x01 PI_POWER_ON_SEQ_BYPASS_ARRAY:RW:16:8:=0x00 PI_INIT_DFS_CALVL_ONLY:RW:8:1:=0x00 PI_INIT_WORK_FREQ:RW:0:5:=0x01 */
+	0x00000000U, /* PI_SEQ1_PAT:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ1_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ2_PAT:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ2_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ3_PAT:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ3_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ4_PAT:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ4_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ5_PAT:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ5_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ6_PAT:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ6_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ7_PAT:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ7_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ8_PAT:RW:0:28:=0x00000000 */
+	0x00000000U, /* PI_SEQ8_PAT_MASK:RW:0:28:=0x00000000 */
+	0x05000101U, /* PI_CS_MAP:RW:24:4:=0x0f RESERVED:RW:16:1:=0x00 PI_SW_RST_N:RW_D:8:1:=0x01 PI_WDT_DISABLE:RW_D:0:1:=0x01 */
+	0x08494925U, /* PI_TMRR:RW:24:4:=0x08 PI_TDELAY_RDWR_2_BUS_IDLE_F2:RW:16:8:=0x49 PI_TDELAY_RDWR_2_BUS_IDLE_F1:RW:8:8:=0x49 PI_TDELAY_RDWR_2_BUS_IDLE_F0:RW:0:8:=0x25 */
+	0x380E0C04U, /* PI_CASLAT_LIN_F1:RW:24:7:=0x38 PI_WRLAT_F1:RW:16:6:=0x0e PI_CASLAT_LIN_F0:RW:8:7:=0x0c PI_WRLAT_F0:RW:0:6:=0x04 */
+	0x0002500EU, /* PI_AREFRESH:WR:24:1:=0x00 PI_PREAMBLE_SUPPORT:RW:16:2:=0x02 PI_CASLAT_LIN_F2:RW:8:7:=0x38 PI_WRLAT_F2:RW:0:6:=0x0e */
+	0x00460003U, /* PI_TREF_F0:RW:16:16:=0x0046 PI_TRFC_F0:RW:0:10:=0x0003 */
+	0x182600CFU, /* PI_TREF_F1:RW:16:16:=0x1826 PI_TRFC_F1:RW:0:10:=0x00cf */
+	0x182600CFU, /* PI_TREF_F2:RW:16:16:=0x1826 PI_TRFC_F2:RW:0:10:=0x00cf */
+	0x00000005U, /* PI_SWLVL_OP_DONE:RD:24:1:=0x00 PI_SWLVL_LOAD:WR:16:1:=0x00 PI_TREF_INTERVAL:RW:0:16:=0x0005 */
+	0x00000000U, /* PI_SW_WRLVL_RESP_3:RD:24:1:=0x00 PI_SW_WRLVL_RESP_2:RD:16:1:=0x00 PI_SW_WRLVL_RESP_1:RD:8:1:=0x00 PI_SW_WRLVL_RESP_0:RD:0:1:=0x00 */
+	0x00000000U, /* PI_SW_RDLVL_RESP_3:RD:24:2:=0x00 PI_SW_RDLVL_RESP_2:RD:16:2:=0x00 PI_SW_RDLVL_RESP_1:RD:8:2:=0x00 PI_SW_RDLVL_RESP_0:RD:0:2:=0x00 */
+	0x00000000U, /* PI_SWLVL_EXIT:WR:24:1:=0x00 PI_SWLVL_START:WR:16:1:=0x00 PI_SW_LEVELING_MODE:RW:8:3:=0x00 PI_SW_CALVL_RESP_0:RD:0:2:=0x00 */
+	0x00000000U, /* PI_SWLVL_WR_SLICE_1:WR:24:1:=0x00 PI_SW_WDQLVL_RESP_0:RD:16:2:=0x00 PI_SWLVL_RD_SLICE_0:WR:8:1:=0x00 PI_SWLVL_WR_SLICE_0:WR:0:1:=0x00 */
+	0x00000000U, /* PI_SWLVL_RD_SLICE_2:WR:24:1:=0x00 PI_SWLVL_WR_SLICE_2:WR:16:1:=0x00 PI_SW_WDQLVL_RESP_1:RD:8:2:=0x00 PI_SWLVL_RD_SLICE_1:WR:0:1:=0x00 */
+	0x00000000U, /* PI_SW_WDQLVL_RESP_3:RD:24:2:=0x00 PI_SWLVL_RD_SLICE_3:WR:16:1:=0x00 PI_SWLVL_WR_SLICE_3:WR:8:1:=0x00 PI_SW_WDQLVL_RESP_2:RD:0:2:=0x00 */
+	0x00000000U, /* PI_SWLVL_SM2_RD:WR:24:1:=0x00 PI_SWLVL_SM2_WR:WR:16:1:=0x00 PI_SWLVL_SM2_START:WR:8:1:=0x00 PI_SW_WDQLVL_VREF:RW:0:7:=0x00 */
+	0x01000000U, /* PI_16BIT_DRAM_CONNECT:RW_D:24:1:=0x01 PI_SRE_PERIOD_EN:RW:16:1:=0x00 PI_DFS_PERIOD_EN:RW:8:1:=0x00 PI_SEQUENTIAL_LVL_REQ:WR:0:1:=0x00 */
+	0x00040404U, /* PI_WRLVL_REQ:WR:24:1:=0x00 PI_TDFI_CTRL_DELAY_F2:RW_D:16:4:=0x04 PI_TDFI_CTRL_DELAY_F1:RW_D:8:4:=0x04 PI_TDFI_CTRL_DELAY_F0:RW_D:0:4:=0x04 */
+	0x01280A00U, /* PI_WRLVL_EN:RW:24:2:=0x01 PI_WLMRD:RW:16:6:=0x28 PI_WLDQSEN:RW:8:6:=0x0a PI_WRLVL_CS:RW:0:2:=0x00 */
+	0x00000000U, /* PI_WRLVL_ON_SREF_EXIT:RW:24:1:=0x00 PI_WRLVL_PERIODIC:RW:16:1:=0x00 PI_WRLVL_INTERVAL:RW:0:16:=0x0000 */
+	0x00010000U, /* PI_WRLVL_ERROR_STATUS:RD:24:2:=0x00 PI_WRLVL_CS_MAP:RW:16:4:=0x03 PI_WRLVL_ROTATE:RW:8:1:=0x00 PI_WRLVL_RESP_MASK:RW:0:4:=0x00 */
+	0x00001440U, /* PI_TDFI_WRLVL_WW:RW:8:10:=0x0014 PI_TDFI_WRLVL_EN:RW:0:8:=0x03 */
+	0x00000000U, /* PI_TDFI_WRLVL_RESP:RW:0:32:=0x00000000 */
+	0x00000000U, /* PI_TDFI_WRLVL_MAX:RW:0:32:=0x00000000 */
+	0x00060102U, /* PI_TODTL_2CMD_F0:RW:24:8:=0x00 PI_WRLVL_EN_DEASSERT_2_MRR:RW:16:5:=0x06 PI_WRLVL_MRR_DQ_RETURN_HIZ:RW:8:1:=0x01 PI_WRLVL_STROBE_NUM:RW:0:5:=0x02 */
+	0x00010001U, /* PI_TODTL_2CMD_F2:RW:24:8:=0x00 PI_ODT_EN_F1:RW:16:1:=0x01 PI_TODTL_2CMD_F1:RW:8:8:=0x00 PI_ODT_EN_F0:RW:0:1:=0x01 */
+	0x01000101U, /* PI_ODT_RD_MAP_CS0:RW:24:4:=0x01 PI_TODTH_RD:RW:16:4:=0x00 PI_TODTH_WR:RW:8:4:=0x01 PI_ODT_EN_F2:RW:0:1:=0x01 */
+	0x04020201U, /* PI_ODT_RD_MAP_CS2:RW:24:4:=0x04 PI_ODT_WR_MAP_CS1:RW:16:4:=0x02 PI_ODT_RD_MAP_CS1:RW:8:4:=0x02 PI_ODT_WR_MAP_CS0:RW:0:4:=0x01 */
+	0x00080804U, /* PI_EN_ODT_ASSERT_EXCEPT_RD:RW:24:1:=0x00 PI_ODT_WR_MAP_CS3:RW:16:4:=0x08 PI_ODT_RD_MAP_CS3:RW:8:4:=0x08 PI_ODT_WR_MAP_CS2:RW:0:4:=0x04 */
+	0x00000000U, /* PI_TODTON_MIN_F1:RW:24:4:=0x00 PI_ODTLON_F1:RW:16:4:=0x00 PI_TODTON_MIN_F0:RW:8:4:=0x00 PI_ODTLON_F0:RW:0:4:=0x00 */
+	0x08030000U, /* PI_WR_TO_ODTH_F1:RW:24:6:=0x08 PI_WR_TO_ODTH_F0:RW:16:6:=0x03 PI_TODTON_MIN_F2:RW:8:4:=0x00 PI_ODTLON_F2:RW:0:4:=0x00 */
+	0x15150408U, /* PI_RD_TO_ODTH_F2:RW:24:6:=0x15 PI_RD_TO_ODTH_F1:RW:16:6:=0x15 PI_RD_TO_ODTH_F0:RW:8:6:=0x04 PI_WR_TO_ODTH_F2:RW:0:6:=0x08 */
+	0x00000000U, /* PI_RDLVL_SEQ_EN:RW:24:4:=0x00 PI_RDLVL_CS:RW:16:2:=0x00 PI_RDLVL_GATE_REQ:WR:8:1:=0x00 PI_RDLVL_REQ:WR:0:1:=0x00 */
+	0x00000000U, /* PI_RDLVL_GATE_PERIODIC:RW:24:1:=0x00 PI_RDLVL_ON_SREF_EXIT:RW:16:1:=0x00 PI_RDLVL_PERIODIC:RW:8:1:=0x00 PI_RDLVL_GATE_SEQ_EN:RW:0:4:=0x00 */
+	0x00000000U, /* PI_RDLVL_GATE_ROTATE:RW:24:1:=0x00 PI_RDLVL_ROTATE:RW:16:1:=0x00 RESERVED:RW:8:1:=0x00 PI_RDLVL_GATE_ON_SREF_EXIT:RW:0:1:=0x00 */
+	0x001E0101U, /* PI_TDFI_RDLVL_RR:RW:16:10:=0x001e PI_RDLVL_GATE_CS_MAP:RW:8:4:=0x03 PI_RDLVL_CS_MAP:RW:0:4:=0x03 */
+	0x00000000U, /* PI_TDFI_RDLVL_RESP:RW:0:32:=0x00000000 */
+	0x01000100U, /* PI_RDLVL_GATE_EN:RW:24:2:=0x01 PI_RDLVL_EN:RW:16:2:=0x01 PI_TDFI_RDLVL_EN:RW:8:8:=0x03 PI_RDLVL_RESP_MASK:RW:0:4:=0x00 */
+	0x00000000U, /* PI_TDFI_RDLVL_MAX:RW:0:32:=0x00000000 */
+	0x00000000U, /* PI_RDLVL_INTERVAL:RW:8:16:=0x0000 PI_RDLVL_ERROR_STATUS:RD:0:2:=0x00 */
+	0x01000000U, /* PI_RDLVL_PATTERN_NUM:RW:24:4:=0x01 PI_RDLVL_PATTERN_START:RW:16:4:=0x00 PI_RDLVL_GATE_INTERVAL:RW:0:16:=0x0000 */
+	0x00010101U, /* PI_REG_DIMM_ENABLE:RW:24:1:=0x00 PI_RD_PREAMBLE_TRAINING_EN:RW:16:1:=0x01 PI_RDLVL_GATE_STROBE_NUM:RW:8:5:=0x01 PI_RDLVL_STROBE_NUM:RW:0:5:=0x01 */
+	0x000E0E05U, /* PI_TDFI_RDDATA_EN:RD:24:7:=0x00 PI_RDLAT_ADJ_F2:RW:16:7:=0x0e PI_RDLAT_ADJ_F1:RW:8:7:=0x0e PI_RDLAT_ADJ_F0:RW:0:7:=0x05 */
+	0x000C0C02U, /* PI_TDFI_PHY_WRLAT:RD:24:7:=0x00 PI_WRLAT_ADJ_F2:RW:16:7:=0x0c PI_WRLAT_ADJ_F1:RW:8:7:=0x0c PI_WRLAT_ADJ_F0:RW:0:7:=0x02 */
+	0x02060601U, /* PI_TDFI_PHY_WRDATA:RW:24:3:=0x02 PI_TDFI_WRCSLAT_F2:RW:16:7:=0x06 PI_TDFI_WRCSLAT_F1:RW:8:7:=0x06 PI_TDFI_WRCSLAT_F0:RW:0:7:=0x01 */
+	0x00000000U, /* RESERVED:RW:24:4:=0x00 RESERVED:RW:16:1:=0x00 PI_CALVL_CS:RW:8:2:=0x00 PI_CALVL_REQ:WR:0:1:=0x00 */
+	0x00000003U, /* PI_CALVL_ROTATE:RW:24:1:=0x00 PI_CALVL_ON_SREF_EXIT:RW:16:1:=0x00 PI_CALVL_PERIODIC:RW:8:1:=0x00 PI_CALVL_SEQ_EN:RW:0:2:=0x03 */
+	0x00181701U, /* PI_TDFI_CALVL_CC_F0:RW:16:10:=0x0018 PI_TDFI_CALVL_EN:RW:8:8:=0x17 PI_CALVL_CS_MAP:RW:0:4:=0x03 */
+	0x00280006U, /* PI_TDFI_CALVL_CC_F1:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F0:RW:0:10:=0x0006 */
+	0x00280016U, /* PI_TDFI_CALVL_CC_F2:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F1:RW:0:10:=0x0016 */
+	0x00000016U, /* PI_TDFI_CALVL_CAPTURE_F2:RW:0:10:=0x0016 */
+	0x00000000U, /* PI_TDFI_CALVL_RESP:RW:0:32:=0x00000000 */
+	0x00000000U, /* PI_TDFI_CALVL_MAX:RW:0:32:=0x00000000 */
+	0x00000000U, /* PI_CALVL_ERROR_STATUS:RD:16:2:=0x00 PI_CALVL_EN:RW:8:2:=0x01 PI_CALVL_RESP_MASK:RW:0:1:=0x00 */
+	0x140A0000U, /* PI_TCAMRD:RW:24:6:=0x14 PI_TCACKEL:RW:16:5:=0x0a PI_CALVL_INTERVAL:RW:0:16:=0x0000 */
+	0x00FF010AU, /* PI_TCAENT_F0:RW:16:14:=0x0005 PI_TMRZ_F0:RW:8:5:=0x01 PI_TCACKEH:RW:0:5:=0x0a */
+	0x03018D03U, /* PI_TMRZ_F2:RW:24:5:=0x03 PI_TCAENT_F1:RW:8:14:=0x018d PI_TMRZ_F1:RW:0:5:=0x03 */
+	0x000A018DU, /* PI_CA_TRAIN_VREF_EN:RW:24:1:=0x01 PI_TCAEXT:RW:16:5:=0x0a PI_TCAENT_F2:RW:0:14:=0x018d */
+	0x00060100U, /* PI_TVREF_SHORT_F0:RW:16:10:=0x0006 PI_TDFI_CASEL_F0:RW:8:5:=0x01 PI_TDFI_CACSCA_F0:RW:0:5:=0x00 */
+	0x01000006U, /* PI_TDFI_CASEL_F1:RW:24:5:=0x01 PI_TDFI_CACSCA_F1:RW:16:5:=0x00 PI_TVREF_LONG_F0:RW:0:10:=0x0006 */
+	0x018E018EU, /* PI_TVREF_LONG_F1:RW:16:10:=0x018e PI_TVREF_SHORT_F1:RW:0:10:=0x018e */
+	0x018E0100U, /* PI_TVREF_SHORT_F2:RW:16:10:=0x018e PI_TDFI_CASEL_F2:RW:8:5:=0x01 PI_TDFI_CACSCA_F2:RW:0:5:=0x00 */
+	0x0F0F018EU, /* PI_CALVL_VREF_INITIAL_STOP_POINT:RW:24:7:=0x1e PI_CALVL_VREF_INITIAL_START_POINT:RW:16:7:=0x1a PI_TVREF_LONG_F2:RW:0:10:=0x018e */
+	0x10010204U, /* PI_TDFI_INIT_START_MIN:RW:24:8:=0x10 PI_CALVL_VREF_DELTA:RW:16:4:=0x01 PI_CALVL_VREF_NORMAL_STEPSIZE:RW:8:4:=0x02 PI_CALVL_VREF_INITIAL_STEPSIZE:RW:0:4:=0x04 */
+	0x09090605U, /* PI_TDFI_CALVL_STROBE_F2:RW:24:4:=0x09 PI_TDFI_CALVL_STROBE_F1:RW:16:4:=0x09 PI_TDFI_CALVL_STROBE_F0:RW:8:4:=0x06 PI_TDFI_INIT_COMPLETE_MIN:RW:0:8:=0x05 */
+	0x20000202U, /* PI_TDFI_INIT_START_F0:RW:24:8:=0x20 PI_SW_CA_TRAIN_VREF:RW:16:7:=0x00 PI_CALVL_STROBE_NUM:RW:8:5:=0x02 PI_TCKCKEH:RW:0:4:=0x02 */
+	0x00201000U, /* PI_TDFI_INIT_START_F1:RW:16:8:=0x20 PI_TDFI_INIT_COMPLETE_F0:RW:0:16:=0x1000 */
+	0x00201000U, /* PI_TDFI_INIT_START_F2:RW:16:8:=0x20 PI_TDFI_INIT_COMPLETE_F1:RW:0:16:=0x1000 */
+	0x04041000U, /* PI_INIT_STARTORCOMPLETE_2_CLKDISABLE:RW:24:8:=0x04 PI_CLKDISABLE_2_INIT_START:RW:16:8:=0x04 PI_TDFI_INIT_COMPLETE_F2:RW:0:16:=0x1000 */
+	0x18020100U, /* PI_TCKEHDQS_F1:RW:24:6:=0x18 PI_TCKEHDQS_F0:RW:16:6:=0x02 PI_REFRESH_BETWEEN_SEGMENT_DISABLE:RW_D:8:1:=0x01 PI_DRAM_CLK_DISABLE_DEASSERT_SEL:RW:0:1:=0x00 */
+	0x00010118U, /* PI_WDQLVL_BST_NUM:RW:16:3:=0x01 PI_WDQLVL_VREF_EN:RW:8:1:=0x01 PI_TCKEHDQS_F2:RW:0:6:=0x18 */
+	0x004B004AU, /* PI_TDFI_WDQLVL_RW:RW:16:10:=0x004b PI_TDFI_WDQLVL_WR:RW:0:10:=0x004a */
+	0x0F050000U, /* PI_WDQLVL_VREF_INITIAL_START_POINT:RW:24:7:=0x1a PI_WDQLVL_CS_MAP:RW:16:4:=0x01 PI_WDQLVL_ROTATE:RW:8:1:=0x00 PI_WDQLVL_RESP_MASK:RW:0:4:=0x00 */
+	0x0102040FU, /* PI_WDQLVL_VREF_DELTA:RW:24:4:=0x01 PI_WDQLVL_VREF_NORMAL_STEPSIZE:RW:16:5:=0x02 PI_WDQLVL_VREF_INITIAL_STEPSIZE:RW:8:5:=0x04 PI_WDQLVL_VREF_INITIAL_STOP_POINT:RW:0:7:=0x1e */
+	0x34000000U, /* PI_TDFI_WDQLVL_EN:RW:24:8:=0x34 PI_WDQLVL_CS:RW:16:2:=0x00 PI_WDQLVL_REQ:WR:8:1:=0x00 PI_WDQLVL_PERIODIC:RW:0:1:=0x00 */
+	0x00000000U, /* PI_TDFI_WDQLVL_RESP:RW:0:32:=0x00000000 */
+	0x00000000U, /* PI_TDFI_WDQLVL_MAX:RW:0:32:=0x00000000 */
+	0x00010000U, /* PI_WDQLVL_ON_SREF_EXIT:RW:24:1:=0x00 PI_WDQLVL_EN:RW:16:2:=0x01 PI_WDQLVL_INTERVAL:RW:0:16:=0x0000 */
+
+	0x31000400U, /* PI_MR3_DATA_F0_0:RW+:24:8:=0x31 PI_MR2_DATA_F0_0:RW+:16:8:=0x00 PI_MR1_DATA_F0_0:RW+:8:8:=0x00 PI_WDQLVL_ERROR_STATUS:RD:0:2:=0x00 */
+	0x544D4D36U, /* PI_MR1_DATA_F1_0:RW+:24:8:=0x50 PI_MR14_DATA_F0_0:RW+:16:8:=0x4d PI_MR12_DATA_F0_0:RW+:8:8:=0x4d PI_MR11_DATA_F0_0:RW+:0:8:=0x00 */
+	0x0F36312DU, /* PI_MR12_DATA_F1_0:RW+:24:8:=0x4d PI_MR11_DATA_F1_0:RW+:16:8:=0x00 PI_MR3_DATA_F1_0:RW+:8:8:=0x31 PI_MR2_DATA_F1_0:RW+:0:8:=0x2d */
+	0x312D540FU, /* PI_MR3_DATA_F2_0:RW+:24:8:=0x31 PI_MR2_DATA_F2_0:RW+:16:8:=0x2d PI_MR1_DATA_F2_0:RW+:8:8:=0x50 PI_MR14_DATA_F1_0:RW+:0:8:=0x4d */
+	0x000F0F36U, /* PI_MR13_DATA_0:RW+:24:8:=0x00 PI_MR14_DATA_F2_0:RW+:16:8:=0x4d PI_MR12_DATA_F2_0:RW+:8:8:=0x4d PI_MR11_DATA_F2_0:RW+:0:8:=0x00 */
+	0x36310004U, /* PI_MR11_DATA_F0_1:RW+:24:8:=0x00 PI_MR3_DATA_F0_1:RW+:16:8:=0x31 PI_MR2_DATA_F0_1:RW+:8:8:=0x00 PI_MR1_DATA_F0_1:RW+:0:8:=0x00 */
+	0x2D544D4DU, /* PI_MR2_DATA_F1_1:RW+:24:8:=0x2d PI_MR1_DATA_F1_1:RW+:16:8:=0x50 PI_MR14_DATA_F0_1:RW+:8:8:=0x4d PI_MR12_DATA_F0_1:RW+:0:8:=0x4d */
+	0x0F0F3631U, /* PI_MR14_DATA_F1_1:RW+:24:8:=0x4d PI_MR12_DATA_F1_1:RW+:16:8:=0x4d PI_MR11_DATA_F1_1:RW+:8:8:=0x00 PI_MR3_DATA_F1_1:RW+:0:8:=0x31 */
+	0x36312D54U, /* PI_MR11_DATA_F2_1:RW+:24:8:=0x00 PI_MR3_DATA_F2_1:RW+:16:8:=0x31 PI_MR2_DATA_F2_1:RW+:8:8:=0x2d PI_MR1_DATA_F2_1:RW+:0:8:=0x50 */
+	0x04000F0FU, /* PI_MR1_DATA_F0_2:RW+:24:8:=0x00 PI_MR13_DATA_1:RW+:16:8:=0x00 PI_MR14_DATA_F2_1:RW+:8:8:=0x4d PI_MR12_DATA_F2_1:RW+:0:8:=0x4d */
+	0x4D363100U, /* PI_MR12_DATA_F0_2:RW+:24:8:=0x4d PI_MR11_DATA_F0_2:RW+:16:8:=0x00 PI_MR3_DATA_F0_2:RW+:8:8:=0x31 PI_MR2_DATA_F0_2:RW+:0:8:=0x00 */
+	0x312D544DU, /* PI_MR3_DATA_F1_2:RW+:24:8:=0x31 PI_MR2_DATA_F1_2:RW+:16:8:=0x2d PI_MR1_DATA_F1_2:RW+:8:8:=0x50 PI_MR14_DATA_F0_2:RW+:0:8:=0x4d */
+	0x540F0F36U, /* PI_MR1_DATA_F2_2:RW+:24:8:=0x50 PI_MR14_DATA_F1_2:RW+:16:8:=0x4d PI_MR12_DATA_F1_2:RW+:8:8:=0x4d PI_MR11_DATA_F1_2:RW+:0:8:=0x00 */
+	0x0F36312DU, /* PI_MR12_DATA_F2_2:RW+:24:8:=0x4d PI_MR11_DATA_F2_2:RW+:16:8:=0x00 PI_MR3_DATA_F2_2:RW+:8:8:=0x31 PI_MR2_DATA_F2_2:RW+:0:8:=0x2d */
+	0x0004000FU, /* PI_MR2_DATA_F0_3:RW+:24:8:=0x00 PI_MR1_DATA_F0_3:RW+:16:8:=0x00 PI_MR13_DATA_2:RW+:8:8:=0x00 PI_MR14_DATA_F2_2:RW+:0:8:=0x4d */
+	0x4D4D3631U, /* PI_MR14_DATA_F0_3:RW+:24:8:=0x4d PI_MR12_DATA_F0_3:RW+:16:8:=0x4d PI_MR11_DATA_F0_3:RW+:8:8:=0x00 PI_MR3_DATA_F0_3:RW+:0:8:=0x31 */
+	0x36312D54U, /* PI_MR11_DATA_F1_3:RW+:24:8:=0x00 PI_MR3_DATA_F1_3:RW+:16:8:=0x31 PI_MR2_DATA_F1_3:RW+:8:8:=0x2d PI_MR1_DATA_F1_3:RW+:0:8:=0x50 */
+	0x2D540F0FU, /* PI_MR2_DATA_F2_3:RW+:24:8:=0x2d PI_MR1_DATA_F2_3:RW+:16:8:=0x50 PI_MR14_DATA_F1_3:RW+:8:8:=0x4d PI_MR12_DATA_F1_3:RW+:0:8:=0x4d */
+	0x0F0F3631U, /* PI_MR14_DATA_F2_3:RW+:24:8:=0x4d PI_MR12_DATA_F2_3:RW+:16:8:=0x4d PI_MR11_DATA_F2_3:RW+:8:8:=0x00 PI_MR3_DATA_F2_3:RW+:0:8:=0x31 */
+	0x00020000U, /* PI_ROW_DIFF:RW:16:3:=0x02 PI_BANK_DIFF:RW:8:2:=0x00 PI_MR13_DATA_3:RW+:0:8:=0x00 */
+	
+	0x018D0005U, /* PI_TFC_F1:RW:16:10:=0x018d PI_TFC_F0:RW:0:10:=0x0005 */
+	0x0808018DU, /* PI_TRTP_F0:RW:24:4:=0x08 PI_TCCD:RW:16:5:=0x08 PI_TFC_F2:RW:0:10:=0x018d */
+	0x04060403U, /* PI_TWR_F0:RW:24:6:=0x04 PI_TWTR_F0:RW:16:6:=0x06 PI_TRCD_F0:RW:8:8:=0x04 PI_TRP_F0:RW:0:8:=0x03 */
+	0x03000578U, /* PI_TRAS_MIN_F0:RW:24:8:=0x03 PI_TRAS_MAX_F0:RW:0:17:=0x000578 */
+	0x0A0A2001U, /* PI_TMRW_F0:RW:24:8:=0x0a PI_TMRD_F0:RW:16:6:=0x0a PI_TCCDMW_F0:RW:8:6:=0x20 PI_TDQSCK_MAX_F0:RW:0:4:=0x01 */
+	0x121D220CU, /* PI_TWTR_F1:RW:24:6:=0x12 PI_TRCD_F1:RW:16:8:=0x1d PI_TRP_F1:RW:8:8:=0x22 PI_TRTP_F1:RW:0:4:=0x0c */
+	0x01B2071FU, /* PI_TRAS_MAX_F1:RW:8:17:=0x01b207 PI_TWR_F1:RW:0:6:=0x1f */
+	0x17200643U, /* PI_TMRD_F1:RW:24:6:=0x17 PI_TCCDMW_F1:RW:16:6:=0x20 PI_TDQSCK_MAX_F1:RW:8:4:=0x06 PI_TRAS_MIN_F1:RW:0:8:=0x43 */
+	0x1D220C0AU, /* PI_TRCD_F2:RW:24:8:=0x1d PI_TRP_F2:RW:16:8:=0x22 PI_TRTP_F2:RW:8:4:=0x0c PI_TMRW_F1:RW:0:8:=0x0a */
+	0x00001F12U, /* PI_TWR_F2:RW:8:6:=0x1f PI_TWTR_F2:RW:0:6:=0x12 */
+	0x4301B207U, /* PI_TRAS_MIN_F2:RW:24:8:=0x43 PI_TRAS_MAX_F2:RW:0:17:=0x01b207 */
+	0x0A172006U, /* PI_TMRW_F2:RW:24:8:=0x0a PI_TMRD_F2:RW:16:6:=0x17 PI_TCCDMW_F2:RW:8:6:=0x20 PI_TDQSCK_MAX_F2:RW:0:4:=0x06 */
+	0x00020002U, /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U, /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U, /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U, /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U, /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00000000U, /* PI_INT_STATUS:RD:0:17:=0x000000 */
+	0x00000000U, /* PI_INT_ACK:WR:0:16:=0x0000 */
+	0x00000000U, /* PI_INT_MASK:RW:0:17:=0x000000 */
+	0x00000000U, /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U, /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U, /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U, /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U, /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U, /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U, /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U, /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U, /* PI_BIST_FAIL_ADDR:RD:0:34:=0x00000000 */
+	0x01000400U, /* PI_CTRLUPD_REQ_PER_AREF_EN:RW:24:1:=0x01 PI_LONG_COUNT_MASK:RW:16:5:=0x00 PI_BSTLEN:RW_D:8:5:=0x04 PI_BIST_FAIL_ADDR:RD:0:34:=0x00 */
+	0x00008C00U, /* PI_TDFI_CTRLUPD_MAX_F0:RW:8:16:=0x008c PI_TDFI_CTRLUPD_MIN:RD:0:4:=0x00 */
+	0x00000578U, /* PI_TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x00000578 */
+	0x0000304CU, /* PI_TDFI_CTRLUPD_MAX_F1:RW:0:16:=0x304c */
+	0x0001E2F8U, /* PI_TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x0001e2f8 */
+	0x0000304CU, /* PI_TDFI_CTRLUPD_MAX_F2:RW:0:16:=0x304c */
+	0x0001E2F8U, /* PI_TDFI_CTRLUPD_INTERVAL_F2:RW:0:32:=0x0001e2f8 */
+	0x04000001U, /* PI_ADDR_SPACE:RW:24:6:=0x08 PI_BIST_RESULT:RD:16:2:=0x00 PI_BIST_GO:WR:8:1:=0x00 PI_UPDATE_ERROR_STATUS:RD:0:7:=0x00 */
+	0x00000001U, /* PI_BIST_ADDR_CHECK:RW:8:1:=0x01 PI_BIST_DATA_CHECK:RW:0:1:=0x00 */
+	0x00000000U, /* PI_BIST_START_ADDRESS:RW:0:34:=0x00000000 */
+	0x00000000U, /* PI_BIST_START_ADDRESS:RW:0:34:=0x00 */
+	0xFFFFFFffU, /* PI_BIST_DATA_MASK:RW:0:64:=0x00000000 */
+	0xFFFFFFFFU, /* PI_BIST_DATA_MASK:RW:0:64:=0x00000000 */
+	0x00000001U, /* PI_COL_DIFF:RW:0:4:=0x01 */
+};
+
+
+static const uint32_t DDR_PHY_3200[827] =
+{
+	0x000004F0U,  /* PHY_SW_WRDQ0_SHIFT_0:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_0:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_0:RW:0:11:=0x04f0 */
+	0x00000000U,  /* PHY_SW_WRDQ4_SHIFT_0:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_0:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_0:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_0:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_SW_WRDM_SHIFT_0:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_0:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_0:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_0:RW:0:5:=0x00 */
+	0x00000100U,  /* PHY_DQ_TSEL_ENABLE_0:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_0:RW:0:4:=0x00 */
+	0x01665555U,  /* PHY_DQS_TSEL_ENABLE_0:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_0:RW:0:24:=0x665555 */
+	0x02665555U,  /* PHY_TWO_CYC_PREAMBLE_0:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_0:RW:0:24:=0x665555 */
+	0x00010F00U,  /* PHY_PER_CS_TRAINING_INDEX_0:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_0:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_0:RW:8:2:=0x0f PHY_DBI_MODE_0:RW:0:1:=0x00 */
+	0x04000100U,  /* PHY_LP4_BOOT_RPTR_UPDATE_0:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_0:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_0:RW:0:2:=0x00 */
+	0x00000133U,  /* PHY_LPBK_CONTROL_0:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_0:RW:0:10:=0x0133 */
+	0x000700C0U,  /* SC_PHY_SNAP_OBS_REGS_0:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_0:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_0:RW:0:10:=0x00c0 */
+	0x00CC0201U,  /* PHY_GATE_SMPL1_SLAVE_DELAY_0:RW:16:9:=0x00cc PHY_LPDDR_TYPE_0:RW:8:2:=0x02 PHY_LPDDR_0:RW:0:1:=0x01 */
+	0x00030066U,  /* ON_FLY_GATE_ADJUST_EN_0:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_0:RW:0:9:=0x0066 */
+	0x00000000U,  /* PHY_GATE_TRACKING_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_PST_AMBLE_0:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT9_0:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT10_0:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT11_0:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQ_ENC_OBS_SELECT_0:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_0:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_0:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_0:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_SELECT_0:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_0:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_0:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_0:RW:0:4:=0x00 */
+	0x04080000U,  /* PHY_WRLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_0:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_0:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_0:RW:0:1:=0x00 */
+	0x04080400U,  /* PHY_RDLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_0:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_0:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_0:RW:0:6:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_DATA_MASK_0:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_0:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_0:RW:0:2:=0x00 */
+	0x32103210U,  /* PHY_RDLVL_DATA_SWIZZLE_0:RW:0:32:=0x32103210 */
+	0x00C00708U,  /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_0:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_0:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_0:RW:0:6:=0x08 */
+	0x0001000CU,  /* PHY_WDQLVL_CLR_PREV_RESULTS_0:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_0:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_0:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_0:RW:0:4:=0x0c */
+	0x00000100U,  /* PHY_WDQLVL_DATADM_MASK_0:RW:0:9:=0x0100 */
+	0x55555555U,  /* PHY_USER_PATT0_0:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT1_0:RW:0:32:=0xAAAAAAAA */
+	0x55555555U,  /* PHY_USER_PATT2_0:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT3_0:RW:0:32:=0xAAAAAAAA */
+	0x00005555U,  /* PHY_USER_PATT4_0:RW:0:16:=0x5555 */
+	0x76543210U,  /* PHY_DQ_SWIZZLING_0:RW:0:32:=0x76543210 */
+	0x00000001U,  /* PHY_FIFO_PTR_OBS_0:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_0:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_0:RW:0:1:=0x01 */
+	0x00000000U,  /* PHY_LPBK_RESULT_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_0:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_0:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_0:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_0:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_0:RD:0:8:=0x00 */
+	0x00000000U,  /* PHY_WR_SHIFT_OBS_0:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_0:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_0:RD:0:7:=0x00 */
+	0x00000000U,  /* PHY_WRLVL_HARD1_DELAY_OBS_0:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_0:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_WRLVL_STATUS_OBS_0:RD:0:17:=0x000000 */
+	0x00000000U,  /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_0:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_0:RD:0:9:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_HARD0_DELAY_OBS_0:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_0:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_STATUS_OBS_0:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_0:RD:0:14:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_0:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_0:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_0:RD:0:2:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_STATUS_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_WDQLVL_DQDM_TE_DLY_OBS_0:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_0:RD:0:11:=0x0000 */
+	0x00000000U,  /* PHY_WDQLVL_STATUS_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_MODE_0:RW:0:18:=0x000000 */
+	0x00000000U,  /* PHY_DDL_TEST_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_TEST_MSTR_DLY_OBS_0:RD:0:32:=0x00000000 */
+	0x00200000U,  /* PHY_RX_CAL_SAMPLE_WAIT_0:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_0:RW:8:1:=0x00 SC_PHY_RX_CAL_START_0:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_RX_CAL_DQ1_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ3_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ5_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ7_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQS_0:RW+:16:12:=0x0000 PHY_RX_CAL_DM_0:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_OBS_0:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_0:RW+:0:12:=0x0000 */
+	0x02800280U,  /* PHY_CLK_WRDQ1_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ3_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ5_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ7_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x00000280U,  /* PHY_CLK_WRDQS_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_0:RW+:0:11:=0x0280 */
+	0x00000000U,  /* PHY_RDDQ1_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ3_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ5_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ7_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_0:RW+:0:10:=0x0000 */
+	0x00800080U,  /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_0:RW+:16:10:=0x0080 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_0:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_0:RW+:16:10:=0x0080 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_0:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_0:RW+:16:10:=0x0080 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_0:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_0:RW+:16:10:=0x0080 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_0:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_0:RW+:16:10:=0x0080 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_0:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_0:RW+:16:10:=0x0080 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_0:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_0:RW+:16:10:=0x0080 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_0:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_0:RW+:16:10:=0x0080 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_0:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_0:RW+:16:10:=0x0080 PHY_RDDQS_DM_RISE_SLAVE_DELAY_0:RW+:0:10:=0x0080 */
+	0x00020119U,  /* PHY_WRITE_PATH_LAT_ADD_0:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_0:RW+:16:4:=0x02 PHY_RDDQS_GATE_SLAVE_DELAY_0:RW+:0:10:=0x0119 */
+	0x000001D0U,  /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_0:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_0:RW+:0:10:=0x01d0 */
+	0x03000000U,  /* PHY_GTLVL_LAT_ADJ_START_0:RW+:24:4:=0x03 PHY_GTLVL_RDDQS_SLV_DLY_START_0:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_0:RW+:0:1:=0x00 */
+	0x00000200U,  /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_0:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_0:RW+:0:11:=0x0200 */
+	0x41315141U,  /* PHY_DQS_OE_TIMING_0:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_0:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_0:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_0:RW+:0:8:=0x41 */
+	0xC0013150U,  /* PHY_DQ_IE_TIMING_0:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_0:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_0:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_0:RW+:0:8:=0x50 */
+	0x070000C0U,  /* PHY_RDDATA_EN_DLY_0:RW+:24:4:=0x07 PHY_IE_MODE_0:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_0:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_0:RW+:0:8:=0xc0 */
+	0x00100006U,  /* PHY_MASTER_DELAY_START_0:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_0:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_0:RW+:0:4:=0x06 */
+	0x0C054208U,  /* PHY_WRLVL_DLY_STEP_0:RW+:24:4:=0x0c PHY_RPTR_UPDATE_0:RW+:16:4:=0x05 PHY_MASTER_DELAY_WAIT_0:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_0:RW+:0:6:=0x08 */
+	0x000F0C18U,  /* PHY_GTLVL_RESP_WAIT_CNT_0:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_0:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_0:RW+:0:5:=0x18 */
+	0x01000140U,  /* PHY_GTLVL_FINAL_STEP_0:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_0:RW+:0:10:=0x0140 */
+	0x00000C20U,  /* PHY_RDLVL_DLY_STEP_0:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_0:RW+:0:8:=0x20 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x000004F0U,  /* PHY_SW_WRDQ0_SHIFT_1:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_1:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:0:11:=0x04f0 */
+	0x00000000U,  /* PHY_SW_WRDQ4_SHIFT_1:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_1:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_1:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_1:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_SW_WRDM_SHIFT_1:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_1:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_1:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_1:RW:0:5:=0x00 */
+	0x00000100U,  /* PHY_DQ_TSEL_ENABLE_1:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_1:RW:0:4:=0x00 */
+	0x01665555U,  /* PHY_DQS_TSEL_ENABLE_1:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_1:RW:0:24:=0x665555 */
+	0x02665555U,  /* PHY_TWO_CYC_PREAMBLE_1:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_1:RW:0:24:=0x665555 */
+	0x00010F00U,  /* PHY_PER_CS_TRAINING_INDEX_1:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_1:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_1:RW:8:2:=0x0f PHY_DBI_MODE_1:RW:0:1:=0x00 */
+	0x04000100U,  /* PHY_LP4_BOOT_RPTR_UPDATE_1:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_1:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_1:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_1:RW:0:2:=0x00 */
+	0x00000133U,  /* PHY_LPBK_CONTROL_1:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_1:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_1:RW:0:10:=0x0133 */
+	0x000700C0U,  /* SC_PHY_SNAP_OBS_REGS_1:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_1:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_1:RW:0:10:=0x00c0 */
+	0x00CC0201U,  /* PHY_GATE_SMPL1_SLAVE_DELAY_1:RW:16:9:=0x00cc PHY_LPDDR_TYPE_1:RW:8:2:=0x02 PHY_LPDDR_1:RW:0:1:=0x01 */
+	0x00030066U,  /* ON_FLY_GATE_ADJUST_EN_1:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_1:RW:0:9:=0x0066 */
+	0x00000000U,  /* PHY_GATE_TRACKING_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_PST_AMBLE_1:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT9_1:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT10_1:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT11_1:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQ_ENC_OBS_SELECT_1:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_1:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_1:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_1:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_SELECT_1:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_1:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_1:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_1:RW:0:4:=0x00 */
+	0x04080000U,  /* PHY_WRLVL_UPDT_WAIT_CNT_1:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_1:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_1:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_1:RW:0:1:=0x00 */
+	0x04080400U,  /* PHY_RDLVL_UPDT_WAIT_CNT_1:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_1:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_1:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_1:RW:0:6:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_DATA_MASK_1:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_1:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_1:RW:0:2:=0x00 */
+	0x32103210U,  /* PHY_RDLVL_DATA_SWIZZLE_1:RW:0:32:=0x32103210 */
+	0x00C00708U,  /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_1:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_1:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_1:RW:0:6:=0x08 */
+	0x0001000CU,  /* PHY_WDQLVL_CLR_PREV_RESULTS_1:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_1:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_1:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_1:RW:0:4:=0x0c */
+	0x00000100U,  /* PHY_WDQLVL_DATADM_MASK_1:RW:0:9:=0x0100 */
+	0x55555555U,  /* PHY_USER_PATT0_1:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT1_1:RW:0:32:=0xAAAAAAAA */
+	0x55555555U,  /* PHY_USER_PATT2_1:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT3_1:RW:0:32:=0xAAAAAAAA */
+	0x00005555U,  /* PHY_USER_PATT4_1:RW:0:16:=0x5555 */
+	0x76543210U,  /* PHY_DQ_SWIZZLING_1:RW:0:32:=0x76543210 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_1:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_1:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_1:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LPBK_RESULT_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_1:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_1:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_1:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_1:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_1:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_1:RD:0:8:=0x00 */
+	0x00000000U,  /* PHY_WR_SHIFT_OBS_1:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_1:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_1:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_1:RD:0:7:=0x00 */
+	0x00000000U,  /* PHY_WRLVL_HARD1_DELAY_OBS_1:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_1:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_WRLVL_STATUS_OBS_1:RD:0:17:=0x000000 */
+	0x00000000U,  /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_1:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_1:RD:0:9:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_HARD0_DELAY_OBS_1:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_1:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_STATUS_OBS_1:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_1:RD:0:14:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_1:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_1:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_1:RD:0:2:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_STATUS_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_WDQLVL_DQDM_TE_DLY_OBS_1:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_1:RD:0:11:=0x0000 */
+	0x00000000U,  /* PHY_WDQLVL_STATUS_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_MODE_1:RW:0:18:=0x000000 */
+	0x00000000U,  /* PHY_DDL_TEST_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_TEST_MSTR_DLY_OBS_1:RD:0:32:=0x00000000 */
+	0x00200000U,  /* PHY_RX_CAL_SAMPLE_WAIT_1:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_1:RW:8:1:=0x00 SC_PHY_RX_CAL_START_1:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_RX_CAL_DQ1_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ3_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ5_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ7_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQS_1:RW+:16:12:=0x0000 PHY_RX_CAL_DM_1:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_OBS_1:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_1:RW+:0:12:=0x0000 */
+	0x02800280U,  /* PHY_CLK_WRDQ1_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ3_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ5_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ7_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x00000280U,  /* PHY_CLK_WRDQS_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_1:RW+:0:11:=0x0280 */
+	0x00000000U,  /* PHY_RDDQ1_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ3_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ5_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ7_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_1:RW+:0:10:=0x0000 */
+	0x00800080U,  /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_1:RW+:16:10:=0x0080 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_1:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_1:RW+:16:10:=0x0080 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_1:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_1:RW+:16:10:=0x0080 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_1:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_1:RW+:16:10:=0x0080 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_1:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_1:RW+:16:10:=0x0080 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_1:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_1:RW+:16:10:=0x0080 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_1:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_1:RW+:16:10:=0x0080 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_1:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_1:RW+:16:10:=0x0080 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_1:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_1:RW+:16:10:=0x0080 PHY_RDDQS_DM_RISE_SLAVE_DELAY_1:RW+:0:10:=0x0080 */
+	0x00020119U,  /* PHY_WRITE_PATH_LAT_ADD_1:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_1:RW+:16:4:=0x02 PHY_RDDQS_GATE_SLAVE_DELAY_1:RW+:0:10:=0x0119 */
+	0x000001D0U,  /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_1:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_1:RW+:0:10:=0x01d0 */
+	0x03000000U,  /* PHY_GTLVL_LAT_ADJ_START_1:RW+:24:4:=0x03 PHY_GTLVL_RDDQS_SLV_DLY_START_1:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_1:RW+:0:1:=0x00 */
+	0x00000200U,  /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_1:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_1:RW+:0:11:=0x0200 */
+	0x41315141U,  /* PHY_DQS_OE_TIMING_1:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_1:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_1:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_1:RW+:0:8:=0x41 */
+	0xC0013150U,  /* PHY_DQ_IE_TIMING_1:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_1:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_1:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_1:RW+:0:8:=0x50 */
+	0x070000C0U,  /* PHY_RDDATA_EN_DLY_1:RW+:24:4:=0x07 PHY_IE_MODE_1:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_1:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_1:RW+:0:8:=0xc0 */
+	0x00100006U,  /* PHY_MASTER_DELAY_START_1:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_1:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_1:RW+:0:4:=0x06 */
+	0x0C054208U,  /* PHY_WRLVL_DLY_STEP_1:RW+:24:4:=0x0c PHY_RPTR_UPDATE_1:RW+:16:4:=0x05 PHY_MASTER_DELAY_WAIT_1:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_1:RW+:0:6:=0x08 */
+	0x000F0C18U,  /* PHY_GTLVL_RESP_WAIT_CNT_1:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_1:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_1:RW+:0:5:=0x18 */
+	0x01000140U,  /* PHY_GTLVL_FINAL_STEP_1:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_1:RW+:0:10:=0x0140 */
+	0x00000C20U,  /* PHY_RDLVL_DLY_STEP_1:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_1:RW+:0:8:=0x20 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x000004F0U,  /* PHY_SW_WRDQ0_SHIFT_2:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_2:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_2:RW:0:11:=0x04f0 */
+	0x00000000U,  /* PHY_SW_WRDQ4_SHIFT_2:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_2:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_2:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_2:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_SW_WRDM_SHIFT_2:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_2:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_2:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_2:RW:0:5:=0x00 */
+	0x00000100U,  /* PHY_DQ_TSEL_ENABLE_2:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_2:RW:0:4:=0x00 */
+	0x01665555U,  /* PHY_DQS_TSEL_ENABLE_2:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_2:RW:0:24:=0x665555 */
+	0x02665555U,  /* PHY_TWO_CYC_PREAMBLE_2:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_2:RW:0:24:=0x665555 */
+	0x00010F00U,  /* PHY_PER_CS_TRAINING_INDEX_2:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_2:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_2:RW:8:2:=0x0f PHY_DBI_MODE_2:RW:0:1:=0x00 */
+	0x04000100U,  /* PHY_LP4_BOOT_RPTR_UPDATE_2:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_2:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_2:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_2:RW:0:2:=0x00 */
+	0x00000133U,  /* PHY_LPBK_CONTROL_2:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_2:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_2:RW:0:10:=0x0133 */
+	0x000700C0U,  /* SC_PHY_SNAP_OBS_REGS_2:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_2:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_2:RW:0:10:=0x00c0 */
+	0x00CC0201U,  /* PHY_GATE_SMPL1_SLAVE_DELAY_2:RW:16:9:=0x00cc PHY_LPDDR_TYPE_2:RW:8:2:=0x02 PHY_LPDDR_2:RW:0:1:=0x01 */
+	0x00030066U,  /* ON_FLY_GATE_ADJUST_EN_2:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_2:RW:0:9:=0x0066 */
+	0x00000000U,  /* PHY_GATE_TRACKING_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_PST_AMBLE_2:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT9_2:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT10_2:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT11_2:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQ_ENC_OBS_SELECT_2:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_2:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_2:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_2:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_SELECT_2:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_2:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_2:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_2:RW:0:4:=0x00 */
+	0x04080000U,  /* PHY_WRLVL_UPDT_WAIT_CNT_2:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_2:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_2:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_2:RW:0:1:=0x00 */
+	0x04080400U,  /* PHY_RDLVL_UPDT_WAIT_CNT_2:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_2:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_2:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_2:RW:0:6:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_DATA_MASK_2:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_2:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_2:RW:0:2:=0x00 */
+	0x32103210U,  /* PHY_RDLVL_DATA_SWIZZLE_2:RW:0:32:=0x32103210 */
+	0x00C00708U,  /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_2:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_2:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_2:RW:0:6:=0x08 */
+	0x0001000CU,  /* PHY_WDQLVL_CLR_PREV_RESULTS_2:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_2:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_2:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_2:RW:0:4:=0x0c */
+	0x00000100U,  /* PHY_WDQLVL_DATADM_MASK_2:RW:0:9:=0x0100 */
+	0x55555555U,  /* PHY_USER_PATT0_2:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT1_2:RW:0:32:=0xAAAAAAAA */
+	0x55555555U,  /* PHY_USER_PATT2_2:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT3_2:RW:0:32:=0xAAAAAAAA */
+	0x00005555U,  /* PHY_USER_PATT4_2:RW:0:16:=0x5555 */
+	0x76543210U,  /* PHY_DQ_SWIZZLING_2:RW:0:32:=0x76543210 */
+	0x00000001U,  /* PHY_FIFO_PTR_OBS_2:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_2:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_2:RW:0:1:=0x01 */
+	0x00000000U,  /* PHY_LPBK_RESULT_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_2:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_2:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_2:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_2:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_2:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_2:RD:0:8:=0x00 */
+	0x00000000U,  /* PHY_WR_SHIFT_OBS_2:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_2:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_2:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_2:RD:0:7:=0x00 */
+	0x00000000U,  /* PHY_WRLVL_HARD1_DELAY_OBS_2:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_2:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_WRLVL_STATUS_OBS_2:RD:0:17:=0x000000 */
+	0x00000000U,  /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_2:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_2:RD:0:9:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_HARD0_DELAY_OBS_2:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_2:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_STATUS_OBS_2:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_2:RD:0:14:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_2:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_2:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_2:RD:0:2:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_STATUS_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_WDQLVL_DQDM_TE_DLY_OBS_2:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_2:RD:0:11:=0x0000 */
+	0x00000000U,  /* PHY_WDQLVL_STATUS_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_MODE_2:RW:0:18:=0x000000 */
+	0x00000000U,  /* PHY_DDL_TEST_OBS_2:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_TEST_MSTR_DLY_OBS_2:RD:0:32:=0x00000000 */
+	0x00200000U,  /* PHY_RX_CAL_SAMPLE_WAIT_2:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_2:RW:8:1:=0x00 SC_PHY_RX_CAL_START_2:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_RX_CAL_DQ1_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ3_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ5_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ7_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQS_2:RW+:16:12:=0x0000 PHY_RX_CAL_DM_2:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_OBS_2:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_2:RW+:0:12:=0x0000 */
+	0x02800280U,  /* PHY_CLK_WRDQ1_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ3_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ5_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ7_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x00000280U,  /* PHY_CLK_WRDQS_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_2:RW+:0:11:=0x0280 */
+	0x00000000U,  /* PHY_RDDQ1_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ3_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ5_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ7_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_2:RW+:0:10:=0x0000 */
+	0x00800080U,  /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_2:RW+:16:10:=0x0080 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_2:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_2:RW+:16:10:=0x0080 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_2:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_2:RW+:16:10:=0x0080 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_2:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_2:RW+:16:10:=0x0080 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_2:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_2:RW+:16:10:=0x0080 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_2:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_2:RW+:16:10:=0x0080 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_2:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_2:RW+:16:10:=0x0080 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_2:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_2:RW+:16:10:=0x0080 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_2:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_2:RW+:16:10:=0x0080 PHY_RDDQS_DM_RISE_SLAVE_DELAY_2:RW+:0:10:=0x0080 */
+	0x00020119U,  /* PHY_WRITE_PATH_LAT_ADD_2:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_2:RW+:16:4:=0x02 PHY_RDDQS_GATE_SLAVE_DELAY_2:RW+:0:10:=0x0119 */
+	0x000001D0U,  /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_2:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_2:RW+:0:10:=0x01d0 */
+	0x03000000U,  /* PHY_GTLVL_LAT_ADJ_START_2:RW+:24:4:=0x03 PHY_GTLVL_RDDQS_SLV_DLY_START_2:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_2:RW+:0:1:=0x00 */
+	0x00000200U,  /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_2:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_2:RW+:0:11:=0x0200 */
+	0x41315141U,  /* PHY_DQS_OE_TIMING_2:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_2:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_2:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_2:RW+:0:8:=0x41 */
+	0xC0013150U,  /* PHY_DQ_IE_TIMING_2:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_2:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_2:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_2:RW+:0:8:=0x50 */
+	0x070000C0U,  /* PHY_RDDATA_EN_DLY_2:RW+:24:4:=0x07 PHY_IE_MODE_2:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_2:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_2:RW+:0:8:=0xc0 */
+	0x00100006U,  /* PHY_MASTER_DELAY_START_2:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_2:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_2:RW+:0:4:=0x06 */
+	0x0C054208U,  /* PHY_WRLVL_DLY_STEP_2:RW+:24:4:=0x0c PHY_RPTR_UPDATE_2:RW+:16:4:=0x05 PHY_MASTER_DELAY_WAIT_2:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_2:RW+:0:6:=0x08 */
+	0x000F0C18U,  /* PHY_GTLVL_RESP_WAIT_CNT_2:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_2:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_2:RW+:0:5:=0x18 */
+	0x01000140U,  /* PHY_GTLVL_FINAL_STEP_2:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_2:RW+:0:10:=0x0140 */
+	0x00000C20U,  /* PHY_RDLVL_DLY_STEP_2:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_2:RW+:0:8:=0x20 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x000004F0U,  /* PHY_SW_WRDQ0_SHIFT_3:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_3:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_3:RW:0:11:=0x04f0 */
+	0x00000000U,  /* PHY_SW_WRDQ4_SHIFT_3:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_3:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_3:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_3:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_SW_WRDM_SHIFT_3:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_3:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_3:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_3:RW:0:5:=0x00 */
+	0x00000100U,  /* PHY_DQ_TSEL_ENABLE_3:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_3:RW:0:4:=0x00 */
+	0x01665555U,  /* PHY_DQS_TSEL_ENABLE_3:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_3:RW:0:24:=0x665555 */
+	0x02665555U,  /* PHY_TWO_CYC_PREAMBLE_3:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_3:RW:0:24:=0x665555 */
+	0x00010F00U,  /* PHY_PER_CS_TRAINING_INDEX_3:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_3:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_3:RW:8:2:=0x0f PHY_DBI_MODE_3:RW:0:1:=0x00 */
+	0x04000100U,  /* PHY_LP4_BOOT_RPTR_UPDATE_3:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_3:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_3:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_3:RW:0:2:=0x00 */
+	0x00000133U,  /* PHY_LPBK_CONTROL_3:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_3:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_3:RW:0:10:=0x0133 */
+	0x000700C0U,  /* SC_PHY_SNAP_OBS_REGS_3:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_3:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_3:RW:0:10:=0x00c0 */
+	0x00CC0201U,  /* PHY_GATE_SMPL1_SLAVE_DELAY_3:RW:16:9:=0x00cc PHY_LPDDR_TYPE_3:RW:8:2:=0x02 PHY_LPDDR_3:RW:0:1:=0x01 */
+	0x00030066U,  /* ON_FLY_GATE_ADJUST_EN_3:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_3:RW:0:9:=0x0066 */
+	0x00000000U,  /* PHY_GATE_TRACKING_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_PST_AMBLE_3:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT9_3:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT10_3:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_LP4_RDLVL_PATT11_3:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQ_ENC_OBS_SELECT_3:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_3:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_3:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_3:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_SELECT_3:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_3:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_3:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_3:RW:0:4:=0x00 */
+	0x04080000U,  /* PHY_WRLVL_UPDT_WAIT_CNT_3:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_3:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_3:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_3:RW:0:1:=0x00 */
+	0x04080400U,  /* PHY_RDLVL_UPDT_WAIT_CNT_3:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_3:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_3:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_3:RW:0:6:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_DATA_MASK_3:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_3:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_3:RW:0:2:=0x00 */
+	0x32103210U,  /* PHY_RDLVL_DATA_SWIZZLE_3:RW:0:32:=0x32103210 */
+	0x00C00708U,  /* PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_3:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_3:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_3:RW:0:6:=0x08 */
+	0x0001000CU,  /* PHY_WDQLVL_CLR_PREV_RESULTS_3:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_3:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_3:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_3:RW:0:4:=0x0c */
+	0x00000100U,  /* PHY_WDQLVL_DATADM_MASK_3:RW:0:9:=0x0100 */
+	0x55555555U,  /* PHY_USER_PATT0_3:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT1_3:RW:0:32:=0xAAAAAAAA */
+	0x55555555U,  /* PHY_USER_PATT2_3:RW:0:32:=0x55555555 */
+	0xAAAAAAAAU,  /* PHY_USER_PATT3_3:RW:0:32:=0xAAAAAAAA */
+	0x00005555U,  /* PHY_USER_PATT4_3:RW:0:16:=0x5555 */
+	0x76543210U,  /* PHY_DQ_SWIZZLING_3:RW:0:32:=0x76543210 */
+	0x00000000U,  /* PHY_FIFO_PTR_OBS_3:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_3:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_3:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_LPBK_RESULT_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_3:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_3:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_3:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_3:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_3:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_3:RD:0:8:=0x00 */
+	0x00000000U,  /* PHY_WR_SHIFT_OBS_3:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_3:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_3:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_3:RD:0:7:=0x00 */
+	0x00000000U,  /* PHY_WRLVL_HARD1_DELAY_OBS_3:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_3:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_WRLVL_STATUS_OBS_3:RD:0:17:=0x000000 */
+	0x00000000U,  /* PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_3:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_3:RD:0:9:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_HARD0_DELAY_OBS_3:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_3:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_GTLVL_STATUS_OBS_3:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_3:RD:0:14:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_3:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_3:RD:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_3:RD:0:2:=0x00 */
+	0x00000000U,  /* PHY_RDLVL_STATUS_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_WDQLVL_DQDM_TE_DLY_OBS_3:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_3:RD:0:11:=0x0000 */
+	0x00000000U,  /* PHY_WDQLVL_STATUS_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_MODE_3:RW:0:18:=0x000000 */
+	0x00000000U,  /* PHY_DDL_TEST_OBS_3:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_TEST_MSTR_DLY_OBS_3:RD:0:32:=0x00000000 */
+	0x00200000U,  /* PHY_RX_CAL_SAMPLE_WAIT_3:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_3:RW:8:1:=0x00 SC_PHY_RX_CAL_START_3:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_RX_CAL_DQ1_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ3_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ5_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQ7_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_DQS_3:RW+:16:12:=0x0000 PHY_RX_CAL_DM_3:RW+:0:12:=0x0000 */
+	0x00000000U,  /* PHY_RX_CAL_OBS_3:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_3:RW+:0:12:=0x0000 */
+	0x02800280U,  /* PHY_CLK_WRDQ1_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ3_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ5_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x02800280U,  /* PHY_CLK_WRDQ7_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x00000280U,  /* PHY_CLK_WRDQS_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_3:RW+:0:11:=0x0280 */
+	0x00000000U,  /* PHY_RDDQ1_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ3_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ5_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00000000U,  /* PHY_RDDQ7_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_3:RW+:0:10:=0x0000 */
+	0x00800080U,  /* PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_3:RW+:16:10:=0x0080 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_3:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_3:RW+:16:10:=0x0080 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_3:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_3:RW+:16:10:=0x0080 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_3:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_3:RW+:16:10:=0x0080 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_3:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_3:RW+:16:10:=0x0080 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_3:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_3:RW+:16:10:=0x0080 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_3:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_3:RW+:16:10:=0x0080 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_3:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_3:RW+:16:10:=0x0080 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_3:RW+:0:10:=0x0080 */
+	0x00800080U,  /* PHY_RDDQS_DM_FALL_SLAVE_DELAY_3:RW+:16:10:=0x0080 PHY_RDDQS_DM_RISE_SLAVE_DELAY_3:RW+:0:10:=0x0080 */
+	0x00020119U,  /* PHY_WRITE_PATH_LAT_ADD_3:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_3:RW+:16:4:=0x02 PHY_RDDQS_GATE_SLAVE_DELAY_3:RW+:0:10:=0x0119 */
+	0x000001D0U,  /* PHY_WRLVL_DELAY_PERIOD_THRESHOLD_3:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_3:RW+:0:10:=0x01d0 */
+	0x03000000U,  /* PHY_GTLVL_LAT_ADJ_START_3:RW+:24:4:=0x03 PHY_GTLVL_RDDQS_SLV_DLY_START_3:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_3:RW+:0:1:=0x00 */
+	0x00000200U,  /* PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_3:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_3:RW+:0:11:=0x0200 */
+	0x41315141U,  /* PHY_DQS_OE_TIMING_3:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_3:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_3:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_3:RW+:0:8:=0x41 */
+	0xC0013150U,  /* PHY_DQ_IE_TIMING_3:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_3:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_3:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_3:RW+:0:8:=0x50 */
+	0x070000C0U,  /* PHY_RDDATA_EN_DLY_3:RW+:24:4:=0x07 PHY_IE_MODE_3:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_3:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_3:RW+:0:8:=0xc0 */
+	0x00100006U,  /* PHY_MASTER_DELAY_START_3:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_3:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_3:RW+:0:4:=0x06 */
+	0x0C054208U,  /* PHY_WRLVL_DLY_STEP_3:RW+:24:4:=0x0c PHY_RPTR_UPDATE_3:RW+:16:4:=0x05 PHY_MASTER_DELAY_WAIT_3:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_3:RW+:0:6:=0x08 */
+	0x000F0C18U,  /* PHY_GTLVL_RESP_WAIT_CNT_3:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_3:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_3:RW+:0:5:=0x18 */
+	0x01000140U,  /* PHY_GTLVL_FINAL_STEP_3:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_3:RW+:0:10:=0x0140 */
+	0x00000C20U,  /* PHY_RDLVL_DLY_STEP_3:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_3:RW+:0:8:=0x20 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /* PHY_ADR3_SW_WRADDR_SHIFT_0:RW+:24:5:=0x00 PHY_ADR2_SW_WRADDR_SHIFT_0:RW+:16:5:=0x00 PHY_ADR1_SW_WRADDR_SHIFT_0:RW+:8:5:=0x00 PHY_ADR0_SW_WRADDR_SHIFT_0:RW+:0:5:=0x00 */
+	0x00000000U,  /* PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_0:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_0:RW+:8:5:=0x00 PHY_ADR4_SW_WRADDR_SHIFT_0:RW+:0:5:=0x00 */
+	0x00000000U,  /* SC_PHY_ADR_MANUAL_CLEAR_0:WR:8:3:=0x00 PHY_ADR_CLK_BYPASS_OVERRIDE_0:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_ADR_LPBK_RESULT_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_SLAVE_LOOP_CNT_UPDATE_0:RW:24:3:=0x00 PHY_ADR_MASTER_DLY_LOCK_OBS_0:RD:8:10:=0x0000 PHY_ADR_MASTER_DLY_LOCK_OBS_SELECT_0:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_ADR_LPBK_CONTROL_0:RW:24:6:=0x00 PHY_ADR_TSEL_ENABLE_0:RW:16:1:=0x00 SC_PHY_ADR_SNAP_OBS_REGS_0:WR:8:1:=0x00 PHY_ADR_SLV_DLY_ENC_OBS_SELECT_0:RW:0:3:=0x00 */
+	0x00000002U,  /* PHY_ADR_IE_MODE_0:RW:16:1:=0x00 PHY_ADR_WRADDR_SHIFT_OBS_0:RD:8:3:=0x00 PHY_ADR_TYPE_0:RW:0:2:=0x02 */
+	0x00000000U,  /* PHY_ADR_DDL_MODE_0:RW:0:15:=0x0000 */
+	0x00000000U,  /* PHY_ADR_DDL_TEST_OBS_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_DDL_TEST_MSTR_DLY_OBS_0:RD:0:32:=0x00000000 */
+	0x00400320U,  /* PHY_ADR_CALVL_COARSE_DLY_0:RW:16:11:=0x0040 PHY_ADR_CALVL_START_0:RW:0:11:=0x0320 */
+	0x00000040U,  /* PHY_ADR_CALVL_QTR_0:RW:0:11:=0x0040 */
+	0x00DCBA98U,  /* PHY_ADR_CALVL_SWIZZLE0_0_0:RW:0:24:=0xdcba98 */
+	0x00000000U,  /* PHY_ADR_CALVL_SWIZZLE1_0_0:RW:0:24:=0x000000 */
+	0x00DCBA98U,  /* PHY_ADR_CALVL_SWIZZLE0_1_0:RW:0:24:=0xdcba98 */
+	0x01000000U,  /* PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000 */
+	0x00020010U,  /* PHY_ADR_CALVL_RESP_WAIT_CNT_0:RW:24:4:=0x00 PHY_ADR_CALVL_CAPTURE_CNT_0:RW:16:4:=0x02 PHY_ADR_CALVL_NUM_PATTERNS_0:RW:8:2:=0x00 PHY_ADR_CALVL_RANK_CTRL_0:RW:0:5:=0x10 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS_SELECT_0:RW:24:3:=0x00 SC_PHY_ADR_CALVL_ERROR_CLR_0:WR:16:1:=0x00 SC_PHY_ADR_CALVL_DEBUG_CONT_0:WR:8:1:=0x00 PHY_ADR_CALVL_DEBUG_MODE_0:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS0_0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS1_0:RD:0:32:=0x00000000 */
+	0x00002A01U,  /* PHY_ADR_CALVL_FG_0_0:RW:8:20:=0x00002A PHY_ADR_CALVL_RESULT_0:RW:0:1:=0x01 */
+	0x00000015U,  /* PHY_ADR_CALVL_BG_0_0:RW:0:20:=0x000015 */
+	0x00000015U,  /* PHY_ADR_CALVL_FG_1_0:RW:0:20:=0x000015 */
+	0x0000002AU,  /* PHY_ADR_CALVL_BG_1_0:RW:0:20:=0x00002a */
+	0x00000033U,  /* PHY_ADR_CALVL_FG_2_0:RW:0:20:=0x000033 */
+	0x0000000CU,  /* PHY_ADR_CALVL_BG_2_0:RW:0:20:=0x00000c */
+	0x0000000CU,  /* PHY_ADR_CALVL_FG_3_0:RW:0:20:=0x00000c */
+	0x00000033U,  /* PHY_ADR_CALVL_BG_3_0:RW:0:20:=0x000033 */
+	0x00543210U,  /* PHY_ADR_ADDR_SEL_0:RW:0:24:=0x543210 */
+	0x003F0000U,  /* PHY_ADR_SEG_MASK_0:RW:24:6:=0x00 PHY_ADR_BIT_MASK_0:RW:16:6:=0x3f PHY_ADR_LP4_BOOT_SLV_DELAY_0:RW:0:10:=0x0000 */
+	0x0000003FU,  /* PHY_ADR_CALVL_TRAIN_MASK_0:RW:0:6:=0x3f */
+	0x00030055U,  /* PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55 */
+	0x03000300U,  /* PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300 */
+	0x03000300U,  /* PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300 */
+	0x00000300U,  /* PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300 */
+	0x42080010U,  /* PHY_ADR_MASTER_DELAY_WAIT_0:RW+:24:8:=0x42 PHY_ADR_MASTER_DELAY_STEP_0:RW+:16:6:=0x08 PHY_ADR_MASTER_DELAY_START_0:RW+:0:10:=0x0010 */
+	0x00000003U,  /* PHY_ADR_CALVL_DLY_STEP_0:RW+:0:4:=0x03 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x04040404U,  /* PHY_ADR3_SW_WRADDR_SHIFT_1:RW+:24:5:=0x04 PHY_ADR2_SW_WRADDR_SHIFT_1:RW+:16:5:=0x04 PHY_ADR1_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR0_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04 */
+	0x00000404U,  /* PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR4_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04 */
+	0x00000000U,  /* SC_PHY_ADR_MANUAL_CLEAR_1:WR:8:3:=0x00 PHY_ADR_CLK_BYPASS_OVERRIDE_1:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_ADR_LPBK_RESULT_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_SLAVE_LOOP_CNT_UPDATE_1:RW:24:3:=0x00 PHY_ADR_MASTER_DLY_LOCK_OBS_1:RD:8:10:=0x0000 PHY_ADR_MASTER_DLY_LOCK_OBS_SELECT_1:RW:0:3:=0x00 */
+	0x00000000U,  /* PHY_ADR_LPBK_CONTROL_1:RW:24:6:=0x00 PHY_ADR_TSEL_ENABLE_1:RW:16:1:=0x00 SC_PHY_ADR_SNAP_OBS_REGS_1:WR:8:1:=0x00 PHY_ADR_SLV_DLY_ENC_OBS_SELECT_1:RW:0:3:=0x00 */
+	0x00000002U,  /* PHY_ADR_IE_MODE_1:RW:16:1:=0x00 PHY_ADR_WRADDR_SHIFT_OBS_1:RD:8:3:=0x00 PHY_ADR_TYPE_1:RW:0:2:=0x02 */
+	0x00000000U,  /* PHY_ADR_DDL_MODE_1:RW:0:15:=0x0000 */
+	0x00000000U,  /* PHY_ADR_DDL_TEST_OBS_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_DDL_TEST_MSTR_DLY_OBS_1:RD:0:32:=0x00000000 */
+	0x00400320U,  /* PHY_ADR_CALVL_COARSE_DLY_1:RW:16:11:=0x0040 PHY_ADR_CALVL_START_1:RW:0:11:=0x0320 */
+	0x00000040U,  /* PHY_ADR_CALVL_QTR_1:RW:0:11:=0x0040 */
+	0x00000000U,  /* PHY_ADR_CALVL_SWIZZLE0_0_1:RW:0:24:=0x000000 */
+	0x00000000U,  /* PHY_ADR_CALVL_SWIZZLE1_0_1:RW:0:24:=0x000000 */
+	0x00000000U,  /* PHY_ADR_CALVL_SWIZZLE0_1_1:RW:0:24:=0x000000 */
+	0x01000000U,  /* PHY_ADR_CALVL_DEVICE_MAP_1:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_1:RW:0:24:=0x000000 */
+	0x00020010U,  /* PHY_ADR_CALVL_RESP_WAIT_CNT_1:RW:24:4:=0x00 PHY_ADR_CALVL_CAPTURE_CNT_1:RW:16:4:=0x02 PHY_ADR_CALVL_NUM_PATTERNS_1:RW:8:2:=0x00 PHY_ADR_CALVL_RANK_CTRL_1:RW:0:5:=0x10 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS_SELECT_1:RW:24:3:=0x00 SC_PHY_ADR_CALVL_ERROR_CLR_1:WR:16:1:=0x00 SC_PHY_ADR_CALVL_DEBUG_CONT_1:WR:8:1:=0x00 PHY_ADR_CALVL_DEBUG_MODE_1:RW:0:1:=0x00 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS0_1:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_ADR_CALVL_OBS1_1:RD:0:32:=0x00000000 */
+	0x00002A01U,  /* PHY_ADR_CALVL_FG_0_1:RW:8:20:=0x00002A PHY_ADR_CALVL_RESULT_1:RW:0:1:=0x01 */
+	0x00000015U,  /* PHY_ADR_CALVL_BG_0_1:RW:0:20:=0x000015 */
+	0x00000015U,  /* PHY_ADR_CALVL_FG_1_1:RW:0:20:=0x000015 */
+	0x0000002AU,  /* PHY_ADR_CALVL_BG_1_1:RW:0:20:=0x00002a */
+	0x00000033U,  /* PHY_ADR_CALVL_FG_2_1:RW:0:20:=0x000033 */
+	0x0000000CU,  /* PHY_ADR_CALVL_BG_2_1:RW:0:20:=0x00000c */
+	0x0000000CU,  /* PHY_ADR_CALVL_FG_3_1:RW:0:20:=0x00000c */
+	0x00000033U,  /* PHY_ADR_CALVL_BG_3_1:RW:0:20:=0x000033 */
+	0x00000000U,  /* PHY_ADR_ADDR_SEL_1:RW:0:24:=0x000000 */
+	0x00000000U,  /* PHY_ADR_SEG_MASK_1:RW:24:6:=0x00 PHY_ADR_BIT_MASK_1:RW:16:6:=0x00 PHY_ADR_LP4_BOOT_SLV_DELAY_1:RW:0:10:=0x0000 */
+	0x00000000U,  /* PHY_ADR_CALVL_TRAIN_MASK_1:RW:0:6:=0x00 */
+	0x00030055U,  /* PHY_ADR0_CLK_WR_SLAVE_DELAY_1:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_1:RW+:0:8:=0x55 */
+	0x03000300U,  /* PHY_ADR2_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x03000300U,  /* PHY_ADR4_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x00000300U,  /* PHY_ADR_SW_MASTER_MODE_1:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x42080010U,  /* PHY_ADR_MASTER_DELAY_WAIT_1:RW+:24:8:=0x42 PHY_ADR_MASTER_DELAY_STEP_1:RW+:16:6:=0x08 PHY_ADR_MASTER_DELAY_START_1:RW+:0:10:=0x0010 */
+	0x00000003U,  /* PHY_ADR_CALVL_DLY_STEP_1:RW+:0:4:=0x03 */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000000U,  /*  */
+	0x00000001U,  /* PHY_SW_GRP_SHIFT_1:RW+:24:5:=0x00 PHY_SW_GRP_SHIFT_0:RW+:16:5:=0x00 PHY_FREQ_SEL_INDEX:RW:8:2:=0x00 PHY_FREQ_SEL_MULTICAST_EN:RW_D:0:1:=0x01 */
+	0x00000000U,  /* PHY_GRP_BYPASS_SLAVE_DELAY:RW:16:11:=0x0000 PHY_SW_GRP_SHIFT_3:RW+:8:5:=0x00 PHY_SW_GRP_SHIFT_2:RW+:0:5:=0x00 */
+	0x01000005U,  /* PHY_LP4_BOOT_DISABLE:RW:24:1:=0x01 SC_PHY_MANUAL_UPDATE:WR:16:1:=0x00 PHY_GRP_BYPASS_OVERRIDE:RW:8:1:=0x00 PHY_SW_GRP_BYPASS_SHIFT:RW:0:5:=0x05 */
+	0x04003101U,  /* PHY_CSLVL_START:RW:16:11:=0x0400 PHY_CSLVL_CS_MAP:RW:8:4:=0x31 PHY_CSLVL_ENABLE:RW:0:1:=0x01 */
+	0x00020040U,  /* PHY_CSLVL_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_QTR:RW:0:11:=0x0040 */
+	0x00020055U,  /* PHY_CSLVL_DEBUG_MODE:RW:24:1:=0x00 PHY_CSLVL_COARSE_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_COARSE_DLY:RW:0:11:=0x0055 */
+	0x00000000U,  /* SC_PHY_CSLVL_ERROR_CLR:WR:8:1:=0x00 SC_PHY_CSLVL_DEBUG_CONT:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_CSLVL_OBS0:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_CSLVL_OBS1:RD:0:32:=0x00000000 */
+	0x00000050U,  /* PHY_GRP_SHIFT_OBS_SELECT:RW:24:5:=0x00 PHY_GRP_SLV_DLY_ENC_OBS_SELECT:RW:8:10:=0x0000 PHY_CALVL_CS_MAP:RW:0:8:=0x50 */
+	0x00000000U,  /* PHY_ADRCTL_SLAVE_LOOP_CNT_UPDATE:RW:24:3:=0x00 PHY_GRP_SHIFT_OBS:RD:16:3:=0x00 PHY_GRP_SLV_DLY_ENC_OBS:RD:0:10:=0x0000 */
+	0x01010100U,  /* PHY_LP4_ACTIVE:RW:24:1:=0x01 PHY_ADRCTL_LPDDR:RW:16:1:=0x01 PHY_DFI_PHYUPD_TYPE:RW:8:2:=0x01 PHY_ADRCTL_SNAP_OBS_REGS:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_CONTINUOUS_CLK_CAL_UPDATE:RW:24:1:=0x00 PHY_UPDATE_CLK_CAL_VALUES:RW:16:1:=0x00 PHY_CALVL_RESULT_MASK:RW:8:2:=0x00 PHY_LPDDR3_CS:RW_D:0:1:=0x00 */
+	0x00001102U,  /* PHY_PLL_CTRL:RW+:0:13:=0x1102 */
+	0x00000000U,  /* PHY_PLL_BYPASS:RW+:0:5:=0x00 */
+	0x00010000U,  /* PHY_PAD_VREF_CTRL_DQ_0:RW+:8:14:=0x0100 PHY_LOW_FREQ_SEL:RW+:0:1:=0x00 */
+	0x01000100U,  /* PHY_PAD_VREF_CTRL_DQ_2:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_1:RW+:0:14:=0x0100 */
+	0x01000100U,  /* PHY_PAD_VREF_CTRL_AC:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_3:RW+:0:14:=0x0100 */
+	0x00030003U,  /* PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03 */
+	0x03000300U,  /* PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300 */
+	0x00000300U,  /* PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300 */
+	0x00001B02U,  /* PHY_PLL_CTRL_OVERRIDE:RW:16:16:=0x0000 PHY_LP4_BOOT_PLL_CTRL:RW:0:13:=0x1b02 */
+	0x00000064U,  /* PHY_PLL_OBS_0:RD:8:16:=0x0000 PHY_PLL_WAIT:RW:0:8:=0x64 */
+	0x00000000U,  /* PHY_PLL_OBS_2:RD:16:16:=0x0000 PHY_PLL_OBS_1:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_PLL_OBS_4:RD:16:16:=0x0000 PHY_PLL_OBS_3:RD:0:16:=0x0000 */
+	0x00010303U,  /* PHY_LP_WAKEUP:RW:24:4:=0x00 PHY_LP4_BOOT_LOW_FREQ_SEL:RW:16:1:=0x01 PHY_TCKSRE_WAIT:RW:8:4:=0x03 PHY_PLL_TESTOUT_SEL:RW:0:3:=0x03 */
+	0x00041100U,  /* PHY_PAD_FDBK_DRIVE:RW+:8:18:=0x000411 PHY_TDFI_PHY_WRDELAY:RW:0:1:=0x00 */
+	0x00400040U,  /* PHY_PAD_DQS_DRIVE:RW+:16:12:=0x0040 PHY_PAD_DATA_DRIVE:RW+:0:10:=0x0040 */
+	0x00000411U,  /* PHY_PAD_ADDR_DRIVE:RW+:0:18:=0x000411 */
+	0x00000411U,  /* PHY_PAD_CLK_DRIVE:RW+:0:20:=0x000411 */
+	0x00004410U,  /* PHY_PAD_FDBK_TERM:RW+:0:18:=0x004410 */
+	0x00004410U,  /* PHY_PAD_DATA_TERM:RW+:0:17:=0x004410 */
+	0x00004410U,  /* PHY_PAD_DQS_TERM:RW+:0:17:=0x004410 */
+	0x00004410U,  /* PHY_PAD_ADDR_TERM:RW+:0:18:=0x004410 */
+	0x00004410U,  /* PHY_PAD_CLK_TERM:RW+:0:18:=0x004410 */
+	0x00000411U,  /* PHY_PAD_CKE_DRIVE:RW+:0:18:=0x000411 */
+	0x00004410U,  /* PHY_PAD_CKE_TERM:RW+:0:18:=0x004410 */
+	0x00000411U,  /* PHY_PAD_RST_DRIVE:RW+:0:18:=0x000411 */
+	0x00004410U,  /* PHY_PAD_RST_TERM:RW+:0:18:=0x004410 */
+	0x00000411U,  /* PHY_PAD_CS_DRIVE:RW+:0:18:=0x000411 */
+	0x00004410U,  /* PHY_PAD_CS_TERM:RW+:0:18:=0x004410 */
+	0x00000000U,  /* PHY_ADRCTL_RX_CAL:RW:0:25:=0x00000000 */
+	0x00000000U,  /* PHY_ADRCTL_LP3_RX_CAL:RW:0:25:=0x00000000 */
+	0x00000000U,  /* PHY_TST_CLK_PAD_CTRL:RW:0:32:=0x00000000 */
+	0x64000000U,  /* PHY_CAL_MODE_0:RW:24:8:=0x64 PHY_TST_CLK_PAD_CTRL2:RW:0:23:=0x000000 */
+	0x00000000U,  /* PHY_CAL_START_0:WR:8:1:=0x00 PHY_CAL_CLEAR_0:WR:0:1:=0x00 */
+	0x00000000U,  /* PHY_CAL_INTERVAL_COUNT_0:RW:0:32:=0x00000000 */
+	0x00000108U,  /* PHY_CAL_CLK_SELECT_0:RW:8:3:=0x01 PHY_CAL_SAMPLE_WAIT_0:RW:0:8:=0x08 */
+	0x00000000U,  /* PHY_CAL_RESULT_OBS_0:RD:0:24:=0x000000 */
+	0x00000000U,  /* PHY_CAL_RESULT2_OBS_0:RD:0:24:=0x000000 */
+	0x00000000U,  /* PHY_AC_LPBK_ERR_CLEAR:WR:24:1:=0x00 PHY_ADRCTL_MANUAL_UPDATE:WR:16:1:=0x00 PHY_PAD_ATB_CTRL:RW:0:16:=0x0000 */
+	0x00000000U,  /* PHY_AC_LPBK_OBS_SELECT:RW:0:5:=0x00 */
+	0x00000000U,  /* PHY_AC_LPBK_ENABLE:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_AC_LPBK_CONTROL:RW:0:9:=0x0000 */
+	0x00000000U,  /* PHY_AC_LPBK_RESULT_OBS:RD:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_AC_CLK_LPBK_CONTROL:RW:24:6:=0x00 PHY_AC_CLK_LPBK_ENABLE:RW:8:16:=0x0000 PHY_AC_CLK_LPBK_OBS_SELECT:RW:0:4:=0x00 */
+	0x00000000U,  /* PHY_AC_CLK_LPBK_RESULT_OBS:RD:0:16:=0x0000 */
+	0x00000000U,  /* PHY_DDL_AC_ENABLE:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PHY_DDL_AC_MODE:RW:0:11:=0x0000 */
+};
+
+static const uint32_t DDR_PI_3200[181] =
+{
+	0x00000B00U,  /* PI_VERSION:RD:16:16:=0x0000 PI_DRAM_CLASS:RW:8:4:=0x0b PI_START:RW:0:1:=0x00 */
+	0x00000100U,  /* PI_TCMD_GAP:RW:16:16:=0x0000 PI_INIT_LVL_EN:RW:8:1:=0x01 PI_NORMAL_LVL_SEQ:RW:0:1:=0x00 */
+	0x00000118U,  /* PI_TDFI_PHYMSTR_MAX_F0:RW:0:32:=0x00000118 */
+	0x0000008CU,  /* PI_TDFI_PHYMSTR_RESP_F0:RW:0:16:=0x008c */
+	0x00001840U,  /* PI_TDFI_PHYMSTR_MAX_F1:RW:0:32:=0x00001840 */
+	0x00000C20U,  /* PI_TDFI_PHYMSTR_RESP_F1:RW:0:16:=0x0c20 */
+	0x000030A0U,  /* PI_TDFI_PHYMSTR_MAX_F2:RW:0:32:=0x000030a0 */
+	0x008C1850U,  /* PI_TDFI_PHYUPD_RESP_F0:RW:16:16:=0x008c PI_TDFI_PHYMSTR_RESP_F2:RW:0:16:=0x1850 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE0_F0:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE1_F0:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE2_F0:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE3_F0:RW:0:32:=0x00000200 */
+	0x00000C20U,  /* PI_TDFI_PHYUPD_RESP_F1:RW:0:16:=0x0c20 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE0_F1:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE1_F1:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE2_F1:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE3_F1:RW:0:32:=0x00000200 */
+	0x00001850U,  /* PI_TDFI_PHYUPD_RESP_F2:RW:0:16:=0x1850 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE0_F2:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE1_F2:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE2_F2:RW:0:32:=0x00000200 */
+	0x00000200U,  /* PI_TDFI_PHYUPD_TYPE3_F2:RW:0:32:=0x00000200 */
+	0x00010000U,  /* PI_EXIT_AFTER_INIT_CALVL:RW_D:16:1:=0x01 PI_CONTROL_ERROR_STATUS:RD:0:9:=0x0000 */
+	0x00000007U,  /* PI_FREQ_MAP:RW:0:32:=0x00000007 */
+	0x01000001U,  /* PI_POWER_ON_SEQ_END_ARRAY:RW:24:8:=0x01 PI_POWER_ON_SEQ_BYPASS_ARRAY:RW:16:8:=0x00 PI_INIT_DFS_CALVL_ONLY:RW:8:1:=0x00 PI_INIT_WORK_FREQ:RW:0:5:=0x01 */
+	0x00000000U,  /* PI_SEQ1_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ1_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ2_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ2_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ3_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ3_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ4_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ4_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ5_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ5_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ6_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ6_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ7_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ7_PAT_MASK:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ8_PAT:RW:0:28:=0x00000000 */
+	0x00000000U,  /* PI_SEQ8_PAT_MASK:RW:0:28:=0x00000000 */
+	0x0F000101U,  /* PI_CS_MAP:RW:24:4:=0x0f RESERVED:RW:16:1:=0x00 PI_SW_RST_N:RW_D:8:1:=0x01 PI_WDT_DISABLE:RW_D:0:1:=0x01 */
+	0x08342D25U,  /* PI_TMRR:RW:24:4:=0x08 PI_TDELAY_RDWR_2_BUS_IDLE_F2:RW:16:8:=0x34 PI_TDELAY_RDWR_2_BUS_IDLE_F1:RW:8:8:=0x2d PI_TDELAY_RDWR_2_BUS_IDLE_F0:RW:0:8:=0x25 */
+	0x14060C04U,  /* PI_CASLAT_LIN_F1:RW:24:7:=0x14 PI_WRLAT_F1:RW:16:6:=0x06 PI_CASLAT_LIN_F0:RW:8:7:=0x0c PI_WRLAT_F0:RW:0:6:=0x04 */
+	0x00021C08U,  /* PI_AREFRESH:WR:24:1:=0x00 PI_PREAMBLE_SUPPORT:RW:16:2:=0x02 PI_CASLAT_LIN_F2:RW:8:7:=0x1c PI_WRLAT_F2:RW:0:6:=0x08 */
+	0x00460003U,  /* PI_TREF_F0:RW:16:16:=0x0046 PI_TRFC_F0:RW:0:10:=0x0003 */
+	0x06100034U,  /* PI_TREF_F1:RW:16:16:=0x0610 PI_TRFC_F1:RW:0:10:=0x0034 */
+	0x0C280068U,  /* PI_TREF_F2:RW:16:16:=0x0c28 PI_TRFC_F2:RW:0:10:=0x0068 */
+	0x00000005U,  /* PI_SWLVL_OP_DONE:RD:24:1:=0x00 PI_SWLVL_LOAD:WR:16:1:=0x00 PI_TREF_INTERVAL:RW:0:16:=0x0005 */
+	0x00000000U,  /* PI_SW_WRLVL_RESP_3:RD:24:1:=0x00 PI_SW_WRLVL_RESP_2:RD:16:1:=0x00 PI_SW_WRLVL_RESP_1:RD:8:1:=0x00 PI_SW_WRLVL_RESP_0:RD:0:1:=0x00 */
+	0x00000000U,  /* PI_SW_RDLVL_RESP_3:RD:24:2:=0x00 PI_SW_RDLVL_RESP_2:RD:16:2:=0x00 PI_SW_RDLVL_RESP_1:RD:8:2:=0x00 PI_SW_RDLVL_RESP_0:RD:0:2:=0x00 */
+	0x00000000U,  /* PI_SWLVL_EXIT:WR:24:1:=0x00 PI_SWLVL_START:WR:16:1:=0x00 PI_SW_LEVELING_MODE:RW:8:3:=0x00 PI_SW_CALVL_RESP_0:RD:0:2:=0x00 */
+	0x00000000U,  /* PI_SWLVL_WR_SLICE_1:WR:24:1:=0x00 PI_SW_WDQLVL_RESP_0:RD:16:2:=0x00 PI_SWLVL_RD_SLICE_0:WR:8:1:=0x00 PI_SWLVL_WR_SLICE_0:WR:0:1:=0x00 */
+	0x00000000U,  /* PI_SWLVL_RD_SLICE_2:WR:24:1:=0x00 PI_SWLVL_WR_SLICE_2:WR:16:1:=0x00 PI_SW_WDQLVL_RESP_1:RD:8:2:=0x00 PI_SWLVL_RD_SLICE_1:WR:0:1:=0x00 */
+	0x00000000U,  /* PI_SW_WDQLVL_RESP_3:RD:24:2:=0x00 PI_SWLVL_RD_SLICE_3:WR:16:1:=0x00 PI_SWLVL_WR_SLICE_3:WR:8:1:=0x00 PI_SW_WDQLVL_RESP_2:RD:0:2:=0x00 */
+	0x00000000U,  /* PI_SWLVL_SM2_RD:WR:24:1:=0x00 PI_SWLVL_SM2_WR:WR:16:1:=0x00 PI_SWLVL_SM2_START:WR:8:1:=0x00 PI_SW_WDQLVL_VREF:RW:0:7:=0x00 */
+	0x01000000U,  /* PI_16BIT_DRAM_CONNECT:RW_D:24:1:=0x01 PI_SRE_PERIOD_EN:RW:16:1:=0x00 PI_DFS_PERIOD_EN:RW:8:1:=0x00 PI_SEQUENTIAL_LVL_REQ:WR:0:1:=0x00 */
+	0x00040404U,  /* PI_WRLVL_REQ:WR:24:1:=0x00 PI_TDFI_CTRL_DELAY_F2:RW_D:16:4:=0x04 PI_TDFI_CTRL_DELAY_F1:RW_D:8:4:=0x04 PI_TDFI_CTRL_DELAY_F0:RW_D:0:4:=0x04 */
+	0x01280A00U,  /* PI_WRLVL_EN:RW:24:2:=0x01 PI_WLMRD:RW:16:6:=0x28 PI_WLDQSEN:RW:8:6:=0x0a PI_WRLVL_CS:RW:0:2:=0x00 */
+	0x00000000U,  /* PI_WRLVL_ON_SREF_EXIT:RW:24:1:=0x00 PI_WRLVL_PERIODIC:RW:16:1:=0x00 PI_WRLVL_INTERVAL:RW:0:16:=0x0000 */
+	0x00030000U,  /* PI_WRLVL_ERROR_STATUS:RD:24:2:=0x00 PI_WRLVL_CS_MAP:RW:16:4:=0x03 PI_WRLVL_ROTATE:RW:8:1:=0x00 PI_WRLVL_RESP_MASK:RW:0:4:=0x00 */
+	0x00001403U,  /* PI_TDFI_WRLVL_WW:RW:8:10:=0x0014 PI_TDFI_WRLVL_EN:RW:0:8:=0x03 */
+	0x00000000U,  /* PI_TDFI_WRLVL_RESP:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PI_TDFI_WRLVL_MAX:RW:0:32:=0x00000000 */
+	0x00060102U,  /* PI_TODTL_2CMD_F0:RW:24:8:=0x00 PI_WRLVL_EN_DEASSERT_2_MRR:RW:16:5:=0x06 PI_WRLVL_MRR_DQ_RETURN_HIZ:RW:8:1:=0x01 PI_WRLVL_STROBE_NUM:RW:0:5:=0x02 */
+	0x00010001U,  /* PI_TODTL_2CMD_F2:RW:24:8:=0x00 PI_ODT_EN_F1:RW:16:1:=0x01 PI_TODTL_2CMD_F1:RW:8:8:=0x00 PI_ODT_EN_F0:RW:0:1:=0x01 */
+	0x01000101U,  /* PI_ODT_RD_MAP_CS0:RW:24:4:=0x01 PI_TODTH_RD:RW:16:4:=0x00 PI_TODTH_WR:RW:8:4:=0x01 PI_ODT_EN_F2:RW:0:1:=0x01 */
+	0x04020201U,  /* PI_ODT_RD_MAP_CS2:RW:24:4:=0x04 PI_ODT_WR_MAP_CS1:RW:16:4:=0x02 PI_ODT_RD_MAP_CS1:RW:8:4:=0x02 PI_ODT_WR_MAP_CS0:RW:0:4:=0x01 */
+	0x00080804U,  /* PI_EN_ODT_ASSERT_EXCEPT_RD:RW:24:1:=0x00 PI_ODT_WR_MAP_CS3:RW:16:4:=0x08 PI_ODT_RD_MAP_CS3:RW:8:4:=0x08 PI_ODT_WR_MAP_CS2:RW:0:4:=0x04 */
+	0x00000000U,  /* PI_TODTON_MIN_F1:RW:24:4:=0x00 PI_ODTLON_F1:RW:16:4:=0x00 PI_TODTON_MIN_F0:RW:8:4:=0x00 PI_ODTLON_F0:RW:0:4:=0x00 */
+	0x04030000U,  /* PI_WR_TO_ODTH_F1:RW:24:6:=0x04 PI_WR_TO_ODTH_F0:RW:16:6:=0x03 PI_TODTON_MIN_F2:RW:8:4:=0x00 PI_ODTLON_F2:RW:0:4:=0x00 */
+	0x0A070405U,  /* PI_RD_TO_ODTH_F2:RW:24:6:=0x0a PI_RD_TO_ODTH_F1:RW:16:6:=0x07 PI_RD_TO_ODTH_F0:RW:8:6:=0x04 PI_WR_TO_ODTH_F2:RW:0:6:=0x05 */
+	0x00000000U,  /* PI_RDLVL_SEQ_EN:RW:24:4:=0x00 PI_RDLVL_CS:RW:16:2:=0x00 PI_RDLVL_GATE_REQ:WR:8:1:=0x00 PI_RDLVL_REQ:WR:0:1:=0x00 */
+	0x00000000U,  /* PI_RDLVL_GATE_PERIODIC:RW:24:1:=0x00 PI_RDLVL_ON_SREF_EXIT:RW:16:1:=0x00 PI_RDLVL_PERIODIC:RW:8:1:=0x00 PI_RDLVL_GATE_SEQ_EN:RW:0:4:=0x00 */
+	0x00000000U,  /* PI_RDLVL_GATE_ROTATE:RW:24:1:=0x00 PI_RDLVL_ROTATE:RW:16:1:=0x00 RESERVED:RW:8:1:=0x00 PI_RDLVL_GATE_ON_SREF_EXIT:RW:0:1:=0x00 */
+	0x001E0303U,  /* PI_TDFI_RDLVL_RR:RW:16:10:=0x001e PI_RDLVL_GATE_CS_MAP:RW:8:4:=0x03 PI_RDLVL_CS_MAP:RW:0:4:=0x03 */
+	0x00000000U,  /* PI_TDFI_RDLVL_RESP:RW:0:32:=0x00000000 */
+	0x01010300U,  /* PI_RDLVL_GATE_EN:RW:24:2:=0x01 PI_RDLVL_EN:RW:16:2:=0x01 PI_TDFI_RDLVL_EN:RW:8:8:=0x03 PI_RDLVL_RESP_MASK:RW:0:4:=0x00 */
+	0x00000000U,  /* PI_TDFI_RDLVL_MAX:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PI_RDLVL_INTERVAL:RW:8:16:=0x0000 PI_RDLVL_ERROR_STATUS:RD:0:2:=0x00 */
+	0x01000000U,  /* PI_RDLVL_PATTERN_NUM:RW:24:4:=0x01 PI_RDLVL_PATTERN_START:RW:16:4:=0x00 PI_RDLVL_GATE_INTERVAL:RW:0:16:=0x0000 */
+	0x00010101U,  /* PI_REG_DIMM_ENABLE:RW:24:1:=0x00 PI_RD_PREAMBLE_TRAINING_EN:RW:16:1:=0x01 PI_RDLVL_GATE_STROBE_NUM:RW:8:5:=0x01 PI_RDLVL_STROBE_NUM:RW:0:5:=0x01 */
+	0x00070705U,  /* PI_TDFI_RDDATA_EN:RD:24:7:=0x00 PI_RDLAT_ADJ_F2:RW:16:7:=0x07 PI_RDLAT_ADJ_F1:RW:8:7:=0x07 PI_RDLAT_ADJ_F0:RW:0:7:=0x05 */
+	0x00060402U,  /* PI_TDFI_PHY_WRLAT:RD:24:7:=0x00 PI_WRLAT_ADJ_F2:RW:16:7:=0x06 PI_WRLAT_ADJ_F1:RW:8:7:=0x04 PI_WRLAT_ADJ_F0:RW:0:7:=0x02 */
+	0x02000301U,  /* PI_TDFI_PHY_WRDATA:RW:24:3:=0x02 PI_TDFI_WRCSLAT_F2:RW:16:7:=0x00 PI_TDFI_WRCSLAT_F1:RW:8:7:=0x03 PI_TDFI_WRCSLAT_F0:RW:0:7:=0x01 */
+	0x00000000U,  /* RESERVED:RW:24:4:=0x00 RESERVED:RW:16:1:=0x00 PI_CALVL_CS:RW:8:2:=0x00 PI_CALVL_REQ:WR:0:1:=0x00 */
+	0x00000003U,  /* PI_CALVL_ROTATE:RW:24:1:=0x00 PI_CALVL_ON_SREF_EXIT:RW:16:1:=0x00 PI_CALVL_PERIODIC:RW:8:1:=0x00 PI_CALVL_SEQ_EN:RW:0:2:=0x03 */
+	0x0018170FU,  /* PI_TDFI_CALVL_CC_F0:RW:16:10:=0x0018 PI_TDFI_CALVL_EN:RW:8:8:=0x17 PI_CALVL_CS_MAP:RW:0:4:=0x0f */
+	0x001C0006U,  /* PI_TDFI_CALVL_CC_F1:RW:16:10:=0x001c PI_TDFI_CALVL_CAPTURE_F0:RW:0:10:=0x0006 */
+	0x0020000AU,  /* PI_TDFI_CALVL_CC_F2:RW:16:10:=0x0020 PI_TDFI_CALVL_CAPTURE_F1:RW:0:10:=0x000a */
+	0x0000000EU,  /* PI_TDFI_CALVL_CAPTURE_F2:RW:0:10:=0x000e */
+	0x00000000U,  /* PI_TDFI_CALVL_RESP:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PI_TDFI_CALVL_MAX:RW:0:32:=0x00000000 */
+	0x00000100U,  /* PI_CALVL_ERROR_STATUS:RD:16:2:=0x00 PI_CALVL_EN:RW:8:2:=0x01 PI_CALVL_RESP_MASK:RW:0:1:=0x00 */
+	0x140A0000U,  /* PI_TCAMRD:RW:24:6:=0x14 PI_TCACKEL:RW:16:5:=0x0a PI_CALVL_INTERVAL:RW:0:16:=0x0000 */
+	0x0005010AU,  /* PI_TCAENT_F0:RW:16:14:=0x0005 PI_TMRZ_F0:RW:8:5:=0x01 PI_TCACKEH:RW:0:5:=0x0a */
+	0x02006401U,  /* PI_TMRZ_F2:RW:24:5:=0x02 PI_TCAENT_F1:RW:8:14:=0x0064 PI_TMRZ_F1:RW:0:5:=0x01 */
+	0x010A00C8U,  /* PI_CA_TRAIN_VREF_EN:RW:24:1:=0x01 PI_TCAEXT:RW:16:5:=0x0a PI_TCAENT_F2:RW:0:14:=0x00c8 */
+	0x00060100U,  /* PI_TVREF_SHORT_F0:RW:16:10:=0x0006 PI_TDFI_CASEL_F0:RW:8:5:=0x01 PI_TDFI_CACSCA_F0:RW:0:5:=0x00 */
+	0x01000006U,  /* PI_TDFI_CASEL_F1:RW:24:5:=0x01 PI_TDFI_CACSCA_F1:RW:16:5:=0x00 PI_TVREF_LONG_F0:RW:0:10:=0x0006 */
+	0x00650065U,  /* PI_TVREF_LONG_F1:RW:16:10:=0x0065 PI_TVREF_SHORT_F1:RW:0:10:=0x0065 */
+	0x00C90100U,  /* PI_TVREF_SHORT_F2:RW:16:10:=0x00c9 PI_TDFI_CASEL_F2:RW:8:5:=0x01 PI_TDFI_CACSCA_F2:RW:0:5:=0x00 */
+	0x1E1A00C9U,  /* PI_CALVL_VREF_INITIAL_STOP_POINT:RW:24:7:=0x1e PI_CALVL_VREF_INITIAL_START_POINT:RW:16:7:=0x1a PI_TVREF_LONG_F2:RW:0:10:=0x00c9 */
+	0x10010204U,  /* PI_TDFI_INIT_START_MIN:RW:24:8:=0x10 PI_CALVL_VREF_DELTA:RW:16:4:=0x01 PI_CALVL_VREF_NORMAL_STEPSIZE:RW:8:4:=0x02 PI_CALVL_VREF_INITIAL_STEPSIZE:RW:0:4:=0x04 */
+	0x07060605U,  /* PI_TDFI_CALVL_STROBE_F2:RW:24:4:=0x07 PI_TDFI_CALVL_STROBE_F1:RW:16:4:=0x06 PI_TDFI_CALVL_STROBE_F0:RW:8:4:=0x06 PI_TDFI_INIT_COMPLETE_MIN:RW:0:8:=0x05 */
+	0x20000202U,  /* PI_TDFI_INIT_START_F0:RW:24:8:=0x20 PI_SW_CA_TRAIN_VREF:RW:16:7:=0x00 PI_CALVL_STROBE_NUM:RW:8:5:=0x02 PI_TCKCKEH:RW:0:4:=0x02 */
+	0x00201000U,  /* PI_TDFI_INIT_START_F1:RW:16:8:=0x20 PI_TDFI_INIT_COMPLETE_F0:RW:0:16:=0x1000 */
+	0x00201000U,  /* PI_TDFI_INIT_START_F2:RW:16:8:=0x20 PI_TDFI_INIT_COMPLETE_F1:RW:0:16:=0x1000 */
+	0x04041000U,  /* PI_INIT_STARTORCOMPLETE_2_CLKDISABLE:RW:24:8:=0x04 PI_CLKDISABLE_2_INIT_START:RW:16:8:=0x04 PI_TDFI_INIT_COMPLETE_F2:RW:0:16:=0x1000 */
+	0x0C020100U,  /* PI_TCKEHDQS_F1:RW:24:6:=0x0c PI_TCKEHDQS_F0:RW:16:6:=0x02 PI_REFRESH_BETWEEN_SEGMENT_DISABLE:RW_D:8:1:=0x01 PI_DRAM_CLK_DISABLE_DEASSERT_SEL:RW:0:1:=0x00 */
+	0x00010110U,  /* PI_WDQLVL_BST_NUM:RW:16:3:=0x01 PI_WDQLVL_VREF_EN:RW:8:1:=0x01 PI_TCKEHDQS_F2:RW:0:6:=0x10 */
+	0x004B004AU,  /* PI_TDFI_WDQLVL_RW:RW:16:10:=0x004b PI_TDFI_WDQLVL_WR:RW:0:10:=0x004a */
+	0x1A0F0000U,  /* PI_WDQLVL_VREF_INITIAL_START_POINT:RW:24:7:=0x1a PI_WDQLVL_CS_MAP:RW:16:4:=0x0f PI_WDQLVL_ROTATE:RW:8:1:=0x00 PI_WDQLVL_RESP_MASK:RW:0:4:=0x00 */
+	0x0102041EU,  /* PI_WDQLVL_VREF_DELTA:RW:24:4:=0x01 PI_WDQLVL_VREF_NORMAL_STEPSIZE:RW:16:5:=0x02 PI_WDQLVL_VREF_INITIAL_STEPSIZE:RW:8:5:=0x04 PI_WDQLVL_VREF_INITIAL_STOP_POINT:RW:0:7:=0x1e */
+	0x34000000U,  /* PI_TDFI_WDQLVL_EN:RW:24:8:=0x34 PI_WDQLVL_CS:RW:16:2:=0x00 PI_WDQLVL_REQ:WR:8:1:=0x00 PI_WDQLVL_PERIODIC:RW:0:1:=0x00 */
+	0x00000000U,  /* PI_TDFI_WDQLVL_RESP:RW:0:32:=0x00000000 */
+	0x00000000U,  /* PI_TDFI_WDQLVL_MAX:RW:0:32:=0x00000000 */
+	0x00010000U,  /* PI_WDQLVL_ON_SREF_EXIT:RW:24:1:=0x00 PI_WDQLVL_EN:RW:16:2:=0x01 PI_WDQLVL_INTERVAL:RW:0:16:=0x0000 */
+	0x31000000U,  /* PI_MR3_DATA_F0_0:RW+:24:8:=0x31 PI_MR2_DATA_F0_0:RW+:16:8:=0x00 PI_MR1_DATA_F0_0:RW+:8:8:=0x00 PI_WDQLVL_ERROR_STATUS:RD:0:2:=0x00 */
+	0x104D4D00U,  /* PI_MR1_DATA_F1_0:RW+:24:8:=0x10 PI_MR14_DATA_F0_0:RW+:16:8:=0x4d PI_MR12_DATA_F0_0:RW+:8:8:=0x4d PI_MR11_DATA_F0_0:RW+:0:8:=0x00 */
+	0x4D003109U,  /* PI_MR12_DATA_F1_0:RW+:24:8:=0x4d PI_MR11_DATA_F1_0:RW+:16:8:=0x00 PI_MR3_DATA_F1_0:RW+:8:8:=0x31 PI_MR2_DATA_F1_0:RW+:0:8:=0x09 */
+	0x3112204DU,  /* PI_MR3_DATA_F2_0:RW+:24:8:=0x31 PI_MR2_DATA_F2_0:RW+:16:8:=0x12 PI_MR1_DATA_F2_0:RW+:8:8:=0x20 PI_MR14_DATA_F1_0:RW+:0:8:=0x4d */
+	0x004D4D00U,  /* PI_MR13_DATA_0:RW+:24:8:=0x00 PI_MR14_DATA_F2_0:RW+:16:8:=0x4d PI_MR12_DATA_F2_0:RW+:8:8:=0x4d PI_MR11_DATA_F2_0:RW+:0:8:=0x00 */
+	0x00310000U,  /* PI_MR11_DATA_F0_1:RW+:24:8:=0x00 PI_MR3_DATA_F0_1:RW+:16:8:=0x31 PI_MR2_DATA_F0_1:RW+:8:8:=0x00 PI_MR1_DATA_F0_1:RW+:0:8:=0x00 */
+	0x09104D4DU,  /* PI_MR2_DATA_F1_1:RW+:24:8:=0x09 PI_MR1_DATA_F1_1:RW+:16:8:=0x10 PI_MR14_DATA_F0_1:RW+:8:8:=0x4d PI_MR12_DATA_F0_1:RW+:0:8:=0x4d */
+	0x4D4D0031U,  /* PI_MR14_DATA_F1_1:RW+:24:8:=0x4d PI_MR12_DATA_F1_1:RW+:16:8:=0x4d PI_MR11_DATA_F1_1:RW+:8:8:=0x00 PI_MR3_DATA_F1_1:RW+:0:8:=0x31 */
+	0x00311220U,  /* PI_MR11_DATA_F2_1:RW+:24:8:=0x00 PI_MR3_DATA_F2_1:RW+:16:8:=0x31 PI_MR2_DATA_F2_1:RW+:8:8:=0x12 PI_MR1_DATA_F2_1:RW+:0:8:=0x20 */
+	0x00004D4DU,  /* PI_MR1_DATA_F0_2:RW+:24:8:=0x00 PI_MR13_DATA_1:RW+:16:8:=0x00 PI_MR14_DATA_F2_1:RW+:8:8:=0x4d PI_MR12_DATA_F2_1:RW+:0:8:=0x4d */
+	0x4D003100U,  /* PI_MR12_DATA_F0_2:RW+:24:8:=0x4d PI_MR11_DATA_F0_2:RW+:16:8:=0x00 PI_MR3_DATA_F0_2:RW+:8:8:=0x31 PI_MR2_DATA_F0_2:RW+:0:8:=0x00 */
+	0x3109104DU,  /* PI_MR3_DATA_F1_2:RW+:24:8:=0x31 PI_MR2_DATA_F1_2:RW+:16:8:=0x09 PI_MR1_DATA_F1_2:RW+:8:8:=0x10 PI_MR14_DATA_F0_2:RW+:0:8:=0x4d */
+	0x204D4D00U,  /* PI_MR1_DATA_F2_2:RW+:24:8:=0x20 PI_MR14_DATA_F1_2:RW+:16:8:=0x4d PI_MR12_DATA_F1_2:RW+:8:8:=0x4d PI_MR11_DATA_F1_2:RW+:0:8:=0x00 */
+	0x4D003112U,  /* PI_MR12_DATA_F2_2:RW+:24:8:=0x4d PI_MR11_DATA_F2_2:RW+:16:8:=0x00 PI_MR3_DATA_F2_2:RW+:8:8:=0x31 PI_MR2_DATA_F2_2:RW+:0:8:=0x12 */
+	0x0000004DU,  /* PI_MR2_DATA_F0_3:RW+:24:8:=0x00 PI_MR1_DATA_F0_3:RW+:16:8:=0x00 PI_MR13_DATA_2:RW+:8:8:=0x00 PI_MR14_DATA_F2_2:RW+:0:8:=0x4d */
+	0x4D4D0031U,  /* PI_MR14_DATA_F0_3:RW+:24:8:=0x4d PI_MR12_DATA_F0_3:RW+:16:8:=0x4d PI_MR11_DATA_F0_3:RW+:8:8:=0x00 PI_MR3_DATA_F0_3:RW+:0:8:=0x31 */
+	0x00310910U,  /* PI_MR11_DATA_F1_3:RW+:24:8:=0x00 PI_MR3_DATA_F1_3:RW+:16:8:=0x31 PI_MR2_DATA_F1_3:RW+:8:8:=0x09 PI_MR1_DATA_F1_3:RW+:0:8:=0x10 */
+	0x12204D4DU,  /* PI_MR2_DATA_F2_3:RW+:24:8:=0x12 PI_MR1_DATA_F2_3:RW+:16:8:=0x20 PI_MR14_DATA_F1_3:RW+:8:8:=0x4d PI_MR12_DATA_F1_3:RW+:0:8:=0x4d */
+	0x4D4D0031U,  /* PI_MR14_DATA_F2_3:RW+:24:8:=0x4d PI_MR12_DATA_F2_3:RW+:16:8:=0x4d PI_MR11_DATA_F2_3:RW+:8:8:=0x00 PI_MR3_DATA_F2_3:RW+:0:8:=0x31 */
+	0x00020000U,  /* PI_ROW_DIFF:RW:16:3:=0x02 PI_BANK_DIFF:RW:8:2:=0x00 PI_MR13_DATA_3:RW+:0:8:=0x00 */
+	0x00640005U,  /* PI_TFC_F1:RW:16:10:=0x0064 PI_TFC_F0:RW:0:10:=0x0005 */
+	0x080800C8U,  /* PI_TRTP_F0:RW:24:4:=0x08 PI_TCCD:RW:16:5:=0x08 PI_TFC_F2:RW:0:10:=0x00c8 */
+	0x04060403U,  /* PI_TWR_F0:RW:24:6:=0x04 PI_TWTR_F0:RW:16:6:=0x06 PI_TRCD_F0:RW:8:8:=0x04 PI_TRP_F0:RW:0:8:=0x03 */
+	0x03000578U,  /* PI_TRAS_MIN_F0:RW:24:8:=0x03 PI_TRAS_MAX_F0:RW:0:17:=0x000578 */
+	0x0A0A2001U,  /* PI_TMRW_F0:RW:24:8:=0x0a PI_TMRD_F0:RW:16:6:=0x0a PI_TCCDMW_F0:RW:8:6:=0x20 PI_TDQSCK_MAX_F0:RW:0:4:=0x01 */
+	0x06080908U,  /* PI_TWTR_F1:RW:24:6:=0x06 PI_TRCD_F1:RW:16:8:=0x08 PI_TRP_F1:RW:8:8:=0x09 PI_TRTP_F1:RW:0:4:=0x08 */
+	0x006D600AU,  /* PI_TRAS_MAX_F1:RW:8:17:=0x006d60 PI_TWR_F1:RW:0:6:=0x0a */
+	0x0A200211U,  /* PI_TMRD_F1:RW:24:6:=0x0a PI_TCCDMW_F1:RW:16:6:=0x20 PI_TDQSCK_MAX_F1:RW:8:4:=0x02 PI_TRAS_MIN_F1:RW:0:8:=0x11 */
+	0x0F11080AU,  /* PI_TRCD_F2:RW:24:8:=0x0f PI_TRP_F2:RW:16:8:=0x11 PI_TRTP_F2:RW:8:4:=0x08 PI_TMRW_F1:RW:0:8:=0x0a */
+	0x0000110AU,  /* PI_TWR_F2:RW:8:6:=0x11 PI_TWTR_F2:RW:0:6:=0x0a */
+	0x2200DAC0U,  /* PI_TRAS_MIN_F2:RW:24:8:=0x22 PI_TRAS_MAX_F2:RW:0:17:=0x00dac0 */
+	0x0A0C2003U,  /* PI_TMRW_F2:RW:24:8:=0x0a PI_TMRD_F2:RW:16:6:=0x0c PI_TCCDMW_F2:RW:8:6:=0x20 PI_TDQSCK_MAX_F2:RW:0:4:=0x03 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00020002U,  /* RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02 */
+	0x00000000U,  /* PI_INT_STATUS:RD:0:17:=0x000000 */
+	0x00000000U,  /* PI_INT_ACK:WR:0:16:=0x0000 */
+	0x00000000U,  /* PI_INT_MASK:RW:0:17:=0x000000 */
+	0x00000000U,  /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_EXP_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_DATA:RD:0:128:=0x00000000 */
+	0x00000000U,  /* PI_BIST_FAIL_ADDR:RD:0:34:=0x00000000 */
+	0x01000400U,  /* PI_CTRLUPD_REQ_PER_AREF_EN:RW:24:1:=0x01 PI_LONG_COUNT_MASK:RW:16:5:=0x00 PI_BSTLEN:RW_D:8:5:=0x04 PI_BIST_FAIL_ADDR:RD:0:34:=0x00 */
+	0x00008C00U,  /* PI_TDFI_CTRLUPD_MAX_F0:RW:8:16:=0x008c PI_TDFI_CTRLUPD_MIN:RD:0:4:=0x00 */
+	0x00000578U,  /* PI_TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x00000578 */
+	0x00000C20U,  /* PI_TDFI_CTRLUPD_MAX_F1:RW:0:16:=0x0c20 */
+	0x00007940U,  /* PI_TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x00007940 */
+	0x00001850U,  /* PI_TDFI_CTRLUPD_MAX_F2:RW:0:16:=0x1850 */
+	0x0000F320U,  /* PI_TDFI_CTRLUPD_INTERVAL_F2:RW:0:32:=0x0000f320 */
+	0x08000000U,  /* PI_ADDR_SPACE:RW:24:6:=0x08 PI_BIST_RESULT:RD:16:2:=0x00 PI_BIST_GO:WR:8:1:=0x00 PI_UPDATE_ERROR_STATUS:RD:0:7:=0x00 */
+	0x00000100U,  /* PI_BIST_ADDR_CHECK:RW:8:1:=0x01 PI_BIST_DATA_CHECK:RW:0:1:=0x00 */
+	0x00000000U,  /* PI_BIST_START_ADDRESS:RW:0:34:=0x00000000 */
+	0x00000000U,  /* PI_BIST_START_ADDRESS:RW:0:34:=0x00 */
+	0x00000000U,  /* PI_BIST_DATA_MASK:RW:0:64:=0x00000000 */
+	0x00000000U,  /* PI_BIST_DATA_MASK:RW:0:64:=0x00000000 */
+	0x00000001U,  /* PI_COL_DIFF:RW:0:4:=0x01 */
+};
+
+
+
+static const DDR_PHY_REG_T ddr_reg[] = {
+        [PHY_DQ_TSEL_SELECT_0]                      = { 0x0404U,  0U, BITW_24 },
+        [PHY_DQS_TSEL_SELECT_0]                     = { 0x0405U,  0U, BITW_24 },
+        [PHY_LP4_RDLVL_PATT8_0]                     = { 0x040EU,  0U, BITW_32 },
+        [PHY_DQ_SWIZZLING_0]                        = { 0x0420U,  0U, BITW_32 },
+        [PHY_WRLVL_HARD1_DELAY_OBS_0]               = { 0x0426U, 16U, BITW_10 },
+        [PHY_WRLVL_HARD0_DELAY_OBS_0]               = { 0x0426U,  0U, BITW_10 },
+        [PHY_CLK_WRDQ1_SLAVE_DELAY_0]               = { 0x043AU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ0_SLAVE_DELAY_0]               = { 0x043AU,  0U, BITW_11 },
+        [PHY_CLK_WRDQ3_SLAVE_DELAY_0]               = { 0x043BU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ2_SLAVE_DELAY_0]               = { 0x043BU,  0U, BITW_11 },
+        [PHY_CLK_WRDQ5_SLAVE_DELAY_0]               = { 0x043CU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ4_SLAVE_DELAY_0]               = { 0x043CU,  0U, BITW_11 },
+        [PHY_CLK_WRDQ7_SLAVE_DELAY_0]               = { 0x043DU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ6_SLAVE_DELAY_0]               = { 0x043DU,  0U, BITW_11 },
+        [PHY_CLK_WRDM_SLAVE_DELAY_0]                = { 0x043EU,  0U, BITW_11 },
+        [PHY_RDDQ1_SLAVE_DELAY_0]                   = { 0x043FU, 16U, BITW_10 },
+        [PHY_RDDQ0_SLAVE_DELAY_0]                   = { 0x043FU,  0U, BITW_10 },
+        [PHY_RDDQ3_SLAVE_DELAY_0]                   = { 0x0440U, 16U, BITW_10 },
+        [PHY_RDDQ2_SLAVE_DELAY_0]                   = { 0x0440U,  0U, BITW_10 },
+        [PHY_RDDQ5_SLAVE_DELAY_0]                   = { 0x0441U, 16U, BITW_10 },
+        [PHY_RDDQ4_SLAVE_DELAY_0]                   = { 0x0441U,  0U, BITW_10 },
+        [PHY_RDDQ7_SLAVE_DELAY_0]                   = { 0x0442U, 16U, BITW_10 },
+        [PHY_RDDQ6_SLAVE_DELAY_0]                   = { 0x0442U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_0]          = { 0x0443U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_0]          = { 0x0443U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_0]          = { 0x0444U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_0]          = { 0x0444U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_0]          = { 0x0445U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_0]          = { 0x0445U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_0]          = { 0x0446U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_0]          = { 0x0446U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_0]          = { 0x0447U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_0]          = { 0x0447U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_0]          = { 0x0448U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_0]          = { 0x0448U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_0]          = { 0x0449U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_0]          = { 0x0449U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_0]          = { 0x044AU, 16U, BITW_10 },
+        [PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_0]          = { 0x044AU,  0U, BITW_10 },
+        [PHY_RDDQS_DM_FALL_SLAVE_DELAY_0]           = { 0x044BU, 16U, BITW_10 },
+        [PHY_RDDQS_DM_RISE_SLAVE_DELAY_0]           = { 0x044BU,  0U, BITW_10 },
+        [PHY_WRITE_PATH_LAT_ADD_0]                  = { 0x044CU, 24U, BITW_03 },
+        [PHY_RDDQS_LATENCY_ADJUST_0]                = { 0x044CU, 16U, BITW_04 },
+        [PHY_RDDQS_GATE_SLAVE_DELAY_0]              = { 0x044CU,  0U, BITW_10 },
+        [PHY_DQ_TSEL_SELECT_1]                      = { 0x0484U,  0U, BITW_24 },
+        [PHY_DQS_TSEL_SELECT_1]                     = { 0x0485U,  0U, BITW_24 },
+        [PHY_LP4_RDLVL_PATT8_1]                     = { 0x048EU,  0U, BITW_32 },
+        [PHY_DQ_SWIZZLING_1]                        = { 0x04A0U,  0U, BITW_32 },
+        [PHY_WRLVL_HARD1_DELAY_OBS_1]               = { 0x04A6U, 16U, BITW_10 },
+        [PHY_WRLVL_HARD0_DELAY_OBS_1]               = { 0x04A6U,  0U, BITW_10 },
+        [PHY_CLK_WRDQ1_SLAVE_DELAY_1]               = { 0x04BAU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ0_SLAVE_DELAY_1]               = { 0x04BAU,  0U, BITW_11 },
+        [PHY_CLK_WRDQ3_SLAVE_DELAY_1]               = { 0x04BBU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ2_SLAVE_DELAY_1]               = { 0x04BBU,  0U, BITW_11 },
+        [PHY_CLK_WRDQ5_SLAVE_DELAY_1]               = { 0x04BCU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ4_SLAVE_DELAY_1]               = { 0x04BCU,  0U, BITW_11 },
+        [PHY_CLK_WRDQ7_SLAVE_DELAY_1]               = { 0x04BDU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ6_SLAVE_DELAY_1]               = { 0x04BDU,  0U, BITW_11 },
+        [PHY_CLK_WRDQS_SLAVE_DELAY_1]               = { 0x04BEU, 16U, BITW_10 },
+        [PHY_CLK_WRDM_SLAVE_DELAY_1]                = { 0x04BEU,  0U, BITW_11 },
+        [PHY_RDDQ1_SLAVE_DELAY_1]                   = { 0x04BFU, 16U, BITW_10 },
+        [PHY_RDDQ0_SLAVE_DELAY_1]                   = { 0x04BFU,  0U, BITW_10 },
+        [PHY_RDDQ3_SLAVE_DELAY_1]                   = { 0x04C0U, 16U, BITW_10 },
+        [PHY_RDDQ2_SLAVE_DELAY_1]                   = { 0x04C0U,  0U, BITW_10 },
+        [PHY_RDDQ5_SLAVE_DELAY_1]                   = { 0x04C1U, 16U, BITW_10 },
+        [PHY_RDDQ4_SLAVE_DELAY_1]                   = { 0x04C1U,  0U, BITW_10 },
+        [PHY_RDDQ7_SLAVE_DELAY_1]                   = { 0x04C2U, 16U, BITW_10 },
+        [PHY_RDDQ6_SLAVE_DELAY_1]                   = { 0x04C2U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_1]          = { 0x04C3U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_1]          = { 0x04C3U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_1]          = { 0x04C4U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_1]          = { 0x04C4U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_1]          = { 0x04C5U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_1]          = { 0x04C5U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_1]          = { 0x04C6U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_1]          = { 0x04C6U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_1]          = { 0x04C7U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_1]          = { 0x04C7U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_1]          = { 0x04C8U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_1]          = { 0x04C8U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_1]          = { 0x04C9U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_1]          = { 0x04C9U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_1]          = { 0x04CAU, 16U, BITW_10 },
+        [PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_1]          = { 0x04CAU,  0U, BITW_10 },
+        [PHY_RDDQS_DM_FALL_SLAVE_DELAY_1]           = { 0x04CBU, 16U, BITW_10 },
+        [PHY_RDDQS_DM_RISE_SLAVE_DELAY_1]           = { 0x04CBU,  0U, BITW_10 },
+        [PHY_WRITE_PATH_LAT_ADD_1]                  = { 0x04CCU, 24U, BITW_03 },
+        [PHY_RDDQS_LATENCY_ADJUST_1]                = { 0x04CCU, 16U, BITW_04 },
+        [PHY_RDDQS_GATE_SLAVE_DELAY_1]              = { 0x04CCU,  0U, BITW_10 },
+        [PHY_DQ_TSEL_SELECT_2]                      = { 0x0504U,  0U, BITW_24 },
+        [PHY_DQS_TSEL_SELECT_2]                     = { 0x0505U,  0U, BITW_24 },
+        [PHY_LP4_RDLVL_PATT8_2]                     = { 0x050EU,  0U, BITW_32 },
+        [PHY_DQ_SWIZZLING_2]                        = { 0x0520U,  0U, BITW_32 },
+        [PHY_WRLVL_HARD1_DELAY_OBS_2]               = { 0x0526U, 16U, BITW_10 },
+        [PHY_WRLVL_HARD0_DELAY_OBS_2]               = { 0x0526U,  0U, BITW_10 },
+        [PHY_CLK_WRDQ1_SLAVE_DELAY_2]               = { 0x053AU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ0_SLAVE_DELAY_2]               = { 0x053AU,  0U, BITW_11 },
+        [PHY_CLK_WRDQ3_SLAVE_DELAY_2]               = { 0x053BU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ2_SLAVE_DELAY_2]               = { 0x053BU,  0U, BITW_11 },
+        [PHY_CLK_WRDQ5_SLAVE_DELAY_2]               = { 0x053CU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ4_SLAVE_DELAY_2]               = { 0x053CU,  0U, BITW_11 },
+        [PHY_CLK_WRDQ7_SLAVE_DELAY_2]               = { 0x053DU, 16U, BITW_11 },
+        [PHY_CLK_WRDQ6_SLAVE_DELAY_2]               = { 0x053DU,  0U, BITW_11 },
+        [PHY_CLK_WRDQS_SLAVE_DELAY_2]               = { 0x053EU, 16U, BITW_10 },
+        [PHY_CLK_WRDM_SLAVE_DELAY_2]                = { 0x053EU,  0U, BITW_11 },
+        [PHY_RDDQ1_SLAVE_DELAY_2]                   = { 0x053FU, 16U, BITW_10 },
+        [PHY_RDDQ0_SLAVE_DELAY_2]                   = { 0x053FU,  0U, BITW_10 },
+        [PHY_RDDQ3_SLAVE_DELAY_2]                   = { 0x0540U, 16U, BITW_10 },
+        [PHY_RDDQ2_SLAVE_DELAY_2]                   = { 0x0540U,  0U, BITW_10 },
+        [PHY_RDDQ5_SLAVE_DELAY_2]                   = { 0x0541U, 16U, BITW_10 },
+        [PHY_RDDQ4_SLAVE_DELAY_2]                   = { 0x0541U,  0U, BITW_10 },
+        [PHY_RDDQ7_SLAVE_DELAY_2]                   = { 0x0542U, 16U, BITW_10 },
+        [PHY_RDDQ6_SLAVE_DELAY_2]                   = { 0x0542U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_2]          = { 0x0543U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_2]          = { 0x0543U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_2]          = { 0x0544U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_2]          = { 0x0544U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_2]          = { 0x0545U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_2]          = { 0x0545U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_2]          = { 0x0546U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_2]          = { 0x0546U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_2]          = { 0x0547U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_2]          = { 0x0547U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_2]          = { 0x0548U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_2]          = { 0x0548U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_2]          = { 0x0549U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_2]          = { 0x0549U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_2]          = { 0x054AU, 16U, BITW_10 },
+        [PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_2]          = { 0x054AU,  0U, BITW_10 },
+        [PHY_RDDQS_DM_FALL_SLAVE_DELAY_2]           = { 0x054BU, 16U, BITW_10 },
+        [PHY_RDDQS_DM_RISE_SLAVE_DELAY_2]           = { 0x054BU,  0U, BITW_10 },
+        [PHY_WRITE_PATH_LAT_ADD_2]                  = { 0x054CU, 24U, BITW_03 },
+        [PHY_RDDQS_LATENCY_ADJUST_2]                = { 0x054CU, 16U, BITW_04 },
+        [PHY_RDDQS_GATE_SLAVE_DELAY_2]              = { 0x054CU,  0U, BITW_10 },
+        [PHY_DQ_TSEL_SELECT_3]                      = { 0x0584U,  0U, BITW_24 },
+        [PHY_DQS_TSEL_SELECT_3]                     = { 0x0585U,  0U, BITW_24 },
+        [PHY_LP4_RDLVL_PATT8_3]                     = { 0x058EU,  0U, BITW_32 },
+        [PHY_DQ_SWIZZLING_3]                        = { 0x05A0U,  0U, BITW_32 },
+        [PHY_WRLVL_HARD1_DELAY_OBS_3]               = { 0x05A6U, 16U, BITW_10 },
+        [PHY_WRLVL_HARD0_DELAY_OBS_3]               = { 0x05A6U,  0U, BITW_10 },
+        [PHY_RDDQ1_SLAVE_DELAY_3]                   = { 0x05BFU, 16U, BITW_10 },
+        [PHY_RDDQ0_SLAVE_DELAY_3]                   = { 0x05BFU,  0U, BITW_10 },
+        [PHY_RDDQ3_SLAVE_DELAY_3]                   = { 0x05C0U, 16U, BITW_10 },
+        [PHY_RDDQ2_SLAVE_DELAY_3]                   = { 0x05C0U,  0U, BITW_10 },
+        [PHY_RDDQ5_SLAVE_DELAY_3]                   = { 0x05C1U, 16U, BITW_10 },
+        [PHY_RDDQ4_SLAVE_DELAY_3]                   = { 0x05C1U,  0U, BITW_10 },
+        [PHY_RDDQ7_SLAVE_DELAY_3]                   = { 0x05C2U, 16U, BITW_10 },
+        [PHY_RDDQ6_SLAVE_DELAY_3]                   = { 0x05C2U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_3]          = { 0x05C3U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_3]          = { 0x05C3U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_3]          = { 0x05C4U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_3]          = { 0x05C4U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_3]          = { 0x05C5U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_3]          = { 0x05C5U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_3]          = { 0x05C6U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_3]          = { 0x05C6U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_3]          = { 0x05C7U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_3]          = { 0x05C7U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_3]          = { 0x05C8U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_3]          = { 0x05C8U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_3]          = { 0x05C9U, 16U, BITW_10 },
+        [PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_3]          = { 0x05C9U,  0U, BITW_10 },
+        [PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_3]          = { 0x05CAU, 16U, BITW_10 },
+        [PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_3]          = { 0x05CAU,  0U, BITW_10 },
+        [PHY_RDDQS_DM_FALL_SLAVE_DELAY_3]           = { 0x05CBU, 16U, BITW_10 },
+        [PHY_RDDQS_DM_RISE_SLAVE_DELAY_3]           = { 0x05CBU,  0U, BITW_10 },
+        [PHY_WRITE_PATH_LAT_ADD_3]                  = { 0x05CCU, 24U, BITW_03 },
+        [PHY_RDDQS_LATENCY_ADJUST_3]                = { 0x05CCU, 16U, BITW_04 },
+        [PHY_RDDQS_GATE_SLAVE_DELAY_3]              = { 0x05CCU,  0U, BITW_10 },
+        [PHY_ADR_CALVL_SWIZZLE0_0_0]                = { 0x060CU,  0U, BITW_24 },
+        [PHY_ADR_CALVL_SWIZZLE1_0_0]                = { 0x060DU,  0U, BITW_24 },
+        [PHY_ADR_CALVL_SWIZZLE0_1_0]                = { 0x060EU,  0U, BITW_24 },
+        [PHY_ADR_CALVL_DEVICE_MAP_0]                = { 0x060FU, 24U, BITW_04 },
+        [PHY_ADR_CALVL_SWIZZLE1_1_0]                = { 0x060FU,  0U, BITW_24 },
+        [PHY_ADR_ADDR_SEL_0]                        = { 0x061CU,  0U, BITW_24 },
+        [PHY_ADR0_CLK_WR_SLAVE_DELAY_0]             = { 0x061FU,  8U, BITW_11 },
+        [PHY_ADR2_CLK_WR_SLAVE_DELAY_0]             = { 0x0620U, 16U, BITW_11 },
+        [PHY_ADR1_CLK_WR_SLAVE_DELAY_0]             = { 0x0620U,  0U, BITW_11 },
+        [PHY_ADR4_CLK_WR_SLAVE_DELAY_0]             = { 0x0621U, 16U, BITW_11 },
+        [PHY_ADR3_CLK_WR_SLAVE_DELAY_0]             = { 0x0621U,  0U, BITW_11 },
+        [PHY_ADR5_CLK_WR_SLAVE_DELAY_0]             = { 0x0622U,  0U, BITW_11 },
+        [PHY_FREQ_SEL_INDEX]                        = { 0x0700U,  8U, BITW_02 },
+        [SC_PHY_MANUAL_UPDATE]                      = { 0x0702U, 16U, BITW_01 },
+        [PHY_GRP_SLAVE_DELAY_0]                     = { 0x0712U,  8U, BITW_11 },
+        [PHY_GRP_SLAVE_DELAY_2]                     = { 0x0713U, 16U, BITW_11 },
+        [PHY_GRP_SLAVE_DELAY_1]                     = { 0x0713U,  0U, BITW_11 },
+        [PHY_GRP_SLAVE_DELAY_3]                     = { 0x0714U,  0U, BITW_11 },
+        [PHY_PAD_ADDR_DRIVE]                        = { 0x071CU,  0U, BITW_18 },
+        [PHY_PAD_CLK_DRIVE]                         = { 0x071DU,  0U, BITW_20 },
+        [PHY_PAD_FDBK_TERM]                         = { 0x071EU,  0U, BITW_18 },
+        [PHY_PAD_DATA_TERM]                         = { 0x071FU,  0U, BITW_17 },
+        [PHY_PAD_DQS_TERM]                          = { 0x0720U,  0U, BITW_17 },
+        [PHY_PAD_ADDR_TERM]                         = { 0x0721U,  0U, BITW_18 },
+        [PHY_PAD_CLK_TERM]                          = { 0x0722U,  0U, BITW_18 },
+        [PHY_PAD_CKE_DRIVE]                         = { 0x0723U,  0U, BITW_18 },
+        [PHY_PAD_CKE_TERM]                          = { 0x0724U,  0U, BITW_18 },
+        [PHY_PAD_RST_DRIVE]                         = { 0x0725U,  0U, BITW_18 },
+        [PHY_PAD_RST_TERM]                          = { 0x0726U,  0U, BITW_18 },
+        [PHY_PAD_CS_DRIVE]                          = { 0x0727U,  0U, BITW_18 },
+        [PHY_PAD_CS_TERM]                           = { 0x0728U,  0U, BITW_18 },
+        [PHY_CAL_MODE_0]                            = { 0x072CU, 24U, BITW_08 },
+        [PHY_TST_CLK_PAD_CTRL2]                     = { 0x072CU,  0U, BITW_23 },
+        [PHY_CAL_START_0]                           = { 0x072DU,  8U, BITW_01 },
+        [PHY_CAL_CLEAR_0]                           = { 0x072DU,  0U, BITW_01 },
+        [PHY_CAL_CLK_SELECT_0]                      = { 0x072FU,  8U, BITW_03 },
+        [PHY_ADRCTL_MANUAL_UPDATE]                  = { 0x0732U, 16U, BITW_01 },
+        [PI_START]                                  = { 0x0200U,  0U, BITW_01 },
+        [PI_CS_MAP]                                 = { 0x0229U, 24U, BITW_04 },
+        [PI_SW_RST_N]                               = { 0x0229U,  8U, BITW_01 },
+        [PI_WDT_DISABLE]                            = { 0x0229U,  0U, BITW_01 },
+        [PI_WRLVL_EN]                               = { 0x023AU, 24U, BITW_02 },
+        [PI_RDLVL_GATE_EN]                          = { 0x024DU, 24U, BITW_02 },
+        [PI_RDLVL_EN]                               = { 0x024DU, 16U, BITW_02 },
+        [PI_RDLVL_PATTERN_START]                    = { 0x0250U, 16U, BITW_04 },
+        [PI_CALVL_EN]                               = { 0x025DU,  8U, BITW_02 },
+        [PI_CALVL_CS_MAP]                           = { 0x0257U,  0U, BITW_04 },
+        [PI_WDQLVL_EN]                              = { 0x0275U, 16U, BITW_02 },
+        [PI_INT_STATUS]                             = { 0x029BU,  0U, BITW_17 },
+};
+
+
+uint32_t ddr_phy_reg_read(uint32_t ch, uint32_t reg)
+{
+	uint32_t data;
+
+	mmio_write_32(DBSC_DBPDRGA(ch), (uint32_t)ddr_reg[reg].reg);
+	dsb();
+	data =  mmio_read_32(DBSC_DBPDRGD(ch));
+
+	return (data >> ddr_reg[reg].lsb) & ddr_reg[reg].bit_width;
+}
+
+void ddr_phy_reg_write(uint32_t ch, uint16_t reg, uint32_t data)
+{
+	uint32_t temp;
+
+	mmio_write_32(DBSC_DBPDRGA(ch), (uint32_t)ddr_reg[reg].reg);
+	dsb();
+	temp = mmio_read_32(DBSC_DBPDRGD(ch));
+	temp &= (~(ddr_reg[reg].bit_width << ddr_reg[reg].lsb));
+	temp |= ((data & ddr_reg[reg].bit_width) << ddr_reg[reg].lsb);
+	mmio_write_32(DBSC_DBPDRGD(ch), temp);
+}
+
+uint32_t ddr_phy_reg_rawread(uint32_t ch, uint32_t reg)
+{
+	mmio_write_32(DBSC_DBPDRGA(ch), reg);
+	dsb();
+	return mmio_read_32(DBSC_DBPDRGD(ch));
+}
+
+void ddr_phy_reg_rawwrite(uint32_t ch, uint16_t reg, uint32_t data)
+{
+	mmio_write_32(DBSC_DBPDRGA(ch), reg);
+	dsb();
+	mmio_write_32(DBSC_DBPDRGD(ch), data);
+	dsb();
+}
+
+
+void bl2_phy_init(void)
+{
+	uint32_t md;
+	uint32_t i;
+	uint32_t j;
+	uint32_t init_phy_num;
+	uint32_t init_pi_num;
+	const uint32_t *init_phy_ptr;
+	const uint32_t *init_pi_ptr;
+
+	md = (mmio_read_32(RST_MODEMR));
+	if ((uint32_t)(md & MODEMR_DDR_CLOCK_MASK) == MODEMR_DDR_CLOCK_3200) {
+		init_phy_num = INIT_DRAM_TBL_PHY_3200_NUM;	/* MD19=0,MD17=0 */
+		init_pi_num = INIT_DRAM_TBL_PI_3200_NUM;
+		init_phy_ptr = &DDR_PHY_3200[0];
+		init_pi_ptr = &DDR_PI_3200[0];
+	} else {
+		init_phy_num = INIT_DRAM_TBL_PHY_1600_NUM;	/* MD19=0,MD17=0 */
+		init_pi_num = INIT_DRAM_TBL_PI_1600_NUM;
+		init_phy_ptr = &DDR_PHY_suresh[0];
+		init_pi_ptr = &DDR_PI_suresh[0];
+/*		init_phy_ptr = &DDR_PHY_1600[0];	*/
+/*		init_pi_ptr = &DDR_PI_1600[0];	*/
+	}
+
+	for (i = 0U; i < init_phy_num; i++) {
+		for (j = 0U; j < PHY_MAX_NUM; j++) {
+			mmio_write_32(DBSC_DBPDRGA(j),
+					(i + INIT_DRAM_TBL_PHY_START));
+			dsb();
+			mmio_write_32(DBSC_DBPDRGD(j), *(init_phy_ptr + i));
+		}
+	
+	}
+
+	for (i = 0U; i < init_pi_num; i++) {
+		for (j = 0U; j < PHY_MAX_NUM; j++) {
+			mmio_write_32(DBSC_DBPDRGA(j),
+					(i + INIT_DRAM_TBL_PI_START));
+			dsb();
+			mmio_write_32(DBSC_DBPDRGD(j), *(init_pi_ptr + i));
+		}
+	}
+}
diff --git a/plat/renesas/rcar/bl2_qos_init.c b/plat/renesas/rcar/bl2_qos_init.c
new file mode 100644
index 0000000..a3c3711
--- /dev/null
+++ b/plat/renesas/rcar/bl2_qos_init.c
@@ -0,0 +1,614 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <mmio.h>
+#include <bl_common.h>
+#include <debug.h>
+#include "bl2_qos_init.h"
+
+#define	RCAR_QOS_VERSION		"rev.0.24"
+
+#define	RCAR_QOS_NONE			(3U)
+#define	RCAR_QOS_TYPE_GFX		(0U)
+#define	RCAR_QOS_TYPE_HIGH_RESOLUTION	(1U)
+
+#define	RCAR_DRAM_SPLIT_LINEAR		(0U)
+#define	RCAR_DRAM_SPLIT_4CH		(1U)
+#define	RCAR_DRAM_SPLIT_2CH		(2U)
+
+#define	DBSC_BASE			(0xE6790000U)
+#define	DBSC_AXARB			(DBSC_BASE + 0x0800U)
+
+#define	AXI_BASE			(0xE6784000U)
+#define	AXI_ADSPLCR0			(AXI_BASE + 0x0008U)
+#define	AXI_ADSPLCR1			(AXI_BASE + 0x000CU)
+#define	AXI_ADSPLCR2			(AXI_BASE + 0x0010U)
+#define	AXI_ADSPLCR3			(AXI_BASE + 0x0014U)
+#define	ADSPLCR0_ADRMODE_DEFAULT	((uint32_t)0U << 31U)
+#define	ADSPLCR0_ADRMODE_GEN2		((uint32_t)1U << 31U)
+#define	ADSPLCR0_SPLITSEL(x)		((uint32_t)(x) << 16U)
+#define	ADSPLCR0_AREA(x)		((uint32_t)(x) <<  8U)
+#define	ADSPLCR0_SWP			(0x0CU)
+
+#define	MSTAT_BASE			(0xE67E0000U)
+#define	MSTAT_FIX_QOS_BANK0		(MSTAT_BASE + 0x0000U)
+#define	MSTAT_FIX_QOS_BANK1		(MSTAT_BASE + 0x1000U)
+#define	MSTAT_BE_QOS_BANK0		(MSTAT_BASE + 0x2000U)
+#define	MSTAT_BE_QOS_BANK1		(MSTAT_BASE + 0x3000U)
+#define	MSTAT_SL_INIT			(MSTAT_BASE + 0x8000U)
+#define	MSTAT_REF_ARS			(MSTAT_BASE + 0x8004U)
+#define	MSTAT_STATQC			(MSTAT_BASE + 0x8008U)
+
+#define	RALLOC_BASE			(0xE67F0000U)
+#define	RALLOC_RAS			(RALLOC_BASE + 0x0000U)
+#define	RALLOC_FIXTH			(RALLOC_BASE + 0x0004U)
+#define	RALLOC_RAEN			(RALLOC_BASE + 0x0018U)
+#define	RALLOC_REGGD			(RALLOC_BASE + 0x0020U)
+#define	RALLOC_DANN			(RALLOC_BASE + 0x0030U)
+#define	RALLOC_DANT			(RALLOC_BASE + 0x0038U)
+#define	RALLOC_EC			(RALLOC_BASE + 0x003CU)
+#define	RALLOC_EMS			(RALLOC_BASE + 0x0040U)
+#define	RALLOC_INSFC			(RALLOC_BASE + 0x0050U)
+#define	RALLOC_BERR			(RALLOC_BASE + 0x0054U)
+
+
+typedef struct {
+	uintptr_t addr;
+	uint64_t value;
+} mstat_slot_t;
+
+
+#if RCAR_QOS_TYPE  == RCAR_QOS_TYPE_GFX
+static const mstat_slot_t mstat_fix[] = {
+	{0x0000U, 0x0000000000000000U},
+	{0x0008U, 0x0000000000000000U},
+	{0x0010U, 0x0000000000000000U},
+	{0x0018U, 0x0000000000000000U},
+	{0x0020U, 0x0000000000000000U},
+	{0x0028U, 0x0000000000000000U},
+	{0x0030U, 0x0000000000000000U},
+	{0x0038U, 0x0000000000000000U},
+	{0x0040U, 0x00140C060000FFFFU},
+	{0x0048U, 0x0000000000000000U},
+	{0x0050U, 0x0000000000000000U},
+	{0x0058U, 0x001408070000FFFFU},
+	{0x0060U, 0x001414140000FFFFU},
+	{0x0068U, 0x0000000000000000U},
+	{0x0070U, 0x0000000000000000U},
+	{0x0078U, 0x0000000000000000U},
+	{0x0080U, 0x0000000000000000U},
+	{0x0088U, 0x00140C060000FFFFU},
+	{0x0090U, 0x001414140000FFFFU},
+	{0x0098U, 0x001408070000FFFFU},
+	{0x00A0U, 0x0000000000000000U},
+	{0x00A8U, 0x0000000000000000U},
+	{0x00B0U, 0x0000000000000000U},
+	{0x00B8U, 0x0000000000000000U},
+	{0x00C0U, 0x0000000000000000U},
+	{0x00C8U, 0x0000000000000000U},
+	{0x00D0U, 0x0000000000000000U},
+	{0x00D8U, 0x0000000000000000U},
+	{0x00E0U, 0x0000000000000000U},
+	{0x00E8U, 0x0000000000000000U},
+	{0x00F0U, 0x0000000000000000U},
+	{0x00F8U, 0x0000000000000000U},
+	{0x0100U, 0x0000000000000000U},
+	{0x0108U, 0x0000000000000000U},
+	{0x0110U, 0x0000000000000000U},
+	{0x0118U, 0x0000000000000000U},
+	{0x0120U, 0x0000000000000000U},
+	{0x0128U, 0x0000000000000000U},
+	{0x0130U, 0x0000000000000000U},
+	{0x0138U, 0x001008060000FFFFU},
+	{0x0140U, 0x001008060000FFFFU},
+	{0x0148U, 0x001008060000FFFFU},
+	{0x0150U, 0x001008060000FFFFU},
+	{0x0158U, 0x001008060000FFFFU},
+	{0x0160U, 0x001008060000FFFFU},
+	{0x0168U, 0x001008060000FFFFU},
+	{0x0170U, 0x001008060000FFFFU},
+	{0x0178U, 0x001008060000FFFFU},
+	{0x0180U, 0x001008060000FFFFU},
+	{0x0188U, 0x001008060000FFFFU},
+	{0x0190U, 0x0010201E0000FFFFU},
+	{0x0198U, 0x0010201E0000FFFFU},
+	{0x01A0U, 0x001008060000FFFFU},
+	{0x01A8U, 0x001008060000FFFFU},
+	{0x01B0U, 0x001008060000FFFFU},
+	{0x01B8U, 0x0000000000000000U},
+	{0x01C0U, 0x0000000000000000U},
+	{0x01C8U, 0x0000000000000000U},
+	{0x01D0U, 0x0000000000000000U},
+	{0x01D8U, 0x0000000000000000U},
+	{0x01E0U, 0x0000000000000000U},
+	{0x01E8U, 0x0000000000000000U},
+	{0x01F0U, 0x0000000000000000U},
+	{0x01F8U, 0x0000000000000000U},
+	{0x0200U, 0x0000000000000000U},
+	{0x0208U, 0x0000000000000000U},
+	{0x0210U, 0x0000000000000000U},
+	{0x0218U, 0x0000000000000000U},
+	{0x0220U, 0x0000000000000000U},
+	{0x0228U, 0x0000000000000000U},
+	{0x0230U, 0x0000000000000000U},
+	{0x0238U, 0x0000000000000000U},
+	{0x0240U, 0x0000000000000000U},
+	{0x0248U, 0x0000000000000000U},
+	{0x0250U, 0x0000000000000000U},
+	{0x0258U, 0x0000000000000000U},
+	{0x0260U, 0x0000000000000000U},
+	{0x0268U, 0x0000000000000000U},
+	{0x0270U, 0x0000000000000000U},
+	{0x0278U, 0x0000000000000000U},
+	{0x0280U, 0x0000000000000000U},
+	{0x0288U, 0x0000000000000000U},
+	{0x0290U, 0x0000000000000000U},
+	{0x0298U, 0x0000000000000000U},
+	{0x02A0U, 0x0000000000000000U},
+	{0x02A8U, 0x0000000000000000U},
+	{0x02B0U, 0x0000000000000000U},
+	{0x02B8U, 0x0000000000000000U},
+	{0x02C0U, 0x0000000000000000U},
+	{0x02C8U, 0x0000000000000000U},
+	{0x02D0U, 0x0000000000000000U},
+	{0x02D8U, 0x0000000000000000U},
+	{0x02E0U, 0x0000000000000000U},
+	{0x02E8U, 0x0000000000000000U},
+	{0x02F0U, 0x0000000000000000U},
+	{0x02F8U, 0x0000000000000000U},
+	{0x0300U, 0x0000000000000000U},
+	{0x0308U, 0x0000000000000000U},
+	{0x0310U, 0x0000000000000000U},
+	{0x0318U, 0x0000000000000000U},
+	{0x0320U, 0x0000000000000000U},
+	{0x0328U, 0x0000000000000000U},
+	{0x0330U, 0x0000000000000000U},
+	{0x0338U, 0x0000000000000000U},
+};
+
+static const mstat_slot_t mstat_be[] = {
+	{0x0000U, 0x0000000000000000U},
+	{0x0008U, 0x0000000000000000U},
+	{0x0010U, 0x0000000000000000U},
+	{0x0018U, 0x0000000000000000U},
+	{0x0020U, 0x001000100C8FFC01U},
+	{0x0028U, 0x001000100C8FFC01U},
+	{0x0030U, 0x0000000000000000U},
+	{0x0038U, 0x0000000000000000U},
+	{0x0040U, 0x0000000000000000U},
+	{0x0048U, 0x0000000000000000U},
+	{0x0050U, 0x001000100C8FFC01U},
+	{0x0058U, 0x0000000000000000U},
+	{0x0060U, 0x0000000000000000U},
+	{0x0068U, 0x001000100C8FFC01U},
+	{0x0070U, 0x001000100C8FFC01U},
+	{0x0078U, 0x0000000000000000U},
+	{0x0080U, 0x0000000000000000U},
+	{0x0088U, 0x0000000000000000U},
+	{0x0090U, 0x0000000000000000U},
+	{0x0098U, 0x0000000000000000U},
+	{0x00A0U, 0x0000000000000000U},
+	{0x00A8U, 0x001000100C8FFC01U},
+	{0x00B0U, 0x001000100C8FFC01U},
+	{0x00B8U, 0x001000100C8FFC01U},
+	{0x00C0U, 0x0000000000000000U},
+	{0x00C8U, 0x001000100C8FFC01U},
+	{0x00D0U, 0x001000100C8FFC01U},
+	{0x00D8U, 0x002000200C8FFC01U},
+	{0x00E0U, 0x002000200C8FFC01U},
+	{0x00E8U, 0x001000100C8FFC01U},
+	{0x00F0U, 0x0000000000000000U},
+	{0x00F8U, 0x0000000000000000U},
+	{0x0100U, 0x0000000000000000U},
+	{0x0108U, 0x0000000000000000U},
+	{0x0110U, 0x0000000000000000U},
+	{0x0118U, 0x0000000000000000U},
+	{0x0120U, 0x0000000000000000U},
+	{0x0128U, 0x0000000000000000U},
+	{0x0130U, 0x001000100C8FFC01U},
+	{0x0138U, 0x0000000000000000U},
+	{0x0140U, 0x0000000000000000U},
+	{0x0148U, 0x0000000000000000U},
+	{0x0150U, 0x0000000000000000U},
+	{0x0158U, 0x0000000000000000U},
+	{0x0160U, 0x0000000000000000U},
+	{0x0168U, 0x0000000000000000U},
+	{0x0170U, 0x0000000000000000U},
+	{0x0178U, 0x0000000000000000U},
+	{0x0180U, 0x0000000000000000U},
+	{0x0188U, 0x0000000000000000U},
+	{0x0190U, 0x0000000000000000U},
+	{0x0198U, 0x0000000000000000U},
+	{0x01A0U, 0x0000000000000000U},
+	{0x01A8U, 0x0000000000000000U},
+	{0x01B0U, 0x0000000000000000U},
+	{0x01B8U, 0x001000100C8FFC01U},
+	{0x01C0U, 0x001000700C8FFC01U},
+	{0x01C8U, 0x001000700C8FFC01U},
+	{0x01D0U, 0x001000700C8FFC01U},
+	{0x01D8U, 0x001000700C8FFC01U},
+	{0x01E0U, 0x001000100C8FFC01U},
+	{0x01E8U, 0x001000000C8FFC01U},
+	{0x01F0U, 0x001000100C8FFC01U},
+	{0x01F8U, 0x001000100C8FFC01U},
+	{0x0200U, 0x001000100C8FFC01U},
+	{0x0208U, 0x001000100C8FFC01U},
+	{0x0210U, 0x001000100C8FFC01U},
+	{0x0218U, 0x001000100C8FFC01U},
+	{0x0220U, 0x001000100C8FFC01U},
+	{0x0228U, 0x001000100C8FFC01U},
+	{0x0230U, 0x001000100C8FFC01U},
+	{0x0238U, 0x001000100C8FFC01U},
+	{0x0240U, 0x001000100C8FFC01U},
+	{0x0248U, 0x001000100C8FFC01U},
+	{0x0250U, 0x001000100C8FFC01U},
+	{0x0258U, 0x001000100C8FFC01U},
+	{0x0260U, 0x0000000000000000U},
+	{0x0268U, 0x0000000000000000U},
+	{0x0270U, 0x0000000000000000U},
+	{0x0278U, 0x0000000000000000U},
+	{0x0280U, 0x0000000000000000U},
+	{0x0288U, 0x0000000000000000U},
+	{0x0290U, 0x0000000000000000U},
+	{0x0298U, 0x0000000000000000U},
+	{0x02A0U, 0x001000100C8FFC01U},
+	{0x02A8U, 0x001000100C8FFC01U},
+	{0x02B0U, 0x0000000000000000U},
+	{0x02B8U, 0x0000000000000000U},
+	{0x02C0U, 0x001000100C8FFC01U},
+	{0x02C8U, 0x001000100C8FFC01U},
+	{0x02D0U, 0x001000100C8FFC01U},
+	{0x02D8U, 0x001000100C8FFC01U},
+	{0x02E0U, 0x0000000000000000U},
+	{0x02E8U, 0x0000000000000000U},
+	{0x02F0U, 0x001000400C8FFC01U},
+	{0x02F8U, 0x001000400C8FFC01U},
+	{0x0300U, 0x001000100C8FFC01U},
+	{0x0308U, 0x001000400C8FFC01U},
+	{0x0310U, 0x001000400C8FFC01U},
+	{0x0318U, 0x001000100C8FFC01U},
+	{0x0320U, 0x001000400C8FFC01U},
+	{0x0328U, 0x001000400C8FFC01U},
+	{0x0330U, 0x001000400C8FFC01U},
+	{0x0338U, 0x001000400C8FFC01U},
+};
+
+#elif RCAR_QOS_TYPE  == RCAR_QOS_TYPE_HIGH_RESOLUTION
+static const mstat_slot_t mstat_fix[] = {
+	{0x0000U, 0x000C00000000FFFFU},
+	{0x0008U, 0x000C00000000FFFFU},
+	{0x0010U, 0x000C00000000FFFFU},
+	{0x0018U, 0x000C00000000FFFFU},
+	{0x0020U, 0x001400000000FFFFU},
+	{0x0028U, 0x000C00000000FFFFU},
+	{0x0030U, 0x001000000000FFFFU},
+	{0x0038U, 0x001000000000FFFFU},
+	{0x0040U, 0x001414050000FFFFU},
+	{0x0048U, 0x000C00000000FFFFU},
+	{0x0050U, 0x000C10010000FFFFU},
+	{0x0058U, 0x001408060000FFFFU},
+	{0x0060U, 0x001404030000FFFFU},
+	{0x0068U, 0x000C10010000FFFFU},
+	{0x0070U, 0x001400000000FFFFU},
+	{0x0078U, 0x001000000000FFFFU},
+	{0x0080U, 0x001000000000FFFFU},
+	{0x0088U, 0x001408050000FFFFU},
+	{0x0090U, 0x001404030000FFFFU},
+	{0x0098U, 0x001404020000FFFFU},
+	{0x00A0U, 0x000C00000000FFFFU},
+	{0x00A8U, 0x000C00000000FFFFU},
+	{0x00B0U, 0x001004010000FFFFU},
+	{0x00B8U, 0x000C00000000FFFFU},
+	{0x00C0U, 0x000C00000000FFFFU},
+	{0x00C8U, 0x001004010000FFFFU},
+	{0x00D0U, 0x001400000000FFFFU},
+	{0x00D8U, 0x001004010000FFFFU},
+	{0x00E0U, 0x001004040000FFFFU},
+	{0x00E8U, 0x001400000000FFFFU},
+	{0x00F0U, 0x001004010000FFFFU},
+	{0x00F8U, 0x001004010000FFFFU},
+	{0x0100U, 0x001004020000FFFFU},
+	{0x0108U, 0x001000000000FFFFU},
+	{0x0110U, 0x001004010000FFFFU},
+	{0x0118U, 0x001004010000FFFFU},
+	{0x0120U, 0x001004030000FFFFU},
+	{0x0128U, 0x001000000000FFFFU},
+	{0x0130U, 0x001400000000FFFFU},
+	{0x0138U, 0x001004030000FFFFU},
+	{0x0140U, 0x001004020000FFFFU},
+	{0x0148U, 0x001004020000FFFFU},
+	{0x0150U, 0x001004040000FFFFU},
+	{0x0158U, 0x001008050000FFFFU},
+	{0x0160U, 0x001008050000FFFFU},
+	{0x0168U, 0x001004030000FFFFU},
+	{0x0170U, 0x001004030000FFFFU},
+	{0x0178U, 0x001004020000FFFFU},
+	{0x0180U, 0x001004020000FFFFU},
+	{0x0188U, 0x001004020000FFFFU},
+	{0x0190U, 0x0010100D0000FFFFU},
+	{0x0198U, 0x00100C0A0000FFFFU},
+	{0x01A0U, 0x001008050000FFFFU},
+	{0x01A8U, 0x001008050000FFFFU},
+	{0x01B0U, 0x001008050000FFFFU},
+	{0x01B8U, 0x001400000000FFFFU},
+	{0x01C0U, 0x000C04010000FFFFU},
+	{0x01C8U, 0x000C04010000FFFFU},
+	{0x01D0U, 0x000C04010000FFFFU},
+	{0x01D8U, 0x000C04010000FFFFU},
+	{0x01E0U, 0x001004010000FFFFU},
+	{0x01E8U, 0x000C04010000FFFFU},
+	{0x01F0U, 0x000C04010000FFFFU},
+	{0x01F8U, 0x001004010000FFFFU},
+	{0x0200U, 0x001400000000FFFFU},
+	{0x0208U, 0x000C04010000FFFFU},
+	{0x0210U, 0x000C04010000FFFFU},
+	{0x0218U, 0x000C04010000FFFFU},
+	{0x0220U, 0x000C00000000FFFFU},
+	{0x0228U, 0x000C04010000FFFFU},
+	{0x0230U, 0x000C00000000FFFFU},
+	{0x0238U, 0x001400000000FFFFU},
+	{0x0240U, 0x000C04010000FFFFU},
+	{0x0248U, 0x000C04010000FFFFU},
+	{0x0250U, 0x000C04010000FFFFU},
+	{0x0258U, 0x000C04010000FFFFU},
+	{0x0260U, 0x000C00000000FFFFU},
+	{0x0268U, 0x001410010000FFFFU},
+	{0x0270U, 0x001404010000FFFFU},
+	{0x0278U, 0x000C00000000FFFFU},
+	{0x0280U, 0x001400000000FFFFU},
+	{0x0288U, 0x001400000000FFFFU},
+	{0x0290U, 0x001410010000FFFFU},
+	{0x0298U, 0x001404010000FFFFU},
+	{0x02A0U, 0x000C04010000FFFFU},
+	{0x02A8U, 0x001000000000FFFFU},
+	{0x02B0U, 0x001004010000FFFFU},
+	{0x02B8U, 0x001004010000FFFFU},
+	{0x02C0U, 0x000C04010000FFFFU},
+	{0x02C8U, 0x001400000000FFFFU},
+	{0x02D0U, 0x001000000000FFFFU},
+	{0x02D8U, 0x001004010000FFFFU},
+	{0x02E0U, 0x001000000000FFFFU},
+	{0x02E8U, 0x001400000000FFFFU},
+	{0x02F0U, 0x000C00000000FFFFU},
+	{0x02F8U, 0x000C00000000FFFFU},
+	{0x0300U, 0x001400000000FFFFU},
+	{0x0308U, 0x000C00000000FFFFU},
+	{0x0310U, 0x000C00000000FFFFU},
+	{0x0318U, 0x000C00000000FFFFU},
+	{0x0320U, 0x000C00000000FFFFU},
+	{0x0328U, 0x000C00000000FFFFU},
+	{0x0330U, 0x000C00000000FFFFU},
+	{0x0338U, 0x000C00000000FFFFU},
+};
+
+static const mstat_slot_t mstat_be[] = {
+	{0x0000U, 0x001000100C8FFC01U},
+	{0x0008U, 0x001000100C8FFC01U},
+	{0x0010U, 0x001000100C8FFC01U},
+	{0x0018U, 0x001000100C8FFC01U},
+	{0x0020U, 0x001000100C8FFC01U},
+	{0x0028U, 0x001000100C8FFC01U},
+	{0x0030U, 0x002000100C8FFC01U},
+	{0x0038U, 0x002000100C8FFC01U},
+	{0x0040U, 0x000000000C800000U},
+	{0x0048U, 0x002000000C8FFC01U},
+	{0x0050U, 0x000000000C800000U},
+	{0x0058U, 0x000000000C800000U},
+	{0x0060U, 0x000000000C800000U},
+	{0x0068U, 0x000000000C800000U},
+	{0x0070U, 0x001000100C8FFC01U},
+	{0x0078U, 0x002000100C8FFC01U},
+	{0x0080U, 0x002000100C8FFC01U},
+	{0x0088U, 0x000000000C800000U},
+	{0x0090U, 0x000000000C800000U},
+	{0x0098U, 0x000000000C800000U},
+	{0x00A0U, 0x001000100C8FFC01U},
+	{0x00A8U, 0x001000100C8FFC01U},
+	{0x00B0U, 0x001000100C8FFC01U},
+	{0x00B8U, 0x001000100C8FFC01U},
+	{0x00C0U, 0x001000100C8FFC01U},
+	{0x00C8U, 0x001000100C8FFC01U},
+	{0x00D0U, 0x001000100C8FFC01U},
+	{0x00D8U, 0x002000100C8FFC01U},
+	{0x00E0U, 0x002000400C8FFC01U},
+	{0x00E8U, 0x001000100C8FFC01U},
+	{0x00F0U, 0x002000100C8FFC01U},
+	{0x00F8U, 0x002000100C8FFC01U},
+	{0x0100U, 0x002000100C8FFC01U},
+	{0x0108U, 0x002000100C8FFC01U},
+	{0x0110U, 0x002000100C8FFC01U},
+	{0x0118U, 0x002000100C8FFC01U},
+	{0x0120U, 0x002000100C8FFC01U},
+	{0x0128U, 0x002000200C8FFC01U},
+	{0x0130U, 0x001000100C8FFC01U},
+	{0x0138U, 0x002000100C8FFC01U},
+	{0x0140U, 0x002000100C8FFC01U},
+	{0x0148U, 0x002000100C8FFC01U},
+	{0x0150U, 0x002000100C8FFC01U},
+	{0x0158U, 0x002000100C8FFC01U},
+	{0x0160U, 0x002000100C8FFC01U},
+	{0x0168U, 0x002000100C8FFC01U},
+	{0x0170U, 0x002000100C8FFC01U},
+	{0x0178U, 0x002000100C8FFC01U},
+	{0x0180U, 0x002000100C8FFC01U},
+	{0x0188U, 0x002000100C8FFC01U},
+	{0x0190U, 0x002000400C8FFC01U},
+	{0x0198U, 0x002000100C8FFC01U},
+	{0x01A0U, 0x002000100C8FFC01U},
+	{0x01A8U, 0x002000100C8FFC01U},
+	{0x01B0U, 0x002000100C8FFC01U},
+	{0x01B8U, 0x001000100C8FFC01U},
+	{0x01C0U, 0x001000100C8FFC01U},
+	{0x01C8U, 0x001000100C8FFC01U},
+	{0x01D0U, 0x001000100C8FFC01U},
+	{0x01D8U, 0x001000100C8FFC01U},
+	{0x01E0U, 0x001000100C8FFC01U},
+	{0x01E8U, 0x001000100C8FFC01U},
+	{0x01F0U, 0x001000100C8FFC01U},
+	{0x01F8U, 0x001000100C8FFC01U},
+	{0x0200U, 0x001000100C8FFC01U},
+	{0x0208U, 0x001000100C8FFC01U},
+	{0x0210U, 0x001000100C8FFC01U},
+	{0x0218U, 0x001000100C8FFC01U},
+	{0x0220U, 0x001000100C8FFC01U},
+	{0x0228U, 0x001000100C8FFC01U},
+	{0x0230U, 0x001000100C8FFC01U},
+	{0x0238U, 0x001000100C8FFC01U},
+	{0x0240U, 0x001000100C8FFC01U},
+	{0x0248U, 0x001000100C8FFC01U},
+	{0x0250U, 0x001000100C8FFC01U},
+	{0x0258U, 0x001000100C8FFC01U},
+	{0x0260U, 0x001000100C8FFC01U},
+	{0x0268U, 0x001000100C8FFC01U},
+	{0x0270U, 0x001000100C8FFC01U},
+	{0x0278U, 0x001000100C8FFC01U},
+	{0x0280U, 0x001000100C8FFC01U},
+	{0x0288U, 0x001000100C8FFC01U},
+	{0x0290U, 0x001000100C8FFC01U},
+	{0x0298U, 0x001000100C8FFC01U},
+	{0x02A0U, 0x001000100C8FFC01U},
+	{0x02A8U, 0x001000100C8FFC01U},
+	{0x02B0U, 0x001000100C8FFC01U},
+	{0x02B8U, 0x001000100C8FFC01U},
+	{0x02C0U, 0x001000100C8FFC01U},
+	{0x02C8U, 0x001000100C8FFC01U},
+	{0x02D0U, 0x001000100C8FFC01U},
+	{0x02D8U, 0x001000100C8FFC01U},
+	{0x02E0U, 0x001000100C8FFC01U},
+	{0x02E8U, 0x001000100C8FFC01U},
+	{0x02F0U, 0x001000200C8FFC01U},
+	{0x02F8U, 0x001000200C8FFC01U},
+	{0x0300U, 0x001000100C8FFC01U},
+	{0x0308U, 0x001000200C8FFC01U},
+	{0x0310U, 0x001000200C8FFC01U},
+	{0x0318U, 0x001000100C8FFC01U},
+	{0x0320U, 0x001000200C8FFC01U},
+	{0x0328U, 0x001000200C8FFC01U},
+	{0x0330U, 0x001000200C8FFC01U},
+	{0x0338U, 0x001000200C8FFC01U},
+};
+#endif
+
+
+void bl2_qos_init(void)
+{
+	uint32_t i;
+
+	/* DRAM Split Address mapping */
+#if RCAR_DRAM_SPLIT == RCAR_DRAM_SPLIT_4CH
+	NOTICE("BL2: DRAM Split is 4ch\n");
+	mmio_write_32(AXI_ADSPLCR0, ADSPLCR0_ADRMODE_DEFAULT
+				  | ADSPLCR0_SPLITSEL(0xFFU)
+				  | ADSPLCR0_AREA(0x1BU)
+				  | ADSPLCR0_SWP);
+	mmio_write_32(AXI_ADSPLCR1, 0x00000000U);
+	mmio_write_32(AXI_ADSPLCR2, 0xA8A90000U);
+	mmio_write_32(AXI_ADSPLCR3, 0x00000000U);
+#elif RCAR_DRAM_SPLIT == RCAR_DRAM_SPLIT_2CH
+	NOTICE("BL2: DRAM Split is 2ch\n");
+	mmio_write_32(AXI_ADSPLCR0, 0x00000000U);
+	mmio_write_32(AXI_ADSPLCR1, ADSPLCR0_ADRMODE_DEFAULT
+				  | ADSPLCR0_SPLITSEL(0xFFU)
+				  | ADSPLCR0_AREA(0x1BU)
+				  | ADSPLCR0_SWP);
+	mmio_write_32(AXI_ADSPLCR2, 0x00000000U);
+	mmio_write_32(AXI_ADSPLCR3, 0x00000000U);
+#else
+	NOTICE("BL2: DRAM Split is OFF\n");
+#endif
+
+#if !(RCAR_QOS_TYPE == RCAR_QOS_NONE)
+#if RCAR_QOS_TYPE  == RCAR_QOS_TYPE_GFX
+	NOTICE("BL2: QoS is Gfx Oriented(%s)\n", RCAR_QOS_VERSION);
+#elif RCAR_QOS_TYPE  == RCAR_QOS_TYPE_HIGH_RESOLUTION
+	NOTICE("BL2: QoS is High Resolution(%s)\n", RCAR_QOS_VERSION);
+#endif
+
+	/* AR Cache setting */
+	mmio_write_32(0xE67D1000U, 0x00000100U);
+	mmio_write_32(0xE67D1008U, 0x00000100U);
+
+	/* Resource Alloc setting */
+	mmio_write_32(RALLOC_RAS,   0x00000040U);
+	mmio_write_32(RALLOC_FIXTH, 0x000F0005U);
+	mmio_write_32(RALLOC_RAEN,  0x00000001U);
+	mmio_write_32(RALLOC_REGGD, 0x00000004U);
+	mmio_write_64(RALLOC_DANN,  0x0202000004040404U);
+	mmio_write_32(RALLOC_DANT,  0x003C1110U);
+	mmio_write_32(RALLOC_EC,    0x00080001U);	/* need for H3 ES1 */
+	mmio_write_64(RALLOC_EMS,   0x0000000000000000U);
+	mmio_write_32(RALLOC_INSFC, 0xC7840001U);
+	mmio_write_32(RALLOC_BERR,  0x00000000U);
+
+	/* MSTAT setting */
+	mmio_write_32(MSTAT_SL_INIT, 0x0305007DU);
+	mmio_write_32(MSTAT_REF_ARS, 0x00330000U);
+
+	/* MSTAT SRAM setting */
+	for (i = 0U; i < ARRAY_SIZE(mstat_fix); i++) {
+		mmio_write_64(MSTAT_FIX_QOS_BANK0 + mstat_fix[i].addr,
+				mstat_fix[i].value);
+		mmio_write_64(MSTAT_FIX_QOS_BANK1 + mstat_fix[i].addr,
+				mstat_fix[i].value);
+	}
+	for (i = 0U; i < ARRAY_SIZE(mstat_be); i++) {
+		mmio_write_64(MSTAT_BE_QOS_BANK0 + mstat_be[i].addr,
+				mstat_be[i].value);
+		mmio_write_64(MSTAT_BE_QOS_BANK1 + mstat_be[i].addr,
+				mstat_be[i].value);
+	}
+
+	/* AXI-IF arbitration setting */
+	mmio_write_32(DBSC_AXARB, 0x18010000U);
+
+	/* 3DG bus Leaf setting */
+	mmio_write_32(0xFD820808U, 0x00001234U);
+	mmio_write_32(0xFD820800U, 0x0000003FU);
+	mmio_write_32(0xFD821800U, 0x0000003FU);
+	mmio_write_32(0xFD822800U, 0x0000003FU);
+	mmio_write_32(0xFD823800U, 0x0000003FU);
+	mmio_write_32(0xFD824800U, 0x0000003FU);
+	mmio_write_32(0xFD825800U, 0x0000003FU);
+	mmio_write_32(0xFD826800U, 0x0000003FU);
+	mmio_write_32(0xFD827800U, 0x0000003FU);
+
+	/* Resource Alloc start */
+	mmio_write_32(RALLOC_RAEN,  0x00000001U);
+
+	/* MSTAT start */
+	mmio_write_32(MSTAT_STATQC, 0x00000001U);
+#else
+	NOTICE("BL2: QoS is None\n");
+
+	/* Resource Alloc setting */
+	mmio_write_32(RALLOC_EC,    0x00080001U);	/* need for H3 ES1 */
+#endif /* !(RCAR_QOS_TYPE == RCAR_QOS_NONE) */
+}
diff --git a/plat/renesas/rcar/bl2_rcar_setup.c b/plat/renesas/rcar/bl2_rcar_setup.c
new file mode 100644
index 0000000..717312f
--- /dev/null
+++ b/plat/renesas/rcar/bl2_rcar_setup.c
@@ -0,0 +1,378 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch_helpers.h>
+#include <assert.h>
+#include <bl_common.h>
+#include <console.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <string.h>
+#include "rcar_def.h"
+#include "rcar_private.h"
+#include "io_common.h"
+#include "bl2_pfc_init.h"
+#include "bl2_sdram_init.h"
+#include "rpc_driver.h"
+#include "dma_driver.h"
+#include "bl2_secure_setting.h"
+#include "bl2_cpg_register.h"
+#include "bl2_cpg_init.h"
+#include "bl2_qos_init.h"
+#include <debug.h>
+#include <mmio.h>
+#include "ddr/boot_init_dram.h"
+#include "rcar_version.h"
+
+
+/* CPG write protect registers */
+/*#define	CPG_CPGWPR		(CPG_BASE + 0x900U)*/
+/*#define	CPG_CPGWPCR		(CPG_BASE + 0x904U)*/
+#define	CPGWPR_PASSWORD		(0x5A5AFFFFU)
+#define	CPGWPCR_PASSWORD	(0xA5A50000U)
+
+/* CA57 Debug Resource control registers */
+#define	CPG_CA57DBGRCR		(CPG_BASE + 0x2180U)
+#define	DBGCPUPREN		((uint32_t)1U << 19U)
+#define	CPG_PLL0CR		(CPG_BASE + 0x00D8U)
+#define	CPG_PLL2CR		(CPG_BASE + 0x002CU)
+#define	CPG_PLL4CR		(CPG_BASE + 0x01F4U)
+
+
+/*******************************************************************************
+ * Declarations of linker defined symbols which will help us find the layout
+ * of trusted SRAM
+ ******************************************************************************/
+extern unsigned long __RO_START__;
+extern unsigned long __RO_END__;
+
+#if USE_COHERENT_MEM
+extern unsigned long __COHERENT_RAM_START__;
+extern unsigned long __COHERENT_RAM_END__;
+#endif
+
+/*
+ * The next 2 constants identify the extents of the code & RO data region.
+ * These addresses are used by the MMU setup code and therefore they must be
+ * page-aligned.  It is the responsibility of the linker script to ensure that
+ * __RO_START__ and __RO_END__ linker symbols refer to page-aligned addresses.
+ */
+#define BL2_RO_BASE (unsigned long)(&__RO_START__)
+#define BL2_RO_LIMIT (unsigned long)(&__RO_END__)
+
+#if USE_COHERENT_MEM
+/*
+ * The next 2 constants identify the extents of the coherent memory region.
+ * These addresses are used by the MMU setup code and therefore they must be
+ * page-aligned.  It is the responsibility of the linker script to ensure that
+ * __COHERENT_RAM_START__ and __COHERENT_RAM_END__ linker symbols refer to
+ * page-aligned addresses.
+ */
+#define BL2_COHERENT_RAM_BASE (unsigned long)(&__COHERENT_RAM_START__)
+#define BL2_COHERENT_RAM_LIMIT (unsigned long)(&__COHERENT_RAM_END__)
+#endif
+
+/* Data structure which holds the extents of the trusted SRAM for BL2 */
+static meminfo_t bl2_tzram_layout
+__attribute__ ((aligned(PLATFORM_CACHE_LINE_SIZE)));
+
+/* Assert that BL3-1 parameters fit in shared memory */
+CASSERT((PARAMS_BASE + sizeof(bl2_to_bl31_params_mem_t)) <
+	(RCAR_SHARED_MEM_BASE + RCAR_SHARED_MEM_SIZE),
+	assert_bl31_params_do_not_fit_in_shared_memory);
+
+/*******************************************************************************
+ * Reference to structures which holds the arguments which need to be passed
+ * to BL31
+ ******************************************************************************/
+static bl31_params_t *bl2_to_bl31_params;
+static entry_point_info_t *bl31_ep_info;
+
+meminfo_t *bl2_plat_sec_mem_layout(void)
+{
+	return &bl2_tzram_layout;
+}
+
+/*******************************************************************************
+ * This function assigns a pointer to the memory that the platform has kept
+ * aside to pass platform specific and trusted firmware related information
+ * to BL31. This memory is allocated by allocating memory to
+ * bl2_to_bl31_params_mem_t structure which is a superset of all the
+ * structure whose information is passed to BL31
+ * NOTE: This function should be called only once and should be done
+ * before generating params to BL31
+ ******************************************************************************/
+bl31_params_t *bl2_plat_get_bl31_params(void)
+{
+	bl2_to_bl31_params_mem_t *bl31_params_mem;
+
+	/*
+	 * Allocate the memory for all the arguments that needs to
+	 * be passed to BL31
+	 */
+	bl31_params_mem = (bl2_to_bl31_params_mem_t *)PARAMS_BASE;
+	memset((void *)PARAMS_BASE, 0, sizeof(bl2_to_bl31_params_mem_t));
+
+	/* Assign memory for TF related information */
+	bl2_to_bl31_params = &bl31_params_mem->bl31_params;
+	SET_PARAM_HEAD(bl2_to_bl31_params, PARAM_BL31, VERSION_1, 0);
+
+	/* Fill BL31 related information */
+	bl31_ep_info = &bl31_params_mem->bl31_ep_info;
+	bl2_to_bl31_params->bl31_image_info = &bl31_params_mem->bl31_image_info;
+	SET_PARAM_HEAD(bl2_to_bl31_params->bl31_image_info, PARAM_IMAGE_BINARY,
+						VERSION_1, 0);
+
+	/* Fill BL32 related information if it exists */
+	if (BL32_BASE) {
+		bl2_to_bl31_params->bl32_ep_info =
+					&bl31_params_mem->bl32_ep_info;
+		SET_PARAM_HEAD(bl2_to_bl31_params->bl32_ep_info,
+					PARAM_EP, VERSION_1, 0);
+		bl2_to_bl31_params->bl32_image_info =
+					&bl31_params_mem->bl32_image_info;
+		SET_PARAM_HEAD(bl2_to_bl31_params->bl32_image_info,
+					PARAM_IMAGE_BINARY,
+					VERSION_1, 0);
+	}
+
+	/* Fill BL33 related information */
+	bl2_to_bl31_params->bl33_ep_info = &bl31_params_mem->bl33_ep_info;
+	SET_PARAM_HEAD(bl2_to_bl31_params->bl33_ep_info,
+					PARAM_EP, VERSION_1, 0);
+	bl2_to_bl31_params->bl33_image_info = &bl31_params_mem->bl33_image_info;
+	SET_PARAM_HEAD(bl2_to_bl31_params->bl33_image_info, PARAM_IMAGE_BINARY,
+					VERSION_1, 0);
+
+	return bl2_to_bl31_params;
+}
+
+
+/*******************************************************************************
+ * This function returns a pointer to the shared memory that the platform
+ * has kept to point to entry point information of BL31 to BL2
+ ******************************************************************************/
+struct entry_point_info *bl2_plat_get_bl31_ep_info(void)
+{
+#if 0
+#if DEBUG
+	bl31_ep_info->args.arg1 = RCAR_BL31_PLAT_PARAM_VAL;
+#endif
+#else
+	bl31_ep_info->args.arg1 = 0x00000000;	/* nomal boot/cold boot */
+#endif
+	return bl31_ep_info;
+}
+
+/*******************************************************************************
+ * BL1 has passed the extents of the trusted SRAM that should be visible to BL2
+ * in x0. This memory layout is sitting at the base of the free trusted SRAM.
+ * Copy it to a safe loaction before its reclaimed by later BL2 functionality.
+ ******************************************************************************/
+void bl2_early_platform_setup(meminfo_t *mem_layout)
+{
+	uint32_t reg;
+
+	/* disable Secure Watchdog Timer */
+	mmio_write_32(0xE6030004U, 0xA5A5A500U);
+
+#if MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+	/* initialize Pin Function */
+	bl2_pfc_init();
+#endif
+
+	/* Initialize the console to provide early debug support */
+	(void)console_init(0U, 0U, 0U);
+
+	/* boot message */
+	NOTICE("BL2: R-Car H3 Loader Rev.%s\n", version_of_renesas);
+
+	/* Setup the BL2 memory layout */
+	bl2_tzram_layout = *mem_layout;
+
+#if MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+	/* Initialize SDRAM */
+/*	bl2_sdram_init();	*/
+	InitDram();
+#endif
+
+	/* Initialize RPC */
+	initRPC();
+
+	/* Initialize DMA */
+	initDMA();
+
+#if MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+	/* Initialize secure configuration */
+	bl2_secure_setting();
+
+	/* Initialize CPG configuration */
+	bl2_cpg_init();
+
+	/* initialize QoS configration */
+	bl2_qos_init();
+#endif
+
+	/* Release CPG write protect */
+	mmio_write_32(CPG_CPGWPR, CPGWPR_PASSWORD);
+	mmio_write_32(CPG_CPGWPCR, CPGWPCR_PASSWORD);
+
+	/* CA57 debug resource control */
+	mmio_write_32(CPG_CA57DBGRCR,
+			DBGCPUPREN | mmio_read_32(CPG_CA57DBGRCR));
+
+	/* PLL0, PLL2, PLL4 setting */
+	reg = mmio_read_32(CPG_PLL2CR);
+	reg &= ~((uint32_t)1U << 5U);	/* bit5 = 0 */
+	mmio_write_32(CPG_PLL2CR, reg);
+
+	reg = mmio_read_32(CPG_PLL4CR);
+	reg &= ~((uint32_t)1U << 5U);	/* bit5 = 0 */
+	mmio_write_32(CPG_PLL4CR, reg);
+
+	reg = mmio_read_32(CPG_PLL0CR);
+	reg &= ~((uint32_t)1U << 12U);	/* bit12 = 0 */
+	mmio_write_32(CPG_PLL0CR, reg);
+
+	/* Initialise the IO layer and register platform IO devices */
+	rcar_io_setup();
+}
+
+/*******************************************************************************
+ * Perform platform specific setup. For now just initialize the memory location
+ * to use for passing arguments to BL31.
+ ******************************************************************************/
+void bl2_platform_setup(void)
+{
+	/*
+	 * Do initial security configuration to allow DRAM/device access. On
+	 * Base RCAR only DRAM security is programmable (via TrustZone), but
+	 * other platforms might have more programmable security devices
+	 * present.
+	 */
+}
+
+/* Flush the TF params and the TF plat params */
+void bl2_plat_flush_bl31_params(void)
+{
+#if 0
+	flush_dcache_range((unsigned long)PARAMS_BASE, \
+				sizeof(bl2_to_bl31_params_mem_t));
+#endif
+}
+
+
+/*******************************************************************************
+ * Perform the very early platform specific architectural setup here. At the
+ * moment this is only intializes the mmu in a quick and dirty way.
+ ******************************************************************************/
+void bl2_plat_arch_setup(void)
+{
+#if 0
+	rcar_configure_mmu_el1(bl2_tzram_layout.total_base,
+			      bl2_tzram_layout.total_size,
+			      BL2_RO_BASE,
+			      BL2_RO_LIMIT
+#if USE_COHERENT_MEM
+			      , BL2_COHERENT_RAM_BASE,
+			      BL2_COHERENT_RAM_LIMIT
+#endif
+			      );
+#endif
+}
+
+/*******************************************************************************
+ * Before calling this function BL31 is loaded in memory and its entrypoint
+ * is set by load_image. This is a placeholder for the platform to change
+ * the entrypoint of BL31 and set SPSR and security state.
+ * On RCAR we are only setting the security state, entrypoint
+ ******************************************************************************/
+void bl2_plat_set_bl31_ep_info(image_info_t *bl31_image_info,
+					entry_point_info_t *bl31_ep_info)
+{
+	SET_SECURITY_STATE(bl31_ep_info->h.attr, SECURE);
+	bl31_ep_info->spsr = SPSR_64(MODE_EL3, MODE_SP_ELX,
+					DISABLE_ALL_EXCEPTIONS);
+}
+
+
+/*******************************************************************************
+ * Before calling this function BL32 is loaded in memory and its entrypoint
+ * is set by load_image. This is a placeholder for the platform to change
+ * the entrypoint of BL32 and set SPSR and security state.
+ * On RCAR we are only setting the security state, entrypoint
+ ******************************************************************************/
+void bl2_plat_set_bl32_ep_info(image_info_t *bl32_image_info,
+					entry_point_info_t *bl32_ep_info)
+{
+	SET_SECURITY_STATE(bl32_ep_info->h.attr, SECURE);
+	bl32_ep_info->spsr = rcar_get_spsr_for_bl32_entry();
+}
+
+/*******************************************************************************
+ * Before calling this function BL33 is loaded in memory and its entrypoint
+ * is set by load_image. This is a placeholder for the platform to change
+ * the entrypoint of BL33 and set SPSR and security state.
+ * On RCAR we are only setting the security state, entrypoint
+ ******************************************************************************/
+void bl2_plat_set_bl33_ep_info(image_info_t *image,
+					entry_point_info_t *bl33_ep_info)
+{
+	SET_SECURITY_STATE(bl33_ep_info->h.attr, NON_SECURE);
+	bl33_ep_info->spsr = rcar_get_spsr_for_bl33_entry();
+}
+
+
+/*******************************************************************************
+ * Populate the extents of memory available for loading BL32
+ ******************************************************************************/
+void bl2_plat_get_bl32_meminfo(meminfo_t *bl32_meminfo)
+{
+	/*
+	 * Populate the extents of memory available for loading BL32.
+	 */
+	bl32_meminfo->total_base = BL32_BASE;
+	bl32_meminfo->free_base = BL32_BASE;
+	bl32_meminfo->total_size = BL32_BASE;
+	bl32_meminfo->free_size = BL32_LIMIT - BL32_BASE;
+}
+
+
+/*******************************************************************************
+ * Populate the extents of memory available for loading BL33
+ ******************************************************************************/
+void bl2_plat_get_bl33_meminfo(meminfo_t *bl33_meminfo)
+{
+	bl33_meminfo->total_base = DRAM1_NS_BASE;
+	bl33_meminfo->total_size = DRAM1_NS_SIZE;
+	bl33_meminfo->free_base = DRAM1_NS_BASE;
+	bl33_meminfo->free_size = DRAM1_NS_SIZE;
+}
diff --git a/plat/renesas/rcar/bl2_sdram_init.c b/plat/renesas/rcar/bl2_sdram_init.c
new file mode 100644
index 0000000..b20df9d
--- /dev/null
+++ b/plat/renesas/rcar/bl2_sdram_init.c
@@ -0,0 +1,2275 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <debug.h>
+#include <mmio.h>
+#include <arch_helpers.h>
+#include <bl_common.h>
+#include "bl2_sdram_init.h"
+#include "bl2_phy_init.h"
+
+
+
+#define	BIT3			(0x08U)
+
+/* #define	DEBUG_SDRA_REG_PRINT */	/* print dbsc4 registers */
+
+#define	EFUSE_DUMMY5		(0xE60603E8U)
+#define	GET_DUMMY5_PKG(x)	(((x) & 0x00000001) >> 0U)	/* bit 0 */
+#define	DUMMY5_PKG_SIP		((uint32_t)0U)
+#define	DUMMY5_PKG_DISCRETE	((uint32_t)1U)
+#define	GET_DUMMY5_VENDOR(x)	(((x) & 0x00000000U) >> 1U)	/* bit 2:1 */
+#define	DUMMY5_VENDOR_SAMSUNG	((uint32_t)0U)
+#define	DUMMY5_VENDOR_MICRON	((uint32_t)0U)
+#define	DUMMY5_VENDOR_HYNIX	((uint32_t)0U)
+#define	GET_DUMMY5_MEMCONFIG(x)	(((x) & 0x00000078U) >> 3U)	/* bit 6:3 */
+#define	DUMMY5_MEMCONFIG_1GB_4	((uint32_t)0U)
+#define	DUMMY5_MEMCONFIG_2GB_4	((uint32_t)1U)
+#define	GET_DUMMY5_MEMTYPE(x)	(((x) & 0x00000380U) >> 7U)	/* bit 9:7 */
+#define	DUMMY5_MEMTYPE_LPDDR4	((uint32_t)0U)
+#define	DUMMY5_MEMTYPE_LPDDR3	((uint32_t)1U)
+#define	DUMMY5_MEMTYPE_DDR3L	((uint32_t)2U)
+#define	GET_DUMMY5_MEMRATE(x)	(((x) & 0x00000C00U) >> 10U)	/* bit 11:10 */
+#define	DUMMY5_MEMRATE_3200	((uint32_t)0U)
+#define	DUMMY5_MEMRATE_2667	((uint32_t)1U)
+
+#define	CPG_BASE		(0xE6150000U)
+#define	CPG_PLL3CR		(CPG_BASE + 0x00DCU)
+#define	CPG_SRCR4		(CPG_BASE + 0x00BCU)
+#define	CPG_PLLECR		(CPG_BASE + 0x00D0U)
+#define	CPG_CPGWPR		(CPG_BASE + 0x0900U)
+#define	CPG_SRSTCLR4		(CPG_BASE + 0x0950U)
+#define	PLLECR_PLL3ST		((uint32_t)1U << 11U)
+#define	PLLECR_PLL3E		((uint32_t)1U << 3U)
+
+#define	RST_BASE		(0xE6160000U)
+#define	RST_MODEMR		(RST_BASE + 0x0060U)
+#define	MODEMR_MD19		((uint32_t)1U << 19U)
+#define	MODEMR_MD17		((uint32_t)1U << 17U)
+#define MODEMR_DDR_CLOCK_MASK	((uint32_t)(~(MODEMR_MD19 | MODEMR_MD17)))
+#define MODEMR_DDR_CLOCK_3200	(0x00000000U)
+#define MODEMR_DDR_CLOCK_1600	((uint32_t)(MODEMR_MD19 | MODEMR_MD17))
+
+
+#define	DBSC_BASE		(0xE6790000U)
+#define	DBSC_DBSYSCONF0		(DBSC_BASE + 0x0000U)
+#define	DBSC_DBSYSCONF1		(DBSC_BASE + 0x0004U)
+#define	DBSC_DBPHYCONF0		(DBSC_BASE + 0x0010U)
+#define	DBSC_DBKIND		(DBSC_BASE + 0x0020U)
+#define	DBSC_DBMEMCONF_0_0	(DBSC_BASE + 0x0030U)
+#define	DBSC_DBMEMCONF_0_1	(DBSC_BASE + 0x0034U)
+#define	DBSC_DBMEMCONF_0_2	(DBSC_BASE + 0x0038U)
+#define	DBSC_DBMEMCONF_0_3	(DBSC_BASE + 0x003CU)
+#define	DBSC_DBMEMCONF_1_0	(DBSC_BASE + 0x0040U)
+#define	DBSC_DBMEMCONF_1_1	(DBSC_BASE + 0x0044U)
+#define	DBSC_DBMEMCONF_1_2	(DBSC_BASE + 0x0048U)
+#define	DBSC_DBMEMCONF_1_3	(DBSC_BASE + 0x004CU)
+#define	DBSC_DBMEMCONF_2_0	(DBSC_BASE + 0x0050U)
+#define	DBSC_DBMEMCONF_2_1	(DBSC_BASE + 0x0054U)
+#define	DBSC_DBMEMCONF_2_2	(DBSC_BASE + 0x0058U)
+#define	DBSC_DBMEMCONF_2_3	(DBSC_BASE + 0x005CU)
+#define	DBSC_DBMEMCONF_3_0	(DBSC_BASE + 0x0060U)
+#define	DBSC_DBMEMCONF_3_1	(DBSC_BASE + 0x0064U)
+#define	DBSC_DBMEMCONF_3_2	(DBSC_BASE + 0x0068U)
+#define	DBSC_DBMEMCONF_3_3	(DBSC_BASE + 0x006CU)
+#define	DBSC_DBINTEN		(DBSC_BASE + 0x0180U)
+#define	DBSC_DBINTSTAT0		(DBSC_BASE + 0x0184U)
+#define	DBSC_DBACEN		(DBSC_BASE + 0x0200U)
+#define	DBSC_DBRFEN		(DBSC_BASE + 0x0204U)
+#define	DBSC_DBCMD		(DBSC_BASE + 0x0208U)
+#define	DBSC_DBWAIT		(DBSC_BASE + 0x0210U)
+#define	DBSC_DBSYSCTRL0		(DBSC_BASE + 0x0280U)
+#define	DBSC_DBTR0		(DBSC_BASE + 0x0300U)
+#define	DBSC_DBTR1		(DBSC_BASE + 0x0304U)
+#define	DBSC_DBTR2		(DBSC_BASE + 0x0308U)
+#define	DBSC_DBTR3		(DBSC_BASE + 0x030CU)
+#define	DBSC_DBTR4		(DBSC_BASE + 0x0310U)
+#define	DBSC_DBTR5		(DBSC_BASE + 0x0314U)
+#define	DBSC_DBTR6		(DBSC_BASE + 0x0318U)
+#define	DBSC_DBTR7		(DBSC_BASE + 0x031CU)
+#define	DBSC_DBTR8		(DBSC_BASE + 0x0320U)
+#define	DBSC_DBTR9		(DBSC_BASE + 0x0324U)
+#define	DBSC_DBTR10		(DBSC_BASE + 0x0328U)
+#define	DBSC_DBTR11		(DBSC_BASE + 0x032CU)
+#define	DBSC_DBTR12		(DBSC_BASE + 0x0330U)
+#define	DBSC_DBTR13		(DBSC_BASE + 0x0334U)
+#define	DBSC_DBTR14		(DBSC_BASE + 0x0338U)
+#define	DBSC_DBTR15		(DBSC_BASE + 0x033CU)
+#define	DBSC_DBTR16		(DBSC_BASE + 0x0340U)
+#define	DBSC_DBTR17		(DBSC_BASE + 0x0344U)
+#define	DBSC_DBTR18		(DBSC_BASE + 0x0348U)
+#define	DBSC_DBTR19		(DBSC_BASE + 0x034CU)
+#define	DBSC_DBTR20		(DBSC_BASE + 0x0350U)
+#define	DBSC_DBTR21		(DBSC_BASE + 0x0354U)
+#define	DBSC_DBTR22		(DBSC_BASE + 0x0358U)
+#define	DBSC_DBTR23		(DBSC_BASE + 0x035CU)
+#define	DBSC_DBBL		(DBSC_BASE + 0x0400U)
+#define	DBSC_DBRFCNF1		(DBSC_BASE + 0x0414U)
+#define	DBSC_DBRFCNF2		(DBSC_BASE + 0x0418U)
+#define	DBSC_DBRFCNF3		(DBSC_BASE + 0x041CU)
+#define	DBSC_DBTSPCNF		(DBSC_BASE + 0x0420U)
+#define	DBSC_DBCALCNF		(DBSC_BASE + 0x0424U)
+#define	DBSC_DBCALTR		(DBSC_BASE + 0x0428U)
+#define	DBSC_DBRNK0		(DBSC_BASE + 0x0430U)
+#define	DBSC_DBRNK1		(DBSC_BASE + 0x0434U)
+#define	DBSC_DBRNK2		(DBSC_BASE + 0x0438U)
+#define	DBSC_DBRNK3		(DBSC_BASE + 0x043CU)
+#define	DBSC_DBRNK4		(DBSC_BASE + 0x0440U)
+#define	DBSC_DBRNK5		(DBSC_BASE + 0x0444U)
+#define	DBSC_DBRNK6		(DBSC_BASE + 0x0448U)
+#define	DBSC_DBPDNCNF		(DBSC_BASE + 0x0450U)
+#define	DBSC_DBODT0		(DBSC_BASE + 0x0460U)
+#define	DBSC_DBODT1		(DBSC_BASE + 0x0464U)
+#define	DBSC_DBODT2		(DBSC_BASE + 0x0468U)
+#define	DBSC_DBODT3		(DBSC_BASE + 0x046CU)
+#define	DBSC_DBODT4		(DBSC_BASE + 0x0470U)
+#define	DBSC_DBODT5		(DBSC_BASE + 0x0474U)
+#define	DBSC_DBODT6		(DBSC_BASE + 0x0478U)
+#define	DBSC_DBODT7		(DBSC_BASE + 0x047CU)
+#define	DBSC_DBMRRDR		(DBSC_BASE + 0x0480U)
+#define	DBSC_DBTSPDR		(DBSC_BASE + 0x0484U)
+#define	DBSC_DBADJ0		(DBSC_BASE + 0x0500U)
+#define	DBSC_DBADJ2		(DBSC_BASE + 0x0508U)
+#define	DBSC_DBDBICNT		(DBSC_BASE + 0x0518U)
+#define	DBSC_DBDFIPMSTRCNF	(DBSC_BASE + 0x0520U)
+#define	DBSC_DBDFIPMSTRSTAT	(DBSC_BASE + 0x0524U)
+#define	DBSC_DBDFILPCNF		(DBSC_BASE + 0x0528U)
+#define	DBSC_DBDFISTAT0		(DBSC_BASE + 0x0600U)
+#define	DBSC_DBDFISTAT1		(DBSC_BASE + 0x0640U)
+#define	DBSC_DBDFISTAT2		(DBSC_BASE + 0x0680U)
+#define	DBSC_DBDFISTAT3		(DBSC_BASE + 0x06C0U)
+#define	DBSC_DBDFICNT_0		(DBSC_BASE + 0x0604U)
+#define	DBSC_DBDFICNT_1		(DBSC_BASE + 0x0644U)
+#define	DBSC_DBDFICNT_2		(DBSC_BASE + 0x0684U)
+#define	DBSC_DBDFICNT_3		(DBSC_BASE + 0x06C4U)
+#define	DBSC_DBDFICNT(x)	(DBSC_BASE + 0x0604U + (uint32_t)((x) * 0x40U))
+#define	DBSC_DBPDCNT00		(DBSC_BASE + 0x0610U)
+#define	DBSC_DBPDCNT10		(DBSC_BASE + 0x0650U)
+#define	DBSC_DBPDCNT20		(DBSC_BASE + 0x0690U)
+#define	DBSC_DBPDCNT30		(DBSC_BASE + 0x06D0U)
+#define	DBSC_DBPDCNT01		(DBSC_BASE + 0x0614U)
+#define	DBSC_DBPDCNT11		(DBSC_BASE + 0x0654U)
+#define	DBSC_DBPDCNT21		(DBSC_BASE + 0x0694U)
+#define	DBSC_DBPDCNT31		(DBSC_BASE + 0x06D4U)
+#define	DBSC_DBPDCNT02		(DBSC_BASE + 0x0618U)
+#define	DBSC_DBPDCNT12		(DBSC_BASE + 0x0658U)
+#define	DBSC_DBPDCNT22		(DBSC_BASE + 0x0698U)
+#define	DBSC_DBPDCNT32		(DBSC_BASE + 0x06D8U)
+#define	DBSC_DBPDCNT03		(DBSC_BASE + 0x061CU)
+#define	DBSC_DBPDCNT13		(DBSC_BASE + 0x065CU)
+#define	DBSC_DBPDCNT23		(DBSC_BASE + 0x069CU)
+#define	DBSC_DBPDCNT33		(DBSC_BASE + 0x06DCU)
+#define	DBSC_DBPDLK_0		(DBSC_BASE + 0x0620U)
+#define	DBSC_DBPDLK_1		(DBSC_BASE + 0x0660U)
+#define	DBSC_DBPDLK_2		(DBSC_BASE + 0x06A0U)
+#define	DBSC_DBPDLK_3		(DBSC_BASE + 0x06E0U)
+#define	DBSC_DBPDRGA_0		(DBSC_BASE + 0x0624U)
+#define	DBSC_DBPDRGA_1		(DBSC_BASE + 0x0664U)
+#define	DBSC_DBPDRGA_2		(DBSC_BASE + 0x06A4U)
+#define	DBSC_DBPDRGA_3		(DBSC_BASE + 0x06E4U)
+#define	DBSC_DBPDRGD_0		(DBSC_BASE + 0x0628U)
+#define	DBSC_DBPDRGD_1		(DBSC_BASE + 0x0668U)
+#define	DBSC_DBPDRGD_2		(DBSC_BASE + 0x06A8U)
+#define	DBSC_DBPDRGD_3		(DBSC_BASE + 0x06E8U)
+#define	DBSC_DBBUS0CNF0		(DBSC_BASE + 0x0800U)
+#define	DBSC_DBBUS0CNF1		(DBSC_BASE + 0x0804U)
+#define	DBSC_DBCAM0CNF0		(DBSC_BASE + 0x0900U)
+#define	DBSC_DBCAM0CNF1		(DBSC_BASE + 0x0904U)
+#define	DBSC_DBCAM0CNF2		(DBSC_BASE + 0x0908U)
+#define	DBSC_DBCAM0CNF3		(DBSC_BASE + 0x090CU)
+#define	DBSC_DBBCAMSWAP		(DBSC_BASE + 0x09F0U)
+#define	DBSC_DBBCAMDIS		(DBSC_BASE + 0x09FCU)
+#define	DBSC_DBSCHCNT0		(DBSC_BASE + 0x1000U)
+#define	DBSC_DBSCHCNT1		(DBSC_BASE + 0x1004U)
+#define	DBSC_DBSCHSZ0		(DBSC_BASE + 0x1010U)
+#define	DBSC_DBSCHRW0		(DBSC_BASE + 0x1020U)
+#define	DBSC_DBSCHRW1		(DBSC_BASE + 0x1024U)
+#define	DBSC_DBSCHQOS_0_0	(DBSC_BASE + 0x1030U)
+#define	DBSC_DBSCHQOS_1_0	(DBSC_BASE + 0x1040U)
+#define	DBSC_DBSCHQOS_2_0	(DBSC_BASE + 0x1050U)
+#define	DBSC_DBSCHQOS_3_0	(DBSC_BASE + 0x1060U)
+#define	DBSC_DBSCHQOS_4_0	(DBSC_BASE + 0x1070U)
+#define	DBSC_DBSCHQOS_5_0	(DBSC_BASE + 0x1080U)
+#define	DBSC_DBSCHQOS_6_0	(DBSC_BASE + 0x1090U)
+#define	DBSC_DBSCHQOS_7_0	(DBSC_BASE + 0x10A0U)
+#define	DBSC_DBSCHQOS_8_0	(DBSC_BASE + 0x10B0U)
+#define	DBSC_DBSCHQOS_9_0	(DBSC_BASE + 0x10C0U)
+#define	DBSC_DBSCHQOS_10_0	(DBSC_BASE + 0x10D0U)
+#define	DBSC_DBSCHQOS_11_0	(DBSC_BASE + 0x10E0U)
+#define	DBSC_DBSCHQOS_12_0	(DBSC_BASE + 0x10F0U)
+#define	DBSC_DBSCHQOS_13_0	(DBSC_BASE + 0x1100U)
+#define	DBSC_DBSCHQOS_14_0	(DBSC_BASE + 0x1110U)
+#define	DBSC_DBSCHQOS_15_0	(DBSC_BASE + 0x1120U)
+#define	DBSC_DBSCHQOS_0_1	(DBSC_BASE + 0x1034U)
+#define	DBSC_DBSCHQOS_1_1	(DBSC_BASE + 0x1044U)
+#define	DBSC_DBSCHQOS_2_1	(DBSC_BASE + 0x1054U)
+#define	DBSC_DBSCHQOS_3_1	(DBSC_BASE + 0x1064U)
+#define	DBSC_DBSCHQOS_4_1	(DBSC_BASE + 0x1074U)
+#define	DBSC_DBSCHQOS_5_1	(DBSC_BASE + 0x1084U)
+#define	DBSC_DBSCHQOS_6_1	(DBSC_BASE + 0x1094U)
+#define	DBSC_DBSCHQOS_7_1	(DBSC_BASE + 0x10A4U)
+#define	DBSC_DBSCHQOS_8_1	(DBSC_BASE + 0x10B4U)
+#define	DBSC_DBSCHQOS_9_1	(DBSC_BASE + 0x10C4U)
+#define	DBSC_DBSCHQOS_10_1	(DBSC_BASE + 0x10D4U)
+#define	DBSC_DBSCHQOS_11_1	(DBSC_BASE + 0x10E4U)
+#define	DBSC_DBSCHQOS_12_1	(DBSC_BASE + 0x10F4U)
+#define	DBSC_DBSCHQOS_13_1	(DBSC_BASE + 0x1104U)
+#define	DBSC_DBSCHQOS_14_1	(DBSC_BASE + 0x1114U)
+#define	DBSC_DBSCHQOS_15_1	(DBSC_BASE + 0x1124U)
+#define	DBSC_DBSCHQOS_0_2	(DBSC_BASE + 0x1038U)
+#define	DBSC_DBSCHQOS_1_2	(DBSC_BASE + 0x1048U)
+#define	DBSC_DBSCHQOS_2_2	(DBSC_BASE + 0x1058U)
+#define	DBSC_DBSCHQOS_3_2	(DBSC_BASE + 0x1068U)
+#define	DBSC_DBSCHQOS_4_2	(DBSC_BASE + 0x1078U)
+#define	DBSC_DBSCHQOS_5_2	(DBSC_BASE + 0x1088U)
+#define	DBSC_DBSCHQOS_6_2	(DBSC_BASE + 0x1098U)
+#define	DBSC_DBSCHQOS_7_2	(DBSC_BASE + 0x10A8U)
+#define	DBSC_DBSCHQOS_8_2	(DBSC_BASE + 0x10B8U)
+#define	DBSC_DBSCHQOS_9_2	(DBSC_BASE + 0x10C8U)
+#define	DBSC_DBSCHQOS_10_2	(DBSC_BASE + 0x10D8U)
+#define	DBSC_DBSCHQOS_11_2	(DBSC_BASE + 0x10E8U)
+#define	DBSC_DBSCHQOS_12_2	(DBSC_BASE + 0x10F8U)
+#define	DBSC_DBSCHQOS_13_2	(DBSC_BASE + 0x1108U)
+#define	DBSC_DBSCHQOS_14_2	(DBSC_BASE + 0x1118U)
+#define	DBSC_DBSCHQOS_15_2	(DBSC_BASE + 0x1128U)
+#define	DBSC_DBSCHQOS_0_3	(DBSC_BASE + 0x103CU)
+#define	DBSC_DBSCHQOS_1_3	(DBSC_BASE + 0x104CU)
+#define	DBSC_DBSCHQOS_2_3	(DBSC_BASE + 0x105CU)
+#define	DBSC_DBSCHQOS_3_3	(DBSC_BASE + 0x106CU)
+#define	DBSC_DBSCHQOS_4_3	(DBSC_BASE + 0x107CU)
+#define	DBSC_DBSCHQOS_5_3	(DBSC_BASE + 0x108CU)
+#define	DBSC_DBSCHQOS_6_3	(DBSC_BASE + 0x109CU)
+#define	DBSC_DBSCHQOS_7_3	(DBSC_BASE + 0x10ACU)
+#define	DBSC_DBSCHQOS_8_3	(DBSC_BASE + 0x10BCU)
+#define	DBSC_DBSCHQOS_9_3	(DBSC_BASE + 0x10CCU)
+#define	DBSC_DBSCHQOS_10_3	(DBSC_BASE + 0x10DCU)
+#define	DBSC_DBSCHQOS_11_3	(DBSC_BASE + 0x10ECU)
+#define	DBSC_DBSCHQOS_12_3	(DBSC_BASE + 0x10FCU)
+#define	DBSC_DBSCHQOS_13_3	(DBSC_BASE + 0x110CU)
+#define	DBSC_DBSCHQOS_14_3	(DBSC_BASE + 0x111CU)
+#define	DBSC_DBSCHQOS_15_3	(DBSC_BASE + 0x112CU)
+#define	DBSC_DBSCTR0		(DBSC_BASE + 0x1700U)
+#define	DBSC_DBSCTR1		(DBSC_BASE + 0x1708U)
+#define	DBSC_DBSCHRW2		(DBSC_BASE + 0x170CU)
+#define	DBSC_DBMRRDR0		(DBSC_BASE + 0x1800U)
+#define	DBSC_DBMRRDR1		(DBSC_BASE + 0x1804U)
+#define	DBSC_DBMRRDR2		(DBSC_BASE + 0x1808U)
+#define	DBSC_DBMRRDR3		(DBSC_BASE + 0x180CU)
+#define	DBSC_DBDTMP0		(DBSC_BASE + 0x1820U)
+#define	DBSC_DBDTMP1		(DBSC_BASE + 0x1824U)
+#define	DBSC_DBDTMP2		(DBSC_BASE + 0x1828U)
+#define	DBSC_DBDTMP3		(DBSC_BASE + 0x182CU)
+#define	DBSC_DBDQSOSC00		(DBSC_BASE + 0x1840U)
+#define	DBSC_DBDQSOSC10		(DBSC_BASE + 0x1848U)
+#define	DBSC_DBDQSOSC20		(DBSC_BASE + 0x1850U)
+#define	DBSC_DBDQSOSC30		(DBSC_BASE + 0x1858U)
+#define	DBSC_DBDQSOSC01		(DBSC_BASE + 0x1844U)
+#define	DBSC_DBDQSOSC11		(DBSC_BASE + 0x184CU)
+#define	DBSC_DBDQSOSC21		(DBSC_BASE + 0x1854U)
+#define	DBSC_DBDQSOSC31		(DBSC_BASE + 0x185CU)
+#define	DBSC_DBOSCTHH00		(DBSC_BASE + 0x1880U)
+#define	DBSC_DBOSCTHH10		(DBSC_BASE + 0x1888U)
+#define	DBSC_DBOSCTHH20		(DBSC_BASE + 0x1890U)
+#define	DBSC_DBOSCTHH30		(DBSC_BASE + 0x1898U)
+#define	DBSC_DBOSCTHH01		(DBSC_BASE + 0x1884U)
+#define	DBSC_DBOSCTHH11		(DBSC_BASE + 0x188CU)
+#define	DBSC_DBOSCTHH21		(DBSC_BASE + 0x1894U)
+#define	DBSC_DBOSCTHH31		(DBSC_BASE + 0x189CU)
+#define	DBSC_DBOSCTHL00		(DBSC_BASE + 0x18C0U)
+#define	DBSC_DBOSCTHL10		(DBSC_BASE + 0x18C8U)
+#define	DBSC_DBOSCTHL20		(DBSC_BASE + 0x18D0U)
+#define	DBSC_DBOSCTHL30		(DBSC_BASE + 0x18D8U)
+#define	DBSC_DBOSCTHL01		(DBSC_BASE + 0x18C4U)
+#define	DBSC_DBOSCTHL11		(DBSC_BASE + 0x18CCU)
+#define	DBSC_DBOSCTHL21		(DBSC_BASE + 0x18D4U)
+#define	DBSC_DBOSCTHL31		(DBSC_BASE + 0x18DCU)
+#define	DBSC_DBFSFCONF0		(DBSC_BASE + 0x2000U)
+
+#define	DBSC_DBSTATE0		(DBSC_BASE + 0x0108U)
+#define	DBSC_PLL_LOCK(x)	(DBSC_BASE + 0x4054U \
+					   + (uint32_t)((x) * 0x0100U))
+#define	DBSC_PLL_LOCK_0		(DBSC_BASE + 0x4054U)
+#define	DBSC_PLL_LOCK_1		(DBSC_BASE + 0x4154U)
+#define	DBSC_PLL_LOCK_2		(DBSC_BASE + 0x4254U)
+#define	DBSC_PLL_LOCK_3		(DBSC_BASE + 0x4354U)
+#if 1
+#define DBSC_DBPDCNT0_0		DBSC_DBPDCNT00
+#define DBSC_DBPDCNT0_1		DBSC_DBPDCNT10
+#define DBSC_DBPDCNT0_2		DBSC_DBPDCNT20
+#define DBSC_DBPDCNT0_3		DBSC_DBPDCNT30
+#define DBSC_DBPDCNT_0		DBSC_DBPDCNT03
+#define DBSC_DBPDCNT_1		DBSC_DBPDCNT13
+#define DBSC_DBPDCNT_2		DBSC_DBPDCNT23
+#define DBSC_DBPDCNT_3		DBSC_DBPDCNT33
+#define DBSC_INITCOMP_0		DBSC_DBDFISTAT0
+#define DBSC_INITCOMP_1		DBSC_DBDFISTAT1
+#define DBSC_INITCOMP_2		DBSC_DBDFISTAT2
+#define DBSC_INITCOMP_3		DBSC_DBDFISTAT3
+#define DBSC_DFI_FREQ_0		DBSC_DBPDCNT01
+#define DBSC_DFI_FREQ_1		DBSC_DBPDCNT11
+#define DBSC_DFI_FREQ_2		DBSC_DBPDCNT21
+#define DBSC_DFI_FREQ_3		DBSC_DBPDCNT31
+#define DBSC_FREQ_CHG_ACK_0	DBSC_DBPDCNT02
+#define DBSC_FREQ_CHG_ACK_1	DBSC_DBPDCNT12
+#define DBSC_FREQ_CHG_ACK_2	DBSC_DBPDCNT22
+#define DBSC_FREQ_CHG_ACK_3	DBSC_DBPDCNT32
+#endif
+
+
+#define	DDCG_LPDDR3		(0x0008U)
+#define	DDCG_LPDDR4		(0x000AU)
+
+#define	DBMEMCONF_DENS_2N	(0x00000000U)
+#define	DBMEMCONF_DENS_2N3	(0x40000000U)
+#define	DBMEMCONF_AWRW_12	(0x0C000000U)
+#define	DBMEMCONF_AWRW_13	(0x0D000000U)
+#define	DBMEMCONF_AWRW_14	(0x0E000000U)
+#define	DBMEMCONF_AWRW_15	(0x0F000000U)
+#define	DBMEMCONF_AWRW_16	(0x10000000U)
+#define	DBMEMCONF_AWBK		(0x00030000U)
+#define	DBMEMCONF_AWCL_9	(0x00000900U)
+#define	DBMEMCONF_AWCL_10	(0x00000A00U)
+#define	DBMEMCONF_AWCL_11	(0x00000B00U)
+#define	DBMEMCONF_DW_10		(0x00000002U)
+
+#define	DBPHYCONF0_PHY_DFI	(0x01U)
+
+#define	DBTR0_CL(x)		((uint32_t)(x) << 0U)
+#define	DBTR1_CWL(x)		((uint32_t)(x) << 0U)
+#define	DBTR2_AL_0		(0x00U)
+#define	DBTR3_TRCD(x)		((uint32_t)(x) << 0U)
+#define	DBTR4_TRPA(x)		((uint32_t)(x) << 16U)
+#define	DBTR4_TRP(x)		((uint32_t)(x) << 0U)
+#define	DBTR5_TRC(x)		((uint32_t)(x) << 0U)
+#define	DBTR6_TRAS(x)		((uint32_t)(x) << 0U)
+#define	DBTR7_TRRD_S(x)		((uint32_t)(x) << 16U)
+#define	DBTR7_TRRD(x)		((uint32_t)(x) << 0U)
+#define	DBTR8_TFAW(x)		((uint32_t)(x) << 0U)
+#define	DBTR9_TRDPR(x)		((uint32_t)(x) << 0U)
+#define	DBTR10_TWR(x)		((uint32_t)(x) << 0U)
+#define	DBTR11_TWRTWR(x)	((uint32_t)(x) << 0U)
+#define	DBTR12_TWRRD_S(x)	((uint32_t)(x) << 16U)
+#define	DBTR12_TWRRD(x)		((uint32_t)(x) << 0U)
+#define	DBTR13_TRFCPB(x)	((uint32_t)(x) << 16U)
+#define	DBTR13_TRFC_TRFCAB(x)	((uint32_t)(x) << 0U)
+#define	DBTR14_TCKEHDLL(x)	((uint32_t)(x) << 16U)
+#define	DBTR14_TCKEH(x)		((uint32_t)(x) << 0U)
+#define	DBTR15_TCKESR(x)	((uint32_t)(x) << 16U)
+#define	DBTR15_TCKEL(x)		((uint32_t)(x) << 0U)
+#define	DBTR16_DQIENLTNCY(x)	((uint32_t)(x) << 24U)
+#define	DBTR16_DQL(x)		((uint32_t)(x) << 16U)
+#define	DBTR16_DQENLTNCY(x)	((uint32_t)(x) << 8U)
+#define	DBTR16_WDQL(x)		((uint32_t)(x) << 0U)
+#define	DBTR17_TMODRD(x)	((uint32_t)(x) << 24U)
+#define	DBTR17_TMOD(x)		((uint32_t)(x) << 16U)
+#define	DBTR17_TRDMR(x)		((uint32_t)(x) << 0U)
+#define	DBTR18_RODTL(x)		((uint32_t)(x) << 24U)
+#define	DBTR18_RODTA(x)		((uint32_t)(x) << 16U)
+#define	DBTR18_WODTL(x)		((uint32_t)(x) << 8U)
+#define	DBTR18_WODTA(x)		((uint32_t)(x) << 0U)
+#define	DBTR19_TZQCL(x)		((uint32_t)(x) << 16U)
+#define	DBTR19_TZQCS(x)		((uint32_t)(x) << 0U)
+#define	DBTR20_TXSDLL(x)	((uint32_t)(x) << 16U)
+#define	DBTR20_TXS(x)		((uint32_t)(x) << 0U)
+#define DBTR21_TCCD_S(x)	((uint32_t)(x) << 16U)
+#define DBTR21_TCCD(x)		((uint32_t)(x) << 0U)
+#define DBTR22_TZQCAL(x)	((uint32_t)(x) << 16U)
+#define	DBTR22_TZQLAT(x)	((uint32_t)(x) << 0U)
+
+#define	DBBL_BL8		((uint32_t)0x00)
+#define	DBBL_BL16		((uint32_t)0x02)
+
+#define	DBRNK1_RKRP(x)		((uint32_t)(x) << 16U)
+#define DBRNK1_RKRF(x)		((uint32_t)(x) << 0U)
+#define	DBRNK2_RKRR7(x)		((uint32_t)(x) << 28U)
+#define	DBRNK2_RKRR6(x)		((uint32_t)(x) << 24U)
+#define	DBRNK2_RKRR5(x)		((uint32_t)(x) << 20U)
+#define	DBRNK2_RKRR4(x)		((uint32_t)(x) << 16U)
+#define	DBRNK2_RKRR3(x)		((uint32_t)(x) << 12U)
+#define	DBRNK2_RKRR2(x)		((uint32_t)(x) << 8U)
+#define	DBRNK2_RKRR1(x)		((uint32_t)(x) << 4U)
+#define	DBRNK2_RKRR0(x)		((uint32_t)(x) << 0U)
+#define	DBRNK3_RKRW7(x)		((uint32_t)(x) << 28U)
+#define	DBRNK3_RKRW6(x)		((uint32_t)(x) << 24U)
+#define	DBRNK3_RKRW5(x)		((uint32_t)(x) << 20U)
+#define	DBRNK3_RKRW4(x)		((uint32_t)(x) << 16U)
+#define	DBRNK3_RKRW3(x)		((uint32_t)(x) << 12U)
+#define	DBRNK3_RKRW2(x)		((uint32_t)(x) << 8U)
+#define	DBRNK3_RKRW1(x)		((uint32_t)(x) << 4U)
+#define	DBRNK3_RKRW0(x)		((uint32_t)(x) << 0U)
+#define	DBRNK4_RKWR7(x)		((uint32_t)(x) << 28U)
+#define	DBRNK4_RKWR6(x)		((uint32_t)(x) << 24U)
+#define	DBRNK4_RKWR5(x)		((uint32_t)(x) << 20U)
+#define	DBRNK4_RKWR4(x)		((uint32_t)(x) << 16U)
+#define	DBRNK4_RKWR3(x)		((uint32_t)(x) << 12U)
+#define	DBRNK4_RKWR2(x)		((uint32_t)(x) << 8U)
+#define	DBRNK4_RKWR1(x)		((uint32_t)(x) << 4U)
+#define	DBRNK4_RKWR0(x)		((uint32_t)(x) << 0U)
+#define	DBRNK5_RKWW7(x)		((uint32_t)(x) << 28U)
+#define	DBRNK5_RKWW6(x)		((uint32_t)(x) << 24U)
+#define	DBRNK5_RKWW5(x)		((uint32_t)(x) << 20U)
+#define	DBRNK5_RKWW4(x)		((uint32_t)(x) << 16U)
+#define	DBRNK5_RKWW3(x)		((uint32_t)(x) << 12U)
+#define	DBRNK5_RKWW2(x)		((uint32_t)(x) << 8U)
+#define	DBRNK5_RKWW1(x)		((uint32_t)(x) << 4U)
+#define	DBRNK5_RKWW0(x)		((uint32_t)(x) << 0U)
+#define	DBRNK6_REFMODE_ALL	(0x00U)
+#define	DBRNK6_REFMODE_RANK	(0x00U)
+
+#define	DBADJ0_CAMODE_1_CLK	(0x00U)
+#define	DBADJ0_CAMODE_2_CLK	(0x01U)
+
+#define	DBPDCNT0_DFIRESETN	(0x01U)
+#define	DBPDCNT3_CNTREG(x)	((uint32_t)(x) << 16U)
+#define	DBPDCNT3_DLLRST		(0xCF01U)
+
+#define	DBCAM0CNF1_WBKWAIT(x)		((uint32_t)(x) << 16U)
+#define	DBCAM0CNF1_SWPINPRI3(x)		((uint32_t)(x) << 12U)
+#define	DBCAM0CNF1_SWPINPRI2(x)		((uint32_t)(x) << 8U)
+#define	DBCAM0CNF1_SWPINPRI1(x)		((uint32_t)(x) << 4U)
+#define	DBCAM0CNF1_SWPINPRI1F(x)	((uint32_t)(x) << 0U)
+
+#define	DBCAM0CNF2_FILLUNIT_64		(0x0000U)
+#define	DBCAM0CNF2_FILLUNIT_128		(0x0100U)
+#define	DBCAM0CNF2_FILLUNIT_256		(0x0200U)
+#define	DBCAM0CNF2_FCDIRTYMAX(x)	((uint32_t)(x) << 4U)
+#define	DBCAM0CNF2_FCDIRTYMIN(x)	((uint32_t)(x) << 0U)
+
+#define DBCAM0CNF3_RDFULL(x)		((uint32_t)(x) << 0U)
+
+#define	DBSCHCNT0_SCWBPRI_3		((uint32_t)8U << 24U)
+#define	DBSCHCNT0_SCWBPRI_2		((uint32_t)4U << 24U)
+#define	DBSCHCNT0_SCWBPRI_1		((uint32_t)2U << 24U)
+#define	DBSCHCNT0_SCWBPRI_0		((uint32_t)1U << 24U)
+#define	DBSCHCNT0_SCQTZEN_3		((uint32_t)1U << 19U)
+#define	DBSCHCNT0_SCQTZEN_2		((uint32_t)1U << 18U)
+#define	DBSCHCNT0_SCQTZEN_1		((uint32_t)1U << 17U)
+#define	DBSCHCNT0_SCQTZEN_0		((uint32_t)1U << 16U)
+#define	DBSCHCNT0_SCSZEN_EN		(0x20U)
+#define	DBSCHCNT0_SCSZEN_DIS		(0x00U)
+#define	DBSCHCNT0_SCBAEN_EN		(0x10U)
+#define	DBSCHCNT0_SCBAEN_DIS		(0x00U)
+#define	DBSCHCNT0_SCPGEN_EN		(0x04U)
+#define	DBSCHCNT0_SCPGEN_DIS		(0x00U)
+#define	DBSCHCNT0_SCRWEN_EN		(0x02U)
+#define	DBSCHCNT0_SCRWEN_DIS		(0x00U)
+#define	DBSCHCNT0_SCQOSEN_EN		(0x01U)
+#define	DBSCHCNT0_SCQOSEN_DIS		(0x00U)
+
+#define	DBSCHCNT1_SCHCH3(x)		((uint32_t)(x) << 12U)
+#define	DBSCHCNT1_SCHCH2(x)		((uint32_t)(x) << 8U)
+#define	DBSCHCNT1_SCHCH1(x)		((uint32_t)(x) << 4U)
+#define	DBSCHCNT1_SCHCH0(x)		((uint32_t)(x) << 0U)
+
+#define	DBSCHSZ0_SZTH(x)		((uint32_t)(x) << 0U)
+
+#define	DBSCHRW1_SCBADEC(x)		((uint32_t)(x) << 16U)
+#define	DBSCHRW1_RWWTPERI(x)		((uint32_t)(x) << 0U)
+
+#define	DBSYSCONF1_FREQRATIO_1_4	(0x02U)
+
+#define	DBPDLK_KEYWORD			(0xA55AU)
+
+#define	DBDFICNT_DFIBYTEDIS(x)		((uint32_t)(x) << 16U)
+#define	DBDFICNT_DFICLKDIS(x)		((uint32_t)(x) << 8U)
+#define	DBDFICNT_DFIFREQRATIO_1_1	(0x00U)
+#define	DBDFICNT_DFIFREQRATIO_1_2	(0x10U)
+#define	DBDFICNT_DFIFREQRATIO_1_4	(0x20U)
+#define	DBDFICNT_DFIINITSTART		(0x01U)
+
+#define	DBCMD_OPC_WAIT			((uint32_t)0x00U << 24U)
+#define	DBCMD_OPC_RESET			((uint32_t)0x01U << 24U)
+#define	DBCMD_OPC_LOCK			((uint32_t)0x02U << 24U)
+#define	DBCMD_OPC_PREA			((uint32_t)0x04U << 24U)
+#define	DBCMD_OPC_REF			((uint32_t)0x05U << 24U)
+#define	DBCMD_OPC_ZQC			((uint32_t)0x06U << 24U)
+#define	DBCMD_OPC_PD			((uint32_t)0x08U << 24U)
+#define	DBCMD_OPC_DPD			((uint32_t)0x09U << 24U)
+#define	DBCMD_OPC_SR			((uint32_t)0x0AU << 24U)
+#define	DBCMD_OPC_MPC			((uint32_t)0x0DU << 24U)
+#define	DBCMD_OPC_MRW			((uint32_t)0x0EU << 24U)
+#define	DBCMD_OPC_MRR			((uint32_t)0x0FU << 24U)
+#define	DBCMD_CH(x)			((uint32_t)(x) << 20U)
+#define	DBCMD_CH_ALL			((uint32_t)8U << 20U)
+#define	DBCMD_RANK(x)			((uint32_t)(x) << 16U)
+#define	DBCMD_RANK_ALL			((uint32_t)4U << 16U)
+#define	DBCMD_ARG_RESET_NEGATE		(0x0000U)
+#define	DBCMD_ARG_RESET_ASSERT		(0x0001U)
+#define	DBCMD_ARG_LOCK_DISABLED		(0x0000U)
+#define	DBCMD_ARG_LOCK_DISABLING	(0x0001U)
+#define	DBCMD_ARG_PREA			(0x0010U)
+#define	DBCMD_ARG_REF			(0x0010U)
+#define	DBCMD_ARG_ZQCS			(0x0000U)
+#define	DBCMD_ARG_ZQCL			(0x0001U)
+#define	DBCMD_ARG_ENTER			(0x0000U)
+#define	DBCMD_ARG_EXIT			(0x0001U)
+#define	DBCMD_ARG_MPC(op)		((uint32_t)(op) << 0U)
+#define	DBCMD_ARG_MRW(ma, op)		(((uint32_t)(ma) << 8U) | \
+					 ((uint32_t)(op) << 0U))
+#define	DBCMD_ARG_MRR(ma)		((uint32_t)(ma) << 8U)
+
+#define	DBDFIPMSTRCNF_EN		(0x01U)
+#define	DBDFIPMSTRCNF_DIS		(0x00U)
+
+#define	DBBUS0CNF0_EXSTA(x)		((uint32_t)(x) << 24U)
+#define	DBBUS0CNF0_EN			(0x00010000U)
+#define	DBBUS0CNF0_DIS			(0x00000000U)
+#define	DBBUS0CNF0_ROUND_ROBIN		(0x00U)
+#define	DBBUS0CNF0_READ_HIGH_PRIORITY	(0x01U)
+#define	DBBUS0CNF0_WRITE_HIGH_PRIORITY	(0x02U)
+
+#define	DBRFCNF1_REFPMAX(x)		((uint32_t)(x) << 16U)
+#define	DBRFCNF1_REFINT(x)		((uint32_t)(x) << 0U)
+
+#define	DBRFCNF2_REFPMIN		((uint32_t)0x0001U << 16U)
+#define	DBRFCNF2_REFINT_1_1		(0x00U)
+#define	DBRFCNF2_REFINT_1_2		(0x01U)
+
+#define	DBRFEN_ARFEN_START		(0x01U)
+#define	DBRFEN_ARFEN_STOP		(0x00U)
+
+#define DBACEN_ACCEN_EN			(0x01U)
+#define DBACEN_ACCEN_DIS		(0x00U)
+
+
+static void SoftDelay(uint32_t loop);
+static void pvt_dbsc_regset(void);
+static void pvt_manual_update(uint32_t flag);
+static void pvt_freq_change_ack(uintptr_t phychno, uint32_t freq_flag);
+static uint32_t pvt_pi_training_go_all(void);
+static uint32_t pvt_pi_training(void);
+static void WaitDBCMD(void);
+static void DDRPHY_PVT_OVERWRITE(void);
+static void change_lpddr4_en(uintptr_t phychno, uint32_t mode);
+static void copy_dqdelay(uintptr_t phychno, uint32_t s_byte, uint32_t d_byte);
+
+static void InitDDR1600_4GByte_mod_0804(void);
+
+#ifdef DEBUG_SDRA_REG_PRINT
+static void print_dbsc4_reg(uint32_t address);
+static void print_phy_reg(uint32_t address);
+static void print_regs(void);
+#endif /* DEBUG_SDRA_REG_PRINT */
+
+
+static const uint16_t	dqdelay_tbl[4][38] = {
+	       {(uint16_t)PHY_CLK_WRDQ1_SLAVE_DELAY_0,
+		(uint16_t)PHY_CLK_WRDQ0_SLAVE_DELAY_0,
+		(uint16_t)PHY_CLK_WRDQ3_SLAVE_DELAY_0,
+		(uint16_t)PHY_CLK_WRDQ2_SLAVE_DELAY_0,
+		(uint16_t)PHY_CLK_WRDQ5_SLAVE_DELAY_0,
+		(uint16_t)PHY_CLK_WRDQ4_SLAVE_DELAY_0,
+		(uint16_t)PHY_CLK_WRDQ7_SLAVE_DELAY_0,
+		(uint16_t)PHY_CLK_WRDQ6_SLAVE_DELAY_0,
+		(uint16_t)PHY_CLK_WRDM_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQ1_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQ0_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQ3_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQ2_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQ5_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQ4_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQ7_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQ6_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DM_FALL_SLAVE_DELAY_0,
+		(uint16_t)PHY_RDDQS_DM_RISE_SLAVE_DELAY_0,
+		(uint16_t)PHY_WRITE_PATH_LAT_ADD_0,
+		(uint16_t)PHY_RDDQS_LATENCY_ADJUST_0,
+		(uint16_t)PHY_RDDQS_GATE_SLAVE_DELAY_0},
+	       {(uint16_t)PHY_CLK_WRDQ1_SLAVE_DELAY_1,
+		(uint16_t)PHY_CLK_WRDQ0_SLAVE_DELAY_1,
+		(uint16_t)PHY_CLK_WRDQ3_SLAVE_DELAY_1,
+		(uint16_t)PHY_CLK_WRDQ2_SLAVE_DELAY_1,
+		(uint16_t)PHY_CLK_WRDQ5_SLAVE_DELAY_1,
+		(uint16_t)PHY_CLK_WRDQ4_SLAVE_DELAY_1,
+		(uint16_t)PHY_CLK_WRDQ7_SLAVE_DELAY_1,
+		(uint16_t)PHY_CLK_WRDQ6_SLAVE_DELAY_1,
+		(uint16_t)PHY_CLK_WRDM_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQ1_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQ0_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQ3_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQ2_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQ5_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQ4_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQ7_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQ6_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DM_FALL_SLAVE_DELAY_1,
+		(uint16_t)PHY_RDDQS_DM_RISE_SLAVE_DELAY_1,
+		(uint16_t)PHY_WRITE_PATH_LAT_ADD_1,
+		(uint16_t)PHY_RDDQS_LATENCY_ADJUST_1,
+		(uint16_t)PHY_RDDQS_GATE_SLAVE_DELAY_1},
+	       {(uint16_t)PHY_CLK_WRDQ1_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ0_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ3_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ2_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ5_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ4_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ7_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ6_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDM_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQ1_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQ0_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQ3_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQ2_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQ5_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQ4_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQ7_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQ6_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DM_FALL_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQS_DM_RISE_SLAVE_DELAY_2,
+		(uint16_t)PHY_WRITE_PATH_LAT_ADD_2,
+		(uint16_t)PHY_RDDQS_LATENCY_ADJUST_2,
+		(uint16_t)PHY_RDDQS_GATE_SLAVE_DELAY_2},
+	       {(uint16_t)PHY_CLK_WRDQ1_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ0_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ3_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ2_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ5_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ4_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ7_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDQ6_SLAVE_DELAY_2,
+		(uint16_t)PHY_CLK_WRDM_SLAVE_DELAY_2,
+		(uint16_t)PHY_RDDQ1_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQ0_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQ3_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQ2_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQ5_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQ4_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQ7_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQ6_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DM_FALL_SLAVE_DELAY_3,
+		(uint16_t)PHY_RDDQS_DM_RISE_SLAVE_DELAY_3,
+		(uint16_t)PHY_WRITE_PATH_LAT_ADD_3,
+		(uint16_t)PHY_RDDQS_LATENCY_ADJUST_3,
+		(uint16_t)PHY_RDDQS_GATE_SLAVE_DELAY_3}
+};
+
+
+static void SoftDelay(uint32_t loop)
+{
+	volatile uint32_t i;
+	for (i = 0U; i < loop; i++) {
+	}
+}
+
+
+void bl2_sdram_init(void)
+{
+	uint32_t md;
+
+	md = (mmio_read_32(RST_MODEMR));
+	if ((uint32_t)(md & MODEMR_DDR_CLOCK_MASK) == MODEMR_DDR_CLOCK_3200) {
+		InitDDR1600_4GByte_mod_0804(); /* MD19=0,MD17=0 : DDR3200 */
+	} else {
+		InitDDR1600_4GByte_mod_0804(); /* MD19=1,MD17=1 : DDR1600 */
+	}
+
+#ifdef DEBUG_SDRA_REG_PRINT
+	print_regs(); /* print DBSC4 regsiters */
+#endif /* DEBUG_SDRA_REG_PRINT */
+}
+
+
+static void InitDDR1600_4GByte_mod_0804(void)
+{
+	uint32_t mode = 0U;
+	uint32_t i;
+	uint32_t j;
+	uint32_t dataL;
+	uint32_t reset_flag;
+	uintptr_t phychno;
+	uint32_t phytrainingok;
+
+	uint32_t freq = 0x2fU;
+	uint32_t fdiv = 0x0U;
+	uint32_t lvlen = 0x17U;
+	uint32_t pvtover = 0x1U;
+	uint32_t drive = 0x1U;
+
+	uint32_t cad[4] = {0x2a0U, 0x2a0U, 0x2a0U, 0x2a0U};
+	uint32_t grp[4] = {0x2a0U, 0x2a0U, 0x2a0U, 0x2a0U};
+
+	uint32_t skip_pll_reset = 0x0U;
+	uint32_t phymrw = 0x0fU;
+	uint32_t pad_cal_wa = 0x0U;
+	uint32_t updt_wa = 0x3U;
+
+	uint32_t pvtcode_cal_lpddr4[4][8];
+	uint32_t pvtcode_cal_lpddr3[4][8];
+	
+	/* DDR RESET ASSERT */
+	mmio_write_32(DBSC_DBPDCNT00, DBPDCNT0_DFIRESETN);
+	mmio_write_32(DBSC_DBPDCNT10, DBPDCNT0_DFIRESETN);
+	mmio_write_32(DBSC_DBPDCNT20, DBPDCNT0_DFIRESETN);
+	mmio_write_32(DBSC_DBPDCNT30, DBPDCNT0_DFIRESETN);
+
+	if (!skip_pll_reset) {
+		/* reset pulse */
+		do {
+			mmio_write_32(CPG_CPGWPR, 0xBFFFFFFFU);
+			mmio_write_32(CPG_SRCR4, 0x40000000U);
+			mmio_write_32(CPG_CPGWPR, 0xBFFFFFFFU);
+			mmio_write_32(CPG_SRSTCLR4, 0x40000000U);
+			reset_flag = mmio_read_32(DBSC_DBKIND);
+		} while (reset_flag!=0U);
+
+		/* Unlock DDRPHY register */
+		mmio_write_32(DBSC_DBPDLK_0, DBPDLK_KEYWORD);
+		mmio_write_32(DBSC_DBPDLK_1, DBPDLK_KEYWORD);
+		mmio_write_32(DBSC_DBPDLK_2, DBPDLK_KEYWORD);
+		mmio_write_32(DBSC_DBPDLK_3, DBPDLK_KEYWORD);
+
+		for (i = 0U; i < PHY_MAX_NUM; i++) {
+			ddr_phy_reg_rawwrite(i, PI_CS_MAP, 0U);
+			ddr_phy_reg_rawwrite(i, PI_SW_RST_N, 0U);
+			ddr_phy_reg_rawwrite(i, PI_WDT_DISABLE, 0U);
+		}
+
+		j = mmio_read_32(CPG_PLL3CR);
+		j = (j & 0x00ffff7fU) | ((freq << 24U) & 0xff000000U)
+				      | ((fdiv <<  7U) & 0x00000080U);
+		mmio_write_32(CPG_CPGWPR, ~j);
+		mmio_write_32(CPG_PLL3CR, j);
+
+		SoftDelay(20000U);
+		
+		do {
+			dataL = mmio_read_32(CPG_PLLECR);
+		} while ((dataL & PLLECR_PLL3ST) == 0U);
+		
+		for (i = 0U; i < PHY_MAX_NUM; i++) {
+			ddr_phy_reg_rawwrite(i, PI_SW_RST_N, 1U);
+		}
+	}
+
+	pvt_dbsc_regset();
+
+	/* DDR RESET NEGATE */
+	mmio_write_32(DBSC_DBPDCNT00, 0x0U);
+	mmio_write_32(DBSC_DBPDCNT10, 0x0U);
+	mmio_write_32(DBSC_DBPDCNT20, 0x0U);
+	mmio_write_32(DBSC_DBPDCNT30, 0x0U);
+	
+	/* (DDRPHY Kick Initialize Sequence) */
+	/* Unlock DDRPHY register(AGAIN) */
+	mmio_write_32(DBSC_DBPDLK_0, DBPDLK_KEYWORD);
+	mmio_write_32(DBSC_DBPDLK_1, DBPDLK_KEYWORD);
+	mmio_write_32(DBSC_DBPDLK_2, DBPDLK_KEYWORD);
+	mmio_write_32(DBSC_DBPDLK_3, DBPDLK_KEYWORD);
+
+	/* (PHY parameter and PI parameter Initialize)
+	 * Initialize Leveling parameter including WDQLVL */
+	bl2_phy_init();
+
+	if(drive)
+	{
+		for (i = 0U; i < PHY_MAX_NUM; i++) {
+		/* TSEL_SELECT 0x0e6e0e -> 0x006e0e */
+			ddr_phy_reg_write(i, PHY_DQ_TSEL_SELECT_0,
+					  0x00006E0EU);
+			ddr_phy_reg_write(i, PHY_DQS_TSEL_SELECT_0,
+					  0x00006E0EU);
+			ddr_phy_reg_write(i, PHY_DQ_TSEL_SELECT_1,
+					  0x00006E0EU);
+			ddr_phy_reg_write(i, PHY_DQS_TSEL_SELECT_1,
+					  0x00006E0EU);
+			ddr_phy_reg_write(i, PHY_DQ_TSEL_SELECT_2,
+					  0x00006E0EU);
+			ddr_phy_reg_write(i, PHY_DQS_TSEL_SELECT_2,
+					  0x00006E0EU);
+			ddr_phy_reg_write(i, PHY_DQ_TSEL_SELECT_3,
+					  0x00006E0EU);
+			ddr_phy_reg_write(i, PHY_DQS_TSEL_SELECT_3,
+					  0x00006E0EU);
+
+			/* CKE 27F6E(LVSTL) -> 03fee(CMOS40orm) */
+			ddr_phy_reg_write(i, PHY_PAD_CKE_DRIVE, 0x00003FEEU);
+
+			/* RST 27F6E(LVSTL) -> 03fee(CMOS40orm) */
+			ddr_phy_reg_write(i, PHY_PAD_RST_DRIVE, 0x00003FEEU);
+			ddr_phy_reg_write(i, PHY_PAD_CS_TERM,   0x00010F68U);
+	/* TERM 10F68(PVTR=10,PVTN=3D,PVTP=28)
+	 *  -> 1154f(PVTR=11,PVTN=15,PVTP=0f */
+			ddr_phy_reg_write(i, PHY_PAD_ADDR_TERM, 0x0001154FU);
+			ddr_phy_reg_write(i, PHY_PAD_CKE_TERM,  0x0001154FU);
+			ddr_phy_reg_write(i, PHY_PAD_CLK_TERM,  0x0001154FU);
+			ddr_phy_reg_write(i, PHY_PAD_CS_TERM,   0x0001154FU);
+			ddr_phy_reg_write(i, PHY_PAD_DATA_TERM, 0x0001154FU);
+			ddr_phy_reg_write(i, PHY_PAD_FDBK_TERM, 0x0003154FU);
+			ddr_phy_reg_write(i, PHY_PAD_CS_TERM,   0x0001154FU);
+		}
+	}
+	
+
+	/* Set PCB bit swap connection for Salvator-X */
+	ddr_phy_reg_write(0U, PHY_DQ_SWIZZLING_0, 0x20741365U); /* DQ7-0   */
+	ddr_phy_reg_write(0U, PHY_DQ_SWIZZLING_1, 0x34256107U); /* DQ15-8  */
+	ddr_phy_reg_write(0U, PHY_DQ_SWIZZLING_2, 0x57460321U); /* DQ23-16 */
+	ddr_phy_reg_write(0U, PHY_DQ_SWIZZLING_3, 0x70614532U); /* DQ31-24 */
+	ddr_phy_reg_write(0U, PHY_ADR_ADDR_SEL_0, 0x00543210U); /* AC5-0   */
+	ddr_phy_reg_write(0U, PHY_ADR_CALVL_SWIZZLE0_0_0, 0x00DCBA98U); /* DRAM Byte 0 */
+	ddr_phy_reg_write(0U, PHY_ADR_CALVL_SWIZZLE1_0_0, 0x00000000U); /* DRAM Byte 1 */
+	ddr_phy_reg_write(0U, PHY_ADR_CALVL_SWIZZLE0_1_0, 0x00DCBA98U); /* DRAM Byte 2 */
+	ddr_phy_reg_write(0U, PHY_ADR_CALVL_SWIZZLE1_1_0, 0x00000000U); /* DRAM Byte 3 */
+	ddr_phy_reg_write(0U, PHY_ADR_CALVL_DEVICE_MAP_0, 0x1U);
+
+	ddr_phy_reg_write(1U, PHY_DQ_SWIZZLING_0, 0x23547610U); /* DQ7-0   */
+	ddr_phy_reg_write(1U, PHY_DQ_SWIZZLING_1, 0x34526107U); /* DQ15-8  */
+	ddr_phy_reg_write(1U, PHY_DQ_SWIZZLING_2, 0x67452310U); /* DQ23-16 */
+	ddr_phy_reg_write(1U, PHY_DQ_SWIZZLING_3, 0x32106754U); /* DQ31-24 */
+	ddr_phy_reg_write(1U, PHY_ADR_ADDR_SEL_0, 0x00543210U); /* AC5-0   */
+	ddr_phy_reg_write(1U, PHY_ADR_CALVL_SWIZZLE0_0_0, 0x00DCBA98U); /* DRAM Byte 2 */
+	ddr_phy_reg_write(1U, PHY_ADR_CALVL_SWIZZLE1_0_0, 0x00DCBA98U); /* DRAM Byte 0 */
+	ddr_phy_reg_write(1U, PHY_ADR_CALVL_SWIZZLE0_1_0, 0x00DCBA98U); /* DRAM Byte 1 */
+	ddr_phy_reg_write(1U, PHY_ADR_CALVL_SWIZZLE1_1_0, 0x00DCBA98U); /* DRAM Byte 3 */
+	ddr_phy_reg_write(1U, PHY_ADR_CALVL_DEVICE_MAP_0, 0x2U);
+
+	ddr_phy_reg_write(2U, PHY_DQ_SWIZZLING_0, 0x30216754U); /* DQ7-0   */
+	ddr_phy_reg_write(2U, PHY_DQ_SWIZZLING_1, 0x67453210U); /* DQ15-8  */
+	ddr_phy_reg_write(2U, PHY_DQ_SWIZZLING_2, 0x70165243U); /* DQ23-16 */
+	ddr_phy_reg_write(2U, PHY_DQ_SWIZZLING_3, 0x07162345U); /* DQ31-24 */
+	ddr_phy_reg_write(2U, PHY_ADR_ADDR_SEL_0, 0x00543210U); /* AC5-0   */
+	ddr_phy_reg_write(2U, PHY_ADR_CALVL_SWIZZLE0_0_0, 0x00DCBA98U); /* DRAM Byte 3 */
+	ddr_phy_reg_write(2U, PHY_ADR_CALVL_SWIZZLE1_0_0, 0x00DCBA98U); /* DRAM Byte 1 */
+	ddr_phy_reg_write(2U, PHY_ADR_CALVL_SWIZZLE0_1_0, 0x00DCBA98U); /* DRAM Byte 2 */
+	ddr_phy_reg_write(2U, PHY_ADR_CALVL_SWIZZLE1_1_0, 0x00DCBA98U); /* DRAM Byte 0 */
+	ddr_phy_reg_write(2U, PHY_ADR_CALVL_DEVICE_MAP_0, 0x1U);
+
+	ddr_phy_reg_write(3U, PHY_DQ_SWIZZLING_0, 0x01327654U); /* DQ7-0   */
+	ddr_phy_reg_write(3U, PHY_DQ_SWIZZLING_1, 0x70615432U); /* DQ15-8  */
+	ddr_phy_reg_write(3U, PHY_DQ_SWIZZLING_2, 0x54760123U); /* DQ23-16 */
+	ddr_phy_reg_write(3U, PHY_DQ_SWIZZLING_3, 0x07162345U); /* DQ31-24 */
+	ddr_phy_reg_write(3U, PHY_ADR_ADDR_SEL_0, 0x00543210U); /* AC5-0   */
+	ddr_phy_reg_write(3U, PHY_ADR_CALVL_SWIZZLE0_0_0, 0X00DCBA98U); /* DRAM Byte 3 */
+	ddr_phy_reg_write(3U, PHY_ADR_CALVL_SWIZZLE1_0_0, 0X00DCBA98U); /* DRAM Byte 1 */
+	ddr_phy_reg_write(3U, PHY_ADR_CALVL_SWIZZLE0_1_0, 0X00DCBA98U); /* DRAM Byte 2 */
+	ddr_phy_reg_write(3U, PHY_ADR_CALVL_SWIZZLE1_1_0, 0X00DCBA98U); /* DRAM Byte 0 */
+	ddr_phy_reg_write(3U, PHY_ADR_CALVL_DEVICE_MAP_0, 0x1U);
+
+	/* CH1 CALVL for swap */
+	/* CH1 CALVL can be done only for CS[2] ( M2 dq_h -> soc M2 dq_h ) */
+	/* PI_CALVL_CS_MAP:RW:0:4:= 0x4 */
+	ddr_phy_reg_write(1U, PI_CALVL_CS_MAP, 0x4U);
+
+	mmio_write_32(DBSC_DBDFIPMSTRCNF, DBDFIPMSTRCNF_EN);
+
+	for (i = 0U; i < PHY_MAX_NUM; i++) {
+		/* CALVL_EN */
+		if (lvlen & 0x00000001U) {
+			ddr_phy_reg_write(i, PI_CALVL_EN, 1U);
+		} else {
+			ddr_phy_reg_write(i, PI_CALVL_EN, 0U);
+		}
+
+		/* WRLVL_EN */
+		if (lvlen & 0x00000002U) {
+			ddr_phy_reg_write(i, PI_WRLVL_EN, 1U);
+		}
+		else
+		{
+			ddr_phy_reg_write(i, PI_WRLVL_EN, 0U);
+		}
+
+		/* RDLVL_GATE_EN */
+		if (lvlen & 0x00000004U) {
+			ddr_phy_reg_write(i, PI_RDLVL_GATE_EN, 1U);
+		} else {
+			ddr_phy_reg_write(i, PI_RDLVL_GATE_EN, 0U);
+		}
+
+		/* RDLVL_EN */
+		if (lvlen & 0x00000008U) {
+			ddr_phy_reg_write(i, PI_RDLVL_EN, 1U);
+		}
+		else
+		{
+			ddr_phy_reg_write(i, PI_RDLVL_EN, 0U);
+		}
+
+		/* WRDQLVL_EN */
+		if (lvlen & 0x00000010U) {
+			ddr_phy_reg_write(i, PI_WDQLVL_EN, 1U);
+		}
+		else
+		{
+			ddr_phy_reg_write(i, PI_WDQLVL_EN, 0U);
+		}
+	}
+
+	if (pad_cal_wa) {
+		for (i = 0U; i < PHY_MAX_NUM; i++) {
+			ddr_phy_reg_write(i, PHY_CAL_MODE_0, 0U);
+			ddr_phy_reg_write(i, PHY_TST_CLK_PAD_CTRL2, 0x000700U);
+		}
+	}
+
+	/* dbdficnt0 freq_ratio = 01 (2:1)init_start =1 */
+	mmio_write_32(DBSC_DBDFICNT_0, DBDFICNT_DFIBYTEDIS(0U)
+				     | DBDFICNT_DFICLKDIS(0U)
+				     | DBDFICNT_DFIFREQRATIO_1_2
+				     | DBDFICNT_DFIINITSTART);
+	mmio_write_32(DBSC_DBDFICNT_1, DBDFICNT_DFIBYTEDIS(0U)
+				     | DBDFICNT_DFICLKDIS(0U)
+				     | DBDFICNT_DFIFREQRATIO_1_2
+				     | DBDFICNT_DFIINITSTART);
+	mmio_write_32(DBSC_DBDFICNT_2, DBDFICNT_DFIBYTEDIS(0U)
+				     | DBDFICNT_DFICLKDIS(0U)
+				     | DBDFICNT_DFIFREQRATIO_1_2
+				     | DBDFICNT_DFIINITSTART);
+	mmio_write_32(DBSC_DBDFICNT_3, DBDFICNT_DFIBYTEDIS(0U)
+				     | DBDFICNT_DFICLKDIS(0U)
+				     | DBDFICNT_DFIFREQRATIO_1_2
+				     | DBDFICNT_DFIINITSTART);
+
+	mmio_write_32(DBSC_DBPDCNT03, DBPDCNT3_DLLRST); /* dll_rst_n0 -> 1 */
+	mmio_write_32(DBSC_DBPDCNT13, DBPDCNT3_DLLRST);
+	mmio_write_32(DBSC_DBPDCNT23, DBPDCNT3_DLLRST);
+	mmio_write_32(DBSC_DBPDCNT33, DBPDCNT3_DLLRST);
+
+	/* Need Handshake sequence betweed DBSC and PHY */
+	do {
+		dataL = 0x00000001U & mmio_read_32(DBSC_DBDFISTAT0);
+	} while (dataL != 0x00000001U); /* Wait for PI status[0] is 0 */
+	do {
+		dataL = 0x00000001U & mmio_read_32(DBSC_DBDFISTAT1);
+	} while (dataL != 0x00000001U); /* Wait for PI status[0] is 0 */
+	do {
+		dataL = 0x00000001U & mmio_read_32(DBSC_DBDFISTAT2);
+	} while (dataL != 0x00000001U); /* Wait for PI status[0] is 0 */
+	do {
+		dataL = 0x00000001U & mmio_read_32(DBSC_DBDFISTAT3);
+	} while (dataL != 0x00000001U); /* Wait for PI status[0] is 0 */
+
+	/* Need Handshake sequence betweed DBSC and PHY */
+	if (pad_cal_wa) {
+		for (j = 0U; j < PHY_MAX_NUM; j++) {
+			pvtcode_cal_lpddr3[j][0] =
+					ddr_phy_reg_read(j, PHY_PAD_FDBK_TERM);
+			pvtcode_cal_lpddr3[j][1] =
+					ddr_phy_reg_read(j, PHY_PAD_DATA_TERM);
+			pvtcode_cal_lpddr3[j][2] =
+					ddr_phy_reg_read(j, PHY_PAD_DQS_TERM);
+			pvtcode_cal_lpddr3[j][3] =
+					ddr_phy_reg_read(j, PHY_PAD_ADDR_TERM);
+/*			pvtcode_cal_lpddr3[j][4] =
+					ddr_phy_reg_read(j, PHY_PAD_CLK_TERM);
+*/
+			pvtcode_cal_lpddr3[j][5] =
+					ddr_phy_reg_read(j, PHY_PAD_CKE_TERM);
+			pvtcode_cal_lpddr3[j][6] =
+					ddr_phy_reg_read(j, PHY_PAD_RST_TERM);
+			pvtcode_cal_lpddr3[j][7] =
+					ddr_phy_reg_read(j, PHY_PAD_CS_TERM);
+			pvtcode_cal_lpddr3[j][4] = pvtcode_cal_lpddr3[j][3];
+		}
+	
+		for (j = 0U; j < PHY_MAX_NUM; j++) {
+			ddr_phy_reg_write(i, PHY_TST_CLK_PAD_CTRL2, 0x000B00U); /* change to LPDDR4 class */
+			ddr_phy_reg_write(i, PHY_CAL_CLEAR_0, 1U); /* [0]cal_clear */
+			ddr_phy_reg_write(i, PHY_CAL_CLK_SELECT_0, 0U);
+			ddr_phy_reg_write(i, PHY_CAL_MODE_0, 0x65U);
+			ddr_phy_reg_write(i, PHY_CAL_START_0, 1U); /* [8]cal_start */
+		}
+		SoftDelay(2000U); /* wait for 2msec */
+
+		for (j = 0U; j < PHY_MAX_NUM; j++) {
+			pvtcode_cal_lpddr4[j][0] =
+					ddr_phy_reg_read(j, PHY_PAD_FDBK_TERM);
+			pvtcode_cal_lpddr4[j][1] =
+					ddr_phy_reg_read(j, PHY_PAD_DATA_TERM);
+			pvtcode_cal_lpddr4[j][2] =
+					ddr_phy_reg_read(j, PHY_PAD_DQS_TERM);
+			pvtcode_cal_lpddr4[j][3] =
+					ddr_phy_reg_read(j, PHY_PAD_ADDR_TERM);
+/*			pvtcode_cal_lpddr4[j][4] =
+					ddr_phy_reg_read(j, PHY_PAD_CLK_TERM);
+*/
+			pvtcode_cal_lpddr4[j][5] =
+					ddr_phy_reg_read(j, PHY_PAD_CKE_TERM);
+			pvtcode_cal_lpddr4[j][6] =
+					ddr_phy_reg_read(j, PHY_PAD_RST_TERM);
+			pvtcode_cal_lpddr4[j][7] =
+					ddr_phy_reg_read(j, PHY_PAD_CS_TERM);
+			pvtcode_cal_lpddr4[j][4] =
+					pvtcode_cal_lpddr3[j][3];
+		}
+
+		for (j = 0U; j < PHY_MAX_NUM; j++) {
+			dataL = (pvtcode_cal_lpddr4[j][0] & 0xFFFFF000U)
+			      | (pvtcode_cal_lpddr3[j][0] & 0x00000FFFU);
+			ddr_phy_reg_write(i, PHY_PAD_FDBK_TERM, dataL);
+			dataL = (pvtcode_cal_lpddr4[j][1] & 0xFFFFF000U)
+			      | (pvtcode_cal_lpddr3[j][1] & 0x00000FFFU);
+			ddr_phy_reg_write(i, PHY_PAD_DATA_TERM, dataL);
+			dataL = (pvtcode_cal_lpddr4[j][2] & 0xFFFFF000U)
+			      | (pvtcode_cal_lpddr3[j][2] & 0x00000FFFU);
+			ddr_phy_reg_write(i, PHY_PAD_DQS_TERM, dataL);
+			dataL = (pvtcode_cal_lpddr4[j][3] & 0xFFFFF000U)
+			      | (pvtcode_cal_lpddr3[j][3] & 0x00000FFFU);
+			ddr_phy_reg_write(i, PHY_PAD_ADDR_TERM, dataL);
+			dataL = (pvtcode_cal_lpddr4[j][4] & 0xFFFFF000U)
+			      | (pvtcode_cal_lpddr3[j][4] & 0x00000FFFU);
+			ddr_phy_reg_write(i, PHY_PAD_CLK_TERM, dataL);
+			dataL = (pvtcode_cal_lpddr4[j][5] & 0xFFFFF000U)
+			      | (pvtcode_cal_lpddr3[j][5] & 0x00000FFFU);
+			ddr_phy_reg_write(i, PHY_PAD_CKE_TERM, dataL);
+			dataL = (pvtcode_cal_lpddr4[j][6] & 0xFFFFF000U)
+			      | (pvtcode_cal_lpddr3[j][6] & 0x00000FFFU);
+			ddr_phy_reg_write(i, PHY_PAD_RST_TERM, dataL);
+			dataL = (pvtcode_cal_lpddr4[j][7] & 0xFFFFF000U)
+			      | (pvtcode_cal_lpddr3[j][7] & 0x00000FFFU);
+			ddr_phy_reg_write(i, PHY_PAD_CS_TERM, dataL);
+		}
+	}
+
+/* ====== PVT_Overwrite ====== */
+	if (pvtover == 1U) {
+		DDRPHY_PVT_OVERWRITE();
+	}
+
+	for (i = 0U; i < PHY_MAX_NUM; i++) {
+		ddr_phy_reg_write(i, PHY_ADR0_CLK_WR_SLAVE_DELAY_0, cad[i]);
+		ddr_phy_reg_write(i, PHY_ADR1_CLK_WR_SLAVE_DELAY_0, cad[i]);
+		ddr_phy_reg_write(i, PHY_ADR2_CLK_WR_SLAVE_DELAY_0, cad[i]);
+		ddr_phy_reg_write(i, PHY_ADR3_CLK_WR_SLAVE_DELAY_0, cad[i]);
+		ddr_phy_reg_write(i, PHY_ADR4_CLK_WR_SLAVE_DELAY_0, cad[i]);
+		ddr_phy_reg_write(i, PHY_ADR5_CLK_WR_SLAVE_DELAY_0, cad[i]);
+		ddr_phy_reg_write(i, PHY_GRP_SLAVE_DELAY_0, grp[i]);
+		ddr_phy_reg_write(i, PHY_GRP_SLAVE_DELAY_1, grp[i]);
+		ddr_phy_reg_write(i, PHY_GRP_SLAVE_DELAY_2, grp[i]);
+		ddr_phy_reg_write(i, PHY_GRP_SLAVE_DELAY_3, grp[i]);
+	}
+
+	/* Need Handshake sequence betweed DBSC and PHY */
+
+	if (updt_wa & 0x2U) {
+		pvt_manual_update(0x0fU);
+	}
+	if (updt_wa & 0x4U) {
+		pvt_manual_update(0xf0U);
+	}
+
+
+	/* CHANGE IMPEDANCE CODE to CMOS MODE */
+	change_lpddr4_en(0xfU, 0U);
+
+	phychno = 0x0fU;
+
+
+	/* (SDRAM Initalize) */
+	mmio_write_32(DBSC_DBCMD, DBCMD_OPC_RESET /* RSX chA rkA */
+				| DBCMD_CH(phychno)
+				| DBCMD_RANK_ALL
+				| DBCMD_ARG_RESET_ASSERT);
+	WaitDBCMD();
+
+	SoftDelay(2000U); /* wait for 2msec */
+
+	mmio_write_32(DBSC_DBCMD, DBCMD_OPC_PD /* PDE chA rkA */
+				| DBCMD_CH(phychno)
+				| DBCMD_RANK_ALL
+				| DBCMD_ARG_ENTER);
+	WaitDBCMD();
+
+	mmio_write_32(DBSC_DBCMD, DBCMD_OPC_PD
+				| DBCMD_CH(phychno)
+				| DBCMD_RANK_ALL
+				| DBCMD_ARG_EXIT);
+	WaitDBCMD();
+
+	mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW /* MRW chA rkA 02:00 */
+				| DBCMD_CH(phychno)
+				| DBCMD_RANK_ALL
+				| DBCMD_ARG_MRW(0x02U, 0x00U));
+	WaitDBCMD();
+
+	mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW /* MRW chA rkA 03:31 */
+				| DBCMD_CH(phychno)
+				| DBCMD_RANK_ALL
+				| DBCMD_ARG_MRW(0x03U, 0x31U));
+	WaitDBCMD();
+
+	mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW /* MRW chA rkA 01:00 */
+				| DBCMD_CH(phychno)
+				| DBCMD_RANK_ALL
+				| DBCMD_ARG_MRW(0x01U, 0x00U));
+	WaitDBCMD();
+
+	if(phymrw & (1U<<phychno))
+	{
+		/* MRW chA rkA 0d:00 //FSPOP&FSPWP is fixed to 0, VRO off */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0DU, 0x40U));
+		WaitDBCMD();
+		
+		/* MRW DeviceFeature1
+		 * (Post=1.5tck nWR=30 RDpre=toggle WRPre=2tCK BL=16 */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x01U, 0xD4U));
+		WaitDBCMD();
+		
+		/* MRW DeviceFeature2(0,0SetA,101=WL14,110=RL32) */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x02U, 0x2EU));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW /* MRW chA rkA 03:31 */
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x03U, 0x31U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0BU, 0x36U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0CU, 0x11U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0EU, 0x11U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x16U, 0x06U));
+		WaitDBCMD();
+		
+		/* MRW chA rkA 0d:00 //FSPOP&FSPWP is fixed to 0, VRO off */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0DU, 0x00U));
+		WaitDBCMD();
+		
+		/* MRW DeviceFeature1(Post=1.5tck nWR=30 RDpre=toggle WRPre=2tCK BL=16 */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x01U, 0xD4U));
+		WaitDBCMD();
+		
+		/* MRW DeviceFeature2(0,0SetA,101=WL14,110=RL32) */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x02U, 0x2EU));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW /* MRW chA rkA 03:31 */
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x03U, 0x31U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0DU, 0x36U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0CU, 0x11U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0EU, 0x11U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x16U, 0x06U));
+		WaitDBCMD();
+	}
+		
+	SoftDelay(20U); /* wait for 2usec */
+	
+	/* MPC chA rkA 4FH (ZQCAL start) */
+	mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MPC
+				| DBCMD_CH(phychno)
+				| DBCMD_RANK_ALL
+				| DBCMD_ARG_MPC(0x4FU));
+	WaitDBCMD();
+	
+	/* MPC chA rkA 51H (ZQCAL latch) */
+	mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MPC
+				| DBCMD_CH(phychno)
+				| DBCMD_RANK_ALL
+				| DBCMD_ARG_MPC(0x51U));
+	WaitDBCMD();
+
+	change_lpddr4_en(0xfU, 1U);
+
+	/* WHEN mode==3, skip training */
+	if (mode != 3U) {
+		phytrainingok = pvt_pi_training();
+
+		if (updt_wa & 0x2U) {
+			pvt_manual_update(0x0fU);
+		}
+		if (updt_wa & 0x4U) {
+			pvt_manual_update(0xf0U);
+		}
+	} else {
+		phytrainingok = 0x0fU;
+	}
+
+	for (phychno = 0U; phychno < 4U; phychno += 1U) {
+		if ((phytrainingok & 0x0fU) == 0x0fU) {
+			phychno = 0x0fU;
+		} else {
+			if ((phytrainingok & (1U << phychno)) == 0U) {
+				continue;
+			}
+		}
+		/* MRW chA rkA 0d:00 //FSPOP&FSPWP is fixed to 0, VRO off */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0DU, 0x40U));
+		WaitDBCMD();
+
+		/* MRW DeviceFeature1(Post=1.5tck nWR=30 RDpre=toggle WRPre=2tCK BL=16 */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x01U, 0xD4U));
+		WaitDBCMD();
+		
+		/* MRW DeviceFeature2(0,0SetA,101=WL14,110=RL32) */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x02U, 0x2EU));
+		WaitDBCMD();
+
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW /* MRW chA rkA 03:31 */
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x03U, 0x31U));
+		WaitDBCMD();
+
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0BU, 0x36U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0CU, 0x11U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0EU, 0x11U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x16U, 0x06U));
+		WaitDBCMD();
+
+		/* MRW chA rkA 0d:00 //FSPOP&FSPWP is fixed to 0, VRO off */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0DU, 0x00U));
+		WaitDBCMD();
+		
+		/* MRW DeviceFeature1(Post=1.5tck nWR=30 RDpre=toggle WRPre=2tCK BL=16 */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x01U, 0xD4U));
+		WaitDBCMD();
+		
+		/* MRW DeviceFeature2(0,0SetA,101=WL14,110=RL32) */
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x02U, 0x2EU));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW /* MRW chA rkA 03:31 */
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x03U, 0x31U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0BU, 0x36U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0CU, 0x11U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x0EU, 0x11U));
+		WaitDBCMD();
+		
+		mmio_write_32(DBSC_DBCMD, DBCMD_OPC_MRW
+					| DBCMD_CH(phychno)
+					| DBCMD_RANK_ALL
+					| DBCMD_ARG_MRW(0x16U, 0x06U));
+		WaitDBCMD();
+	}
+
+	mmio_write_32(DBSC_DBBUS0CNF1, 0x70000100U);
+	mmio_write_32(DBSC_DBBUS0CNF0, DBBUS0CNF0_EXSTA(24U)
+				     | DBBUS0CNF0_EN
+				     | DBBUS0CNF0_READ_HIGH_PRIORITY);
+	
+	/* Auto Refresh setting */
+	mmio_write_32(DBSC_DBRFCNF1, DBRFCNF1_REFPMAX(8U) /* refpmax=8 */
+				   | DBRFCNF1_REFINT(6240U)); /* refint=6240 */
+	mmio_write_32(DBSC_DBRFCNF2, DBRFCNF2_REFPMIN /* refpmin=1 */
+				   | DBRFCNF2_REFINT_1_1); /* refints=0 */
+	mmio_write_32(DBSC_DBRFEN, DBRFEN_ARFEN_START);
+	
+	/* DRAM ACCESS enable */
+	mmio_write_32(DBSC_DBACEN, DBACEN_ACCEN_EN);
+
+
+}
+
+
+static void pvt_dbsc_regset(void)
+{
+	mmio_write_32(DBSC_DBPDCNT00, 0x0U);
+	mmio_write_32(DBSC_DBPDCNT10, 0x0U);
+	mmio_write_32(DBSC_DBPDCNT20, 0x0U);
+	mmio_write_32(DBSC_DBPDCNT30, 0x0U);
+	
+	/* LPDDR4-1600(CL14NoDBI),4GByte(8GBit x 4) */
+	mmio_write_32(DBSC_DBSTATE0, 0x00000010U);
+	mmio_write_32(DBSC_DBKIND, DDCG_LPDDR4); /* DRAM type LPDDR4 */
+
+	mmio_write_32(DBSC_DBBL, DBBL_BL16); /* dbbl=2(BL16) */
+
+	/* DRAM Size Registers */
+	/* Please set for 4ranks */
+	mmio_write_32(DBSC_DBMEMCONF_0_0, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_0_1, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_1_0, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_1_1, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_2_0, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_2_1, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_3_0, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_3_1, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+
+	mmio_write_32(DBSC_DBMEMCONF_0_2, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_0_3, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_1_2, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_1_3, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_2_2, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_2_3, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_3_2, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+	mmio_write_32(DBSC_DBMEMCONF_3_3, DBMEMCONF_DENS_2N
+					 | DBMEMCONF_AWRW_15
+					 | DBMEMCONF_AWBK
+					 | DBMEMCONF_AWCL_10
+					 | DBMEMCONF_DW_10);
+
+	mmio_write_32(DBSC_DBPHYCONF0, DBPHYCONF0_PHY_DFI);
+
+	/* DRAM Timing Registers */
+	mmio_write_32(DBSC_DBTR0, DBTR0_CL(32U)); /* cl=32 */
+	mmio_write_32(DBSC_DBTR1, DBTR1_CWL(14U)); /* cwl=14 */
+	mmio_write_32(DBSC_DBTR3, DBTR3_TRCD(29U)); /* trcd=29 */
+	mmio_write_32(DBSC_DBTR4, DBTR4_TRPA(5U) /* trpa=34 */
+				| DBTR4_TRP(80U)); /* trp=29 */
+	mmio_write_32(DBSC_DBTR5, DBTR5_TRC(102U)); /* trc=102 */
+	mmio_write_32(DBSC_DBTR6, DBTR6_TRAS(68U)); /* tras=68 */
+	mmio_write_32(DBSC_DBTR7, DBTR7_TRRD_S(16U) /* trrd_s=16 */
+				 | DBTR7_TRRD_S(16U)); /* trrd=16 */
+	mmio_write_32(DBSC_DBTR8, DBTR8_TFAW(64U)); /* tfaw=64 */
+	mmio_write_32(DBSC_DBTR9, DBTR9_TRDPR(12U)); /* trdpr=12 */
+	mmio_write_32(DBSC_DBTR10, DBTR10_TWR(30U)); /* twr=30 */
+	mmio_write_32(DBSC_DBTR11, DBTR11_TWRTWR(80U)); /* trdwr=18 */
+	mmio_write_32(DBSC_DBTR12, DBTR12_TWRRD_S(80U) /* twrrd_s=20 */
+				 | DBTR12_TWRRD(80U)); /* twrrd=20 */
+	mmio_write_32(DBSC_DBTR13, DBTR13_TRFCPB(144U)
+				 | DBTR13_TRFC_TRFCAB(288U));
+	mmio_write_32(DBSC_DBTR14, DBTR14_TCKEHDLL(12U) /* tckehdll=12 */
+				 | DBTR14_TCKEH(12U)); /* tckeh=12 */
+	mmio_write_32(DBSC_DBTR15, DBTR15_TCKESR(30U) /* tckesr=30 */
+				 | DBTR15_TCKEL(12U)); /* tckel=12 */
+	
+	mmio_write_32(DBSC_DBTR16, DBTR16_DQIENLTNCY(16U)
+				 | DBTR16_DQL(64U)
+				 | DBTR16_DQENLTNCY(12U)
+				 | DBTR16_WDQL(14U));
+	mmio_write_32(DBSC_DBTR17, DBTR17_TMODRD(8U) /* tmodrd=8 */
+				 | DBTR17_TMOD(10U) /* tmod=10 */
+				 | DBTR17_TRDMR(4U)); /* trdmr=4 */
+	mmio_write_32(DBSC_DBTR18, DBTR18_RODTL(0U)
+				 | DBTR18_RODTA(0U)
+				 | DBTR18_WODTL(0U)
+				 | DBTR18_WODTA(0U));
+	mmio_write_32(DBSC_DBTR19, DBTR19_TZQCL(0U) /* tzqcl=0 */
+				 | DBTR19_TZQCS(0U)); /* tzqcs=0 */
+	mmio_write_32(DBSC_DBTR20, DBTR20_TXSDLL(220U) /* txsdll=trfc+12=220 */
+				 | DBTR20_TXS(220U)); /* txs=220 */
+	mmio_write_32(DBSC_DBTR21, DBTR21_TCCD_S(16U) /* tccd_s=8 */
+				 | DBTR21_TCCD(16U)); /* tccd=8 */
+	mmio_write_32(DBSC_DBTR22, DBTR22_TZQCAL(1600U) /* tzqcal=1600 */
+				 | DBTR22_TZQLAT(48U)); /* tzqlat=48 */
+
+	mmio_write_32(DBSC_DBRNK0, 0x00000000U);
+	mmio_write_32(DBSC_DBRNK1, DBRNK1_RKRP(0U)
+				 | DBRNK1_RKRF(0U));
+	mmio_write_32(DBSC_DBRNK2, DBRNK2_RKRR7(0U) /* rkrr=8 */
+				 | DBRNK2_RKRR6(0U)
+				 | DBRNK2_RKRR5(0U)
+				 | DBRNK2_RKRR4(0U)
+				 | DBRNK2_RKRR3(8U)
+				 | DBRNK2_RKRR2(8U)
+				 | DBRNK2_RKRR1(8U)
+				 | DBRNK2_RKRR0(8U));
+	mmio_write_32(DBSC_DBRNK3, DBRNK3_RKRW7(0U) /* rkrw=8 */
+				 | DBRNK3_RKRW6(0U)
+				 | DBRNK3_RKRW5(0U)
+				 | DBRNK3_RKRW4(0U)
+				 | DBRNK3_RKRW3(8U)
+				 | DBRNK3_RKRW2(8U)
+				 | DBRNK3_RKRW1(8U)
+				 | DBRNK3_RKRW0(8U));
+	mmio_write_32(DBSC_DBRNK4, DBRNK4_RKWR7(0U) /* rkwr=8 */
+				 | DBRNK4_RKWR6(0U)
+				 | DBRNK4_RKWR5(0U)
+				 | DBRNK4_RKWR4(0U)
+				 | DBRNK4_RKWR3(8U)
+				 | DBRNK4_RKWR2(8U)
+				 | DBRNK4_RKWR1(8U)
+				 | DBRNK4_RKWR0(8U));
+	mmio_write_32(DBSC_DBRNK5, DBRNK5_RKWW7(0U) /* rkwww=8 */
+				 | DBRNK5_RKWW6(0U)
+				 | DBRNK5_RKWW5(0U)
+				 | DBRNK5_RKWW4(0U)
+				 | DBRNK5_RKWW3(8U)
+				 | DBRNK5_RKWW2(8U)
+				 | DBRNK5_RKWW1(8U)
+				 | DBRNK5_RKWW0(8U));
+	mmio_write_32(DBSC_DBRNK6, DBRNK6_REFMODE_ALL); /* Use ALL Rank */
+	mmio_write_32(DBSC_DBADJ0, DBADJ0_CAMODE_1_CLK);
+	mmio_write_32(DBSC_DBADJ2, 0x00000000U);
+
+	/* BUFCAM settings */
+	mmio_write_32(DBSC_DBCAM0CNF0, 0x00000000U);
+	mmio_write_32(DBSC_DBCAM0CNF1, DBCAM0CNF1_WBKWAIT(8U) /* wbkwait=8 */
+				     | DBCAM0CNF1_SWPINPRI3(2U)
+				     | DBCAM0CNF1_SWPINPRI2(0U)
+				     | DBCAM0CNF1_SWPINPRI1(1U)
+				     | DBCAM0CNF1_SWPINPRI1F(0U));
+	mmio_write_32(DBSC_DBCAM0CNF2, 0x00002000U
+				     | DBCAM0CNF2_FILLUNIT_64
+				     | DBCAM0CNF2_FCDIRTYMAX(0U)
+				     | DBCAM0CNF2_FCDIRTYMIN(0U));
+	mmio_write_32(DBSC_DBCAM0CNF3, DBCAM0CNF3_RDFULL(24U));
+	mmio_write_32(DBSC_DBSCHSZ0, DBSCHCNT0_SCWBPRI_3
+				   | DBSCHCNT0_SCQTZEN_3
+				   | DBSCHCNT0_SCQTZEN_2
+				   | DBSCHCNT0_SCQTZEN_1
+				   | DBSCHCNT0_SCQTZEN_0
+				   | DBSCHCNT0_SCSZEN_EN
+				   | DBSCHCNT0_SCBAEN_EN
+				   | (uint32_t)0x08U
+				   | DBSCHCNT0_SCPGEN_EN
+				   | DBSCHCNT0_SCRWEN_EN
+				   | DBSCHCNT0_SCQOSEN_EN);
+	mmio_write_32(DBSC_DBSCHCNT1, DBSCHCNT1_SCHCH3(1U)
+				    | DBSCHCNT1_SCHCH2(0U)
+				    | DBSCHCNT1_SCHCH1(1U)
+				    | DBSCHCNT1_SCHCH0(0U));
+	mmio_write_32(DBSC_DBSCHSZ0, DBSCHSZ0_SZTH(1U));
+	mmio_write_32(DBSC_DBSCHRW0, 0x00000100U);
+	mmio_write_32(DBSC_DBSCHRW1, DBSCHRW1_SCBADEC(0U)
+				   | DBSCHRW1_RWWTPERI(0x40U));
+	
+	/* QoS Settings */
+	mmio_write_32(DBSC_DBSCHQOS_4_0,  0x00000600U);
+	mmio_write_32(DBSC_DBSCHQOS_4_1,  0x00000480U);
+	mmio_write_32(DBSC_DBSCHQOS_4_2,  0x00000300U);
+	mmio_write_32(DBSC_DBSCHQOS_4_3,  0x00000180U);
+	mmio_write_32(DBSC_DBSCHQOS_9_0,  0x00000400U);
+	mmio_write_32(DBSC_DBSCHQOS_9_1,  0x00000300U);
+	mmio_write_32(DBSC_DBSCHQOS_9_2,  0x00000200U);
+	mmio_write_32(DBSC_DBSCHQOS_9_3,  0x00000100U);
+	mmio_write_32(DBSC_DBSCHQOS_13_0, 0x00000300U);
+	mmio_write_32(DBSC_DBSCHQOS_13_1, 0x00000240U);
+	mmio_write_32(DBSC_DBSCHQOS_13_2, 0x00000180U);
+	mmio_write_32(DBSC_DBSCHQOS_13_3, 0x000000C0U);
+	mmio_write_32(DBSC_DBSCHQOS_14_0, 0x00000200U);
+	mmio_write_32(DBSC_DBSCHQOS_14_1, 0x00000180U);
+	mmio_write_32(DBSC_DBSCHQOS_14_2, 0x00000100U);
+	mmio_write_32(DBSC_DBSCHQOS_14_3, 0x00000080U);
+	mmio_write_32(DBSC_DBSCHQOS_15_0, 0x00000100U);
+	mmio_write_32(DBSC_DBSCHQOS_15_1, 0x000000C0U);
+	mmio_write_32(DBSC_DBSCHQOS_15_2, 0x00000080U);
+	mmio_write_32(DBSC_DBSCHQOS_15_3, 0x00000040U);
+	
+	/* dbsysconf1 freqratio=2. */
+	mmio_write_32(DBSC_DBSYSCONF1, DBSYSCONF1_FREQRATIO_1_4);
+	
+	/* Under Verification */
+	/* wbkwait(0004), wbkmdhi(4,2),wbkmdlo(1,8) */
+	mmio_write_32(DBSC_DBCAM0CNF1, DBCAM0CNF1_WBKWAIT(4U)
+				     | DBCAM0CNF1_SWPINPRI3(4U)
+				     | DBCAM0CNF1_SWPINPRI2(2U)
+				     | DBCAM0CNF1_SWPINPRI1(1U)
+				     | DBCAM0CNF1_SWPINPRI1F(8U));
+	/* rg_scexp[15:0] 0,0(fillunit),8(dirtymax),4(dirtymin) */
+	mmio_write_32(DBSC_DBCAM0CNF2, DBCAM0CNF2_FILLUNIT_256
+				     | DBCAM0CNF2_FCDIRTYMAX(8U)
+				     | DBCAM0CNF2_FCDIRTYMIN(4U));
+	mmio_write_32(DBSC_DBSCHRW0, 0xF7311111U);
+	mmio_write_32(DBSC_DBSCHRW1, DBSCHRW1_SCBADEC(0U)
+				   | DBSCHRW1_RWWTPERI(52U));
+	mmio_write_32(DBSC_DBSCTR0, 0x1A0C1608U);
+	mmio_write_32(DBSC_DBSCTR1, 0x0809070CU);
+	mmio_write_32(DBSC_DBSCHRW2, 0x111F1FFFU);
+}
+
+static void pvt_manual_update(uint32_t flag)
+{
+	if (flag & 0x1U) {
+		ddr_phy_reg_write(0U, SC_PHY_MANUAL_UPDATE, 1U);
+	}
+	if (flag & 0x2U) {
+		ddr_phy_reg_write(1U, SC_PHY_MANUAL_UPDATE, 1U);
+	}
+	if (flag & 0x4U) {
+		ddr_phy_reg_write(2U, SC_PHY_MANUAL_UPDATE, 1U);
+	}
+	if (flag & 0x8U) {
+		ddr_phy_reg_write(3U, SC_PHY_MANUAL_UPDATE, 1U);
+	}
+	
+	if (flag & 0x10U) {
+		ddr_phy_reg_write(0U, PHY_ADRCTL_MANUAL_UPDATE, 1U);
+	}
+	if (flag & 0x20U) {
+		ddr_phy_reg_write(1U, PHY_ADRCTL_MANUAL_UPDATE, 1U);
+	}
+	if (flag & 0x40U) {
+		ddr_phy_reg_write(2U, PHY_ADRCTL_MANUAL_UPDATE, 1U);
+	}
+	if (flag & 0x80U) {
+		ddr_phy_reg_write(3U, PHY_ADRCTL_MANUAL_UPDATE, 1U);
+	}
+}
+
+
+static void pvt_freq_change_ack(uintptr_t phychno, uint32_t freq_flag)
+{
+	/* DFI FREQ */
+	mmio_write_32(DBSC_DBPDCNT01 + (0x40U * phychno), freq_flag);
+
+	/* FREQ CHANGE ACK */
+	mmio_write_32(DBSC_DBPDCNT02 + (0x40U * phychno), 0x0CF20000U);
+	mmio_write_32(DBSC_DBPDCNT02 + (0x40U * phychno), 0x00000000U);
+}
+
+static uint32_t pvt_pi_training_go_all(void)
+{
+	uint32_t dataL;
+	uint32_t phytrainingok;
+	uint32_t retry;
+	uint32_t pll_status[4] = {0U, 0U, 0U, 0U};
+	uint32_t wait_count[4];
+	uintptr_t phychno;
+
+	uint32_t init_start_deassert = 0U;
+
+	if (init_start_deassert == 0U) {
+		for (phychno = 0U; phychno < 4U; phychno++) {
+			/* dfi_init_start negate */
+			mmio_write_32(DBSC_DBDFICNT(phychno),
+					   DBDFICNT_DFIBYTEDIS(0U)
+					 | DBDFICNT_DFICLKDIS(0U)
+					 | DBDFICNT_DFIFREQRATIO_1_2);
+		}
+	}
+
+	for (phychno = 0U; phychno < 4U; phychno++) {
+/*		ddr_phy_reg_rawwrite(phychno, 0x200, 0x00000200U); */
+		ddr_phy_reg_write(phychno, PI_START, 1U);
+		if (init_start_deassert == 1U) {
+			/* dfi_init_start negate */
+			mmio_write_32(DBSC_DBDFICNT(phychno),
+					   DBDFICNT_DFIBYTEDIS(0U)
+					 | DBDFICNT_DFICLKDIS(0U)
+					 | DBDFICNT_DFIFREQRATIO_1_2);
+		}
+	}
+	/* Report_DDRPHY_Check_BIST_PLL_LOCK (); */
+	SoftDelay(20U); /* wait for 2usec */
+
+	if (init_start_deassert == 2U) {
+		for (phychno = 0U; phychno < 4U; phychno++) {
+			/* dfi_init_start negate */
+			mmio_write_32(DBSC_DBDFICNT(phychno),
+					   DBDFICNT_DFIBYTEDIS(0U)
+					 | DBDFICNT_DFICLKDIS(0U)
+					 | DBDFICNT_DFIFREQRATIO_1_2);
+		}
+	}
+
+	phytrainingok = 0U;
+	retry = 0U;
+
+	/* 0 : wait first unlock */
+	/* 1 : pll is off */
+	/* 2 : pll is on */
+
+	pll_status[0] = 0U; /* wait unlock */
+	pll_status[1] = 0U; /* wait unlock */
+	pll_status[2] = 0U; /* wait unlock */
+	pll_status[3] = 0U; /* wait unlock */
+
+	while (1) {
+		for (phychno = 0U; phychno < 4U; phychno++) {
+			if ((phytrainingok & (1U << phychno)) == 1U) {
+				continue;
+			}
+
+			if (pll_status[phychno] == 0U) {
+				dataL = mmio_read_32(DBSC_PLL_LOCK(phychno)); /* Wait for PLL is unlock */
+				if ((dataL & 0x0000001FU) == 0x0U) {
+					pll_status[phychno] = 1U;
+					wait_count[phychno] = 1000U;
+
+					pvt_freq_change_ack(phychno, 0U);
+					retry = 0U;
+				}
+			} else if (pll_status[phychno] == 1U) {
+				dataL = mmio_read_32(DBSC_PLL_LOCK(phychno)); /* Wait for PLL is unlock */
+				if ((dataL & 0x0000001FU) == 0x1FU) {
+					pll_status[phychno] = 2U;
+					wait_count[phychno] = 1000U;
+					retry = 0U;
+				} else {
+					wait_count[phychno]--;
+					if (wait_count[phychno] == 0U) {
+						pvt_freq_change_ack(phychno,
+								2U);
+						wait_count[phychno] = 1000U;
+						retry = 0U;
+					}
+				}
+			} else {
+				if (wait_count[phychno] > 0U) {
+					wait_count[phychno]--;
+					dataL = ddr_phy_reg_read(phychno,
+								 PI_INT_STATUS);
+					if (dataL & 0x1U) {
+						phytrainingok |= (0x1U
+								<< phychno);
+						retry = 0U; /* TRAING OK */
+					}
+				} else {
+					dataL = mmio_read_32( /* Check PLL is unlock again */
+							DBSC_PLL_LOCK(phychno));
+					if ((dataL & 0x0000001FU) == 0x00U) {
+						pll_status[phychno] = 1U;
+						pvt_freq_change_ack(phychno,
+								0U);
+						wait_count[phychno] = 1000U;
+						retry = 0U;
+					} else {
+						wait_count[phychno] = 1000U;
+					}
+				}
+			}
+		}
+		
+		if ((phytrainingok & 0xfU) == 0xfU) {
+			break;
+		}
+		retry++;
+		if (retry == 10000U) {
+			break;
+		}
+	}
+
+	for (phychno = 0U; phychno < 4U; phychno++) {
+		(void)ddr_phy_reg_read(0U, PI_INT_STATUS);
+	}
+
+	return phytrainingok;
+}
+
+static uint32_t pvt_pi_training(void)
+{
+	uintptr_t phychno;
+	uint32_t phytrainingok = 0U;
+	uint32_t i, j;
+	uint32_t dataL;
+
+	if (0) {
+		for (phychno = 0U; phychno < 4U; phychno++) {
+		}
+
+		dataL = ddr_phy_reg_read(0U, PI_INT_STATUS);
+		if (dataL & 0x1U) {
+			phytrainingok |= 0x1U;
+		}
+		dataL = ddr_phy_reg_read(1U, PI_INT_STATUS);
+		if (dataL & 0x1U) {
+			phytrainingok |= 0x2U;
+		}
+		
+		dataL = ddr_phy_reg_read(2U, PI_INT_STATUS);
+		if (dataL & 0x1U) {
+			phytrainingok |= 0x4U;
+		}
+		dataL = ddr_phy_reg_read(3U, PI_INT_STATUS);
+		if (dataL & 0x1U) {
+			phytrainingok |= 0x8U;
+		}
+
+		
+		/* FREQ_SEL_INDEX=3 (not needed? because MULTICAST_EN=1)
+		 * ==> NEED!! otherwise, copy will not copy */
+		ddr_phy_reg_write(0U, PHY_FREQ_SEL_INDEX, 3U);
+		ddr_phy_reg_write(1U, PHY_FREQ_SEL_INDEX, 3U);
+		ddr_phy_reg_write(2U, PHY_FREQ_SEL_INDEX, 3U);
+		ddr_phy_reg_write(3U, PHY_FREQ_SEL_INDEX, 3U);
+		
+		copy_dqdelay(1U, 1U, 2U); /* ch1 2:0:1:3 */
+		copy_dqdelay(1U, 3U, 0U);
+		copy_dqdelay(2U, 1U, 3U); /* ch2 3:1:2:0 */
+		copy_dqdelay(2U, 2U, 0U);
+		copy_dqdelay(3U, 1U, 3U); /* ch3 3:1:2:0 */
+		copy_dqdelay(3U, 2U, 0U);
+	
+		for (phychno = 0U; phychno < 4U; phychno++) {
+			for (i = 0U; i < ARRAY_SIZE(dqdelay_tbl[0]); i++) {
+				for (j = 0U; j < 4U; j++) {
+					dataL = ddr_phy_reg_read(phychno,
+							dqdelay_tbl[j][i]);
+				}
+			}
+		}
+
+	} else {
+		phytrainingok = pvt_pi_training_go_all();
+		for (phychno = 0U; phychno < 4U; phychno++) {
+		}
+
+		/* FREQ_SEL_INDEX=3 (not needed? because MULTICAST_EN=1)
+		 * ==> NEED!! otherwise, copy will not copy */
+		ddr_phy_reg_write(0U, PHY_FREQ_SEL_INDEX, 3U);
+		ddr_phy_reg_write(1U, PHY_FREQ_SEL_INDEX, 3U);
+		ddr_phy_reg_write(2U, PHY_FREQ_SEL_INDEX, 3U);
+		ddr_phy_reg_write(3U, PHY_FREQ_SEL_INDEX, 3U);
+		
+		copy_dqdelay(1U, 1U, 2U); /* ch1 2:0:1:3 */
+		copy_dqdelay(1U, 3U, 0U);
+		copy_dqdelay(2U, 1U, 3U); /* ch2 3:1:2:0 */
+		copy_dqdelay(2U, 2U, 0U);
+		copy_dqdelay(3U, 1U, 3U); /* ch3 3:1:2:0 */
+		copy_dqdelay(3U, 2U, 0U);
+	}
+
+	return phytrainingok;
+}
+
+static void WaitDBCMD(void)
+{
+	uint32_t dataL;
+
+	while (1) {
+		dataL = mmio_read_32(DBSC_DBWAIT);
+		if ((dataL & 0x00000001U) == 0x0U) {
+			break;
+		}
+	}
+}
+
+static void DDRPHY_PVT_OVERWRITE(void)
+{
+	uint32_t j;
+	uint32_t dataL;
+	uint32_t pvtcode[4][3] = {{0x10U, 0x20U, 0x20U},
+				  {0x10U, 0x20U, 0x20U},
+				  {0x10U, 0x20U, 0x20U},
+				  {0x10U, 0x20U, 0x20U}};
+	
+	for (j = 0U; j < PHY_MAX_NUM ; j++) {
+		dataL = ddr_phy_reg_read(j, PHY_PAD_FDBK_TERM);
+		dataL = (dataL & 0xfffe0000U) | ((pvtcode[j][0] << 12U)
+					      |  (pvtcode[j][1] <<  6U)
+					      |  (pvtcode[j][2] <<  0U));
+		ddr_phy_reg_write(j, PHY_PAD_FDBK_TERM, dataL);
+		dataL = ddr_phy_reg_read(j, PHY_PAD_DATA_TERM);
+		dataL = (dataL & 0xfffe0000U) | ((pvtcode[j][0] << 12U)
+					      |  (pvtcode[j][1] <<  6U)
+					      |  (pvtcode[j][2] <<  0U));
+		ddr_phy_reg_write(j, PHY_PAD_DATA_TERM, dataL);
+		dataL = ddr_phy_reg_read(j, PHY_PAD_DQS_TERM);
+		dataL = (dataL & 0xfffe0000U) | ((pvtcode[j][0] << 12U)
+					      |  (pvtcode[j][1] <<  6U)
+					      |  (pvtcode[j][2] <<  0U));
+		ddr_phy_reg_write(j, PHY_PAD_DQS_TERM,  dataL);
+		dataL = ddr_phy_reg_read(j, PHY_PAD_ADDR_TERM);
+		dataL = (dataL & 0xfffe0000U) | ((pvtcode[j][0] << 12U)
+					      |  (pvtcode[j][1] <<  6U)
+					      |  (pvtcode[j][2] <<  0U));
+		ddr_phy_reg_write(j, PHY_PAD_ADDR_TERM, dataL);
+		dataL = ddr_phy_reg_read(j, PHY_PAD_CLK_TERM);
+		dataL = (dataL & 0xfffe0000U) | ((pvtcode[j][0] << 12U)
+					      |  (pvtcode[j][1] <<  6U)
+					      |  (pvtcode[j][2] <<  0U));
+		ddr_phy_reg_write(j, PHY_PAD_CLK_TERM,  dataL);
+		dataL = ddr_phy_reg_read(j, PHY_PAD_CKE_TERM);
+		dataL = (dataL & 0xfffe0000U) | ((pvtcode[j][0] << 12U)
+					      |  (pvtcode[j][1] <<  6U)
+					      |  (pvtcode[j][2] <<  0U));
+		ddr_phy_reg_write(j, PHY_PAD_CKE_TERM,  dataL);
+		dataL = ddr_phy_reg_read(j, PHY_PAD_RST_TERM);
+		dataL = (dataL & 0xfffe0000U) | ((pvtcode[j][0] << 12U)
+					      |  (pvtcode[j][1] <<  6U)
+					      |  (pvtcode[j][2] <<  0));
+		ddr_phy_reg_write(j, PHY_PAD_RST_TERM,  dataL);
+		dataL = ddr_phy_reg_read(j, PHY_PAD_CS_TERM);
+		dataL = (dataL & 0xfffe0000U) | ((pvtcode[j][0] << 12U)
+					      |  (pvtcode[j][1] <<  6U)
+					      |  (pvtcode[j][2] <<  0U));
+		ddr_phy_reg_write(j, PHY_PAD_CS_TERM, dataL);
+	}
+}
+
+
+static void change_lpddr4_en(uintptr_t phychno, uint32_t mode)
+{
+	uint32_t i, from, to;
+	uint32_t set, clr;
+	uint32_t dataL;
+	uint32_t lpddr4_en_off_first = 0x2U;
+
+	if (lpddr4_en_off_first == 0U) {
+		return;
+	}
+
+	if (phychno >= 4U) {
+		from = 0U;
+		to = 3U;
+	} else {
+		from = phychno;
+		to = phychno;
+	}
+	
+
+	for (i = from; i <= to; i++) {
+		if (lpddr4_en_off_first == 1U) {
+			set = 1U << 14U;
+			clr = ~set;
+			if (!mode) {
+				set = 0U;
+			}
+			dataL = ddr_phy_reg_read(i, PHY_PAD_ADDR_DRIVE);
+			dataL = (dataL & clr) | set;
+			ddr_phy_reg_write(i, PHY_PAD_ADDR_DRIVE, dataL);
+			dataL = ddr_phy_reg_read(i, PHY_PAD_CLK_DRIVE);
+			dataL = (dataL & clr) | set;
+			ddr_phy_reg_write(i, PHY_PAD_CLK_DRIVE, dataL);
+			dataL = ddr_phy_reg_read(i, PHY_PAD_CKE_DRIVE);
+			dataL = (dataL & clr) | set;
+			ddr_phy_reg_write(i, PHY_PAD_CKE_DRIVE, dataL);
+			dataL = ddr_phy_reg_read(i, PHY_PAD_CS_DRIVE);
+			dataL = (dataL & clr) | set;
+			ddr_phy_reg_write(i, PHY_PAD_CS_DRIVE, dataL);
+		} else {
+			if (mode) {
+				ddr_phy_reg_write(i,
+						PHY_PAD_ADDR_DRIVE, 0x27F6EU);
+				ddr_phy_reg_write(i,
+						PHY_PAD_CLK_DRIVE,  0x47F6EU);
+				ddr_phy_reg_write(i,
+						PHY_PAD_CKE_DRIVE,  0x27F6EU);
+				ddr_phy_reg_write(i,
+						PHY_PAD_CS_DRIVE,   0x27F6EU);
+			} else {
+				ddr_phy_reg_write(i,
+						PHY_PAD_ADDR_DRIVE, 0x27B22U);
+				ddr_phy_reg_write(i,
+						PHY_PAD_CLK_DRIVE,  0x47B22U);
+				ddr_phy_reg_write(i,
+						PHY_PAD_CKE_DRIVE,  0x27B22U);
+				ddr_phy_reg_write(i,
+						PHY_PAD_CS_DRIVE,   0x27B22U);
+			}
+		}
+	}
+
+}
+
+
+static void copy_dqdelay(uintptr_t phychno, uint32_t s_byte, uint32_t d_byte)
+{
+	uint32_t i;
+	uint32_t s_dataL;
+
+	/* 43A-43E:PHY_CLK_WRDQx_SLAVE_DELAY_0 */
+	/* 43F-442:PHY_RDDQx_SLAVE_DELAY_0 */
+	/* 443-44B:PHY_RDDQS_DQx_FALL_SLAVE_DELAY_0 */
+
+	for (i = 0U; i < ARRAY_SIZE(dqdelay_tbl[0]); i++) {
+		s_dataL = ddr_phy_reg_read(phychno, dqdelay_tbl[s_byte][i]);
+		ddr_phy_reg_write(phychno, dqdelay_tbl[d_byte][i], s_dataL);
+	}
+}
+
+
+#ifdef DEBUG_SDRA_REG_PRINT
+static void print_dbsc4_reg(uint32_t address)
+{
+	uint32_t data;
+
+	data = mmio_read_32((uintptr_t)address);
+	tf_printf("addr = 0x%x, data = 0x%x\n", address, data);
+}
+#endif /* DEBUG_SDRA_REG_PRINT */
+
+
+#ifdef DEBUG_SDRA_REG_PRINT
+static void print_phy_reg(uint32_t address)
+{
+	uint32_t data0;
+	uint32_t data1;
+	uint32_t data2;
+	uint32_t data3;
+
+	mmio_write_32(DBSC_DBPDRGA_0, address);
+	mmio_write_32(DBSC_DBPDRGA_1, address);
+	mmio_write_32(DBSC_DBPDRGA_2, address);
+	mmio_write_32(DBSC_DBPDRGA_3, address);
+
+	data0 = mmio_read_32(DBSC_DBPDRGA_0);
+	data1 = mmio_read_32(DBSC_DBPDRGA_1);
+	data2 = mmio_read_32(DBSC_DBPDRGA_2);
+	data3 = mmio_read_32(DBSC_DBPDRGA_3);
+
+	tf_printf("addr = 0x%x, data = 0x%x 0x%x 0x%x 0x%x\n",
+			address, data0, data1, data2, data3);
+}
+#endif /* DEBUG_SDRA_REG_PRINT */
+
+
+#ifdef DEBUG_SDRA_REG_PRINT
+static void print_regs(void)
+{
+	uint32_t i;
+	uint32_t m;
+	uint32_t n;
+	uint32_t p;
+	uint32_t q;
+	uint32_t md;
+	uint32_t init_phy_num;
+	uint32_t init_pi_num;
+
+	print_dbsc4_reg(DBSC_DBSYSCONF0);
+	print_dbsc4_reg(DBSC_DBSYSCONF1);
+	print_dbsc4_reg(DBSC_DBPHYCONF0);
+	print_dbsc4_reg(DBSC_DBKIND);
+
+	for (m = 0U; m < 3U; m++) {
+		for (n = 0U; n < 3U; n++) {
+			print_dbsc4_reg(DBSC_DBMEMCONF_0_0
+					+ (m * 0x10U)
+					+ (n * 0x04U)
+					+ 0x30U);
+		}
+	}
+
+	print_dbsc4_reg(DBSC_DBINTEN);
+	print_dbsc4_reg(DBSC_DBINTSTAT0);
+	print_dbsc4_reg(DBSC_DBACEN);
+	print_dbsc4_reg(DBSC_DBRFEN);
+	print_dbsc4_reg(DBSC_DBWAIT);
+	print_dbsc4_reg(DBSC_DBSYSCTRL0);
+
+	for (i = 0U; i < 23U; i++) {
+		print_dbsc4_reg(DBSC_DBTR0 + (i * 4U));
+	}
+
+	print_dbsc4_reg(DBSC_DBBL);
+	print_dbsc4_reg(DBSC_DBRFCNF1);
+	print_dbsc4_reg(DBSC_DBRFCNF2);
+	print_dbsc4_reg(DBSC_DBRFCNF3);
+	print_dbsc4_reg(DBSC_DBTSPCNF);
+	print_dbsc4_reg(DBSC_DBCALCNF);
+	print_dbsc4_reg(DBSC_DBCALTR);
+
+	for (i = 0U; i < 6U; i++) {
+		print_dbsc4_reg(DBSC_DBRNK0 + (i * 4U));
+	}
+
+	print_dbsc4_reg(DBSC_DBPDNCNF);
+
+	for (p = 0U; p < 7U; p++) {
+		print_dbsc4_reg(DBSC_DBODT0 + (p * 4U));
+	}
+
+	print_dbsc4_reg(DBSC_DBMRRDR);
+	print_dbsc4_reg(DBSC_DBTSPDR);
+	print_dbsc4_reg(DBSC_DBADJ0);
+	print_dbsc4_reg(DBSC_DBADJ2);
+	print_dbsc4_reg(DBSC_DBDBICNT);
+	print_dbsc4_reg(DBSC_DBDFIPMSTRCNF);
+	print_dbsc4_reg(DBSC_DBDFIPMSTRSTAT);
+	print_dbsc4_reg(DBSC_DBDFILPCNF);
+
+	for (m = 0U; m < 3U; m++) {
+		print_dbsc4_reg(DBSC_DBDFISTAT0 + (m * 0x40U));
+		print_dbsc4_reg(DBSC_DBDFICNT_0 + (m * 0x40U));
+		print_dbsc4_reg(DBSC_DBPDCNT00 + (m * 0x40U));
+		print_dbsc4_reg(DBSC_DBPDCNT01 + (m * 0x40U));
+		print_dbsc4_reg(DBSC_DBPDCNT02 + (m * 0x40U));
+		print_dbsc4_reg(DBSC_DBPDCNT03 + (m * 0x40U));
+		print_dbsc4_reg(DBSC_DBPDLK_0 + (m * 0x40U));
+	}
+
+	print_dbsc4_reg(DBSC_DBBUS0CNF0);
+	print_dbsc4_reg(DBSC_DBBUS0CNF1);
+	print_dbsc4_reg(DBSC_DBCAM0CNF0);
+	print_dbsc4_reg(DBSC_DBCAM0CNF1);
+	print_dbsc4_reg(DBSC_DBCAM0CNF2);
+	print_dbsc4_reg(DBSC_DBBCAMSWAP);
+	print_dbsc4_reg(DBSC_DBBCAMDIS);
+	print_dbsc4_reg(DBSC_DBSCHCNT0);
+	print_dbsc4_reg(DBSC_DBSCHCNT1);
+	print_dbsc4_reg(DBSC_DBSCHSZ0);
+	print_dbsc4_reg(DBSC_DBSCHRW0);
+	print_dbsc4_reg(DBSC_DBSCHRW1);
+
+	for (q = 0U; q < 15U; q++) {
+		print_dbsc4_reg(DBSC_DBSCHQOS_0_0 + (q * 0x10U));
+		print_dbsc4_reg(DBSC_DBSCHQOS_0_1 + (q * 0x10U));
+		print_dbsc4_reg(DBSC_DBSCHQOS_0_2 + (q * 0x10U));
+		print_dbsc4_reg(DBSC_DBSCHQOS_0_3 + (q * 0x10U));
+	}
+
+	for (m = 0U; m < 3U; m++) {
+		print_dbsc4_reg(DBSC_DBMRRDR0 + (m * 0x04U));
+		print_dbsc4_reg(DBSC_DBDTMP0 + (m * 0x04U));
+	}
+
+	for (m = 0U; m < 3U; m++) {
+		print_dbsc4_reg(DBSC_DBDQSOSC00 + (m * 0x08U));
+		print_dbsc4_reg(DBSC_DBDQSOSC01 + (m * 0x08U));
+	}
+	for (m = 0U; m < 3U; m++) {
+		print_dbsc4_reg(DBSC_DBOSCTHH00 + (m * 0x08U));
+		print_dbsc4_reg(DBSC_DBOSCTHH01 + (m * 0x08U));
+	}
+	for (m = 0U; m < 3U; m++) {
+		print_dbsc4_reg(DBSC_DBOSCTHL00 + (m * 0x08U));
+		print_dbsc4_reg(DBSC_DBOSCTHL01 + (m * 0x08U));
+	}
+
+	print_dbsc4_reg(DBSC_DBFSFCONF0);
+
+
+	md = (mmio_read_32(RST_MODEMR));
+	if ((uint32_t)(md & MODEMR_DDR_CLOCK_MASK) == MODEMR_DDR_CLOCK_3200) {
+		init_phy_num = INIT_DRAM_TBL_PHY_3200_NUM; /* MD19=0,MD17=0 */
+		init_pi_num = INIT_DRAM_TBL_PI_3200_NUM;
+	} else {
+		init_phy_num = INIT_DRAM_TBL_PHY_1600_NUM; /* MD19=0,MD17=0 */
+		init_pi_num = INIT_DRAM_TBL_PI_1600_NUM;
+	}
+
+	for (i = 0U; i < init_phy_num; i++) {
+		print_phy_reg(INIT_DRAM_TBL_PHY_START + i);
+	}
+
+	for (i = 0U; i < init_pi_num; i++) {
+		print_phy_reg(INIT_DRAM_TBL_PI_3200_NUM + i);
+	}
+}
+#endif /* DEBUG_SDRA_REG_PRINT */
+
+
diff --git a/plat/renesas/rcar/bl2_secure_setting.c b/plat/renesas/rcar/bl2_secure_setting.c
new file mode 100644
index 0000000..fd2a800
--- /dev/null
+++ b/plat/renesas/rcar/bl2_secure_setting.c
@@ -0,0 +1,468 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "bl2_lifec_register.h"
+#include "bl2_axi_register.h"
+#include "bl2_secure_setting.h"
+#include "mmio.h"
+
+typedef struct {
+	uint32_t	adr;
+	uint32_t	val;
+} reg_setting_t;
+
+static const reg_setting_t lifec_reg_setting[] = {
+
+	/* LIFEC0 (SECURITY) settings */
+
+	/* Security attribute setting for master ports */
+	{SEC_SRC,		0x0000001EU},
+	/** Security attribute setting for slave ports 0 */
+	{SEC_SEL0,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 1 */
+	{SEC_SEL1,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 2 */
+	{SEC_SEL2,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 3 */
+	{SEC_SEL3,		0xFFF7FDFFU},
+	/** Security attribute setting for slave ports 4 */
+	{SEC_SEL4,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 5 */
+	{SEC_SEL5,		0xFFFFFFBFU},
+	/** Security attribute setting for slave ports 6 */
+	{SEC_SEL6,		0xFFFFDBFFU},
+	/** Security attribute setting for slave ports 7 */
+	{SEC_SEL7,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 8 */
+	{SEC_SEL8,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 9 */
+	{SEC_SEL9,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 10 */
+	{SEC_SEL10,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 11 */
+	{SEC_SEL11,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 12 */
+	{SEC_SEL12,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 13 */
+	{SEC_SEL13,		0xFFBFFFEFU},
+	/** Security attribute setting for slave ports 14 */
+	{SEC_SEL14,		0xF3FFFFFFU},
+	/** Security attribute setting for slave ports 15 */
+	{SEC_SEL15,		0xFFFFDE7FU},
+	/** Security group 0 attribute setting for master ports 0 */
+	{SEC_GRP0CR0,		0x00000000U},
+	/** Security group 1 attribute setting for master ports 0 */
+	{SEC_GRP1CR0,		0x00000000U},
+	/** Security group 0 attribute setting for master ports 1 */
+	{SEC_GRP0CR1,		0x00000000U},
+	/** Security group 1 attribute setting for master ports 1 */
+	{SEC_GRP1CR1,		0x00000000U},
+	/** Security group 0 attribute setting for master ports 2 */
+	{SEC_GRP0CR2,		0x00020000U},
+	/** Security group 1 attribute setting for master ports 2 */
+	{SEC_GRP1CR2,		0x00020000U},
+	/** Security group 0 attribute setting for master ports 3 */
+	{SEC_GRP0CR3,		0x00000500U},
+	/** Security group 1 attribute setting for master ports 3 */
+	{SEC_GRP1CR3,		0x00000500U},
+	/** Security group 0 attribute setting for slave ports 0 */
+	{SEC_GRP0COND0,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 0 */
+	{SEC_GRP1COND0,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 1 */
+	{SEC_GRP0COND1,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 1 */
+	{SEC_GRP1COND1,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 2 */
+	{SEC_GRP0COND2,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 2 */
+	{SEC_GRP1COND2,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 3 */
+	{SEC_GRP0COND3,		0x00080200U},
+	/** Security group 1 attribute setting for slave ports 3 */
+	{SEC_GRP1COND3,		0x00080200U},
+	/** Security group 0 attribute setting for slave ports 4 */
+	{SEC_GRP0COND4,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 4 */
+	{SEC_GRP1COND4,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 5 */
+	{SEC_GRP0COND5,		0x00000040U},
+	/** Security group 1 attribute setting for slave ports 5 */
+	{SEC_GRP1COND5,		0x00000040U},
+	/** Security group 0 attribute setting for slave ports 6 */
+	{SEC_GRP0COND6,		0x00002400U},
+	/** Security group 1 attribute setting for slave ports 6 */
+	{SEC_GRP1COND6,		0x00002400U},
+	/** Security group 0 attribute setting for slave ports 7 */
+	{SEC_GRP0COND7,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 7 */
+	{SEC_GRP1COND7,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 8 */
+	{SEC_GRP0COND8,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 8 */
+	{SEC_GRP1COND8,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 9 */
+	{SEC_GRP0COND9,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 9 */
+	{SEC_GRP1COND9,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 10 */
+	{SEC_GRP0COND10,	0x00000000U},
+	/** Security group 1 attribute setting for slave ports 10 */
+	{SEC_GRP1COND10,	0x00000000U},
+	/** Security group 0 attribute setting for slave ports 11 */
+	{SEC_GRP0COND11,	0x00000000U},
+	/** Security group 1 attribute setting for slave ports 11 */
+	{SEC_GRP1COND11,	0x00000000U},
+	/** Security group 0 attribute setting for slave ports 12 */
+	{SEC_GRP0COND12,	0x00000000U},
+	/** Security group 1 attribute setting for slave ports 12 */
+	{SEC_GRP1COND12,	0x00000000U},
+	/** Security group 0 attribute setting for slave ports 13 */
+	{SEC_GRP0COND13,	0x00400010U},
+	/** Security group 1 attribute setting for slave ports 13 */
+	{SEC_GRP1COND13,	0x00400010U},
+	/** Security group 0 attribute setting for slave ports 14 */
+	{SEC_GRP0COND14,	0x0C000000U},
+	/** Security group 1 attribute setting for slave ports 14 */
+	{SEC_GRP1COND14,	0x0C000000U},
+	/** Security group 0 attribute setting for slave ports 15 */
+	{SEC_GRP0COND15,	0x00000180U},
+	/** Security group 1 attribute setting for slave ports 15 */
+	{SEC_GRP1COND15,	0x00000180U},
+	/** Security write protection attribute setting for slave ports 0 */
+	{SEC_READONLY0,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 1 */
+	{SEC_READONLY1,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 2 */
+	{SEC_READONLY2,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 3 */
+	{SEC_READONLY3,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 4 */
+	{SEC_READONLY4,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 5 */
+	{SEC_READONLY5,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 6 */
+	{SEC_READONLY6,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 7 */
+	{SEC_READONLY7,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 8 */
+	{SEC_READONLY8,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 9 */
+	{SEC_READONLY9,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 10 */
+	{SEC_READONLY10,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 11 */
+	{SEC_READONLY11,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 12 */
+	{SEC_READONLY12,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 13 */
+	{SEC_READONLY13,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 14 */
+	{SEC_READONLY14,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 15 */
+	{SEC_READONLY15,	0x00000000U},
+
+	/* LIFEC1 (SAFETY) settings */
+
+	/* Safety group 0 attribute setting for master ports 0 */
+	{SAFE_GRP0CR0,		0x00000000U},
+	/* Safety group 1 attribute setting for master ports 0 */
+	{SAFE_GRP1CR0,		0x00000000U},
+	/* Safety group 0 attribute setting for master ports 1 */
+	{SAFE_GRP0CR1,		0x00000000U},
+	/* Safety group 1 attribute setting for master ports 1 */
+	{SAFE_GRP1CR1,		0x00000000U},
+	/* Safety group 0 attribute setting for master ports 2 */
+	{SAFE_GRP0CR2,		0x00000000U},
+	/* Safety group 1 attribute setting for master ports 2 */
+	{SAFE_GRP1CR2,		0x00000000U},
+	/* Safety group 0 attribute setting for master ports 3 */
+	{SAFE_GRP0CR3,		0x00000000U},
+	/* Safety group 1 attribute setting for master ports 3 */
+	{SAFE_GRP1CR3,		0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 0 */
+	{SAFE_GRP0COND0,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 0 */
+	{SAFE_GRP1COND0,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 1 */
+	{SAFE_GRP0COND1,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 1 */
+	{SAFE_GRP1COND1,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 2 */
+	{SAFE_GRP0COND2,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 2 */
+	{SAFE_GRP1COND2,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 3 */
+	{SAFE_GRP0COND3,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 3 */
+	{SAFE_GRP1COND3,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 4 */
+	{SAFE_GRP0COND4,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 4 */
+	{SAFE_GRP1COND4,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 5 */
+	{SAFE_GRP0COND5,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 5 */
+	{SAFE_GRP1COND5,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 6 */
+	{SAFE_GRP0COND6,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 6 */
+	{SAFE_GRP1COND6,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 7 */
+	{SAFE_GRP0COND7,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 7 */
+	{SAFE_GRP1COND7,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 8 */
+	{SAFE_GRP0COND8,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 8 */
+	{SAFE_GRP1COND8,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 9 */
+	{SAFE_GRP0COND9,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 9 */
+	{SAFE_GRP1COND9,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 10 */
+	{SAFE_GRP0COND10,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 10 */
+	{SAFE_GRP1COND10,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 11 */
+	{SAFE_GRP0COND11,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 11 */
+	{SAFE_GRP1COND11,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 12 */
+	{SAFE_GRP0COND12,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 12 */
+	{SAFE_GRP1COND12,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 13 */
+	{SAFE_GRP0COND13,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 13 */
+	{SAFE_GRP1COND13,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 14 */
+	{SAFE_GRP0COND14,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 14 */
+	{SAFE_GRP1COND14,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 15 */
+	{SAFE_GRP0COND15,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 15 */
+	{SAFE_GRP1COND15,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 0 */
+	{SAFE_READONLY0,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 1 */
+	{SAFE_READONLY1,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 2 */
+	{SAFE_READONLY2,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 3 */
+	{SAFE_READONLY3,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 4 */
+	{SAFE_READONLY4,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 5 */
+	{SAFE_READONLY5,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 6 */
+	{SAFE_READONLY6,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 7 */
+	{SAFE_READONLY7,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 8 */
+	{SAFE_READONLY8,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 9 */
+	{SAFE_READONLY9,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 10 */
+	{SAFE_READONLY10,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 11 */
+	{SAFE_READONLY11,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 12 */
+	{SAFE_READONLY12,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 13 */
+	{SAFE_READONLY13,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 14 */
+	{SAFE_READONLY14,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 15 */
+	{SAFE_READONLY15,	0x00000000U}
+};
+
+static const reg_setting_t axi_reg_setting[] = {
+
+	/* AXI settings */
+
+	/* DRAM protection */
+
+	/* AXI dram protected area division 0 */
+	{AXI_DPTDIVCR0,		0xEE0407E0U},
+	/* AXI dram protected area division 1 */
+	{AXI_DPTDIVCR1,		0xEE080000U},
+	/* AXI dram protected area division 2 */
+	{AXI_DPTDIVCR2,		0xEE080000U},
+	/* AXI dram protected area division 3 */
+	{AXI_DPTDIVCR3,		0xEE080000U},
+	/* AXI dram protected area division 4 */
+	{AXI_DPTDIVCR4,		0xEE080000U},
+	/* AXI dram protected area division 5 */
+	{AXI_DPTDIVCR5,		0xEE080000U},
+	/* AXI dram protected area division 6 */
+	{AXI_DPTDIVCR6,		0xEE080000U},
+	/* AXI dram protected area division 7 */
+	{AXI_DPTDIVCR7,		0xEE080000U},
+	/* AXI dram protected area division 8 */
+	{AXI_DPTDIVCR8,		0xEE080000U},
+	/* AXI dram protected area division 9 */
+	{AXI_DPTDIVCR9,		0xEE080000U},
+	/* AXI dram protected area division 10 */
+	{AXI_DPTDIVCR10,	0xEE080000U},
+	/* AXI dram protected area division 11 */
+	{AXI_DPTDIVCR11,	0xEE080000U},
+	/* AXI dram protected area division 12 */
+	{AXI_DPTDIVCR12,	0xEE080000U},
+	/* AXI dram protected area division 13 */
+	{AXI_DPTDIVCR13,	0xEE080000U},
+	/* AXI dram protected area division 14 */
+	{AXI_DPTDIVCR14,	0xEE080000U},
+
+	/* AXI dram protected area setting 0 */
+	{AXI_DPTCR0,		0xEE00EEEEU},
+	/* AXI dram protected area setting 1 */
+	{AXI_DPTCR1,		0xEE000000U},
+	/* AXI dram protected area setting 2 */
+	{AXI_DPTCR2,		0xEE000000U},
+	/* AXI dram protected area setting 3 */
+	{AXI_DPTCR3,		0xEE000000U},
+	/* AXI dram protected area setting 4 */
+	{AXI_DPTCR4,		0xEE000000U},
+	/* AXI dram protected area setting 5 */
+	{AXI_DPTCR5,		0xEE000000U},
+	/* AXI dram protected area setting 6 */
+	{AXI_DPTCR6,		0xEE000000U},
+	/* AXI dram protected area setting 7 */
+	{AXI_DPTCR7,		0xEE000000U},
+	/* AXI dram protected area setting 8 */
+	{AXI_DPTCR8,		0xEE000000U},
+	/* AXI dram protected area setting 9 */
+	{AXI_DPTCR9,		0xEE000000U},
+	/* AXI dram protected area setting 10 */
+	{AXI_DPTCR10,		0xEE000000U},
+	/* AXI dram protected area setting 11 */
+	{AXI_DPTCR11,		0xEE000000U},
+	/* AXI dram protected area setting 12 */
+	{AXI_DPTCR12,		0xEE000000U},
+	/* AXI dram protected area setting 13 */
+	{AXI_DPTCR13,		0xEE000000U},
+	/* AXI dram protected area setting 14 */
+	{AXI_DPTCR14,		0xEE000000U},
+	/* AXI dram protected area setting 15 */
+	{AXI_DPTCR15,		0xEE000000U}
+
+#if 0
+	/* SRAM ptotection */
+	,
+	/* AXI sram protected area division 0 */
+	{AXI_SPTDIVCR0,		0xEE0E6330U},
+	/* AXI sram protected area division 1 */
+	{AXI_SPTDIVCR1,		0xEE0E6360U},
+	/* AXI sram protected area division 2 */
+	{AXI_SPTDIVCR2,		0xEE0E6360U},
+	/* AXI sram protected area division 3 */
+	{AXI_SPTDIVCR3,		0xEE0E6360U},
+	/* AXI sram protected area division 4 */
+	{AXI_SPTDIVCR4,		0xEE0E6360U},
+	/* AXI sram protected area division 5 */
+	{AXI_SPTDIVCR5,		0xEE0E6360U},
+	/* AXI sram protected area division 6 */
+	{AXI_SPTDIVCR6,		0xEE0E6360U},
+	/* AXI sram protected area division 7 */
+	{AXI_SPTDIVCR7,		0xEE0E6360U},
+	/* AXI sram protected area division 8 */
+	{AXI_SPTDIVCR8,		0xEE0E6360U},
+	/* AXI sram protected area division 9 */
+	{AXI_SPTDIVCR9,		0xEE0E6360U},
+	/* AXI sram protected area division 10 */
+	{AXI_SPTDIVCR10,	0xEE0E6360U},
+	/* AXI sram protected area division 11 */
+	{AXI_SPTDIVCR11,	0xEE0E6360U},
+	/* AXI sram protected area division 12 */
+	{AXI_SPTDIVCR12,	0xEE0E6360U},
+	/* AXI sram protected area division 13 */
+	{AXI_SPTDIVCR13,	0xEE0E6360U},
+	/* AXI sram protected area division 14 */
+	{AXI_SPTDIVCR14,	0xEE0E6360U},
+
+	/* AXI sram protected area setting 0 */
+	{AXI_SPTCR0,		0xEE00EEEEU},
+	/* AXI sram protected area setting 1 */
+	{AXI_SPTCR1,		0xEE000000U},
+	/* AXI sram protected area setting 2 */
+	{AXI_SPTCR2,		0xEE000000U},
+	/* AXI sram protected area setting 3 */
+	{AXI_SPTCR3,		0xEE000000U},
+	/* AXI sram protected area setting 4 */
+	{AXI_SPTCR4,		0xEE000000U},
+	/* AXI sram protected area setting 5 */
+	{AXI_SPTCR5,		0xEE000000U},
+	/* AXI sram protected area setting 6 */
+	{AXI_SPTCR6,		0xEE000000U},
+	/* AXI sram protected area setting 7 */
+	{AXI_SPTCR7,		0xEE000000U},
+	/* AXI sram protected area setting 8 */
+	{AXI_SPTCR8,		0xEE000000U},
+	/* AXI sram protected area setting 9 */
+	{AXI_SPTCR9,		0xEE000000U},
+	/* AXI sram protected area setting 10 */
+	{AXI_SPTCR10,		0xEE000000U},
+	/* AXI sram protected area setting 11 */
+	{AXI_SPTCR11,		0xEE000000U},
+	/* AXI sram protected area setting 12 */
+	{AXI_SPTCR12,		0xEE000000U},
+	/* AXI sram protected area setting 13 */
+	{AXI_SPTCR13,		0xEE000000U},
+	/* AXI sram protected area setting 14 */
+	{AXI_SPTCR14,		0xEE000000U},
+	/* AXI sram protected area setting 15 */
+	{AXI_SPTCR15,		0xEE000000U}
+#endif
+};
+
+void bl2_secure_setting(void)
+{
+#if 0	/* TEST */
+	uint32_t		i, ie;
+	const reg_setting_t	*reg_setting;
+
+	reg_setting = &lifec_reg_setting[0];
+	i = 0;
+	ie = sizeof(*reg_setting) / sizeof(reg_setting_t);
+	for (; i < ie; i++) {
+		mmio_write_32(reg_setting[i].adr, reg_setting[i].val);
+	}
+
+	reg_setting = &axi_reg_setting[0];
+	i = 0;
+	ie = sizeof(*reg_setting) / sizeof(reg_setting_t);
+	for (; i < ie; i++) {
+		mmio_write_32(reg_setting[i].adr, reg_setting[i].val);
+	}
+#endif	/* TEST */
+}
diff --git a/plat/renesas/rcar/bl31_rcar_setup.c b/plat/renesas/rcar/bl31_rcar_setup.c
new file mode 100644
index 0000000..5c5b4d7
--- /dev/null
+++ b/plat/renesas/rcar/bl31_rcar_setup.c
@@ -0,0 +1,269 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <arch_helpers.h>
+#include <arm_gic.h>
+#include <assert.h>
+#include <bl_common.h>
+#include <bl31.h>
+#include <console.h>
+#include <mmio.h>
+#include <platform.h>
+#include <stddef.h>
+#include <debug.h>
+#include "drivers/pwrc/rcar_pwrc.h"
+#include "rcar_def.h"
+#include "rcar_private.h"
+#include "rcar_version.h"
+
+#define	CHECK_MD13_MD14		(0x6000U)
+#define	FREQ_10M		(0x2000U)
+#define	FREQ_12_5M		(0x4000U)
+#define	FREQ_8_33M		(0x0000U)
+#define	FREQ_16_66M		(0x6000U)
+
+/*******************************************************************************
+ * Declarations of linker defined symbols which will help us find the layout
+ * of trusted SRAM
+ ******************************************************************************/
+extern unsigned long __RO_START__;
+extern unsigned long __RO_END__;
+extern unsigned long __BL31_END__;
+
+#if USE_COHERENT_MEM
+extern unsigned long __COHERENT_RAM_START__;
+extern unsigned long __COHERENT_RAM_END__;
+#endif
+
+/*
+ * The next 3 constants identify the extents of the code, RO data region and the
+ * limit of the BL3-1 image.  These addresses are used by the MMU setup code and
+ * therefore they must be page-aligned.  It is the responsibility of the linker
+ * script to ensure that __RO_START__, __RO_END__ & __BL31_END__ linker symbols
+ * refer to page-aligned addresses.
+ */
+#define BL31_RO_BASE (uint64_t)(&__RO_START__)
+#define BL31_RO_LIMIT (uint64_t)(&__RO_END__)
+#define BL31_END (uint64_t)(&__BL31_END__)
+
+#if USE_COHERENT_MEM
+/*
+ * The next 2 constants identify the extents of the coherent memory region.
+ * These addresses are used by the MMU setup code and therefore they must be
+ * page-aligned.  It is the responsibility of the linker script to ensure that
+ * __COHERENT_RAM_START__ and __COHERENT_RAM_END__ linker symbols
+ * refer to page-aligned addresses.
+ */
+#define BL31_COHERENT_RAM_BASE (uint64_t)(&__COHERENT_RAM_START__)
+#define BL31_COHERENT_RAM_LIMIT (uint64_t)(&__COHERENT_RAM_END__)
+#endif
+
+#if RESET_TO_BL31
+static entry_point_info_t bl32_image_ep_info;
+static entry_point_info_t bl33_image_ep_info;
+#else
+/*******************************************************************************
+ * Reference to structure which holds the arguments that have been passed to
+ * BL31 from BL2.
+ ******************************************************************************/
+static bl31_params_t *bl2_to_bl31_params;
+#endif
+
+/* Array of secure interrupts to be configured by the gic driver */
+const unsigned int irq_sec_array[] = {
+	ARM_IRQ_SEC_PHY_TIMER,		/* 29		*/
+	ARM_IRQ_SEC_SGI_0,		/* 8		*/
+	ARM_IRQ_SEC_SGI_1,		/* 9		*/
+	ARM_IRQ_SEC_SGI_2,		/* 10		*/
+	ARM_IRQ_SEC_SGI_3,		/* 11		*/
+	ARM_IRQ_SEC_SGI_4,		/* 12		*/
+	ARM_IRQ_SEC_SGI_5,		/* 13		*/
+	ARM_IRQ_SEC_SGI_6,		/* 14		*/
+	ARM_IRQ_SEC_SGI_7,		/* 15		*/
+	ARM_IRQ_SEC_RPC,		/* 70		*/
+	ARM_IRQ_SEC_TIMER,		/* 166		*/
+	ARM_IRQ_SEC_TIMER_UP,		/* 171		*/
+	ARM_IRQ_SEC_WDT,		/* 173		*/
+	ARM_IRQ_SEC_CRYPT,		/* 102		*/
+	ARM_IRQ_SEC_CRYPT_SecPKA,	/* 97		*/
+	ARM_IRQ_SEC_CRYPT_PubPKA,	/* 98		*/
+	ARM_IRQ_SEC_DMAC2_ERR,		/* 448		*/
+	ARM_IRQ_SEC_DMAC2_0,		/* 449		*/
+	ARM_IRQ_SEC_DMAC2_1,		/* 450		*/
+	ARM_IRQ_SEC_DMAC2_2,		/* 451		*/
+	ARM_IRQ_SEC_DMAC2_3,		/* 452		*/
+	ARM_IRQ_SEC_DMAC2_4,		/* 453		*/
+	ARM_IRQ_SEC_DMAC2_5,		/* 454		*/
+	ARM_IRQ_SEC_DMAC2_6,		/* 455		*/
+	ARM_IRQ_SEC_DMAC2_7,		/* 456		*/
+	ARM_IRQ_SEC_DMAC2_8,		/* 457		*/
+	ARM_IRQ_SEC_DMAC2_9,		/* 458		*/
+	ARM_IRQ_SEC_DMAC2_10,		/* 459		*/
+	ARM_IRQ_SEC_DMAC2_11,		/* 460		*/
+	ARM_IRQ_SEC_DMAC2_12,		/* 461		*/
+	ARM_IRQ_SEC_DMAC2_13,		/* 462		*/
+	ARM_IRQ_SEC_DMAC2_14,		/* 463		*/
+	ARM_IRQ_SEC_DMAC2_15		/* 429		*/
+};
+
+uint32_t rcar_boot_kind_flag __attribute__((section("data")));
+
+/*******************************************************************************
+ * Return a pointer to the 'entry_point_info' structure of the next image for the
+ * security state specified. BL33 corresponds to the non-secure image type
+ * while BL32 corresponds to the secure image type. A NULL pointer is returned
+ * if the image does not exist.
+ ******************************************************************************/
+entry_point_info_t *bl31_plat_get_next_image_ep_info(uint32_t type)
+{
+	entry_point_info_t *next_image_info;
+
+	assert(sec_state_is_valid(type));
+
+	next_image_info =
+			(type == NON_SECURE) ?
+					bl2_to_bl31_params->bl33_ep_info :
+					bl2_to_bl31_params->bl32_ep_info;
+
+	/* None of the images on this platform can have 0x0 as the entrypoint */
+	if (next_image_info->pc)
+		return next_image_info;
+	else
+		return NULL;
+}
+
+/*******************************************************************************
+ * Perform any BL31 specific platform actions. Here is an opportunity to copy
+ * parameters passed by the calling EL (S-EL1 in BL2) before they
+ * are lost (potentially). This needs to be done before the MMU is initialized
+ * so that the memory layout can be used while creating page tables. On the RCAR
+ * we know that BL2 has populated the parameters. So we just use
+ * the reference passed in 'from_bl2' instead of copying. The 'data' parameter
+ * is not used since all the information is contained in 'from_bl2'. Also, BL2
+ * has flushed this information to memory, so we are guaranteed to pick up good
+ * data
+ ******************************************************************************/
+void bl31_early_platform_setup(bl31_params_t *from_bl2,
+		void *plat_params_from_bl2)
+{
+	uint32_t chk_data;
+	uint32_t freq_data;
+
+	/*
+	 * Set frequency data to CNTFID0
+	 */
+	chk_data = mmio_read_32((uintptr_t)RCAR_MODEMR) & CHECK_MD13_MD14;
+	switch (chk_data) {
+	case FREQ_8_33M:
+		freq_data = (uint32_t)(8.3333F * 1000000.0F); /* 8.33MHz	*/
+		break;
+	case FREQ_10M:
+		freq_data = (uint32_t)(10 * 1000000); /* 10MHz	*/
+		break;
+	case FREQ_12_5M:
+		freq_data = (uint32_t)(12.5F * 1000000.0F); /* 12.5MHz	*/
+		break;
+	case FREQ_16_66M:
+		freq_data = (uint32_t)(16.66F * 1000000.0F); /* 16.66MHz	*/
+		break;
+	default:
+		freq_data = 0U;
+		break;
+	}
+	mmio_write_32(RCAR_CNTC_BASE + CNTFID_OFF, freq_data);
+
+	/* Initialize the log area to provide early debug support */
+	console_init(1U, 0U, 0U);
+
+	NOTICE("BL3-1 : Rev.%s\n",version_of_renesas);
+
+	/* Check params passed from BL2 should not be NULL,
+	 * We are not checking plat_params_from_bl2 as NULL as we are not
+	 * using it on RCAR
+	 */
+	assert(from_bl2 != NULL);
+	assert(from_bl2->h.type == PARAM_BL31);
+	assert(from_bl2->h.version >= VERSION_1);
+
+	bl2_to_bl31_params = from_bl2;
+
+	/*
+	 * Initialize CCI for this cluster during cold boot.
+	 * No need for locks as no other CPU is active.
+	 */
+	rcar_cci_init();
+	/*
+	 * Enable CCI coherency for the primary CPU's cluster
+	 * RCAR PSCI code will enable coherency for other clusters.
+	 */
+	rcar_cci_enable();
+
+}
+
+/*******************************************************************************
+ * Initialize the gic, configure the CLCD and zero out variables needed by the
+ * secondaries to boot up correctly.
+ ******************************************************************************/
+void bl31_platform_setup(void)
+{
+
+	/* Initialize the gic cpu and distributor interfaces */
+	arm_gic_init(RCAR_GICC_BASE, RCAR_GICD_BASE, RCAR_GICR_BASE,
+			irq_sec_array, ARRAY_SIZE(irq_sec_array));
+	arm_gic_setup();
+
+	/* Enable and initialize the System level generic timer */
+	mmio_write_32(RCAR_CNTC_BASE + CNTCR_OFF, CNTCR_FCREQ(0) | CNTCR_EN);
+
+	/* Intialize the power controller */
+	rcar_pwrc_setup();
+
+	/* Topologies are best known to the platform. */
+	rcar_setup_topology();
+}
+
+/*******************************************************************************
+ * Perform the very early platform specific architectural setup here. At the
+ * moment this is only intializes the mmu in a quick and dirty way.
+ ******************************************************************************/
+void bl31_plat_arch_setup(void)
+{
+	rcar_configure_mmu_el3(BL31_RO_BASE, (BL31_END - BL31_RO_BASE),
+			BL31_RO_BASE,
+			BL31_RO_LIMIT
+#if USE_COHERENT_MEM
+			, BL31_COHERENT_RAM_BASE,
+			BL31_COHERENT_RAM_LIMIT
+#endif
+	);
+
+}
diff --git a/plat/renesas/rcar/ddr/boot_init_dram.c b/plat/renesas/rcar/ddr/boot_init_dram.c
new file mode 100644
index 0000000..53bb3cc
--- /dev/null
+++ b/plat/renesas/rcar/ddr/boot_init_dram.c
@@ -0,0 +1,3371 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>		//for uint32_t
+#include <string.h>		//for uint32_t
+#include <stdio.h>		//for uint32_t
+#include "boot_init_dram.h"
+#include "init_dram_tbl.h"
+//#include "bit.h"
+//#include "reg_rcarh3.h"
+
+///////////////////////////////////////////////////////////
+/* add start */
+#include <debug.h>
+#define	RST_BASE		(0xE6160000U)
+#define	RST_MODEMR		(RST_BASE + 0x0060U)
+#define	CPG_BASE		(0xE6150000U)
+#define	CPG_PLLECR		(CPG_BASE + 0x00D0U)
+#define	CPG_CPGWPR		(CPG_BASE + 0x900U)
+#define	CPG_PLL3CR		(CPG_BASE + 0x0DCU)
+#define	CPG_SRCR4		(CPG_BASE + 0x0BCU)
+#define	CPG_SRSTCLR4		(CPG_BASE + 0x950U)
+///////////////////////////////////////////////////////////
+
+
+#define	DDR_LVLEN				0x1e
+#define	DDR_FDIV				0x0
+#define	DDR_FDIVA				0x0
+#define	DDR_PLL3ONLY
+
+#define	DDR_DRIVE				0x1
+#define	DDR_LPDDR4_EN_OFF_FIRST	0x1
+#define	DDR_LP4_BOOT_DISABLE	0x1
+
+#define	DDR_PAD_BOOST			0x0
+#define	DDR_PAD_ADDR_CS_DRIVE	0x7f2c
+
+#define	DDR_PVTR_ADJ			0x8
+
+#define	DDR_RX_CAL_MAN			0x033f
+
+#define	DDR_MR3					0x31
+#define	DDR_MR11				0x32	// 120 ohm
+#define	DDR_MR22				0x06
+
+#define	DDR_TSEL_SELECT			0x00002C0C
+
+#define	DDR_VREF				0x0F1F
+
+#define	DDR_PAD_CAL_WA
+
+#define	DDR_UPDT_WA				0x1c48
+#define	DDR_FREQCHG
+
+#define	DDR_RDDQSDQ				0x0
+#define	DDR_CALVLSIDE			0x2
+#define	DDR_LOWDIV				0x4
+#define	DDR_LOWFIX				0x17
+
+#define	DDR_BPGRP				0x000
+#define	DDR_BPCAD				0x000
+
+#define	DDR_PHYVALID			0xf
+#define	DDR_PHYMRW				0xf
+
+#define	DDR_TVAL0				0
+#define	DDR_TVAL1				0
+#define	DDR_TVAL2				0
+#define	DDR_DBS_DFI_WA
+
+#define	DDR_CAD					0x200
+#define	DDR_GRP_A				0x200
+#define	DDR_GRP_B				0x200
+
+#define	DDR_PVTCODE_0			0x10
+#define	DDR_PVTCODE_1			0x20
+#define	DDR_PVTCODE_2			0x20
+
+#define DDR1600_CLK				0x2F		// 1600
+#define DDR2400_CLK				0x47		// 2400
+#define DDR2800_CLK				0x53		// 2800
+#define DDR3200_CLK				0x5f		// 3100
+
+// 9/24
+#define DDR_CACS_CAPTURE_CNT	0x02
+#define DDR_CACS_RESP_WAIT_CNT	0x00
+#define DDR_CACS_CCCP			0x2816
+#define DDR_CACS_START			0x280		// 0x320
+#define DDR_CACS_QTR			0x80		// 0x40
+#define DDR_CACS_STEP			0x03
+
+#define DBSC_DBSYSCONF1			0xE6790004
+#define DBSC_DBPHYCONF0			0xE6790010 //
+#define DBSC_DBKIND				0xE6790020 //
+
+#define DBSC_DBMEMCONF_0_0		0xE6790030
+#define DBSC_DBMEMCONF_0_1		0xE6790034
+#define DBSC_DBMEMCONF_1_0		0xE6790040
+#define DBSC_DBMEMCONF_1_1		0xE6790044
+#define DBSC_DBMEMCONF_2_0		0xE6790050
+#define DBSC_DBMEMCONF_2_1		0xE6790054
+#define DBSC_DBMEMCONF_3_0		0xE6790060
+#define DBSC_DBMEMCONF_3_1		0xE6790064
+
+#define DBSC_DBMEMCONF_0_2		0xE6790038
+#define DBSC_DBMEMCONF_0_3		0xE679003C
+#define DBSC_DBMEMCONF_1_2		0xE6790048
+#define DBSC_DBMEMCONF_1_3		0xE679004C
+#define DBSC_DBMEMCONF_2_2		0xE6790058
+#define DBSC_DBMEMCONF_2_3		0xE679005C
+#define DBSC_DBMEMCONF_3_2		0xE6790068
+#define DBSC_DBMEMCONF_3_3		0xE679006C
+
+#define DBSC_DBSTATE0			0xE6790108
+
+#define DBSC_DBACEN				0xE6790200
+#define DBSC_DBRFEN				0xE6790204
+#define DBSC_DBCMD				0xE6790208
+#define DBSC_DBWAIT				0xE6790210	//wait DBCMD 1=busy, 0=ready
+
+#define DBSC_DBTR0				0xE6790300
+#define DBSC_DBTR1				0xE6790304
+#define DBSC_DBTR3				0xE679030C
+#define DBSC_DBTR4				0xE6790310
+#define DBSC_DBTR5				0xE6790314
+#define DBSC_DBTR6				0xE6790318
+#define DBSC_DBTR7				0xE679031C
+#define DBSC_DBTR8				0xE6790320
+#define DBSC_DBTR9				0xE6790324
+#define DBSC_DBTR10				0xE6790328
+#define DBSC_DBTR11				0xE679032C
+#define DBSC_DBTR12				0xE6790330
+#define DBSC_DBTR13				0xE6790334
+#define DBSC_DBTR14				0xE6790338
+#define DBSC_DBTR15				0xE679033C
+#define DBSC_DBTR16				0xE6790340
+#define DBSC_DBTR17				0xE6790344
+#define DBSC_DBTR18				0xE6790348
+#define DBSC_DBTR19				0xE679034C
+#define DBSC_DBTR20				0xE6790350
+#define DBSC_DBTR21				0xE6790354
+#define DBSC_DBTR22				0xE6790358
+
+#define DBSC_DBBL				0xE6790400
+
+#define DBSC_DBRFCNF1			0xE6790414
+#define DBSC_DBRFCNF2			0xE6790418
+
+#define DBSC_DBRNK0				0xE6790430
+#define DBSC_DBRNK1				0xE6790434
+#define DBSC_DBRNK2				0xE6790438
+#define DBSC_DBRNK3				0xE679043C
+#define DBSC_DBRNK4				0xE6790440
+#define DBSC_DBRNK5				0xE6790444
+#define DBSC_DBRNK6				0xE6790448
+
+#define DBSC_DBADJ0				0xE6790500
+#define DBSC_DBADJ2				0xE6790508
+
+#define DBSC_DBDFIPMSTRCNF		0xE6790520
+
+#define DBSC_DBPDLK_0			0xE6790620
+#define DBSC_DBPDLK_1			0xE6790660
+#define DBSC_DBPDLK_2			0xE67906a0
+#define DBSC_DBPDLK_3			0xE67906e0
+
+#define DBSC_INITCOMP_0			0xE6790600
+#define DBSC_INITCOMP_1			0xE6790640
+#define DBSC_INITCOMP_2			0xE6790680
+#define DBSC_INITCOMP_3			0xE67906C0
+
+#define DBSC_DBDFICNT_0			0xE6790604
+#define DBSC_DBDFICNT_1			0xE6790644
+#define DBSC_DBDFICNT_2			0xE6790684
+#define DBSC_DBDFICNT_3			0xE67906C4
+
+#define DBSC_DBPDCNT0_0			0xE6790610
+#define DBSC_DBPDCNT0_1			0xE6790650
+#define DBSC_DBPDCNT0_2			0xE6790690
+#define DBSC_DBPDCNT0_3			0xE67906D0
+
+#define DBSC_DBPDCNT_0			0xE679061C
+#define DBSC_DBPDCNT_1			0xE679065C
+#define DBSC_DBPDCNT_2			0xE679069C
+#define DBSC_DBPDCNT_3			0xE67906DC
+
+#define DBSC_DBPDRGA_0			0xE6790624  //
+#define DBSC_DBPDRGD_0			0xE6790628  //
+#define DBSC_DBPDRGA_1			0xE6790664  //
+#define DBSC_DBPDRGD_1			0xE6790668  //
+#define DBSC_DBPDRGA_2			0xE67906A4  //
+#define DBSC_DBPDRGD_2			0xE67906A8  //
+#define DBSC_DBPDRGA_3			0xE67906E4  //
+#define DBSC_DBPDRGD_3			0xE67906E8  //
+
+#define DBSC_DBBUS0CNF0			0xE6790800
+#define DBSC_DBBUS0CNF1			0xE6790804
+
+#define DBSC_DBCAM0CNF0			0xE6790900
+#define DBSC_DBCAM0CNF1			0xE6790904
+#define DBSC_DBCAM0CNF2			0xE6790908
+#define DBSC_DBCAM0CNF3			0xE679090C
+#define DBSC_DBSCHCNT0			0xE6791000
+#define DBSC_DBSCHCNT1			0xE6791004
+#define DBSC_DBSCHSZ0			0xE6791010
+#define DBSC_DBSCHRW0			0xE6791020
+#define DBSC_DBSCHRW1			0xE6791024
+
+#define DBSC_DBSCHQOS_0_0		0xE6791030
+#define DBSC_DBSCHQOS_0_1		0xE6791034
+#define DBSC_DBSCHQOS_0_2		0xE6791038
+#define DBSC_DBSCHQOS_0_3		0xE679103C
+#define DBSC_DBSCHQOS_4_0		0xE6791070
+#define DBSC_DBSCHQOS_4_1		0xE6791074
+#define DBSC_DBSCHQOS_4_2		0xE6791078
+#define DBSC_DBSCHQOS_4_3		0xE679107C
+#define DBSC_DBSCHQOS_9_0		0xE67910C0
+#define DBSC_DBSCHQOS_9_1		0xE67910C4
+#define DBSC_DBSCHQOS_9_2		0xE67910C8
+#define DBSC_DBSCHQOS_9_3		0xE67910CC
+#define DBSC_DBSCHQOS_13_0		0xE6791100
+#define DBSC_DBSCHQOS_13_1		0xE6791104
+#define DBSC_DBSCHQOS_13_2		0xE6791108
+#define DBSC_DBSCHQOS_13_3		0xE679110C
+#define DBSC_DBSCHQOS_14_0		0xE6791110
+#define DBSC_DBSCHQOS_14_1		0xE6791114
+#define DBSC_DBSCHQOS_14_2		0xE6791118
+#define DBSC_DBSCHQOS_14_3		0xE679111C
+#define DBSC_DBSCHQOS_15_0		0xE6791120
+#define DBSC_DBSCHQOS_15_1		0xE6791124
+#define DBSC_DBSCHQOS_15_2		0xE6791128
+#define DBSC_DBSCHQOS_15_3		0xE679112C
+
+#define DBSC_DBSCTR0			0xE6791700
+#define DBSC_DBSCTR1			0xE6791708
+#define DBSC_DBSCHRW2			0xE679170C
+
+#define DBSC_SCFCTST0 0xE6791700	//Schedule timing setting register 0
+#define DBSC_SCFCTST1 0xE6791708	//Schedule timing setting register 1
+#define DBSC_SCFCTST2 0xE679170C	//Schedule timing setting register 2
+
+#define TSREG1					0xE60603E8	// Fuse Monitor Register 1
+
+#define DBSC_PLL_LOCK_0 		0xE6794054
+#define DBSC_PLL_LOCK_1 		0xE6794154
+#define DBSC_PLL_LOCK_2 		0xE6794254
+#define DBSC_PLL_LOCK_3 		0xE6794354
+
+#define DBSC_FREQ_CHG_ACK_0 	0xE6790618
+#define DBSC_FREQ_CHG_ACK_1 	0xE6790658
+#define DBSC_FREQ_CHG_ACK_2 	0xE6790698
+#define DBSC_FREQ_CHG_ACK_3 	0xE67906D8
+
+#define DBSC_DFI_FREQ_0 		0xE6790614
+#define DBSC_DFI_FREQ_1 		0xE6790654
+#define DBSC_DFI_FREQ_2 		0xE6790694
+#define DBSC_DFI_FREQ_3 		0xE67906D4
+
+
+
+////////////////////////////////////////////////////////////
+// 2800: RL=28,WL=14,nWR=30,nRTP=12
+#define DDR2800_PI_MR1				0xd4	//DeviceFeature1(Post=1.5tck nWR=30 RDpre=static WRPre=2tCK BL=16		// 1 101 0100
+#define DDR2800_PI_MR2				0x2d	//DeviceFeature2(0,0SetA,101=WL14,101=RL28)					// 0 0 101 101
+#define DDR2800_PI_TFC				0x00c8	//	xxxx
+#define DDR2800_PI_TRTP				0x0B
+#define DDR2800_PI_TCCD				0x08
+#define DDR2800_PI_TWR				0x1A
+//#define DDR2800_PI_TWTR				0x25
+#define DDR2800_PI_TWTR				0x0E
+#define DDR2800_PI_TRCD				0x1A
+#define DDR2800_PI_TRP				0x1E
+#define DDR2800_PI_TRAS_MIN			0x3B
+#define DDR2800_PI_TRAS_MAX			0x0db60	//	xxxx
+#define DDR2800_PI_TMRW				0x08	//	xxxx
+#define DDR2800_PI_TMRD				0x0c	//	xxxx
+#define DDR2800_PI_TCCDMW			0x20
+#define DDR2800_PI_TDQSCK_MAX		0x03
+#define DDR2800_PI_RDLAT_ADJ		0x10	//???
+#define DDR2800_PI_CASLAT_LIN		0x50
+#define DDR2800_PI_WRLAT			0x0e
+#define DDR2800_PI_WRLAT_ADJ		0x0c
+
+
+///////////////////////////////////////////////////////////
+// 2400: RL=24,WL=12,nWR=24,nRTP=10
+#define DDR2400_PI_MR1				0xc4	//DeviceFeature1(Post=1.5tck nWR=24 RDpre=static WRPre=2tCK BL=16		// 1 100 0100
+#define DDR2400_PI_MR2				0x24	//DeviceFeature2(0,0SetA,100=WL12,100=RL24)					// 0 0 100 100
+#define DDR2400_PI_TFC				0x00c8	//	xxxx
+#define DDR2400_PI_TRTP				0x09
+#define DDR2400_PI_TCCD				0x08
+#define DDR2400_PI_TWR				0x16
+#define DDR2400_PI_TWTR				0x0c
+#define DDR2400_PI_TRCD				0x16
+#define DDR2400_PI_TRP				0x1a
+#define DDR2400_PI_TRAS_MIN			0x33
+#define DDR2400_PI_TRAS_MAX			0x0db60	//	xxxx
+#define DDR2400_PI_TMRW				0x08	//	xxxx
+#define DDR2400_PI_TMRD				0x0c	//	xxxx
+#define DDR2400_PI_TCCDMW			0x20
+#define DDR2400_PI_TDQSCK_MAX		0x03
+#define DDR2400_PI_RDLAT_ADJ		0x0e
+#define DDR2400_PI_CASLAT_LIN		0x50	//PI_CASLAT_LIN_F2:RW:0:7:=0x1c
+#define DDR2400_PI_WRLAT			0x0c	//PI_WRLAT_F2:RW:16:5:=0x08
+#define DDR2400_PI_WRLAT_ADJ		0x0a
+/////////////////
+#define DDR1600_PI_MR1				0xa4	//MRW DeviceFeature1(Post=1.5tck nWR=16 RDpre=static WRPre=2tCK BL=16//OK		// 1 010 0100
+#define DDR1600_PI_MR2				0x52	//MRW DeviceFeature2(0,1SetB,010=WL12,010=RL14(nRTP14))//						// 01 010 010
+#define DDR1600_PI_TFC				0x00c8
+#define DDR1600_PI_TRTP				0x08
+#define DDR1600_PI_TCCD				0x08
+#define DDR1600_PI_TWR				0x11
+#define DDR1600_PI_TWTR				0x0a
+#define DDR1600_PI_TRCD				0x0f
+#define DDR1600_PI_TRP				0x11
+#define DDR1600_PI_TRAS_MIN			0x22
+#define DDR1600_PI_TRAS_MAX			0x0db60
+#define DDR1600_PI_TMRW				0x08	//10
+#define DDR1600_PI_TMRD				0x0c
+#define DDR1600_PI_TCCDMW			0x20
+#define DDR1600_PI_TDQSCK_MAX		0x3
+#define DDR1600_PI_RDLAT_ADJ		0x08	//PI_RDLAT_ADJ_F2:RW:16:8:=0x07       //try 07+2 1600
+#define DDR1600_PI_CASLAT_LIN		0x50	//PI_CASLAT_LIN_F2:RW:0:7:=0x1c
+#define DDR1600_PI_WRLAT			0x0c	//PI_WRLAT_F2:RW:16:5:=0x08
+#define DDR1600_PI_WRLAT_ADJ		0x0a
+
+//////////////////////////////////////////////////////////////////
+
+void InitDram(void);
+
+void pvt_dbsc_regset(uint32_t freq);
+void pvt_manual_update(uint32_t flag);
+void set_cacs_delay();
+static void _rx_cal_code_set(uint32_t ch, uint32_t slice, uint8_t _cal_code_up[][4][16],uint8_t _cal_code_dn[][4][16]);
+void rx_cal_manual1(uint32_t chmask);
+void mode_register_set(uint32_t freq,uintptr_t phychno,uint32_t mr13_val);
+void _set_reg(uint32_t ch_mask, uint32_t regadd, uint32_t pos, uint32_t width, uint32_t val);
+void pvt_lvl_enable_set(uint32_t go);
+void pvt_freq_change_ack(uint32_t freq, uintptr_t phychno, uint32_t freq_flag);
+uint32_t pvt_pi_training_go_all_o(uint32_t freq);
+
+inline void PLL3_FREQ(uint32_t freq,uint32_t freq_flag);
+uint32_t pvt_pi_training_go_all(uint32_t freq);
+uint32_t pvt_pi_training(uint32_t freq);
+void WaitDBCMD(void);
+
+void REG_DDRPHY_WRITE ( uintptr_t phyno, uint32_t regadd, uint32_t regdata);
+void change_lpddr4_en(uintptr_t phychno, uint32_t mode);
+void copy_csdelay(uint32_t	phychno, uint32_t s_byte);
+void adjust_rddqsgatedelay(uintptr_t phychno);
+void copy_dqdelay(uintptr_t phychno, uint32_t s_byte, uint32_t d_byte);
+uint32_t pvt_pi_training_go_all_soft(uint32_t freq);
+
+inline void dsb_sev(void);
+
+uint32_t REG_DDRPHY_READ ( uintptr_t phyno, uint32_t regadd);
+uint32_t InitDDR_0917(uint32_t freq);
+void freq2800_reg_set();
+void freq2400_reg_set();
+void freq1600_reg_set();
+
+
+uint8_t cal_code_up[4][4][16];//[11-15]are dummy
+uint8_t cal_code_dn[4][4][16];//[11-15]are dummy
+uint8_t fst1[4][4][16];//[11-15]are dummy
+uint8_t lst0[4][4][16];//[11-15]are dummy
+uint32_t val[4][4][16][4];
+
+void SoftDelay(uint32_t loop)
+{
+	volatile uint32_t i;
+	for(i=0;i<loop;i++);
+}
+
+///////////////////////////////////////////////////////////////////
+
+void InitDram(void)
+{
+	uint32_t md=0;
+	uint32_t freq=DDR3200_CLK;
+
+	md = (*((volatile uint32_t*)RST_MODEMR) & 0x000A0000) >> 17;
+
+	if (md == 0x0) {
+		NOTICE("BL2: DDR3200\n");
+	} else if (md == 0x1) {
+		freq = DDR2800_CLK;	//MD19=0,MD17=1 : LPDDR4-3000, 4GByte(1GByte x4)
+		NOTICE("BL2: DDR2800\n");
+	} else if (md == 0x4) {
+		freq = DDR2400_CLK;	//MD19=1,MD17=0 : LPDDR4-2400, 4GByte(1GByte x4)
+		NOTICE("BL2: DDR2400\n");
+	} else {
+		freq = DDR1600_CLK;	//MD19=1,MD17=1 : LPDDR4-1600, 4GByte(1GByte x4)
+		NOTICE("BL2: DDR1600\n");
+	}
+	InitDDR_0917(freq);
+}
+
+
+void pvt_dbsc_regset(uint32_t freq)
+{
+
+	*((volatile uint32_t*)DBSC_DBPDCNT0_0)	= 0x00;
+	*((volatile uint32_t*)DBSC_DBPDCNT0_1)	= 0x00;
+	*((volatile uint32_t*)DBSC_DBPDCNT0_2)	= 0x00;
+	*((volatile uint32_t*)DBSC_DBPDCNT0_3)	= 0x00;
+
+	//LPDDR4-1600(CL14NoDBI),4GByte(8GBit x 4)
+
+	*((volatile uint32_t*)DBSC_DBSTATE0)	= 0x00000010;
+	*((volatile uint32_t*)DBSC_DBKIND)		= 0x0000000a;	//ddcg=a(lpddr4)
+
+	*((volatile uint32_t*)DBSC_DBBL)		= 0x00000002;	//BL=16(lpddr4)
+
+//DRAM Size Registers
+//Please set for 4ranks
+	*((volatile uint32_t*)DBSC_DBMEMCONF_0_0)	= 0x0f030a02;	//memconf00(ch0/rank0) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_0_1)	= 0x0f030a02;	//memconf01(ch0/rank1) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_1_0)	= 0x0f030a02;	//memconf10(ch1/rank0) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_1_1)	= 0x0f030a02;	//memconf11(ch1/rank1) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_2_0)	= 0x0f030a02;	//memconf20(ch2/rank0) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_2_1)	= 0x0f030a02;	//memconf21(ch2/rank1) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_3_0)	= 0x0f030a02;	//memconf30(ch3/rank0) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_3_1)	= 0x0f030a02;	//memconf31(ch3/rank1) 4GB
+
+	*((volatile uint32_t*)DBSC_DBMEMCONF_0_2)	= 0x0f030a02;	//memconf01(ch0/rank2) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_0_3)	= 0x0f030a02;	//memconf01(ch0/rank3) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_1_2)	= 0x0f030a02;	//memconf01(ch1/rank2) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_1_3)	= 0x0f030a02;	//memconf01(ch1/rank3) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_2_2)	= 0x0f030a02;	//memconf01(ch2/rank2) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_2_3)	= 0x0f030a02;	//memconf01(ch2/rank3) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_3_2)	= 0x0f030a02;	//memconf01(ch3/rank2) 4GB
+	*((volatile uint32_t*)DBSC_DBMEMCONF_3_3)	= 0x0f030a02;	//memconf01(ch3/rank3) 4GB
+
+	*((volatile uint32_t*)DBSC_DBPHYCONF0)	= 0x00000001;	//phyconf0
+
+	if(freq>0x53)
+	{
+		// DDR3200
+		*((volatile uint32_t*)DBSC_DBTR0)	= 0x00000020;	//dbtr0  cl=32
+		*((volatile uint32_t*)DBSC_DBTR1)	= 0x0000000e;	//dbtr1  cwl=14
+		*((volatile uint32_t*)DBSC_DBTR3)	= 0x0000001d;	//dbtr3  trcd=29
+		*((volatile uint32_t*)DBSC_DBTR4)	= 0x0022001d;	//dbtr4  trpa=34 trp=29
+		*((volatile uint32_t*)DBSC_DBTR5)	= 0x00000060;	//dbtr5  trc=102
+		*((volatile uint32_t*)DBSC_DBTR6)	= 0x00000044;	//dbtr6  tras=68
+		*((volatile uint32_t*)DBSC_DBTR7)	= 0x00100010;	//dbtr7  trrd_s=16 trrd=16
+		*((volatile uint32_t*)DBSC_DBTR8)	= 0x00000040;	//dbtr8  tfaw=64
+		*((volatile uint32_t*)DBSC_DBTR9)	= 0x0000000c;	//dbtr9  trdpr=12
+		*((volatile uint32_t*)DBSC_DBTR10)	= 0x0000001d;	//dbtr10 twr=30
+//NG:	*((volatile uint32_t*)DBSC_DBTR11)	= 0x00000021;	//dbtr11 trdwr=33
+		*((volatile uint32_t*)DBSC_DBTR11)	= 0x00000025;	//dbtr11 trdwr=37
+		*((volatile uint32_t*)DBSC_DBTR12)	= 0x00270027;	//dbtr12 twrrd_s=39 twrrd=39
+		*((volatile uint32_t*)DBSC_DBTR13)	= 0x00900120;	//dbtr13 trfcpb=96 trfc=208
+		*((volatile uint32_t*)DBSC_DBTR14)	= 0x000c000c;	//dbtr14 tckehdll=12 tckeh=12
+		*((volatile uint32_t*)DBSC_DBTR15)	= 0x001e000c;	//dbtr15 tckesr=30 tckel=12   currently tckesr is TBD.
+
+		*((volatile uint32_t*)DBSC_DBTR16)	= 0x10400c0e;	//dbtr16 latency?  CL=32 & PHY_RDDATA_EN_DLY_X = 0e (32+2-14=20), CWL=14 & TDFI_PHY_WRDATA=2 
+		*((volatile uint32_t*)DBSC_DBTR17)	= 0x080a0004;	//dbtr17 tmodrd=8  tmod=10 trdmr=4
+		*((volatile uint32_t*)DBSC_DBTR18)	= 0x00000000;	//dbtr18 No odt for DQ exists in LPDDR4.
+		*((volatile uint32_t*)DBSC_DBTR19)	= 0x00000000;	//dbtr19 tzqcl=0 tzqcs=0 because LPDDR4 doesn't support ZQC[SL].
+		*((volatile uint32_t*)DBSC_DBTR20)	= 0x012c012c;	//dbtr20 txsdll=trfc+12=220 txs=220
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x00080008;	//dbtr21 tccd_s= 8 tccd= 8
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000C000C;	//dbtr21 tccd_s=12 tccd=12	u-boot ng			// for lowfreq
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000d000d;	//dbtr21 tccd_s=13 tccd=13	u-boot ng			// for lowfreq
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000e000e;	//dbtr21 tccd_s=14 tccd=14	u-boot ok			// for lowfreq
+		*((volatile uint32_t*)DBSC_DBTR21)	= 0x00100010;	//dbtr21 tccd_s=16 tccd=16	u-boot ok			// for lowfreq
+		*((volatile uint32_t*)DBSC_DBTR22)	= 0x06400030;	//dbtr22 tzqcal=1600 tzqlat=48
+
+	} 
+	else if(freq>0x47)
+	{
+		// DDR2800
+		*((volatile uint32_t*)DBSC_DBTR0)	= 0x0000001c;	//dbtr0  cl=28
+		*((volatile uint32_t*)DBSC_DBTR1)	= 0x0000000e;	//dbtr1  cwl=14
+		*((volatile uint32_t*)DBSC_DBTR3)	= 0x0000001a;	//dbtr3  trcd=26
+		*((volatile uint32_t*)DBSC_DBTR4)	= 0x001e001a;	//dbtr4  trpa=30 trp=26
+//		*((volatile uint32_t*)DBSC_DBTR5)	= 0x00000059;	//dbtr5  trc=89
+		*((volatile uint32_t*)DBSC_DBTR5)	= 0x00000055;	//dbtr5  trc=85
+		*((volatile uint32_t*)DBSC_DBTR6)	= 0x0000003b;	//dbtr6  tras=59
+//		*((volatile uint32_t*)DBSC_DBTR7)	= 0x000e000e;	//dbtr7  trrd_s=14 trrd=14
+		*((volatile uint32_t*)DBSC_DBTR7)	= 0x000f000f;	//dbtr7  trrd_s=15 trrd=15
+//		*((volatile uint32_t*)DBSC_DBTR8)	= 0x00000038;	//dbtr8  tfaw=56
+		*((volatile uint32_t*)DBSC_DBTR8)	= 0x00000039;	//dbtr8  tfaw=57
+//		*((volatile uint32_t*)DBSC_DBTR9)	= 0x0000000b;	//dbtr9  trdpr=11
+		*((volatile uint32_t*)DBSC_DBTR9)	= 0x0000000c;	//dbtr9  trdpr=12
+//		*((volatile uint32_t*)DBSC_DBTR10)	= 0x0000001b;	//dbtr10 twr=27
+		*((volatile uint32_t*)DBSC_DBTR10)	= 0x0000001E;	//dbtr10 twr=30, nWR is 26, but its value is not defined in MR1.nWR
+//		*((volatile uint32_t*)DBSC_DBTR11)	= 0x0000001e;	//dbtr11 trdwr=30
+//NG:	*((volatile uint32_t*)DBSC_DBTR11)	= 0x00000020;	//dbtr11 trdwr=32
+		*((volatile uint32_t*)DBSC_DBTR11)	= 0x00000022;	//dbtr11 trdwr=33
+//		*((volatile uint32_t*)DBSC_DBTR12)	= 0x00250025;	//dbtr12 twrrd_s=37 twrrd=37
+		*((volatile uint32_t*)DBSC_DBTR12)	= 0x00260026;	//dbtr12 twrrd_s=38 twrrd=38
+		*((volatile uint32_t*)DBSC_DBTR13)	= 0x007f00fd;	//dbtr13 trfcpb=127 trfc=253
+		*((volatile uint32_t*)DBSC_DBTR14)	= 0x000c000c;	//dbtr14 tckehdll=12 tckeh=12
+		*((volatile uint32_t*)DBSC_DBTR15)	= 0x0016000b;	//dbtr15 tckesr=22 tckel=11 
+
+		*((volatile uint32_t*)DBSC_DBTR16)	= 0x101f0c0e;	//dbtr16 latency?  CL=32 & PHY_RDDATA_EN_DLY_X = 0e (32+2-14=20), CWL=14 & TDFI_PHY_WRDATA=2 
+		*((volatile uint32_t*)DBSC_DBTR17)	= 0x0c0f0020;	//dbtr17 tmodrd=12  tmod=15 trdmr=32
+		*((volatile uint32_t*)DBSC_DBTR18)	= 0x00000000;	//dbtr18 No odt for DQ exists in LPDDR4.
+		*((volatile uint32_t*)DBSC_DBTR19)	= 0x00000000;	//dbtr19 tzqcl=0 tzqcs=0 because LPDDR4 doesn't support ZQC[SL].
+		*((volatile uint32_t*)DBSC_DBTR20)	= 0x01070107;	//dbtr20 txsdll=txs=tRFCab+7.5ns=263
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x00080008;	//dbtr21 tccd_s= 8 tccd= 8
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000b000b;	//dbtr21 tccd_s=11 tccd=11 But PHY may restrict tccd+1/+2, so set it big enough.
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000C000C;	//dbtr21 tccd_s=12 tccd=12	u-boot ng			// for lowfreq
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000d000d;	//dbtr21 tccd_s=16 tccd=13	u-boot ok			// for lowfreq
+		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000e000e;	//dbtr21 tccd_s=16 tccd=14	u-boot ok			// for lowfreq
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x00100010;	//dbtr21 tccd_s=16 tccd=16	u-boot ok			// for lowfreq
+		*((volatile uint32_t*)DBSC_DBTR22)	= 0x06400030;	//dbtr22 tzqcal=1600 tzqlat=48
+
+	} 
+	else if(freq>0x2f)
+	{
+		// DDR2400
+		*((volatile uint32_t*)DBSC_DBTR0)	= 0x00000018;	//dbtr0  cl=24
+		*((volatile uint32_t*)DBSC_DBTR1)	= 0x0000000c;	//dbtr1  cwl=12
+		*((volatile uint32_t*)DBSC_DBTR3)	= 0x00000016;	//dbtr3  trcd=22
+		*((volatile uint32_t*)DBSC_DBTR4)	= 0x001a0016;	//dbtr4  trpa=26 trp=22
+		*((volatile uint32_t*)DBSC_DBTR5)	= 0x00000049;	//dbtr5  trc=73
+		*((volatile uint32_t*)DBSC_DBTR6)	= 0x00000033;	//dbtr6  tras=51
+		*((volatile uint32_t*)DBSC_DBTR7)	= 0x000d000d;	//dbtr7  trrd_s=13 trrd=13
+		*((volatile uint32_t*)DBSC_DBTR8)	= 0x00000031;	//dbtr8  tfaw=49
+		*((volatile uint32_t*)DBSC_DBTR9)	= 0x0000000a;	//dbtr9  trdpr=10
+		*((volatile uint32_t*)DBSC_DBTR10)	= 0x00000016;	//dbtr10 twr=22
+		*((volatile uint32_t*)DBSC_DBTR11)	= 0x0000001c;	//dbtr11 trdwr=28   PHY may have restriction of this value.
+		*((volatile uint32_t*)DBSC_DBTR12)	= 0x00220022;	//dbtr12 twrrd_s=34 twrrd=34   PHY may restriction of this value.
+		*((volatile uint32_t*)DBSC_DBTR13)	= 0x006d00d9;	//dbtr13 trfcpb=109 trfc=217
+		*((volatile uint32_t*)DBSC_DBTR14)	= 0x000a000a;	//dbtr14 tckehdll=10 tckeh=10
+		*((volatile uint32_t*)DBSC_DBTR15)	= 0x0013000c;	//dbtr15 tckesr=19 tckel=12 
+
+		*((volatile uint32_t*)DBSC_DBTR16)	= 0x08400a0c;	//dbtr16 latency?  CL=24 & PHY_RDDATA_EN_DLY_X = 0e (???), CWL=12 & TDFI_PHY_WRDATA=2 
+		*((volatile uint32_t*)DBSC_DBTR17)	= 0x080a0004;	//dbtr17 tmodrd=8  tmod=10 trdmr=4
+		*((volatile uint32_t*)DBSC_DBTR18)	= 0x00000000;	//dbtr18 No odt for DQ exists in LPDDR4.
+		*((volatile uint32_t*)DBSC_DBTR19)	= 0x00000000;	//dbtr19 tzqcl=0 tzqcs=0 because LPDDR4 doesn't support ZQC[SL].
+		*((volatile uint32_t*)DBSC_DBTR20)	= 0x00e200e2;	//dbtr20 txsdll=txs=tRFCab+7.5ns=226
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x00080008;	//dbtr21 tccd_s=8 tccd=8
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000b000b;	//dbtr21 tccd_s=11 tccd=11 But PHY may restrict tccd+1/+2, so set it big enough.
+		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000C000C;	//dbtr21 tccd_s=12 tccd=12	u-boot ok			// for lowfreq
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x00100010;	//dbtr21 tccd_s=16 tccd=16	u-boot ok			// for lowfreq
+		*((volatile uint32_t*)DBSC_DBTR22)	= 0x04b10025;	//dbtr22 tzqcal=1201 tzqlat=37
+
+	}
+	else
+	{
+		// DDR1600
+		*((volatile uint32_t*)DBSC_DBTR0)	= 0x0000000e;	//dbtr0  cl=14
+		*((volatile uint32_t*)DBSC_DBTR1)	= 0x0000000c;	//dbtr1  cwl=c
+		*((volatile uint32_t*)DBSC_DBTR3)	= 0x0000000f;	//dbtr3  trcd=15
+		*((volatile uint32_t*)DBSC_DBTR4)	= 0x0011000f;	//dbtr4  trpa=17 trp=15
+		*((volatile uint32_t*)DBSC_DBTR5)	= 0x00000030;	//dbtr5  trc=48
+		*((volatile uint32_t*)DBSC_DBTR6)	= 0x00000022;	//dbtr6  tras=34
+		*((volatile uint32_t*)DBSC_DBTR7)	= 0x00080008;	//dbtr7  trrd_s=8 trrd=8
+		*((volatile uint32_t*)DBSC_DBTR8)	= 0x00000020;	//dbtr8  tfaw=32
+		*((volatile uint32_t*)DBSC_DBTR9)	= 0x00000006;	//dbtr9  trdpr=6
+		*((volatile uint32_t*)DBSC_DBTR10)	= 0x0000000f;	//dbtr10 twr=15
+		*((volatile uint32_t*)DBSC_DBTR11)	= 0x00000011;	//dbtr11 trdwr=22
+		*((volatile uint32_t*)DBSC_DBTR12)	= 0x001D001D;	//dbtr12 twrrd_s=20
+		*((volatile uint32_t*)DBSC_DBTR13)	= 0x00480090;	//dbtr13 trfcpb=72  trfcab=144
+		*((volatile uint32_t*)DBSC_DBTR14)	= 0x00060006;	//dbtr14 tckehdll=6
+		*((volatile uint32_t*)DBSC_DBTR15)	= 0x000c0006;	//dbtr15 tckesr=12
+
+		*((volatile uint32_t*)DBSC_DBTR16)	= 0x06200a0C;	//dbtr16 latency?
+		*((volatile uint32_t*)DBSC_DBTR17)	= 0x080a0004;	//dbtr17 tmodrd=8  tmod=10 trdmr=4
+		*((volatile uint32_t*)DBSC_DBTR18)	= 0x00000000;	//dbtr18 No odt for DQ exists in LPDDR4.
+		*((volatile uint32_t*)DBSC_DBTR19)	= 0x00000000;	//dbtr19 tzqcl=0 tzqcs=0 because LPDDR4 doesn't support ZQC[SL].
+		*((volatile uint32_t*)DBSC_DBTR20)	= 0x00b00096;	//dbtr20 txsdll=150
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x00080008;	//dbtr21 tccd_s=8 tccd=8
+		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000b000b;	//dbtr21 tccd_s=11 tccd=11	u-boot ok But PHY may restrict tccd+1/+2, so set it big enough.
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x000C000C;	//dbtr21 tccd_s=12 tccd=12	u-boot ok			// for lowfreq
+//		*((volatile uint32_t*)DBSC_DBTR21)	= 0x00100010;	//dbtr21 tccd_s=16 tccd=16	u-boot ok			// for lowfreq
+		*((volatile uint32_t*)DBSC_DBTR22)	= 0x03200018;	//dbtr22 tzqcal=800 tzqlat=24
+	}
+
+	*((volatile uint32_t*)DBSC_DBRNK0)	= 0x00000000;	//dbrnk0 No odt for DQ exists in LPDDR4(N.Honda).
+	*((volatile uint32_t*)DBSC_DBRNK1)	= 0x00000000;	//dbrnk1 Don't need to set it cause we use all-rank refresh.
+	*((volatile uint32_t*)DBSC_DBRNK2)	= 0x00008888;	//dbrnk2 rkrr=8
+	*((volatile uint32_t*)DBSC_DBRNK3)	= 0x00008888;	//dbrnk3 rkrw=8
+	*((volatile uint32_t*)DBSC_DBRNK4)	= 0x00008888;	//dbrnk4 rkwr=8
+	*((volatile uint32_t*)DBSC_DBRNK5)	= 0x00008888;	//dbrnk5 rkww=8
+	*((volatile uint32_t*)DBSC_DBRNK6)	= 0x00000000;	//dbrnk6 Use ALL Rank
+	*((volatile uint32_t*)DBSC_DBADJ0)	= 0x00000000;	//dbadj0 No Optional setting
+	*((volatile uint32_t*)DBSC_DBADJ2)	= 0x00000000;	//dbadj2 No Optional setting
+
+//BUFCAM settings
+//	*((volatile uint32_t*)DBSC_DBCAM0CNF0)	= 0x00000000;	//dbcam0cnf0 inoen=0, actually it is not used.
+	*((volatile uint32_t*)DBSC_DBCAM0CNF1)	= 0x00044218;	//dbcam0cnf1 
+	*((volatile uint32_t*)DBSC_DBCAM0CNF2)	= 0x000000F4;	//dbcam0cnf2 
+//	*((volatile uint32_t*)DBSC_DBCAM0CNF3)	= 0x00000003;	//
+	*((volatile uint32_t*)DBSC_DBSCHCNT0)	= 0x080F003F;	//dbschcnt0
+	*((volatile uint32_t*)DBSC_DBSCHCNT1)	= 0x00001010;	//dbschcnt1
+	*((volatile uint32_t*)DBSC_DBSCHSZ0)	= 0x00000001;	//dbschsz0
+	*((volatile uint32_t*)DBSC_DBSCHRW0)	= 0xF7311111;	//dbschrw0
+	*((volatile uint32_t*)DBSC_DBSCHRW1)	= 0x00000037;	//dbschrw1
+
+//QoS Settings
+	*((volatile uint32_t*)DBSC_DBSCHQOS_0_0)	= 0x0000F000;	//dbschqos00
+	*((volatile uint32_t*)DBSC_DBSCHQOS_0_1)	= 0x0000E000;	//dbschqos01
+	*((volatile uint32_t*)DBSC_DBSCHQOS_0_2)	= 0x00007000;	//dbschqos02
+	*((volatile uint32_t*)DBSC_DBSCHQOS_0_3)	= 0x00000000;	//dbschqos03
+	*((volatile uint32_t*)DBSC_DBSCHQOS_4_0)	= 0x0000F000;	//dbschqos40
+	*((volatile uint32_t*)DBSC_DBSCHQOS_4_1)	= 0x0000EFFF;	//dbschqos41
+	*((volatile uint32_t*)DBSC_DBSCHQOS_4_2)	= 0x0000B000;	//dbschqos42
+	*((volatile uint32_t*)DBSC_DBSCHQOS_4_3)	= 0x00000000;	//dbschqos43
+	*((volatile uint32_t*)DBSC_DBSCHQOS_9_0)	= 0x0000F000;	//dbschqos90
+	*((volatile uint32_t*)DBSC_DBSCHQOS_9_1)	= 0x0000EFFF;	//dbschqos91
+	*((volatile uint32_t*)DBSC_DBSCHQOS_9_2)	= 0x0000D000;	//dbschqos92
+	*((volatile uint32_t*)DBSC_DBSCHQOS_9_3)	= 0x00000000;	//dbschqos93
+	*((volatile uint32_t*)DBSC_DBSCHQOS_13_0)	= 0x0000F000;	//dbschqos130
+	*((volatile uint32_t*)DBSC_DBSCHQOS_13_1)	= 0x0000EFFF;	//dbschqos131
+	*((volatile uint32_t*)DBSC_DBSCHQOS_13_2)	= 0x0000E800;	//dbschqos132
+	*((volatile uint32_t*)DBSC_DBSCHQOS_13_3)	= 0x00007000;	//dbschqos133
+	*((volatile uint32_t*)DBSC_DBSCHQOS_14_0)	= 0x0000F000;	//dbschqos140
+	*((volatile uint32_t*)DBSC_DBSCHQOS_14_1)	= 0x0000EFFF;	//dbschqos141
+	*((volatile uint32_t*)DBSC_DBSCHQOS_14_2)	= 0x0000E800;	//dbschqos142
+	*((volatile uint32_t*)DBSC_DBSCHQOS_14_3)	= 0x00007000;	//dbschqos143
+	*((volatile uint32_t*)DBSC_DBSCHQOS_15_0)	= 0x000007D0;	//dbschqos150
+	*((volatile uint32_t*)DBSC_DBSCHQOS_15_1)	= 0x000007CF;	//dbschqos151
+	*((volatile uint32_t*)DBSC_DBSCHQOS_15_2)	= 0x000005D0;	//dbschqos152
+	*((volatile uint32_t*)DBSC_DBSCHQOS_15_3)	= 0x000003D0;	//dbschqos153
+
+	*((volatile uint32_t*)DBSC_DBSYSCONF1)		= 0x00000002;	//dbsysconf1 freqratio=2.
+
+//Under Verification
+	*((volatile uint32_t*)DBSC_DBCAM0CNF1)	= 0x00044218;	//wbkwait(0004), wbkmdhi(4,2),wbkmdlo(1,8)             <- independent of dram freq
+	*((volatile uint32_t*)DBSC_DBCAM0CNF2)	= 0x00000284;	//rg_scexp[15:0] 0,0(fillunit),8(dirtymax),4(dirtymin) <- independent of dram freq
+
+	if(freq>0x53)
+	{
+		// DDR3200
+		*((volatile uint32_t*)DBSC_DBSCHRW0)	= 0xF7311111;	//stop_tolerance, independent of dram freq
+		*((volatile uint32_t*)DBSC_DBSCHRW1)	= 0x00000048;	//[15: 8]=trfcpb/4; [ 7: 0]=trfcab/4   ;
+		*((volatile uint32_t*)DBSC_SCFCTST0)	= 0x18030d09;	//[31:24]=trc/4   ; [23:16]=trda->act/4; [15:8]=twra->act/4; [7:0]=trp/4
+		*((volatile uint32_t*)DBSC_SCFCTST1)	= 0x090a080c;	//[31:24]=trdwr/4 ; [23:16]=twrrd/4    ; [15:8]=trcd/4     ; [7:0]=asyncofs
+		*((volatile uint32_t*)DBSC_SCFCTST2)	= 0x111f1fff;	//rd-wr/wr-rd toggle count, independent of dram freq
+	}
+	else if(freq>0x47)
+	{
+		// DDR2800
+		*((volatile uint32_t*)DBSC_DBSCHRW0)	= 0xF7311111;	//stop_tolerance, independent of dram freq
+		*((volatile uint32_t*)DBSC_DBSCHRW1)	= 0x00018248;	//[15: 8]=trfcpb/4; [ 7: 0]=trfcab/4   ;
+//		*((volatile uint32_t*)DBSC_SCFCTST0)	= 0x15030d09;	//[31:24]=trc/4   ; [23:16]=trda->act/4; [15:8]=twra->act/4; [7:0]=trp/4
+		*((volatile uint32_t*)DBSC_SCFCTST0)	= 0x180b1508;	//[31:24]=trc/2.5=18   ; [23:16]=trda->act/2.5=11; [15:8]=twra->act/2.5=21; [7:0]=trp/2.5=8
+//		*((volatile uint32_t*)DBSC_SCFCTST1)	= 0x080a070c;	//[31:24]=trdwr/4 ; [23:16]=twrrd/4    ; [15:8]=trcd/4     ; [7:0]=asyncofs
+		*((volatile uint32_t*)DBSC_SCFCTST1)	= 0x0a0b080C;	//[31:24]=trdwr/2.5=9 ; [23:16]=twrrd/2.5=16   ; [15:8]=trcd/2.5=8     ; [7:0]=asyncofs
+		*((volatile uint32_t*)DBSC_SCFCTST2)	= 0x000F0FFF;	//rd-wr/wr-rd toggle count, independent of dram freq
+	}
+	else if(freq>0x2f)
+	{
+		// DDR2400
+		*((volatile uint32_t*)DBSC_DBSCHRW0)	= 0x22421111;	//stop_tolerance, independent of dram freq
+		*((volatile uint32_t*)DBSC_DBSCHRW1)	= 0x00180034;	//[15: 8]=trfcpb/4; [ 7: 0]=trfcab/4   ;
+		*((volatile uint32_t*)DBSC_SCFCTST0)	= 0x180B1708;	//[31:24]=trc/4   ; [23:16]=trda->act/4; [15:8]=twra->act/4; [7:0]=trp/4
+		*((volatile uint32_t*)DBSC_SCFCTST1)	= 0x0808070C;	//[31:24]=trdwr/4 ; [23:16]=twrrd/4    ; [15:8]=trcd/4     ; [7:0]=asyncofs
+		*((volatile uint32_t*)DBSC_SCFCTST2)	= 0x012F1123;	//rd-wr/wr-rd toggle count, independent of dram freq
+	}
+	else
+	{
+		*((volatile uint32_t*)DBSC_DBSCHRW0)	= 0xF7311111;	//stop_tolerance, independent of dram freq
+		*((volatile uint32_t*)DBSC_DBSCHRW1)	= 0x00000024;	//[15: 8]=trfcpb/4; [ 7: 0]=trfcab/4   ;
+		*((volatile uint32_t*)DBSC_SCFCTST0)	= 0x0c020905;	//[31:24]=trc/4   ; [23:16]=trda->act/4; [15:8]=twra->act/4; [7:0]=trp/4
+		*((volatile uint32_t*)DBSC_SCFCTST1)	= 0x0508040C;	//[31:24]=trdwr/4 ; [23:16]=twrrd/4    ; [15:8]=trcd/4     ; [7:0]=asyncofs
+		*((volatile uint32_t*)DBSC_SCFCTST2)	= 0x000F0FFF;	//rd-wr/wr-rd toggle count, independent of dram freq
+	}
+}
+
+
+void pvt_manual_update(uint32_t flag)
+{
+	if(flag&0x1) {REG_DDRPHY_WRITE(0,0x702,REG_DDRPHY_READ(0,0x702) | (1<<16));};
+	if(flag&0x2) {REG_DDRPHY_WRITE(1,0x702,REG_DDRPHY_READ(1,0x702) | (1<<16));};
+	if(flag&0x4) {REG_DDRPHY_WRITE(2,0x702,REG_DDRPHY_READ(2,0x702) | (1<<16));};
+	if(flag&0x8) {REG_DDRPHY_WRITE(3,0x702,REG_DDRPHY_READ(3,0x702) | (1<<16));};
+
+	if(flag&0x10) {REG_DDRPHY_WRITE(0,0x732,REG_DDRPHY_READ(0,0x732) | (1<<16));};
+	if(flag&0x20) {REG_DDRPHY_WRITE(1,0x732,REG_DDRPHY_READ(1,0x732) | (1<<16));};
+	if(flag&0x40) {REG_DDRPHY_WRITE(2,0x732,REG_DDRPHY_READ(2,0x732) | (1<<16));};
+	if(flag&0x80) {REG_DDRPHY_WRITE(3,0x732,REG_DDRPHY_READ(3,0x732) | (1<<16));};
+}
+
+
+void set_cacs_delay()
+{
+	uint32_t i,f,dataL;
+
+	//FREQ_SEL_INDEX=3 (not needed? because MULTICAST_EN=1) ==> NEED!! otherwise, copy will not copy
+	REG_DDRPHY_WRITE (1,0x00000700,0x0301);
+	REG_DDRPHY_WRITE (2,0x00000700,0x0301);
+	REG_DDRPHY_WRITE (3,0x00000700,0x0301);
+
+	for (i=0;i<4;i++)
+	{
+		for(f=0;f<2;f++)
+		{
+			REG_DDRPHY_WRITE(i,0x700,dataL=((REG_DDRPHY_READ(i,0x700) & 0xfffffcfe) | (f<<8)) );
+
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[0][0],dataL=((DDR_CA_DELAY[0][1] & 0x000000ff) | (DDR_CAD<<8)) );
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[1][0],dataL=((DDR_CA_DELAY[1][1] & 0x00000000) | (DDR_CAD<<16) | (DDR_CAD<<0)) );
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[2][0],dataL=((DDR_CA_DELAY[2][1] & 0x00000000) | (DDR_CAD<<16) | (DDR_CAD<<0)) );
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[3][0],dataL=((DDR_CA_DELAY[3][1] & 0x000f0000) | (DDR_CAD<<0)) );
+
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[0][0]+0x80,dataL=((DDR_CA_DELAY[0][1] & 0x000000ff) | (DDR_CAD<<8)) );
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[1][0]+0x80,dataL=((DDR_CA_DELAY[1][1] & 0x00000000) | (DDR_CAD<<16) | (DDR_CAD<<0)) );
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[2][0]+0x80,dataL=((DDR_CA_DELAY[2][1] & 0x00000000) | (DDR_CAD<<16) | (DDR_CAD<<0)) );
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[3][0]+0x80,dataL=((DDR_CA_DELAY[3][1] & 0x000f0000) | (DDR_CAD<<0)) );
+
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[4][0],dataL=((DDR_CA_DELAY[4][1] & 0x000000ff) | (DDR_GRP_A<<8)) );
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[5][0],dataL=((DDR_CA_DELAY[5][1] & 0x00000000) | (DDR_GRP_B<<16) | (DDR_GRP_A<<0)) );
+			REG_DDRPHY_WRITE(i,DDR_CA_DELAY[6][0],dataL=((DDR_CA_DELAY[6][1] & 0x00000000) | (DDR_GRP_B<<0)) );
+		}
+		REG_DDRPHY_WRITE(i,0x700,dataL=((REG_DDRPHY_READ(i,0x700) & 0xfffffffe) | 1) );
+	}
+
+	for (i=0;i<4;i++)
+	{
+		REG_DDRPHY_WRITE(i,0x702,dataL=((REG_DDRPHY_READ(i,0x702) & 0xfeffffff) | (DDR_LP4_BOOT_DISABLE<<24) ) );
+//		0x00000601, 0x00000000, // PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_0:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_0:RW+:8:5:=0x00 PHY_ADR4_SW_WRADDR_SHIFT_0:RW+:0:5:=0x00
+//		0x00000681, 0x00000404, // PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR4_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04
+//		0x00000701, 0x00000000, // PHY_GRP_BYPASS_SLAVE_DELAY:RW:16:11:=0x0000 PHY_SW_GRP_SHIFT_3:RW+:8:5:=0x00 PHY_SW_GRP_SHIFT_2:RW+:0:5:=0x00
+		REG_DDRPHY_WRITE(i,0x601,dataL=((REG_DDRPHY_READ(i,0x601) & 0xf800ffff) | (DDR_BPCAD<<16)) );
+		REG_DDRPHY_WRITE(i,0x681,dataL=((REG_DDRPHY_READ(i,0x681) & 0xf800ffff) | (DDR_BPCAD<<16)) );
+		REG_DDRPHY_WRITE(i,0x701,dataL=((REG_DDRPHY_READ(i,0x701) & 0xf800ffff) | (DDR_BPGRP<<16)) );
+
+//		0x00000680, 0x04040404, // PHY_ADR3_SW_WRADDR_SHIFT_1:RW+:24:5:=0x04 PHY_ADR2_SW_WRADDR_SHIFT_1:RW+:16:5:=0x04 PHY_ADR1_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR0_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04
+//		0x00000681, 0x00000404, // PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR4_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04
+		REG_DDRPHY_WRITE(i,0x680,dataL=((REG_DDRPHY_READ(i,0x680) & 0xe0e0e0e0) | 0x05050505) );
+		REG_DDRPHY_WRITE(i,0x681,dataL=((REG_DDRPHY_READ(i,0x681) & 0xffffe0e0) | 0x00000505) );
+	}
+}
+
+
+
+static void _rx_cal_code_set(uint32_t ch, uint32_t slice, uint8_t _cal_code_up[][4][16],uint8_t _cal_code_dn[][4][16])
+{
+	uint32_t i;
+	uint32_t code;
+	for(i=0;i<6;i++)
+	{
+		code=((      cal_code_up[ch][slice][i*2+1] &0x3f) <<22)
+		    |((      cal_code_dn[ch][slice][i*2+1] &0x3f) <<16)
+			|((      cal_code_up[ch][slice][i*2]   &0x3f) << 6)
+		    |((      cal_code_dn[ch][slice][i*2]   &0x3f) << 0);
+		REG_DDRPHY_WRITE(ch,0x434+i+slice*0x80,code);
+	}
+}
+
+void rx_cal_manual1(uint32_t chmask)
+{ 
+
+	uint32_t ch,slice;
+	uint32_t index;
+	uint32_t trial;
+	
+	uint16_t cal_obs;
+	uint32_t rx_cal_val;
+	uint32_t NS_WA; //for backward compat
+	
+	uint32_t regadd, o_dataL,dataL;
+	
+/*
+Reports the calibration results. This parameter is only applicable if the phy_rx_cal_override_X parameter is set to fb1. 
+There is a phy_rx_cal_obs_X parameter for each of the slices of data sent on the DFI data bus.
+? Bit [10] = Calibration result from FDBK
+? Bit [9] = rx_cal_rd_dqs; Calibration result from DQS
+? Bit [8] = rx_cal_rd_dm; Calibration result from DM
+? Bits [7:0] = wrlvl_rd_dq;	
+*/
+	rx_cal_val = DDR_RX_CAL_MAN&0x3f;
+	if(DDR_RX_CAL_MAN&0x200)NS_WA=1;
+	else NS_WA=0;
+
+	for(ch=0;ch<4;ch++)
+	{
+		for(slice=0;slice<4;slice++)
+		{
+			REG_DDRPHY_WRITE(ch,0x452+0x80*slice,REG_DDRPHY_READ(ch,0x452+0x80*slice) | (1<<16));	//IE_on
+			REG_DDRPHY_WRITE(ch,0x433+0x80*slice,REG_DDRPHY_READ(ch,0x433+0x80*slice)|0x100); //CAL_OVERRIDE on
+			for(index=0;index<16;index++)
+			{
+				cal_code_up[ch][slice][index]=rx_cal_val;
+				cal_code_dn[ch][slice][index]=rx_cal_val;
+				fst1[ch][slice][index]=0xff;
+				lst0[ch][slice][index]=0xff;
+				for(trial=0;trial<128;trial+=32)
+					val[ch][slice][index][trial/32]=0;
+			}
+			_rx_cal_code_set(ch,slice,cal_code_up,cal_code_dn);
+		}
+	}
+
+	for(trial=0;trial<2*rx_cal_val;trial++)
+	{
+		for(ch=0;ch<4;ch++)
+		{
+			if(!(chmask & (1<<ch)))continue;
+			for(slice=0;slice<4;slice++)
+			{
+				for(index=0;index<11;index++)
+				{
+					if(trial>=rx_cal_val)
+					{
+						cal_code_up[ch][slice][index]=rx_cal_val;
+						cal_code_dn[ch][slice][index]=2*rx_cal_val-trial;
+					}
+					else
+					{
+						cal_code_up[ch][slice][index]=trial;
+						cal_code_dn[ch][slice][index]=rx_cal_val;
+					}
+				}
+				_rx_cal_code_set(ch,slice,cal_code_up,cal_code_dn);
+			}
+		}
+		for(ch=0;ch<4;ch++)
+		{
+			for(slice=0;slice<4;slice++)
+			{
+				cal_obs = (uint16_t)(REG_DDRPHY_READ(ch,0x439+0x80*slice)>>16);
+				for(index=0;index<11;index++)
+				{
+					if(cal_obs&(1<<index) )
+					{
+						val[ch][slice][index][trial/32]|=(1ULL<<trial%32);
+					}
+					else
+					{
+						val[ch][slice][index][trial/32]&=~(1ULL<<trial%32);
+					}
+
+					if(((ch==0 || ch==3)&&(slice==2||slice==3)) || !NS_WA)
+					{
+						if(cal_obs&(1<<index) )
+						{
+							if(fst1[ch][slice][index]==0xff)fst1[ch][slice][index]=trial;
+						}
+						else
+						{
+							lst0[ch][slice][index]=trial;
+						}
+					}
+					else
+					{
+						if(!(cal_obs&(1<<index) ))
+						{
+							if(fst1[ch][slice][index]==0xff)fst1[ch][slice][index]=trial;
+						}
+						else
+						{
+							lst0[ch][slice][index]=trial;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	for(ch=0;ch<4;ch++)
+	{
+		for(slice=0;slice<4;slice++)
+		{
+			for(index=0;index<16;index++)
+			{
+				if(fst1[ch][slice][index]==0xff || lst0[ch][slice][index]==0xff)
+				{
+					cal_code_up[ch][slice][index]=rx_cal_val;
+					cal_code_dn[ch][slice][index]=rx_cal_val;
+				}
+				else
+				{
+					trial=(fst1[ch][slice][index]+lst0[ch][slice][index])>>1;
+					if(trial>=rx_cal_val)
+					{
+						cal_code_up[ch][slice][index]=rx_cal_val;
+						cal_code_dn[ch][slice][index]=2*rx_cal_val-trial;
+					}
+					else
+					{
+						cal_code_up[ch][slice][index]=trial;
+						cal_code_dn[ch][slice][index]=rx_cal_val;
+					}
+				}
+			}
+			_rx_cal_code_set(ch,slice,cal_code_up,cal_code_dn);
+		}
+	}
+
+	for(ch=0;ch<4;ch++)
+	{
+		for(slice=0;slice<4;slice++)
+		{
+			REG_DDRPHY_WRITE(ch,0x452+0x80*slice,REG_DDRPHY_READ(ch,0x452+0x80*slice)&~(1<<16));	//IE_off
+			REG_DDRPHY_WRITE(ch,0x433+0x80*slice,REG_DDRPHY_READ(ch,0x433+0x80*slice)&~0x100); //CAL_OVERRIDE off
+		}
+	}
+	if(1)
+	{
+		for(ch=0;ch<4;ch++)
+		{
+			for(slice=0;slice<4;slice++)
+			{
+				for(index=0;index<11;index++)
+				{
+					regadd=0x434+0x80*slice+index/2;
+					o_dataL=REG_DDRPHY_READ(ch,regadd);
+					if(index%2)dataL=(o_dataL>>16);
+					else dataL=o_dataL;
+					dataL&=0xffff;
+				}
+			}
+		}
+	}
+}
+
+
+void mode_register_set(uint32_t freq,uintptr_t phychno,uint32_t mr13_val)
+{
+
+	*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040d00|(0x00100000 * phychno)|mr13_val;	//MRW 13 chA rkA 0d:00 //FSPOP&FSPWP is fixed to 0, VRO off
+	WaitDBCMD();
+
+	if(freq>0x47)
+	{
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e0401d4|(0x00100000 * phychno);	//MRW 1 DeviceFeature1(Post=1.5tck nWR=30 RDpre=static WRPre=2tCK BL=16
+	}
+	else if (freq > 0x2f)
+	{
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e0401c4|(0x00100000 * phychno);	//MRW 1 DeviceFeature1(Post=1.5tck nWR=24 RDpre=static WRPre=2tCK BL=16
+	}
+	else
+	{
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e0401a4|(0x00100000 * phychno);	//MRW 1 DeviceFeature1(Post=1.5tck nWR=16 RDpre=static WRPre=2tCK BL=16
+	}
+
+	WaitDBCMD();
+
+	if(freq>0x47)
+	{
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e04022e|(0x00100000 * phychno);	//MRW 2 DeviceFeature2(0,0SetA,101=WL14,110=RL32)
+	}
+	else if (freq > 0x2f)
+	{
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040224|(0x00100000 * phychno);	//MRW 2 DeviceFeature2(0,0SetA,100=WL12,100=RL24)
+	}
+	else
+	{
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040252|(0x00100000 * phychno);	//MRW 2 DeviceFeature2(0,1SetB,010=WL12,010=RL14)
+	}
+
+	
+	WaitDBCMD();
+
+	*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040300|(0x00100000 * phychno)|DDR_MR3;	//MRW 3 chA rkA 03:31
+	WaitDBCMD();
+
+	*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040b00|(0x00100000 * phychno)|DDR_MR11;	//MRW 11
+	WaitDBCMD();
+
+	*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040c11|(0x00100000 * phychno);	//MRW 12
+	WaitDBCMD();
+
+	*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040e11|(0x00100000 * phychno);	//MRW 14
+	WaitDBCMD();
+
+	*((volatile uint32_t*)DBSC_DBCMD) = 0x0e041600|(0x00100000 * phychno)|DDR_MR22;	//MRW 22 
+	WaitDBCMD();
+}
+
+void _set_reg(uint32_t ch_mask, uint32_t regadd, uint32_t pos, uint32_t width, uint32_t val)
+{
+	int ch;
+	uint32_t dataL;
+	uint64_t valids;
+	uint64_t valids_shift;
+
+	valids=(1ULL<<width)-1;
+	valids_shift = valids<<pos;
+
+	for(ch=0;ch<4;ch++)
+	{
+		if(!((1<<ch)&ch_mask))continue;
+		dataL=REG_DDRPHY_READ(ch,regadd);
+		dataL=(dataL&~valids_shift) | ((val&valids)<<pos);
+		REG_DDRPHY_WRITE(ch,regadd,dataL);
+	}
+}
+
+
+void pvt_lvl_enable_set(uint32_t go)
+{
+	uint32_t i;
+
+	for(i=0;i<4;i++)
+	{
+	//CALVL_EN
+		if((DDR_LVLEN&go)&0x00000001)
+		{
+			REG_DDRPHY_WRITE(i,0x25d,REG_DDRPHY_READ(i,0x25d) | (1ULL<<8));
+		}
+		else
+		{
+			REG_DDRPHY_WRITE(i,0x25d,REG_DDRPHY_READ(i,0x25d) &~(1ULL<<8));
+		}
+
+	//WRLVL_EN
+		if((DDR_LVLEN&go)&0x00000002)
+		{
+			REG_DDRPHY_WRITE(i,0x23a,REG_DDRPHY_READ(i,0x23a) | (1ULL<<24));
+		}
+		else
+		{
+			REG_DDRPHY_WRITE(i,0x23a,REG_DDRPHY_READ(i,0x23a) &~(1ULL<<24));
+		}
+
+	//RDLVL_GATE_EN
+		if((DDR_LVLEN&go)&0x00000004)
+		{
+			REG_DDRPHY_WRITE(i,0x24d,REG_DDRPHY_READ(i,0x24d) | (1ULL<<24));
+		}
+		else
+		{
+			REG_DDRPHY_WRITE(i,0x24d,REG_DDRPHY_READ(i,0x24d) &~(1ULL<<24));
+		}
+
+	//RDLVL_EN
+		if((DDR_LVLEN&go)&0x00000008)
+		{
+			REG_DDRPHY_WRITE(i,0x24d,REG_DDRPHY_READ(i,0x24d) | (1ULL<<16));
+		}
+		else
+		{
+			REG_DDRPHY_WRITE(i,0x24d,REG_DDRPHY_READ(i,0x24d) &~(1ULL<<16));
+		}
+
+	//WRDQLVL_EN
+		if((DDR_LVLEN&go)&0x00000010)
+		{
+			REG_DDRPHY_WRITE(i,0x275,REG_DDRPHY_READ(i,0x275) | (1ULL<<16));
+		}
+		else
+		{
+			REG_DDRPHY_WRITE(i,0x275,REG_DDRPHY_READ(i,0x275) &~(1ULL<<16));
+		}
+
+	//CSLVL_EN
+		if((DDR_LVLEN&go)&0x00000020)
+		{
+			REG_DDRPHY_WRITE(i,0x703,REG_DDRPHY_READ(i,0x703) | (1));
+		}
+		else
+		{
+			REG_DDRPHY_WRITE(i,0x703,REG_DDRPHY_READ(i,0x703) &~(1));
+		}
+	}
+}
+
+void pvt_freq_change_ack(uint32_t freq, uintptr_t phychno, uint32_t freq_flag)
+{
+	uint32_t dataL;
+	uint32_t j;
+
+	dsb_sev();
+	//DFI FREQ
+	*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) = freq_flag;
+	dataL=*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno));
+	dsb_sev();
+
+#ifdef DDR_FREQCHG
+	j = *((volatile uint32_t*)CPG_PLL3CR);
+	dsb_sev();
+
+//	j = (j&0x00ffff7f) | ((((freq/(3-freq_flag))  << 24))&0xff000000)| ((fdiv << 7)&0x00000080);
+	j = (j&0x00ffff7f) | ((freq & 0xff) << 24)| ((freq_flag == 0) << 7);
+	*((volatile uint32_t*)CPG_PLL3CR) = j;
+	dsb_sev();
+	j = *((volatile uint32_t*)CPG_PLL3CR);
+
+	dsb_sev();
+	do {
+		dataL=*((volatile uint32_t*)CPG_PLLECR);
+	} while( (dataL&0x1f00)!=0x1f00 );
+#endif
+
+	//FREQ CHANGE ACK
+	*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0CF20000;
+	dataL=*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno));
+
+	*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x00000000;
+	dsb_sev();
+}
+
+
+uint32_t pvt_pi_training_go_all_o(uint32_t freq)
+{
+	uint32_t dataL;
+	uint32_t phytrainingok;
+	uint32_t retry;
+	uint32_t pll_status[4];
+	uint32_t wait_count[4];
+	uintptr_t phychno;
+
+	if(DDR_TVAL1==0)
+	{
+		for(phychno=0;phychno<4;phychno++)
+		{
+			//dfi_init_start negate
+			*((volatile uint32_t*)(DBSC_DBDFICNT_0+0x40*phychno)) = 0x00000010;
+			dsb_sev();
+		}
+	}
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		if( (DDR_PHYVALID&(1<<phychno))==0 )
+		{
+			continue;
+		}
+		////////////////////////////////////////////////////////////////////////////////////////////////// PI_START 
+		REG_DDRPHY_WRITE(phychno, 0x200, 0x20410B01);
+//		*((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x040 * phychno)) = 0x00000200;
+//		*((volatile uint32_t*)(DBSC_DBPDRGD_0 + 0x040 * phychno)) = 0x20410B01;
+		if(DDR_TVAL1==1)
+		{
+			//dfi_init_start negate 
+			*((volatile uint32_t*)(DBSC_DBDFICNT_0+0x40*phychno)) = 0x00000010;
+			dsb_sev();
+		}
+	}
+	//////////////////////
+
+	dsb_sev();
+
+	if(DDR_TVAL1==2)
+	{
+		for(phychno=0;phychno<4;phychno++)
+		{
+			//dfi_init_start negate 
+			*((volatile uint32_t*)(DBSC_DBDFICNT_0+0x40*phychno)) = 0x00000010;
+			dsb_sev();
+		}
+	}
+
+	phytrainingok=0;
+	retry=0;
+
+	// 0 : wait first unlock
+	// 1 : pll is off
+	// 2 : pll is on
+
+	pll_status[0]=0;//wait unlock
+	pll_status[1]=0;//wait unlock
+	pll_status[2]=0;//wait unlock
+	pll_status[3]=0;//wait unlock
+
+	while(1)
+	{
+		for(phychno=0;phychno<4;phychno++)
+		{
+			if(DDR_PHYVALID&phytrainingok&(1<<phychno))
+			{
+				continue;
+			}
+
+			if(pll_status[phychno]==0)
+			{
+				dataL = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+phychno*0x100));	//Wait for PLL is unlock
+				if((dataL & 0x0000001F) == 0x0)
+				{
+					pll_status[phychno]=1;
+					wait_count[phychno]=1000;
+
+					pvt_freq_change_ack(freq,phychno,0);
+					retry=0;
+				}
+			}
+			else if(pll_status[phychno]==1)
+			{
+				dataL = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+phychno*0x100));	//Wait for PLL Lock
+				if((dataL & 0x0000001F) == 0x1F)
+				{
+					pll_status[phychno]=2;
+					wait_count[phychno]=1000;
+					retry=0;
+				}
+				else
+				{
+					wait_count[phychno]--;
+					if(wait_count[phychno]==0)
+					{
+						pvt_freq_change_ack(freq,phychno,2);
+						wait_count[phychno]=1000;
+					}
+				}
+			}
+			else
+			{
+				if(wait_count[phychno]>0)
+				{
+					wait_count[phychno]--;
+					dataL = REG_DDRPHY_READ ( phychno, 0x0000029B);
+					if(dataL&0x1)
+					{
+						phytrainingok |= (0x1<<phychno);
+						retry=0;
+						// TRAING OK
+					}
+				}
+				else
+				{
+					dataL = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+phychno*0x100));	//Check PLL is unlock again
+					if((dataL & 0x0000001F) == 0x00)
+					{
+						pll_status[phychno]=1;
+						pvt_freq_change_ack(freq,phychno,0);
+						wait_count[phychno]=1000;
+						retry=0;
+					}
+					else
+					{
+						wait_count[phychno]=1000;
+					}
+				}
+			}
+		}
+
+		if( (DDR_PHYVALID& phytrainingok&0xf)==0xf )
+		{
+			break;
+		}
+		retry++;
+		if(retry==10000)
+		{
+			break;
+		}
+	}
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		dataL = REG_DDRPHY_READ ( phychno, 0x0000029B);
+		REG_DDRPHY_WRITE( phychno, 0x29c, dataL);
+	}
+
+	return phytrainingok;
+}
+
+
+inline void PLL3_FREQ(uint32_t freq, uint32_t freq_flag)
+{
+	uint32_t dataL;
+
+#ifdef	DDR_FREQCHG
+
+	dsb_sev();
+
+	if(freq_flag==0)
+	{
+#ifdef	DDR_LOWFIX
+		dataL = DDR_LOWFIX;
+#else
+		dataL = (freq+1)/DDR_LOWDIV-1;
+#endif
+	}
+	else
+	{
+		dataL = (freq);
+	}
+
+	dataL = (dataL<<24);
+	*((volatile uint32_t*)CPG_CPGWPR) = ~dataL;
+	*((volatile uint32_t*)CPG_PLL3CR) =  dataL;
+
+	dsb_sev();
+	do {
+		dataL=*((volatile uint32_t*)CPG_PLLECR);
+	} while( (dataL&0x1f00)!=0x1f00 );
+
+#endif	// DDR_FREQCHG
+}
+
+#define TR_ERR 4000
+#define TR_MAX (TR_ERR*2)
+#define TE_ERR 10000
+#define TE_MAX (TE_ERR*2)
+
+uint32_t pvt_pi_training_go_all(uint32_t freq)
+{
+	uint32_t flag,i,j;
+	uint32_t dataL;
+	uint32_t phytrainingok;
+	uint32_t retry;
+	uintptr_t phychno;
+	uint32_t FREQ_H;
+
+	FREQ_H=1;
+
+	PLL3_FREQ(freq,0);
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		//dfi_init_start negate
+		*((volatile uint32_t*)(DBSC_DBDFICNT_0+0x40*phychno)) = 0x00000010;
+		dsb_sev();
+	}
+
+	if(DDR_TVAL0&0x100)
+	{
+//		//CHANGE IMPEDANCE CODE to CMOS MODE
+		change_lpddr4_en(0xf,0);
+	}
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		if(DDR_TVAL0&0x1)
+		{
+//		0x00000268, 0x09090605, // PI_TDFI_CALVL_STROBE_F2:RW:24:4:=0x09 PI_TDFI_CALVL_STROBE_F1:RW:16:4:=0x09 PI_TDFI_CALVL_STROBE_F0:RW:8:4:=0x06 PI_TDFI_INIT_COMPLETE_MIN:RW:0:8:=0x05
+//NOTE:TDFI_INIT_COMPLETE_MIN: wait cycle for init_complete: should be max value
+			REG_DDRPHY_WRITE(phychno, 0x268, (REG_DDRPHY_READ(phychno,0x268)&0xffffff00) | 0xff);
+		}
+
+		if(DDR_TVAL0&0x2)
+		{
+//		0x0000026D, 0x18020100, // PI_TCKEHDQS_F1:RW:24:6:=0x18 PI_TCKEHDQS_F0:RW:16:6:=0x02 PI_REFRESH_BETWEEN_SEGMENT_DISABLE:RW_D:8:1:=0x01 PI_DRAM_CLK_DISABLE_DEASSERT_SEL:RW:0:1:=0x00
+//		0x0000026E, 0x00010118, // PI_WDQLVL_BST_NUM:RW:16:3:=0x01 PI_WDQLVL_VREF_EN:RW:8:1:=0x01 PI_TCKEHDQS_F2:RW:0:6:=0x18
+//NOTE:TCKEHDQS
+			REG_DDRPHY_WRITE(phychno, 0x26D, (REG_DDRPHY_READ(phychno,0x26D)&0xc0c0ffff) | (0x18<<24) | (0x18<<16));
+			REG_DDRPHY_WRITE(phychno, 0x26E, (REG_DDRPHY_READ(phychno,0x26E)&0xffffffc0) | (0x18<<0));
+		}
+
+		if(DDR_TVAL0&0x4)
+		{
+//		0x00000262, 0x00060100, // PI_TVREF_SHORT_F0:RW:16:10:=0x0006 PI_TDFI_CASEL_F0:RW:8:5:=0x01 PI_TDFI_CACSCA_F0:RW:0:5:=0x00
+//		0x00000263, 0x01000006, // PI_TDFI_CASEL_F1:RW:24:5:=0x01 PI_TDFI_CACSCA_F1:RW:16:5:=0x00 PI_TVREF_LONG_F0:RW:0:10:=0x0006
+//		0x00000264, 0x018E018E, // PI_TVREF_LONG_F1:RW:16:10:=0x018e PI_TVREF_SHORT_F1:RW:0:10:=0x018e
+//		0x00000265, 0x018E0100, // PI_TVREF_SHORT_F2:RW:16:10:=0x018e PI_TDFI_CASEL_F2:RW:8:5:=0x01 PI_TDFI_CACSCA_F2:RW:0:5:=0x00
+//		0x00000266, 0x0F0F018E, // PI_CALVL_VREF_INITIAL_STOP_POINT:RW:24:7:=0x1e PI_CALVL_VREF_INITIAL_START_POINT:RW:16:7:=0x1a PI_TVREF_LONG_F2:RW:0:10:=0x018e
+//NOTE:TDFI_TVREF_LONG: wait cycle from CKE assert to MRW :
+//			REG_DDRPHY_WRITE(phychno, 0x263, REG_DDRPHY_READ(phychno,0x263)&0xfffffc00 | (0x3ff<<0));
+//			REG_DDRPHY_WRITE(phychno, 0x264, REG_DDRPHY_READ(phychno,0x264)&0xfc00ffff | (0x3ff<<16));
+//			REG_DDRPHY_WRITE(phychno, 0x266, REG_DDRPHY_READ(phychno,0x266)&0xfffffc00 | (0x3ff<<0));
+
+			REG_DDRPHY_WRITE(phychno, 0x262, (REG_DDRPHY_READ(phychno,0x262)&0xfc00ffff) | (0x18e<<0));
+			REG_DDRPHY_WRITE(phychno, 0x263, (REG_DDRPHY_READ(phychno,0x263)&0xfffffc00) | (0x18e<<0));
+			REG_DDRPHY_WRITE(phychno, 0x264, (REG_DDRPHY_READ(phychno,0x264)&0xfc00fc00) | (0x18e<<16) | (0x18e<<0));
+			REG_DDRPHY_WRITE(phychno, 0x266, (REG_DDRPHY_READ(phychno,0x266)&0xfffffc00) | (0x18e<<0));
+		}
+
+		if(DDR_TVAL0&0x8)
+		{
+//		0x0000025F, 0x00FF010A, // PI_TCAENT_F0:RW:16:14:=0x0005 PI_TMRZ_F0:RW:8:5:=0x01 PI_TCACKEH:RW:0:5:=0x0a
+//		0x00000260, 0x03018D03, // PI_TMRZ_F2:RW:24:5:=0x03 PI_TCAENT_F1:RW:8:14:=0x018d PI_TMRZ_F1:RW:0:5:=0x03
+//		0x00000261, 0x000A018D, // PI_CA_TRAIN_VREF_EN:RW:24:1:=0x01 PI_TCAEXT:RW:16:5:=0x0a PI_TCAENT_F2:RW:0:14:=0x018d
+//NOTE:TDFI_TCAENT: wait cycle to begin CA operation
+			REG_DDRPHY_WRITE(phychno, 0x25f, (REG_DDRPHY_READ(phychno,0x25f)&0xc000ffff) | (0x3fff<<16));
+			REG_DDRPHY_WRITE(phychno, 0x260, (REG_DDRPHY_READ(phychno,0x260)&0xffc000ff) | (0x3fff<<8));
+			REG_DDRPHY_WRITE(phychno, 0x261, (REG_DDRPHY_READ(phychno,0x261)&0xffffc000) | (0x3fff<<0));
+		}
+
+		if(DDR_TVAL0&0x10)
+		{
+//		0x00000267, 0x10010204, // PI_TDFI_INIT_START_MIN:RW:24:8:=0x10 PI_CALVL_VREF_DELTA:RW:16:4:=0x01 PI_CALVL_VREF_NORMAL_STEPSIZE:RW:8:4:=0x02 PI_CALVL_VREF_INITIAL_STEPSIZE:RW:0:4:=0x04
+//NOTE:TDFI_INIT_START_MIN: wait to assert init_start
+			REG_DDRPHY_WRITE(phychno, 0x267, (REG_DDRPHY_READ(phychno,0x267)&0x00ffffff) | (0xff<<24));
+		}
+		if(DDR_TVAL0&0x20)
+		{
+//		0x00000269, 0x20000202, // PI_TDFI_INIT_START_F0:RW:24:8:=0x20 PI_SW_CA_TRAIN_VREF:RW:16:7:=0x00 PI_CALVL_STROBE_NUM:RW:8:5:=0x02 PI_TCKCKEH:RW:0:4:=0x02
+//NOTE:PI_TCKCKEH :
+			REG_DDRPHY_WRITE(phychno, 0x269, (REG_DDRPHY_READ(phychno,0x269)&0xfffffff0) | (0xf<<0));
+		}
+
+		if(DDR_TVAL0&0x40)
+		{
+//		0x0000026D, 0x18020100, // PI_TCKEHDQS_F1:RW:24:6:=0x18 PI_TCKEHDQS_F0:RW:16:6:=0x02 PI_REFRESH_BETWEEN_SEGMENT_DISABLE:RW_D:8:1:=0x01 PI_DRAM_CLK_DISABLE_DEASSERT_SEL:RW:0:1:=0x00
+			REG_DDRPHY_WRITE(phychno, 0x26d, (REG_DDRPHY_READ(phychno,0x26d)&0xfffffffe) | (0x1<<0));
+		}
+
+		if(DDR_TVAL0&0x100)
+		{
+			for(i=0;i<4;i++)
+			{
+				REG_DDRPHY_WRITE(phychno, 0x44e + 0x80*i, REG_DDRPHY_READ(phychno, 0x44e + 0x80*i)|1);
+			}
+		}
+//		0x00000414, 0x04080000, // PHY_WRLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_0:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_0:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_0:RW:0:1:=0x00
+//		0x00000415, 0x04080a04, // PHY_RDLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_0:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_0:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_0:RW:0:6:=0x00
+		for(i=0;i<4;i++)
+		{
+			j=((REG_DDRPHY_READ(phychno, 0x414 + 0x80*i)>>24)+((DDR_TVAL0>>12)&0x0f))&0x0f;
+			REG_DDRPHY_WRITE(phychno, 0x414 + 0x80*i, (REG_DDRPHY_READ(phychno, 0x414 + 0x80*i)&0xf0ffffff) | (j<<24));
+		}
+	}
+
+	if(DDR_TVAL0&0x80)
+	{
+		for(phychno=0;phychno<4;phychno++)
+		{
+//		0x00000700, 0x00000001, // PHY_SW_GRP_SHIFT_1:RW+:24:5:=0x00 PHY_SW_GRP_SHIFT_0:RW+:16:5:=0x00 PHY_FREQ_SEL_INDEX:RW:8:2:=0x00 PHY_FREQ_SEL_MULTICAST_EN:RW_D:0:1:=0x01
+			REG_DDRPHY_WRITE(phychno, 0x700, (REG_DDRPHY_READ(phychno,0x700)&0xfffffcfe) | (0x2<<8) | (0x0<<0));
+		}
+	}
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		int slice;
+
+		if(DDR_PHYVALID&(1<<phychno))
+		{
+		}
+		else
+		{
+			continue;
+		}
+
+		for(slice=0;slice<4;slice++)
+		{
+			for(i=0;i<4;i++)
+			{
+//		0x00000409, 0x000700C0, // SC_PHY_SNAP_OBS_REGS_0:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_0:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_0:RW:0:10:=0x00c0
+				REG_DDRPHY_WRITE(phychno, 0x409+0x80*slice, (REG_DDRPHY_READ(phychno, 0x409+0x80*slice) | (1<<24)));
+//		0x00000412, 0x00000000, // PHY_RDDQ_ENC_OBS_SELECT_0:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_0:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_0:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_0:RW:0:3:=0x00
+				REG_DDRPHY_WRITE(phychno, 0x412+0x80*slice, ((REG_DDRPHY_READ(phychno, 0x412+0x80*slice)  & 0xfff8ffff) | 0));
+//		0x00000413, 0x00000000, // PHY_FIFO_PTR_OBS_SELECT_0:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_0:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_0:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_0:RW:0:4:=0x00
+				REG_DDRPHY_WRITE(phychno, 0x413+0x80*slice, ((REG_DDRPHY_READ(phychno, 0x413+0x80*slice)  & 0xfff0f0ff) | (9<<16) | (9<<16)));
+
+
+//		0x00000423, 0x00000000, // PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_0:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_0:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_0:RD:0:10:=0x0000
+//		0x00000424, 0x00000000, // PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_0:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_0:RD:0:8:=0x00
+
+				dataL=REG_DDRPHY_READ(phychno, 0x423+0x80*slice);
+//		0x00000425, 0x00000000, // PHY_WR_SHIFT_OBS_0:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_0:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_0:RD:0:7:=0x00
+				dataL=REG_DDRPHY_READ(phychno, 0x425+0x80*slice);
+			}
+		}
+	}
+
+	phytrainingok=DDR_PHYVALID;
+	if(DDR_UPDT_WA&0x1000)
+	{
+		for(phychno=0;phychno<4;phychno++)
+		{
+			if(!(phytrainingok&(1<<phychno)))continue;
+			//////////////////////
+			*((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x040 * phychno)) = 0x200;
+			dsb_sev();
+			*((volatile uint32_t*)(DBSC_DBPDRGD_0 + 0x040 * phychno)) = 0x20410B01;
+			retry=0;
+			do {
+				dataL  = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*phychno)) & 0x1f;
+				retry++;
+			} while(dataL && retry<TR_MAX);
+			if(retry>=TR_ERR)
+			{
+				phytrainingok&=~(1<<phychno);
+			}
+		}
+	}
+	else
+	{
+
+		for(phychno=0;phychno<4;phychno++)
+		{
+			//////////////////////
+			if(!(DDR_PHYVALID&(1<<phychno)))continue;
+			*((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x040 * phychno)) = 0x200;
+			dsb_sev();
+//BEGIN:timing critical:
+			*((volatile uint32_t*)(DBSC_DBPDRGD_0 + 0x040 * phychno)) = 0x20410B01;
+		}
+		do {
+			dataL  = 0;
+			if(DDR_PHYVALID&(1<<0)) dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*0)) & 0x1f;
+			if(DDR_PHYVALID&(1<<1)) dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*1)) & 0x1f;
+			if(DDR_PHYVALID&(1<<2)) dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*2)) & 0x1f;
+			if(DDR_PHYVALID&(1<<3)) dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*3)) & 0x1f;
+		} while(dataL);
+	}
+
+	if(DDR_LVLEN&0x21)
+	{
+
+		if(DDR_TVAL0&0x100)
+		{
+		//CHANGE IMPEDANCE CODE to LP4 MODE
+			change_lpddr4_en(0xf,0);
+		}
+
+		dsb_sev();
+		dsb_sev();
+
+		if(!(DDR_UPDT_WA&0x2000))
+		{
+			PLL3_FREQ(freq,FREQ_H);
+			
+			dsb_sev();
+			dsb_sev();
+		}
+
+		for(phychno=0;phychno<4;phychno++)
+		{
+			if(!(phytrainingok&(1<<phychno)))continue;
+			//DFI FREQ
+			*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) = FREQ_H;
+	//		*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) = 0;
+			dsb_sev();
+			//CHG_ACK
+			*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0CF20000;
+			dsb_sev();
+	//		//CHG_ACK
+			*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0;
+			dsb_sev();
+			if(DDR_UPDT_WA&0x800)	 //SEQ mode
+			{
+				do {
+					dataL  = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*phychno)) & 0x1f;
+				} while(dataL!=0x1f);
+				do {
+					dataL  = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*phychno)) & 0x1f;
+				} while(dataL);
+			}
+		}
+
+
+		if(!(DDR_UPDT_WA&0x800))	//PARA mode
+		{
+			//lock check
+			do {
+				dataL=0x1f;
+				if(phytrainingok&(1<<0))dataL &= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*0)) & 0x1f;
+				if(phytrainingok&(1<<1))dataL &= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*1)) & 0x1f;
+				if(phytrainingok&(1<<2))dataL &= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*2)) & 0x1f;
+				if(phytrainingok&(1<<3))dataL &= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*3)) & 0x1f;
+			} while(dataL!=0x1f);
+
+			///////////////////////////////////////////////////////////////////////
+			//unlock check
+			do {
+				dataL  = 0;
+				if(phytrainingok&(1<<0))dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*0)) & 0x1f;
+				if(phytrainingok&(1<<1))dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*1)) & 0x1f;
+				if(phytrainingok&(1<<2))dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*2)) & 0x1f;
+				if(phytrainingok&(1<<3))dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*3)) & 0x1f;
+			} while(dataL);
+		}
+
+		if(DDR_TVAL0&0x200)
+		{
+		//CHANGE IMPEDANCE CODE to CMOS MODE
+			change_lpddr4_en(0xf,0);
+		}
+
+		dsb_sev();
+		dsb_sev();
+		dsb_sev();
+
+		PLL3_FREQ(freq,0);
+
+		dsb_sev();
+		dsb_sev();
+		dsb_sev();
+
+if(0){	//////// Retry check NG -----
+		for(phychno=0;phychno<4;phychno++)
+		{
+			if(!(phytrainingok&(1<<phychno)))continue;
+
+			//DFI FREQ
+			*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) =0;	// 0;
+	//		*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) =2;	// 2
+			//CHG_ACK
+			*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0CF20000;
+			//CHG_ACK
+			*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0;
+			retry=0;
+			do {
+				dataL  = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*phychno)) & 0x1f;
+				retry++;
+			} while(dataL!=0x1f && retry<1000);
+			if(retry<1000) {
+				// pi_start_status |= (0x10<<phychno);
+			}
+			else {
+				phytrainingok&=~(1<<phychno);
+			}
+		}
+		//------------NG/////
+} else {
+		for(phychno=0;phychno<4;phychno++){
+			if(!(phytrainingok&(1<<phychno)))continue;
+
+			//DFI FREQ
+			*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) =0;	// 0;
+	//		*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) =2;	// 2
+			dsb_sev();
+
+			//CHG_ACK
+			*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0CF20000;
+			dsb_sev();
+
+			//CHG_ACK
+			*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0;
+			dsb_sev();
+			
+			//NOTE: this detecting may be failed, because asserting period is very short (retry = 1 or 2)
+			// therefore, do not treat as error when timeout.
+			retry=0;
+			do {
+				dataL  = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*phychno)) & 0x1f;
+				retry++;
+			} while(dataL!=0x1f && retry<32);
+		}
+}
+
+//END:timing critical:
+		//unlock check
+		do {
+			dataL  = 0;
+			if(phytrainingok&(1<<0))dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*0)) & 0x1f;
+			if(phytrainingok&(1<<1))dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*1)) & 0x1f;
+			if(phytrainingok&(1<<2))dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*2)) & 0x1f;
+			if(phytrainingok&(1<<3))dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*3)) & 0x1f;
+		} while(dataL);
+
+		if(DDR_TVAL0&0x200)
+		{
+		//CHANGE IMPEDANCE CODE to LP4 MODE
+			change_lpddr4_en(0xf,1);
+		}
+
+		dsb_sev();
+		dsb_sev();
+
+		if(DDR_TVAL0&0x80)
+		{
+			for(phychno=0;phychno<4;phychno++)
+			{
+//		0x00000700, 0x00000001, // PHY_SW_GRP_SHIFT_1:RW+:24:5:=0x00 PHY_SW_GRP_SHIFT_0:RW+:16:5:=0x00 PHY_FREQ_SEL_INDEX:RW:8:2:=0x00 PHY_FREQ_SEL_MULTICAST_EN:RW_D:0:1:=0x01
+				REG_DDRPHY_WRITE(phychno, 0x700, (REG_DDRPHY_READ(phychno,0x700)&0xfffffcfe) | (0x2<<8) | (0x1<<0));
+			}
+		}
+
+		if(DDR_UPDT_WA&0x8000)
+		{
+			if(phytrainingok&(1<<0))		copy_csdelay(0,0);
+			if(phytrainingok&(1<<1))		copy_csdelay(1,2);
+			if(phytrainingok&(1<<2))		copy_csdelay(2,0);
+			if(phytrainingok&(1<<3))		copy_csdelay(3,0);
+			if(phytrainingok&(1<<0))*((volatile uint32_t*)DBSC_DBPDCNT_0) = 0x0000CF00;	//dll_rst_n1 -> 0
+			if(phytrainingok&(1<<1))*((volatile uint32_t*)DBSC_DBPDCNT_1) = 0x0000CF00;
+			if(phytrainingok&(1<<2))*((volatile uint32_t*)DBSC_DBPDCNT_2) = 0x0000CF00;
+			if(phytrainingok&(1<<3))*((volatile uint32_t*)DBSC_DBPDCNT_3) = 0x0000CF00;
+			dsb_sev();
+			if(phytrainingok&(1<<0))*((volatile uint32_t*)DBSC_DBPDCNT_0) = 0x0000CF01;	//dll_rst_n0 -> 1
+			if(phytrainingok&(1<<1))*((volatile uint32_t*)DBSC_DBPDCNT_1) = 0x0000CF01;
+			if(phytrainingok&(1<<2))*((volatile uint32_t*)DBSC_DBPDCNT_2) = 0x0000CF01;
+			if(phytrainingok&(1<<3))*((volatile uint32_t*)DBSC_DBPDCNT_3) = 0x0000CF01;
+
+			dsb_sev();
+			dsb_sev();
+		}
+
+	}	/////////////////////////////////////////lvlen&0x21
+
+	dsb_sev();
+	dsb_sev();
+	dsb_sev();
+
+	PLL3_FREQ(freq,FREQ_H);
+
+	dsb_sev();
+	dsb_sev();
+	dsb_sev();
+
+//	for(phychno=0;phychno<4;phychno++)
+//	{
+//		if(!(phytrainingok&(1<<phychno)))continue;
+///////////////////
+	for(i=0;i<4;i++){
+		if(DDR_TVAL1&0x10){
+			phychno=3-i;
+		} else {
+			phychno=i;
+		}
+		if(!(phytrainingok&(1<<phychno)))continue;
+
+		if(DDR_TVAL1&0x03){
+//		0x00000408, 0x00000133, // PHY_LPBK_CONTROL_0:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_0:RW:0:10:=0x0133
+			uint32_t o_ch,o_slice,o_tmp;
+			o_ch=phychno^0x1;
+			if((DDR_TVAL1&0x03)==1)
+					o_tmp=0x43;
+			else	o_tmp=0x47;
+			for(o_slice=0;o_slice<4;o_slice++){
+				REG_DDRPHY_WRITE(o_ch, 0x408+0x80*o_slice,(REG_DDRPHY_READ(o_ch, 0x408+0x80*o_slice) & 0x00ffffff) | (o_tmp<<24));
+			}
+		}
+////////////////////
+		//DFI FREQ
+		*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) = FREQ_H;
+		dsb_sev();
+		//CHG_ACK
+		*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0CF20000;
+		dsb_sev();
+		//CHG_ACK
+		*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0;
+		dsb_sev();
+
+		if(0)
+		{
+			int slice;
+
+			for(slice=0;slice<4;slice++)
+			{
+				for(i=0;i<4;i++)
+				{
+//		0x00000409, 0x000700C0, // SC_PHY_SNAP_OBS_REGS_0:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_0:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_0:RW:0:10:=0x00c0
+					REG_DDRPHY_WRITE(phychno, 0x409+0x80*slice, (REG_DDRPHY_READ(phychno, 0x409+0x80*slice) | (1<<24)));
+//		0x00000412, 0x00000000, // PHY_RDDQ_ENC_OBS_SELECT_0:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_0:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_0:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_0:RW:0:3:=0x00
+					REG_DDRPHY_WRITE(phychno, 0x412+0x80*slice, ((REG_DDRPHY_READ(phychno, 0x412+0x80*slice)  & 0xfff8ffff) | 0));
+//		0x00000413, 0x00000000, // PHY_FIFO_PTR_OBS_SELECT_0:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_0:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_0:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_0:RW:0:4:=0x00
+					REG_DDRPHY_WRITE(phychno, 0x413+0x80*slice, ((REG_DDRPHY_READ(phychno, 0x413+0x80*slice)  & 0xfff0f0ff) | (9<<16) | (9<<16)));
+
+
+//		0x00000423, 0x00000000, // PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_0:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_0:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_0:RD:0:10:=0x0000
+//		0x00000424, 0x00000000, // PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_0:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_0:RD:0:8:=0x00
+
+					dataL=REG_DDRPHY_READ(phychno, 0x423+0x80*slice);
+//		0x00000425, 0x00000000, // PHY_WR_SHIFT_OBS_0:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_0:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_0:RD:0:7:=0x00
+					dataL=REG_DDRPHY_READ(phychno, 0x425+0x80*slice);
+				}
+			}
+		}
+
+		if(DDR_UPDT_WA&0x400)	//SEQ MODE
+		{
+			retry=0;
+			while(retry<TE_MAX)
+			{
+				dataL = REG_DDRPHY_READ ( phychno, 0x0000029B);
+				if(dataL&0x1)break;
+				retry++;
+			}
+			if(retry>=TE_ERR)
+			{
+				phytrainingok&=~(1<<phychno);
+			}
+		}
+
+		if(DDR_TVAL1&0x03)
+		{
+//		0x00000408, 0x00000133, // PHY_LPBK_CONTROL_0:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_0:RW:0:10:=0x0133
+			uint32_t o_ch,o_slice,o_tmp;
+			o_ch=phychno^0x1;
+			o_tmp=0x0;
+
+			for(o_slice=0;o_slice<4;o_slice++){
+				REG_DDRPHY_WRITE(o_ch, 0x408+0x80*o_slice, 
+					(REG_DDRPHY_READ (o_ch, 0x408+0x80*o_slice) & 0x00ffffff) | (o_tmp<<24));
+			}
+		}
+	}
+
+	retry=10000;
+	flag=0;
+	while(retry>0)
+	{
+		for(phychno=0;phychno<4;phychno++)
+		{
+			if(!(phytrainingok&(1<<phychno)))continue;
+			if(flag & (1<<phychno))continue;
+			dataL = REG_DDRPHY_READ ( phychno, 0x0000029B);
+			
+			if(dataL&0x1)
+			{
+				flag |= (0x1<<phychno);
+				// TRAING OK
+			}
+		}
+		if((flag&phytrainingok)==phytrainingok)break;
+		retry--;
+	}
+
+	phytrainingok&=flag;
+
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		dataL = REG_DDRPHY_READ ( phychno, 0x0000029B);
+		REG_DDRPHY_WRITE( phychno, 0x29c, dataL);
+	}
+
+	return phytrainingok;
+}
+
+uint32_t pvt_pi_training(uint32_t freq)
+{
+	uint32_t phytrainingok=0;
+
+	if(1)
+	{
+		pvt_lvl_enable_set(0x3f);
+
+		if(DDR_UPDT_WA&0x4000)
+		{
+			phytrainingok = pvt_pi_training_go_all_soft(freq);
+		}
+		else if(DDR_UPDT_WA&0x100)
+		{
+			phytrainingok = pvt_pi_training_go_all_o(freq);
+		}
+		else
+		{
+			phytrainingok = pvt_pi_training_go_all(freq);
+		}
+
+		//FREQ_SEL_INDEX=3 (not needed? because MULTICAST_EN=1) ==> NEED!! otherwise, copy will not copy
+		REG_DDRPHY_WRITE (0,0x00000700,0x0301);
+		REG_DDRPHY_WRITE (1,0x00000700,0x0301);
+		REG_DDRPHY_WRITE (2,0x00000700,0x0301);
+		REG_DDRPHY_WRITE (3,0x00000700,0x0301);
+
+		copy_dqdelay(1 ,1,2);		// ch1 2:0:1:3
+		copy_dqdelay(1 ,3,0);
+		copy_dqdelay(2 ,1,3);		// ch2 3:1:2:0
+		copy_dqdelay(2 ,2,0);
+		copy_dqdelay(3 ,1,3);		// ch3 3:1:2:0
+		copy_dqdelay(3 ,2,0);
+
+
+		if(DDR_LVLEN&0x20)
+		{
+			if(DDR_CALVLSIDE== 0x0)
+			{
+				copy_csdelay(0,0);
+				copy_csdelay(1,0);
+				copy_csdelay(2,0);
+				copy_csdelay(3,0);
+			}
+			else if(DDR_CALVLSIDE== 0x1)
+			{
+				copy_csdelay(0,2);
+				copy_csdelay(1,2);
+				copy_csdelay(2,2);
+				copy_csdelay(3,2);
+			}
+			else
+			{
+				copy_csdelay(0,0);
+				copy_csdelay(1,2);
+				copy_csdelay(2,0);
+				copy_csdelay(3,0);
+			}
+		}
+
+		if(DDR_LVLEN&0x4)
+		{
+			adjust_rddqsgatedelay(0);
+			adjust_rddqsgatedelay(1);
+			adjust_rddqsgatedelay(2);
+			adjust_rddqsgatedelay(3);
+		}
+	}
+
+	return phytrainingok;
+}
+
+void WaitDBCMD(void)
+{
+	uint32_t dataL;
+
+	while(1)
+	{
+		dataL = *((volatile uint32_t*)DBSC_DBWAIT);	//wait DBCMD 1=busy, 0=ready
+		if((dataL & 0x00000001) == 0x0)	break;
+	}
+}
+
+
+void REG_DDRPHY_WRITE ( uintptr_t phyno, uint32_t regadd, uint32_t regdata)
+{
+	uint32_t i;
+
+	dsb_sev();
+	*((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x40 * phyno)) = regadd;
+	i = *((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x40 * phyno));	//
+	i = *((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x40 * phyno));	//
+	dsb_sev();
+	*((volatile uint32_t*)(DBSC_DBPDRGD_0 + 0x40 * phyno)) = regdata;
+	i = *((volatile uint32_t*)(DBSC_DBPDRGD_0 + 0x40 * phyno));	//
+	i = *((volatile uint32_t*)(DBSC_DBPDRGD_0 + 0x40 * phyno));	//
+	dsb_sev();
+	(void)i;
+}
+
+void change_lpddr4_en(uintptr_t phychno, uint32_t mode)
+{
+/*
+		0x0000071A, 0x027F6E00, // PHY_PAD_FDBK_DRIVE:RW+:8:18:=0x000411 PHY_TDFI_PHY_WRDELAY:RW:0:1:=0x00
+		0x0000071B, 0x047F027F, // PHY_PAD_DQS_DRIVE:RW+:16:12:=0x0040 PHY_PAD_DATA_DRIVE:RW+:0:10:=0x0040
+		0x0000071C, 0x00027F6E, // PHY_PAD_ADDR_DRIVE:RW+:0:18:=0x000411 // LPDDR4_EN bit 14 is it needed?
+		0x0000071D, 0x00047F6E, // PHY_PAD_CLK_DRIVE:RW+:0:20:=0x000411
+		0x0000071E, 0x00030F68, // PHY_PAD_FDBK_TERM:RW+:0:18:=0x004410 //PVTP = 0x28, PVTN=0x3d, PVTr=0x10
+		0x0000071F, 0x00010F68, // PHY_PAD_DATA_TERM:RW+:0:17:=0x004410
+		0x00000720, 0x00010F68, // PHY_PAD_DQS_TERM:RW+:0:17:=0x004410
+		0x00000721, 0x00010F68, // PHY_PAD_ADDR_TERM:RW+:0:18:=0x004410
+		0x00000722, 0x00010F68, // PHY_PAD_CLK_TERM:RW+:0:18:=0x004410
+		0x00000723, 0x00027F6E, // PHY_PAD_CKE_DRIVE:RW+:0:18:=0x000411
+		0x00000724, 0x00010F68, // PHY_PAD_CKE_TERM:RW+:0:18:=0x004410
+		0x00000725, 0x00027F6E, // PHY_PAD_RST_DRIVE:RW+:0:18:=0x000411
+		0x00000726, 0x00010F68, // PHY_PAD_RST_TERM:RW+:0:18:=0x004410
+		0x00000727, 0x00027F6E, // PHY_PAD_CS_DRIVE:RW+:0:18:=0x000411
+		0x00000728, 0x00010F68, // PHY_PAD_CS_TERM:RW+:0:18:=0x004410
+*/
+
+	uint32_t i,from,to;
+	uint32_t set,clr;
+	uint32_t dataL;
+	uint32_t addr;
+
+#ifdef	DDR_LPDDR4_EN_OFF_FIRST
+#else
+	return;
+#endif
+
+	if(phychno>=4)
+	{
+		from=0; to=3;
+	}
+	else
+	{
+		from=phychno; to=phychno;
+	}
+
+
+	for(i=from;i<=to;i++)
+	{
+#ifdef	DDR_LPDDR4_EN_OFF_FIRST
+		set = 1ULL <<14;
+		clr = ~set;
+		
+		if(!mode)
+		{
+			set = 0;
+		};
+		
+		addr=0x71c;	REG_DDRPHY_WRITE(i,addr,dataL=((REG_DDRPHY_READ(i,addr)&clr)|set) );
+		addr=0x71d;	REG_DDRPHY_WRITE(i,addr,dataL=((REG_DDRPHY_READ(i,addr)&clr)|set) );
+		addr=0x723;	REG_DDRPHY_WRITE(i,addr,dataL=((REG_DDRPHY_READ(i,addr)&clr)|set) );
+		addr=0x727;	REG_DDRPHY_WRITE(i,addr,dataL=((REG_DDRPHY_READ(i,addr)&clr)|set) );
+#else
+		addr=0x71c;	REG_DDRPHY_WRITE(i,addr,dataL=0x00027B22 );
+		addr=0x71d;	REG_DDRPHY_WRITE(i,addr,dataL=0x00047B22 );
+		addr=0x723;	REG_DDRPHY_WRITE(i,addr,dataL=0x00027B22 );
+		addr=0x727;	REG_DDRPHY_WRITE(i,addr,dataL=0x00027B22 );
+#endif
+	}
+
+}
+
+void copy_csdelay(uint32_t	phychno, uint32_t s_byte)
+{
+	uint32_t	dataL[4];
+
+	dataL[0] = ((REG_DDRPHY_READ ( phychno, 0x00000712))& 0x000fff00) >> 8;
+	dataL[1] = ((REG_DDRPHY_READ ( phychno, 0x00000713))& 0x00000fff);
+	dataL[2] = ((REG_DDRPHY_READ ( phychno, 0x00000713))& 0x0fff0000) >> 16;
+	dataL[3] = ((REG_DDRPHY_READ ( phychno, 0x00000714))& 0x00000fff);
+
+	REG_DDRPHY_WRITE (phychno,0x00000712,( dataL[s_byte] << 8) |((REG_DDRPHY_READ ( phychno, 0x00000712)) & 0x0ff));
+	REG_DDRPHY_WRITE (phychno,0x00000713,((dataL[s_byte] << 16)| dataL[s_byte]));
+	REG_DDRPHY_WRITE (phychno,0x00000714,  dataL[s_byte]);
+
+}
+
+void adjust_rddqsgatedelay(uintptr_t phychno)
+{
+	uint32_t	i;
+	uint32_t	s_dataL;
+	uint32_t	d_dataL;
+	uint32_t	teL;
+	uint32_t	leL;
+	uint32_t	meL;
+	uint32_t	fsL;
+	uint32_t	latL,dlyL;
+	uint32_t	maxlatL =0x0;
+	uint32_t	maxdlyL =0x0;
+
+#ifdef	DDR_DBS_DFI_WA
+	for(i=0;i<4;i++)
+	{
+		leL = (REG_DDRPHY_READ ( phychno, 0x00000429 + 0x80*i)>>16) & 0x3fff;
+		teL = (REG_DDRPHY_READ ( phychno, 0x0000042A + 0x80*i)>>0 ) & 0x3fff;
+		fsL = (REG_DDRPHY_READ ( phychno, 0x00000456 + 0x80*i)>>16) & 0x3ff;
+		meL = (leL+teL)>>1;
+		dlyL = (meL-fsL)&0x1ff;
+		latL = ((meL-fsL)>>9) & 7;
+		if(maxlatL < (dlyL + latL* 0x200))
+		{
+			maxdlyL =dlyL;
+			maxlatL =dlyL + latL* 0x200;
+		}
+	}
+#endif
+
+	for(i=0;i<4;i++)
+	{
+		leL = (REG_DDRPHY_READ ( phychno, 0x00000429 + 0x80*i)>>16) & 0x3fff;
+		teL = (REG_DDRPHY_READ ( phychno, 0x0000042A + 0x80*i)>>0 ) & 0x3fff;
+		fsL = (REG_DDRPHY_READ ( phychno, 0x00000456 + 0x80*i)>>16 ) & 0x3ff;
+		meL = (leL+teL)>>1;
+		if(meL<fsL)meL=fsL;///CLIP
+		dlyL = (meL-fsL)&0x1ff;
+		latL = ((meL-fsL)>>9) & 7;
+#ifdef	DDR_DBS_DFI_WA
+		if((maxdlyL > 0xff) & (dlyL < 0x100))
+		{
+			REG_DDRPHY_WRITE ( phychno, 0x0454 + 0x80*i, (REG_DDRPHY_READ ( phychno, 0x00000454 + 0x80*i) + 0x00010000));
+		}
+#endif
+		s_dataL = REG_DDRPHY_READ ( phychno, 0x0000044C + 0x80*i);
+		d_dataL = (s_dataL & 0xff000000) | (latL<<16) | dlyL;
+		REG_DDRPHY_WRITE ( phychno, 0x0000044C + 0x80*i,d_dataL);
+	}
+}
+
+
+void copy_dqdelay(uintptr_t phychno, uint32_t s_byte, uint32_t d_byte)
+{
+	uint32_t	i;
+	uint32_t	s_dataL;
+	uint32_t	d_dataL;
+
+	for (i=0x43A;i<=0x43E;i++)
+	{
+								// 43A-43E:PHY_CLK_WRDQx_SLAVE_DELAY_0
+								// 43F-442:PHY_RDDQx_SLAVE_DELAY_0
+								// 443-44B:PHY_RDDQS_DQx_FALL_SLAVE_DELAY_0
+		if(i==0x43E)
+		{			// 43E:PHY_CLK_WRDQS_SLAVE_DELAY_0:RW+:16:10
+			s_dataL = (REG_DDRPHY_READ ( phychno, i+s_byte*0x80)) & 0x0000ffff; // DM code
+			d_dataL = (REG_DDRPHY_READ ( phychno, i+d_byte*0x80)) & 0xffff0000; // DQS code
+			REG_DDRPHY_WRITE (phychno,i+d_byte*0x80,(s_dataL|d_dataL));
+		}
+		else
+		{
+			s_dataL = REG_DDRPHY_READ ( phychno, i+s_byte*0x80);
+			REG_DDRPHY_WRITE (phychno,i+d_byte*0x80,s_dataL);
+		}
+	}
+
+}
+
+uint32_t pvt_pi_training_go_all_soft(uint32_t freq)
+{
+	uint32_t flag;
+	uint32_t dataL;
+	uint32_t phytrainingok;
+	uint32_t retry;
+	uintptr_t phychno;
+
+	PLL3_FREQ(freq,0);
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		//dfi_init_start negate
+		*((volatile uint32_t*)(DBSC_DBDFICNT_0+0x40*phychno)) = 0x00000010;
+		dsb_sev();
+	}
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		//////////////////////
+		*((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x040 * phychno)) = 0x200;
+		dsb_sev();
+		*((volatile uint32_t*)(DBSC_DBPDRGD_0 + 0x040 * phychno)) = 0x20410B01;
+		dsb_sev();
+
+		dsb_sev();
+		dsb_sev();
+	}
+	do {
+		dataL  = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*0)) & 0x1f;
+		dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*1)) & 0x1f;
+		dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*2)) & 0x1f;
+		dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*3)) & 0x1f;
+		dsb_sev();
+	} while(dataL);
+
+	dsb_sev();
+	dsb_sev();
+
+	if(!(DDR_UPDT_WA&0x2000))
+	{
+		PLL3_FREQ(freq,2);
+		dsb_sev();
+		dsb_sev();
+	}
+
+//	//CHANGE IMPEDANCE CODE to LP4 MODE
+//	change_lpddr4_en(0xf,1);
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		//DFI FREQ
+		*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) = 2;
+//		*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) = 0;
+		dsb_sev();
+		//CHG_ACK
+		*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0CF20000;
+		dsb_sev();
+//		//CHG_ACK
+		*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0;
+		dsb_sev();
+
+		dsb_sev();
+		dsb_sev();
+	}
+
+
+	///////////////////////////////////////////////////////////////////////
+	//unlock check
+	do {
+		dataL  = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*0)) & 0x1f;
+		dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*1)) & 0x1f;
+		dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*2)) & 0x1f;
+		dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*3)) & 0x1f;
+		dsb_sev();
+	} while(dataL);
+
+	dsb_sev();
+	dsb_sev();
+
+	PLL3_FREQ(freq,0);
+
+	dsb_sev();
+	dsb_sev();
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		//DFI FREQ
+		*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) =0;	// 0;
+//		*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) =2;	// 2
+		//CHG_ACK
+		*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0CF20000;
+		//CHG_ACK
+		*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0;
+
+		dsb_sev();
+		dsb_sev();
+	}
+
+//END:timing critical:
+	//unlock check
+	do {
+		dataL  = *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*0)) & 0x1f;
+		dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*1)) & 0x1f;
+		dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*2)) & 0x1f;
+		dataL |= *((volatile uint32_t*)(DBSC_PLL_LOCK_0+0x100*3)) & 0x1f;
+	} while(dataL);
+
+	dsb_sev();
+	dsb_sev();
+
+	PLL3_FREQ(freq,2);
+
+	dsb_sev();
+	dsb_sev();
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		//DFI FREQ
+		*((volatile uint32_t*)(DBSC_DFI_FREQ_0 +0x040 * phychno)) = 2;
+		dsb_sev();
+		//CHG_ACK
+		*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0CF20000;
+		dsb_sev();
+		//CHG_ACK
+		*((volatile uint32_t*)(DBSC_FREQ_CHG_ACK_0 + 0x40 * phychno)) = 0x0;
+
+		dsb_sev();
+		dsb_sev();
+	}
+
+	retry=100000;
+	flag=0;
+	while(retry>0)
+	{
+		for(phychno=0;phychno<4;phychno++)
+		{
+			if(flag & (1<<phychno))continue;
+			dataL = REG_DDRPHY_READ ( phychno, 0x0000029B);
+			if(dataL&0x1)
+			{
+				flag |= (0x1<<phychno);
+				// TRAING OK
+			}
+		}
+		if((flag&DDR_PHYVALID)==DDR_PHYVALID)break;
+		retry--;
+	}
+
+	phytrainingok=flag;
+
+	for(phychno=0;phychno<4;phychno++)
+	{
+		dataL = REG_DDRPHY_READ ( phychno, 0x0000029B);
+		REG_DDRPHY_WRITE( phychno, 0x29c, dataL);
+	}
+
+	return phytrainingok;
+}
+
+inline void dsb_sev(void)
+{
+	__asm__ __volatile__ ("dsb sy");
+
+}
+
+uint32_t REG_DDRPHY_READ ( uintptr_t phyno, uint32_t regadd)
+{
+	uint32_t i;
+
+	dsb_sev();
+	*((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x40 * phyno)) = regadd;
+	dsb_sev();
+	i = *((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x40 * phyno));	//
+	i = *((volatile uint32_t*)(DBSC_DBPDRGA_0 + 0x40 * phyno));	//
+	i = *((volatile uint32_t*)(DBSC_DBPDRGD_0 + 0x40 * phyno));
+	i = *((volatile uint32_t*)(DBSC_DBPDRGD_0 + 0x40 * phyno));
+	dsb_sev();
+	return i ;
+}
+
+uint32_t InitDDR_0917(uint32_t freq)
+{
+	uint32_t i=0;
+	uint32_t j=0;
+	uint32_t k=0;
+	uint32_t dataL=0;
+	uintptr_t phychno=0x0;
+	uint32_t phytrainingok=0x0;
+	uint32_t retry;
+	uint32_t ch,slice;
+
+
+//	if(mode==0 || mode==1|| mode==3)
+	{
+		//DDR RESET ASSERT
+		*((volatile uint32_t*)DBSC_DBPDCNT0_0) = 0x01;
+		*((volatile uint32_t*)DBSC_DBPDCNT0_1) = 0x01;
+		*((volatile uint32_t*)DBSC_DBPDCNT0_2) = 0x01;
+		*((volatile uint32_t*)DBSC_DBPDCNT0_3) = 0x01;
+
+		dsb_sev();
+
+#ifdef	DDR_PLL3ONLY
+		dataL = *((volatile uint32_t*)DBSC_DBKIND);
+
+/*
+//		//reset pulse
+		*((volatile uint32_t*)CPG_CPGWPR) = ~0x40000000;
+		dsb_sev();
+		do {
+			*((volatile uint32_t*)CPG_SRCR4) =  0x40000000;
+//			dsb_sev();
+			*((volatile uint32_t*)CPG_SRSTCLR4) = 0x40000000;
+			dsb_sev();
+			dataL = *((volatile uint32_t*)DBSC_DBKIND);
+		} while (dataL!=0);
+*/
+		*((volatile uint32_t*)DBSC_DBPDLK_0) = 0x0000A55A;	//Unlock DDRPHY register
+		*((volatile uint32_t*)DBSC_DBPDLK_1) = 0x0000A55A;
+		*((volatile uint32_t*)DBSC_DBPDLK_2) = 0x0000A55A;
+		*((volatile uint32_t*)DBSC_DBPDLK_3) = 0x0000A55A;
+
+		REG_DDRPHY_WRITE(0,0x229,0x0);
+		REG_DDRPHY_WRITE(1,0x229,0x0);
+		REG_DDRPHY_WRITE(2,0x229,0x0);
+		REG_DDRPHY_WRITE(3,0x229,0x0);
+
+		dataL=	*((volatile uint32_t*)CPG_PLLECR);
+		*((volatile uint32_t*)CPG_CPGWPR) = ~(dataL & 0xFFFFFFF7);
+		*((volatile uint32_t*)CPG_PLLECR) =   dataL & 0xFFFFFFF7;
+
+		dsb_sev();
+
+		// PLL3
+#ifdef	DDR_FREQCHG
+		j = *((volatile uint32_t*)CPG_PLL3CR);
+
+#ifdef	DDR_LOWFIX
+		j = (j&0x00ffff7f) | ((DDR_LOWFIX & 0xff) << 24);
+#else	// DDR_LOWFIX
+		j = (j&0x00ffff7f) | ((freq & 0xff) << 24) | 0x080;
+#endif	// DDR_LOWFIX
+
+#else	// DDR_FREQCHG
+		j = *((volatile uint32_t*)CPG_PLL3CR);
+		j = (j&0x00ffff7f) | ((freq << 24)&0xff000000)| ((DDR_FDIV << 7)&0x00000080);
+#endif	// DDR_FREQCHG
+
+		*((volatile uint32_t*)CPG_CPGWPR) = ~j;
+		*((volatile uint32_t*)CPG_PLL3CR) =  j;		// CPG_PLL3CL
+
+		*((volatile uint32_t*)CPG_CPGWPR) = ~(dataL |0x8);
+		*((volatile uint32_t*)CPG_PLLECR) =   dataL |0x8;
+
+		do {
+			dataL=*((volatile uint32_t*)CPG_PLLECR);
+		} while( (dataL&0x800)==0 );
+
+		*((volatile uint32_t*)CPG_CPGWPR) = ~0x40000000;
+		do {
+			*((volatile uint32_t*)CPG_SRCR4) = 0x40000000;
+			*((volatile uint32_t*)CPG_SRSTCLR4) = 0x40000000;
+			dataL = *((volatile uint32_t*)DBSC_DBKIND);
+		} while (dataL!=0);
+
+		REG_DDRPHY_WRITE(0,0x229,0x100);
+		REG_DDRPHY_WRITE(1,0x229,0x100);
+		REG_DDRPHY_WRITE(2,0x229,0x100);
+		REG_DDRPHY_WRITE(3,0x229,0x100);
+
+#endif	//	DDR_PLL3ONLY
+
+		pvt_dbsc_regset(freq);
+
+		//DDR RESET NEGATE
+		*((volatile uint32_t*)DBSC_DBPDCNT0_0) = 0x00;
+		*((volatile uint32_t*)DBSC_DBPDCNT0_1) = 0x00;
+		*((volatile uint32_t*)DBSC_DBPDCNT0_2) = 0x00;
+		*((volatile uint32_t*)DBSC_DBPDCNT0_3) = 0x00;
+
+		//(DDRPHY Kick Initialize Sequence)
+		*((volatile uint32_t*)DBSC_DBPDLK_0) = 0x0000A55A;	//Unlock DDRPHY register(AGAIN)
+		*((volatile uint32_t*)DBSC_DBPDLK_1) = 0x0000A55A;
+		*((volatile uint32_t*)DBSC_DBPDLK_2) = 0x0000A55A;
+		*((volatile uint32_t*)DBSC_DBPDLK_3) = 0x0000A55A;
+
+		//(PHY parameter and PI parameter Initialize)	Initialize Leveling parameter including WDQLVL
+
+		for( i=0; i<DDR_PHY_NUM; i++ )
+		{
+			REG_DDRPHY_WRITE(0,DDR_PHY_suresh[i][0],DDR_PHY_suresh[i][1]);
+			REG_DDRPHY_WRITE(1,DDR_PHY_suresh[i][0],DDR_PHY_suresh[i][1]);
+			REG_DDRPHY_WRITE(2,DDR_PHY_suresh[i][0],DDR_PHY_suresh[i][1]);
+			REG_DDRPHY_WRITE(3,DDR_PHY_suresh[i][0],DDR_PHY_suresh[i][1]);
+		}
+
+#ifdef	DDR_DRIVE
+		for( i=0; i<DDR_PHY_DRIVE_TERM_OVERWRITE_NUM; i++ )
+		{
+			REG_DDRPHY_WRITE(0,DDR_PHY_DDR_PHY_DRIVE_TERM_OVERWITE_1600[i][0],DDR_PHY_DDR_PHY_DRIVE_TERM_OVERWITE_1600[i][1]);
+			REG_DDRPHY_WRITE(1,DDR_PHY_DDR_PHY_DRIVE_TERM_OVERWITE_1600[i][0],DDR_PHY_DDR_PHY_DRIVE_TERM_OVERWITE_1600[i][1]);
+			REG_DDRPHY_WRITE(2,DDR_PHY_DDR_PHY_DRIVE_TERM_OVERWITE_1600[i][0],DDR_PHY_DDR_PHY_DRIVE_TERM_OVERWITE_1600[i][1]);
+			REG_DDRPHY_WRITE(3,DDR_PHY_DDR_PHY_DRIVE_TERM_OVERWITE_1600[i][0],DDR_PHY_DDR_PHY_DRIVE_TERM_OVERWITE_1600[i][1]);
+		}
+#endif
+//		0x00000404, 0x03006E0E, // PHY_DQS_TSEL_ENABLE_0:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_0:RW:0:24:=0x665555
+//		0x00000405, 0x02006E0E, // PHY_TWO_CYC_PREAMBLE_0:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_0:RW:0:24:=0x665555
+#ifdef	DDR_TSEL_SELECT
+		{
+			uint32_t adr;
+
+			for(ch=0;ch<4;ch++)
+			{
+				for(slice=0;slice<4;slice++)
+				{
+					for(i=0;i<2;i++)
+					{
+						adr=0x404+i+0x80*slice;
+						dataL=REG_DDRPHY_READ(ch,adr);
+						dataL=(dataL&0xff000000) | DDR_TSEL_SELECT;
+						REG_DDRPHY_WRITE(ch,adr,dataL);
+					}
+				}
+			}
+		}
+#endif
+
+		for( i=0; i<DDR_PI_NUM; i++ )
+		{
+			REG_DDRPHY_WRITE(0,DDR_PI_suresh[i][0],DDR_PI_suresh[i][1]);
+			REG_DDRPHY_WRITE(1,DDR_PI_suresh[i][0],DDR_PI_suresh[i][1]);
+			REG_DDRPHY_WRITE(2,DDR_PI_suresh[i][0],DDR_PI_suresh[i][1]);
+			REG_DDRPHY_WRITE(3,DDR_PI_suresh[i][0],DDR_PI_suresh[i][1]);
+		}
+
+// Traning Reg setting
+		if(freq>0x53)
+		{
+			//							// def 3200
+		}
+		else if(freq>0x47)
+		{
+//			freq2800_reg_set();			// need more tuning
+		}
+		else if(freq>0x2f)
+		{
+//			freq2400_reg_set();			// need more tuning
+		}
+		else
+		{
+			freq1600_reg_set();
+		}
+
+		//Set PCB bit swap connection 
+		for( i=0; i<9+5; i++ )
+		{
+			REG_DDRPHY_WRITE(0,DDR_SIP_SWAP_CH0[i][0],DDR_SIP_SWAP_CH0[i][1]);
+			REG_DDRPHY_WRITE(1,DDR_SIP_SWAP_CH1[i][0],DDR_SIP_SWAP_CH1[i][1]);
+			REG_DDRPHY_WRITE(2,DDR_SIP_SWAP_CH2[i][0],DDR_SIP_SWAP_CH2[i][1]);
+			REG_DDRPHY_WRITE(3,DDR_SIP_SWAP_CH3[i][0],DDR_SIP_SWAP_CH3[i][1]);
+		}
+
+		for (i=0;i<4;i++)
+		{
+			REG_DDRPHY_WRITE(i,0x40B,REG_DDRPHY_READ(i,0x40B) & (0xfffcffff));
+			REG_DDRPHY_WRITE(i,0x48B,REG_DDRPHY_READ(i,0x48B) & (0xfffcffff));
+			REG_DDRPHY_WRITE(i,0x50B,REG_DDRPHY_READ(i,0x50B) & (0xfffcffff));
+			REG_DDRPHY_WRITE(i,0x58B,REG_DDRPHY_READ(i,0x58B) & (0xfffcffff));
+		}
+
+		if(DDR_CALVLSIDE== 0x0)
+		{
+			REG_DDRPHY_WRITE(0,0x709,((REG_DDRPHY_READ(0,0x709) & 0xffffff00) | 0x0000010));
+			REG_DDRPHY_WRITE(0,0x257,((REG_DDRPHY_READ(0,0x257) & 0xfffffff0) | 0x0000001));
+
+			REG_DDRPHY_WRITE(1,0x709,((REG_DDRPHY_READ(1,0x709) & 0xffffff00) | 0x0000011));
+			REG_DDRPHY_WRITE(1,0x257,((REG_DDRPHY_READ(1,0x257) & 0xfffffff0) | 0x0000001));
+			REG_DDRPHY_WRITE(1,0x60c,0x00543210);
+			REG_DDRPHY_WRITE(1,0x421,((REG_DDRPHY_READ(1,0x421) & 0xfffffffe) | 0x0000001));
+			REG_DDRPHY_WRITE(1,0x4a1,((REG_DDRPHY_READ(1,0x4a1) & 0xfffffffe) | 0x0000001));
+			REG_DDRPHY_WRITE(1,0x521,((REG_DDRPHY_READ(1,0x521) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(1,0x5a1,((REG_DDRPHY_READ(1,0x5a1) & 0xfffffffe) | 0x0000000));
+
+			REG_DDRPHY_WRITE(2,0x709,((REG_DDRPHY_READ(2,0x709) & 0xffffff00) | 0x0000000));
+			REG_DDRPHY_WRITE(2,0x257,((REG_DDRPHY_READ(2,0x257) & 0xfffffff0) | 0x0000001));
+			REG_DDRPHY_WRITE(2,0x60c,0x00DCBA98);
+			REG_DDRPHY_WRITE(2,0x421,((REG_DDRPHY_READ(2,0x421) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(2,0x4a1,((REG_DDRPHY_READ(2,0x4a1) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(2,0x521,((REG_DDRPHY_READ(2,0x521) & 0xfffffffe) | 0x0000001));
+			REG_DDRPHY_WRITE(2,0x5a1,((REG_DDRPHY_READ(2,0x5a1) & 0xfffffffe) | 0x0000001));
+
+			REG_DDRPHY_WRITE(3,0x709,((REG_DDRPHY_READ(3,0x709) & 0xffffff00) | 0x0000000));
+			REG_DDRPHY_WRITE(3,0x257,((REG_DDRPHY_READ(3,0x257) & 0xfffffff0) | 0x0000001));
+			REG_DDRPHY_WRITE(3,0x60c,0x00DCBA98);
+			REG_DDRPHY_WRITE(3,0x421,((REG_DDRPHY_READ(3,0x421) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(3,0x4a1,((REG_DDRPHY_READ(3,0x4a1) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(3,0x521,((REG_DDRPHY_READ(3,0x521) & 0xfffffffe) | 0x0000001));
+			REG_DDRPHY_WRITE(3,0x5a1,((REG_DDRPHY_READ(3,0x5a1) & 0xfffffffe) | 0x0000001));
+		}
+
+		if(DDR_CALVLSIDE== 0x1)
+		{
+			REG_DDRPHY_WRITE(0,0x709,((REG_DDRPHY_READ(0,0x709) & 0xffffff00) | 0x0000010));
+			REG_DDRPHY_WRITE(0,0x257,((REG_DDRPHY_READ(0,0x257) & 0xfffffff0) | 0x0000004));
+
+			REG_DDRPHY_WRITE(1,0x709,((REG_DDRPHY_READ(1,0x709) & 0xffffff00) | 0x0000011));
+			REG_DDRPHY_WRITE(1,0x257,((REG_DDRPHY_READ(1,0x257) & 0xfffffff0) | 0x0000004));
+			REG_DDRPHY_WRITE(1,0x60c,0x00DCBA98);
+			REG_DDRPHY_WRITE(1,0x421,((REG_DDRPHY_READ(1,0x421) & 0xfffffffe) | 0x0000001));
+			REG_DDRPHY_WRITE(1,0x4a1,((REG_DDRPHY_READ(1,0x4a1) & 0xfffffffe) | 0x0000001));
+			REG_DDRPHY_WRITE(1,0x521,((REG_DDRPHY_READ(1,0x521) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(1,0x5a1,((REG_DDRPHY_READ(1,0x5a1) & 0xfffffffe) | 0x0000000));
+
+			REG_DDRPHY_WRITE(2,0x709,((REG_DDRPHY_READ(2,0x709) & 0xffffff00) | 0x0000000));
+			REG_DDRPHY_WRITE(2,0x257,((REG_DDRPHY_READ(2,0x257) & 0xfffffff0) | 0x0000004));
+			REG_DDRPHY_WRITE(2,0x60c,0x00543210);
+			REG_DDRPHY_WRITE(2,0x421,((REG_DDRPHY_READ(2,0x421) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(2,0x4a1,((REG_DDRPHY_READ(2,0x4a1) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(2,0x521,((REG_DDRPHY_READ(2,0x521) & 0xfffffffe) | 0x0000001));
+			REG_DDRPHY_WRITE(2,0x5a1,((REG_DDRPHY_READ(2,0x5a1) & 0xfffffffe) | 0x0000001));
+
+			REG_DDRPHY_WRITE(3,0x709,((REG_DDRPHY_READ(3,0x709) & 0xffffff00) | 0x0000000));
+			REG_DDRPHY_WRITE(3,0x257,((REG_DDRPHY_READ(3,0x257) & 0xfffffff0) | 0x0000004));
+			REG_DDRPHY_WRITE(3,0x60c,0x00543210);
+			REG_DDRPHY_WRITE(3,0x421,((REG_DDRPHY_READ(3,0x421) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(3,0x4a1,((REG_DDRPHY_READ(3,0x4a1) & 0xfffffffe) | 0x0000000));
+			REG_DDRPHY_WRITE(3,0x521,((REG_DDRPHY_READ(3,0x521) & 0xfffffffe) | 0x0000001));
+			REG_DDRPHY_WRITE(3,0x5a1,((REG_DDRPHY_READ(3,0x5a1) & 0xfffffffe) | 0x0000001));
+		}
+#ifdef	DDR_VREF
+		for (i=0;i<4;i++)
+		{
+			REG_DDRPHY_WRITE(i,0x70F,((REG_DDRPHY_READ(i,0x70f) & 0x000000ff)|(DDR_VREF << 8) ));
+			REG_DDRPHY_WRITE(i,0x710,(DDR_VREF |(DDR_VREF << 16) ));
+			REG_DDRPHY_WRITE(i,0x711,(DDR_VREF |(DDR_VREF << 16) ));
+		}
+#endif
+
+
+#ifdef	DDR_PAD_BOOST
+		for (i=0;i<4;i++)
+		{
+			REG_DDRPHY_WRITE(i,0x71B,((REG_DDRPHY_READ(i,0x71B) & 0xfbfffdff) ));	//phy_pad_dqs_drive ,phy_pad_data_drive
+		}
+#else
+		for (i=0;i<4;i++)
+		{
+			REG_DDRPHY_WRITE(i,0x71B,((REG_DDRPHY_READ(i,0x71B) | 0x04000200) ));	//phy_pad_dqs_drive ,phy_pad_data_drive
+		}
+#endif
+
+#ifdef	DDR_PAD_ADDR_CS_DRIVE
+		for (i=0;i<4;i++){
+			REG_DDRPHY_WRITE(i,0x71C,DDR_PAD_ADDR_CS_DRIVE);	//pad_addr_drive
+			REG_DDRPHY_WRITE(i,0x727,DDR_PAD_ADDR_CS_DRIVE);	//pad_cs_drive
+		}
+#endif
+
+//#define CH0B
+#ifdef  CH0B
+		// CH0 CALVL for swap
+		// CH0 CALVL to CS[2] ( M2 dq_h -> soc M2 dq_h )
+		REG_DDRPHY_WRITE(0,0x0257,0x00181704);		// PI_CALVL_CS_MAP:RW:0:4:= 0x4
+		//0x0000060F, 0x01000000, // PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000	// SoC Byte3   -> DRAM Byte 3
+		REG_DDRPHY_WRITE(0,0x060F,0x02DCBA98);
+#endif
+		// CH1 CALVL for swap
+		// CH1 CALVL can be done only for CS[2] ( M2 dq_h -> soc M2 dq_h )
+		REG_DDRPHY_WRITE(1,0x0257,0x00181704);		// PI_CALVL_CS_MAP:RW:0:4:= 0x4
+
+		*((volatile uint32_t*)DBSC_DBDFIPMSTRCNF) = 0x00000001;	//DFI_PHYMSTR_ACK = 1
+	}	// (mode==0 || mode==1|| mode==3)
+
+
+	///////////////////////////////////////////////////////////////////////////////////////////////////////////end_of_mode1
+	pvt_lvl_enable_set(0x3f);
+
+	set_cacs_delay();
+
+	REG_DDRPHY_WRITE(0,0x44c,0x0004000c);
+	REG_DDRPHY_WRITE(0,0x4cc,0x0004000c);
+	REG_DDRPHY_WRITE(0,0x54c,0x00040042);
+	REG_DDRPHY_WRITE(0,0x5cc,0x0004004e);
+	REG_DDRPHY_WRITE(1,0x44c,0x0004004e);
+	REG_DDRPHY_WRITE(1,0x4cc,0x0004005a);
+	REG_DDRPHY_WRITE(1,0x54c,0x00040078);
+	REG_DDRPHY_WRITE(1,0x5cc,0x00040042);
+	REG_DDRPHY_WRITE(2,0x44c,0x00040012);
+	REG_DDRPHY_WRITE(2,0x4cc,0x00040066);
+	REG_DDRPHY_WRITE(2,0x54c,0x000301f4);
+	REG_DDRPHY_WRITE(2,0x5cc,0x0004004e);
+	REG_DDRPHY_WRITE(3,0x44c,0x0004001e);
+	REG_DDRPHY_WRITE(3,0x4cc,0x00040042);
+	REG_DDRPHY_WRITE(3,0x54c,0x00040066);
+	REG_DDRPHY_WRITE(3,0x5cc,0x000400c6);
+
+// 9/24
+//cacs_capture_cnt//cacs_resp_wait_cnt
+//		0x00000257, 0x00181701, // PI_TDFI_CALVL_CC_F0:RW:16:10:=0x0018 PI_TDFI_CALVL_EN:RW:8:8:=0x17 PI_CALVL_CS_MAP:RW:0:4:=0x03
+//		0x00000258, 0x00280006, // PI_TDFI_CALVL_CC_F1:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F0:RW:0:10:=0x0006
+//		0x00000259, 0x00280016, // PI_TDFI_CALVL_CC_F2:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F1:RW:0:10:=0x0016
+//		0x0000025A, 0x00000016, // PI_TDFI_CALVL_CAPTURE_F2:RW:0:10:=0x0016
+	for(ch=0;ch<4;ch++){
+//		0x00000610, 0x00020010, // PHY_ADR_CALVL_RESP_WAIT_CNT_0:RW:24:4:=0x00 PHY_ADR_CALVL_CAPTURE_CNT_0:RW:16:4:=0x02 PHY_ADR_CALVL_NUM_PATTERNS_0:RW:8:2:=0x00 PHY_ADR_CALVL_RANK_CTRL_0:RW:0:5:=0x10
+//		0x0000060A, 0x00400320, // PHY_ADR_CALVL_COARSE_DLY_0:RW:16:11:=0x0040 PHY_ADR_CALVL_START_0:RW:0:11:=0x0320
+//		0x0000060B, 0x00000040, // PHY_ADR_CALVL_QTR_0:RW:0:11:=0x0040
+//		0x00000624, 0x00000003, // PHY_ADR_CALVL_DLY_STEP_0:RW+:0:4:=0x03
+
+		uint32_t cc=(DDR_CACS_CCCP>>16)&0xff;
+		uint32_t cp=(DDR_CACS_CCCP>>0)&0xff;
+
+		REG_DDRPHY_WRITE(ch,0x257,(REG_DDRPHY_READ(ch,0x257) & 0x0000ffff) | (cc<<16)); 
+		REG_DDRPHY_WRITE(ch,0x258,(REG_DDRPHY_READ(ch,0x258) & 0x00000000) | (cc<<16) | cp); 
+		REG_DDRPHY_WRITE(ch,0x259,(REG_DDRPHY_READ(ch,0x259) & 0x00000000) | (cc<<16) | cp); 
+		REG_DDRPHY_WRITE(ch,0x25a,(REG_DDRPHY_READ(ch,0x25a) & 0x00000000) | cp); 
+
+
+		for(slice=0;slice<2;slice++){
+			REG_DDRPHY_WRITE(ch,0x610+0x80*slice,(REG_DDRPHY_READ(ch,0x610+0x80*slice) & 0xf0f0ffff )
+				| ((DDR_CACS_RESP_WAIT_CNT&0x0f)<<24)
+				| ((DDR_CACS_CAPTURE_CNT&0x0f)<<16)
+			);
+			REG_DDRPHY_WRITE(ch,0x60a+0x80*slice,(REG_DDRPHY_READ(ch,0x60a+0x80*slice) & 0xfffff000 )
+				| DDR_CACS_START
+			);
+			REG_DDRPHY_WRITE(ch,0x60b+0x80*slice,(REG_DDRPHY_READ(ch,0x60b+0x80*slice) & 0xfffff000 )
+				| DDR_CACS_QTR
+			);
+			REG_DDRPHY_WRITE(ch,0x624+0x80*slice,(REG_DDRPHY_READ(ch,0x624+0x80*slice) & 0xfffffff0 )
+				| DDR_CACS_STEP
+			);
+		}
+
+//		0x00000704, 0x00020040, // PHY_CSLVL_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_QTR:RW:0:11:=0x0040
+//		0x00000705, 0x00020055, // PHY_CSLVL_DEBUG_MODE:RW:24:1:=0x00 PHY_CSLVL_COARSE_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_COARSE_DLY:RW:0:11:=0x0055
+		slice=0;
+		REG_DDRPHY_WRITE(ch,0x704+0x80*slice,(REG_DDRPHY_READ(ch,0x704+0x80*slice) & 0xfff0ffff) | ((DDR_CACS_CAPTURE_CNT&0x0f)<<16));
+		REG_DDRPHY_WRITE(ch,0x705+0x80*slice,(REG_DDRPHY_READ(ch,0x705+0x80*slice) & 0xfff0ffff) | ((DDR_CACS_CAPTURE_CNT&0x0f)<<16));
+	}
+//-------
+
+	dsb_sev();
+	dsb_sev();
+	dsb_sev();
+
+	PLL3_FREQ(freq,0);
+
+	dsb_sev();
+	dsb_sev();
+	dsb_sev();
+
+#ifdef	DDR_PAD_CAL_WA
+	for(i=0;i<4;i++)
+	{
+		REG_DDRPHY_WRITE(i,0x72c,REG_DDRPHY_READ(i,0x72c)& ~(1<<24) ); //init_start_disable clear
+	}
+
+	// Rx Cal IE issue w/a
+	for(ch=0;ch<4;ch++)
+	{
+		for(slice=0;slice<4;slice++)
+		{
+			if(DDR_TVAL2&0x1)
+			{
+				REG_DDRPHY_WRITE(ch,0x452+0x80*slice,REG_DDRPHY_READ(ch,0x452+0x80*slice) | (1<<16));
+			}
+//		0x00000433, 0x00200000, // PHY_RX_CAL_SAMPLE_WAIT_0:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_0:RW:8:1:=0x00 SC_PHY_RX_CAL_START_0:WR:0:1:=0x00
+			if(DDR_TVAL2&0x2)
+			{
+				REG_DDRPHY_WRITE(ch,0x433+slice*0x80,REG_DDRPHY_READ(ch,0x433+slice*0x80)|0x100);
+			}
+			else
+			{
+				REG_DDRPHY_WRITE(ch,0x433+slice*0x80,REG_DDRPHY_READ(ch,0x433+slice*0x80)&0xfffffeff);
+			}
+		}
+	}
+	dsb_sev();
+#endif
+
+	*((volatile uint32_t*)DBSC_DBDFICNT_0) = 0x00000010;	//dbdficnt0 freq_ratio = 01 (2:1)init_start =1
+	*((volatile uint32_t*)DBSC_DBDFICNT_1) = 0x00000010;
+	*((volatile uint32_t*)DBSC_DBDFICNT_2) = 0x00000010;
+	*((volatile uint32_t*)DBSC_DBDFICNT_3) = 0x00000010;
+	dsb_sev();
+
+	dsb_sev();
+	dsb_sev();
+
+	*((volatile uint32_t*)DBSC_DBDFICNT_0) = 0x00000011;	//dbdficnt0 freq_ratio = 01 (2:1)init_start =1
+	*((volatile uint32_t*)DBSC_DBDFICNT_1) = 0x00000011;
+	*((volatile uint32_t*)DBSC_DBDFICNT_2) = 0x00000011;
+	*((volatile uint32_t*)DBSC_DBDFICNT_3) = 0x00000011;
+	dsb_sev();
+
+	dsb_sev();
+	dsb_sev();
+
+	*((volatile uint32_t*)DBSC_DBPDCNT_0) = 0x000000;	//dll_rst_n0 -> 1
+	*((volatile uint32_t*)DBSC_DBPDCNT_1) = 0x000000;
+	*((volatile uint32_t*)DBSC_DBPDCNT_2) = 0x000000;
+	*((volatile uint32_t*)DBSC_DBPDCNT_3) = 0x000000;
+	dsb_sev();
+
+	*((volatile uint32_t*)DBSC_DBPDCNT_0) = 0x0000CF00;	//dll_rst_n0 -> 1
+	*((volatile uint32_t*)DBSC_DBPDCNT_1) = 0x0000CF00;
+	*((volatile uint32_t*)DBSC_DBPDCNT_2) = 0x0000CF00;
+	*((volatile uint32_t*)DBSC_DBPDCNT_3) = 0x0000CF00;
+	dsb_sev();
+
+	*((volatile uint32_t*)DBSC_DBPDCNT_0) = 0x0000CF01;	//dll_rst_n0 -> 1
+	*((volatile uint32_t*)DBSC_DBPDCNT_1) = 0x0000CF01;
+	*((volatile uint32_t*)DBSC_DBPDCNT_2) = 0x0000CF01;
+	*((volatile uint32_t*)DBSC_DBPDCNT_3) = 0x0000CF01;
+	dsb_sev();
+
+	SoftDelay(1*1000); 	//wait for 1ms
+
+	phytrainingok=0;
+	//Need Handshake sequence betweed DBSC and PHY
+	if(DDR_UPDT_WA&0x40)
+	{
+		for(ch=0;ch<4;ch++)
+		{
+			for(slice=0;slice<4;slice++)
+			{
+//		0x00000433, 0x00200000, // PHY_RX_CAL_SAMPLE_WAIT_0:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_0:RW:8:1:=0x00 SC_PHY_RX_CAL_START_0:WR:0:1:=0x00
+				if(DDR_TVAL2&0x2)
+				{
+					REG_DDRPHY_WRITE(ch,0x433+slice*0x80,REG_DDRPHY_READ(ch,0x433+slice*0x80)|0x1|0x100);
+				}
+				else
+				{
+					REG_DDRPHY_WRITE(ch,0x433+slice*0x80,REG_DDRPHY_READ(ch,0x433+slice*0x80)|0x1);
+				}
+			}
+		}
+		dsb_sev();
+	}
+
+	j=(DDR_UPDT_WA>>24)&0xff;
+	k=0;
+	for(phychno=0;phychno<4;phychno++)
+	{
+		if(!(DDR_PHYVALID&(1<<phychno)))continue;
+		for(i=0;i<=j;i++)
+		{
+			if(i>0)
+			{ //after first init, init_start should be negated so as to wakeup pll
+				*((volatile uint32_t*)(DBSC_DBDFICNT_0+0x40*phychno)) = 0x00000011;	//dbdficnt0 freq_ratio = 01 (2:1)init_start =1
+				dsb_sev();
+				*((volatile uint32_t*)(DBSC_DBDFICNT_0+0x40*phychno)) = 0x00000010;	//dbdficnt0 freq_ratio = 01 (2:1)init_start =0
+				dsb_sev();
+//			0x000004B3, 0x00200000, // PHY_RX_CAL_SAMPLE_WAIT_1:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_1:RW:8:1:=0x00 SC_PHY_RX_CAL_START_1:WR:0:1:=0x00
+				for(retry=0;retry<4;retry++)
+				{
+					REG_DDRPHY_WRITE(phychno,0x433+retry*0x80,REG_DDRPHY_READ(phychno,0x433+retry*0x80)|0x1);
+				}
+			}
+
+			retry=0;
+			while(retry<2048)
+			{
+				dataL = *((volatile uint32_t*)(DBSC_INITCOMP_0+phychno*0x40));	//Wait for DBSC_INITCOMP_0[0] is 1
+				if((dataL & 0x00000001) == 0x1)	break;
+				retry++;
+			}
+			if(retry<2048)
+			{
+				phytrainingok|=(1<<phychno);
+			}
+			else
+			{
+				k|=(1<<phychno);
+			}
+		}
+	}
+
+	phytrainingok &=~k;
+	if((phytrainingok&DDR_PHYVALID)!=DDR_PHYVALID)
+	{
+		return phytrainingok;
+	}
+
+#ifdef	DDR_PAD_CAL_WA
+	{
+		uint32_t pvtn_h,pvtn_l;
+		uint32_t pvtp_h,pvtp_l;
+		uint32_t pvtr;
+		uint32_t o_dataL;
+
+		for(j=0;j<4;j++){
+			dataL=REG_DDRPHY_READ(j,0x731);
+			pvtn_h=(dataL >>18)& 0x03f;
+			pvtn_l=(dataL >>12)& 0x03f;
+			pvtp_h=(dataL >> 6)& 0x03f;
+			pvtp_l=(dataL >> 0)& 0x03f;
+			for( i=0; i<DDR_PHY_PVT_OVERWRITE_NUM; i++ )
+			{
+				o_dataL=REG_DDRPHY_READ(j,DDR_PHY_DDR_PHY_PVT_OVERWITE_1600[i][0]);
+				pvtr=(o_dataL >>12)& 0x01f;
+				dataL=(o_dataL & 0xffe00000) | (((pvtr+DDR_PVTR_ADJ)&0x1f)<<12) | (((pvtn_h+pvtn_l)>>1)<<6) | ((pvtp_h+pvtp_l)>>1);
+				REG_DDRPHY_WRITE(j,DDR_PHY_DDR_PHY_PVT_OVERWITE_1600[i][0],dataL);
+
+				dataL=REG_DDRPHY_READ(j,DDR_PHY_DDR_PHY_PVT_OVERWITE_1600[i][0]);
+			}
+		}
+
+		for(ch=0;ch<4;ch++)
+		{
+			for(slice=0;slice<4;slice++)
+			{
+				REG_DDRPHY_WRITE(ch,0x452+0x80*slice,REG_DDRPHY_READ(ch,0x452+0x80*slice) & ~(1<<16));//PAD_PHY_IE_MODE OFF
+//		0x00000433, 0x00200000, // PHY_RX_CAL_SAMPLE_WAIT_0:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_0:RW:8:1:=0x00 SC_PHY_RX_CAL_START_0:WR:0:1:=0x00
+				REG_DDRPHY_WRITE(ch,0x433+slice*0x80,REG_DDRPHY_READ(ch,0x433+slice*0x80)&0xffff0000);
+			}
+		}
+
+	}
+#endif
+
+	if(DDR_RX_CAL_MAN&0x100)
+	{
+		rx_cal_manual1(phytrainingok);
+	}
+
+	//Need Handshake sequence betweed DBSC and PHY
+
+	if(DDR_UPDT_WA&0x2)
+	{
+		pvt_manual_update(0x0f);
+	}
+	if(DDR_UPDT_WA&0x4)
+	{
+		pvt_manual_update(0xf0);
+	}
+
+	//CHANGE IMPEDANCE CODE to CMOS MODE
+	change_lpddr4_en(0xf,0);
+
+	for(phychno=0;phychno<4;phychno+=1)
+	{
+		if((DDR_PHYVALID&0x0f)==0x0f)
+		{
+			phychno=0x0f;
+		}
+		else
+		{
+			if( (DDR_PHYVALID&(1<<phychno))==0 )
+			{
+				continue;
+			}
+		}
+
+		//(SDRAM Initalize)
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x01040001|(0x00100000 * phychno);	//RSX chA rkA
+		WaitDBCMD();
+
+		dsb_sev();
+
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x08040000|(0x00100000 * phychno);	//PDE chA rkA
+		WaitDBCMD();
+
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x08040000|(0x00100000 * phychno);	//PDE chA rkA
+		WaitDBCMD();
+
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x08040001|(0x00100000 * phychno);	//PDX ch0 rk0
+		WaitDBCMD();
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x08040001|(0x00100000 * phychno);	//PDX ch0 rk0
+		WaitDBCMD();
+
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040200|(0x00100000 * phychno);	//MRW chA rkA 02:00
+		WaitDBCMD();
+
+//		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040331|(0x00100000 * phychno);	//MRW chA rkA 03:31
+//		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040311|(0x00100000 * phychno);	//MRW chA rkA 03:31
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040300|(0x00100000 * phychno)|DDR_MR3;	//MRW chA rkA 03:31
+		WaitDBCMD();
+
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0e040100|(0x00100000 * phychno);	//MRW chA rkA 01:00
+		WaitDBCMD();
+
+		if((DDR_PHYMRW & (1<<phychno)) || (phychno==0x0f))
+		{/////////////////////////////////////////////////////////// phymrw
+			mode_register_set(freq, phychno, 0x40);
+			mode_register_set(freq, phychno, 0x00);
+		} /////////////////////////////////////////////////////////// phymrw
+
+		dsb_sev();
+
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0d04004F|(0x00100000 * phychno);	//MPC chA rkA 4FH (ZQCAL start)
+		WaitDBCMD();
+
+		*((volatile uint32_t*)DBSC_DBCMD) = 0x0d040051|(0x00100000 * phychno);	//MPC chA rkA 51H (ZQCAL latch)
+		WaitDBCMD();
+	}
+	{
+		for(ch=0;ch<4;ch++)
+		{
+			j=0x276; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0x00ffffff) | (DDR_MR3<<24);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x278; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0xffff00ff) | (DDR_MR3<<8);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x279; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0x00ffffff) | (DDR_MR3<<24);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x27b; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0xff00ffff) | (DDR_MR3<<16);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x27d; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0xffffff00) | (DDR_MR3<<0);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x27e; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0xff00ffff) | (DDR_MR3<<16);
+			;REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x280; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0xffff00ff) | (DDR_MR3<<8);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x281; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0x00ffffff) | (DDR_MR3<<24);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x283; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0xffff00ff) | (DDR_MR3<<8);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x285; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0xffffff00) | (DDR_MR3<<0);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x286; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0xff00ffff) | (DDR_MR3<<16);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+			j=0x288; dataL=REG_DDRPHY_READ(ch,j);
+			dataL=(dataL&0xffffff00) | (DDR_MR3<<0);
+			REG_DDRPHY_WRITE(ch,j,dataL);
+
+		}
+
+		_set_reg(0x0f,0x277, 0,8,DDR_MR11);
+		_set_reg(0x0f,0x278,16,8,DDR_MR11);
+		_set_reg(0x0f,0x27a, 0,8,DDR_MR11);
+		_set_reg(0x0f,0x27b,24,8,DDR_MR11);
+		_set_reg(0x0f,0x27d, 8,8,DDR_MR11);
+		_set_reg(0x0f,0x27e,24,8,DDR_MR11);
+		_set_reg(0x0f,0x280,16,8,DDR_MR11);
+		_set_reg(0x0f,0x282, 0,8,DDR_MR11);
+		_set_reg(0x0f,0x283,16,8,DDR_MR11);
+		_set_reg(0x0f,0x285, 8,8,DDR_MR11);
+		_set_reg(0x0f,0x286,24,8,DDR_MR11);
+		_set_reg(0x0f,0x288, 8,8,DDR_MR11);
+	}
+
+	//CHANGE IMPEDANCE CODE to LPDDR4 MODE
+	change_lpddr4_en(0xf,1);
+
+	phytrainingok&=pvt_pi_training(freq);
+	if(DDR_UPDT_WA&0x2)
+	{
+		pvt_manual_update(0x0f);
+	}
+	if(DDR_UPDT_WA&0x4)
+	{
+		pvt_manual_update(0xf0);
+	}
+
+	for(phychno=0;phychno<4;phychno+=1)
+	{
+		if((DDR_PHYVALID&phytrainingok& 0x0f)==0x0f)
+		{
+			phychno=0x0f;
+		}
+		else
+		{
+			if( (DDR_PHYVALID&phytrainingok&(1<<phychno))==0 )
+			{
+				continue;
+			}
+		}
+		mode_register_set(freq, phychno, 0x40);
+		mode_register_set(freq, phychno, 0x00);
+	}
+
+	if(DDR_UPDT_WA&0x38)
+	{
+		for(i=0;i<1000;i++)
+		{
+			//dummy
+			REG_DDRPHY_READ(0,0x229);
+			REG_DDRPHY_READ(1,0x229);
+			REG_DDRPHY_READ(2,0x229);
+			REG_DDRPHY_READ(3,0x229);
+		}
+	}
+
+	if(DDR_UPDT_WA&0x20)
+	{
+		REG_DDRPHY_WRITE(0,0x229,0x000);
+		REG_DDRPHY_WRITE(1,0x229,0x000);
+		REG_DDRPHY_WRITE(2,0x229,0x000);
+		REG_DDRPHY_WRITE(3,0x229,0x000);
+
+		REG_DDRPHY_WRITE(0,0x229,0x100);
+		REG_DDRPHY_WRITE(1,0x229,0x100);
+		REG_DDRPHY_WRITE(2,0x229,0x100);
+		REG_DDRPHY_WRITE(3,0x229,0x100);
+	}
+
+	if(DDR_UPDT_WA&0x08)
+	{
+		*((volatile uint32_t*)DBSC_DBPDCNT_0) = 0x0000CF00;	//dll_rst_n0 -> 1
+		*((volatile uint32_t*)DBSC_DBPDCNT_1) = 0x0000CF00;
+		*((volatile uint32_t*)DBSC_DBPDCNT_2) = 0x0000CF00;
+		*((volatile uint32_t*)DBSC_DBPDCNT_3) = 0x0000CF00;
+		dsb_sev();
+
+		for(i=0;i<1000;i++)
+		{
+			//dummy
+			REG_DDRPHY_READ(0,0x229);
+			REG_DDRPHY_READ(1,0x229);
+			REG_DDRPHY_READ(2,0x229);
+			REG_DDRPHY_READ(3,0x229);
+		}
+	}
+
+	if(DDR_UPDT_WA&0x10)
+	{
+		*((volatile uint32_t*)DBSC_DBDFICNT_0) = 0x00000010;	//dbdficnt0 freq_ratio = 01 (2:1)init_start =1 
+		*((volatile uint32_t*)DBSC_DBDFICNT_1) = 0x00000010;
+		*((volatile uint32_t*)DBSC_DBDFICNT_2) = 0x00000010;
+		*((volatile uint32_t*)DBSC_DBDFICNT_3) = 0x00000010;
+		*((volatile uint32_t*)DBSC_DBDFICNT_0) = 0x00000011;	//dbdficnt0 freq_ratio = 01 (2:1)init_start =1 
+		*((volatile uint32_t*)DBSC_DBDFICNT_1) = 0x00000011;
+		*((volatile uint32_t*)DBSC_DBDFICNT_2) = 0x00000011;
+		*((volatile uint32_t*)DBSC_DBDFICNT_3) = 0x00000011;
+		dsb_sev();
+	}
+
+	if(DDR_UPDT_WA&0x08)
+	{
+		*((volatile uint32_t*)DBSC_DBPDCNT_0) = 0x0000CF01;	//dll_rst_n0 -> 1
+		*((volatile uint32_t*)DBSC_DBPDCNT_1) = 0x0000CF01;
+		*((volatile uint32_t*)DBSC_DBPDCNT_2) = 0x0000CF01;
+		*((volatile uint32_t*)DBSC_DBPDCNT_3) = 0x0000CF01;
+		dsb_sev();
+
+		for(i=0;i<1000;i++){//dummy
+			REG_DDRPHY_READ(0,0x229);
+			REG_DDRPHY_READ(1,0x229);
+			REG_DDRPHY_READ(2,0x229);
+			REG_DDRPHY_READ(3,0x229);
+		}
+	}
+
+	if(DDR_UPDT_WA&0x18)
+	{
+		for(i=0;i<1000;i++)
+		{
+			//dummy
+			REG_DDRPHY_READ(0,0x229);
+			REG_DDRPHY_READ(1,0x229);
+			REG_DDRPHY_READ(2,0x229);
+			REG_DDRPHY_READ(3,0x229);
+		}
+	}
+
+	if(DDR_UPDT_WA&0x10)
+	{
+		*((volatile uint32_t*)DBSC_DBDFICNT_0) = 0x00000010;	//dbdficnt0 freq_ratio = 01 (2:1)init_start =1 
+		*((volatile uint32_t*)DBSC_DBDFICNT_1) = 0x00000010;
+		*((volatile uint32_t*)DBSC_DBDFICNT_2) = 0x00000010;
+		*((volatile uint32_t*)DBSC_DBDFICNT_3) = 0x00000010;
+		dsb_sev();
+
+		//Need Handshake sequence betweed DBSC and PHY
+		while(1)
+		{
+			dataL = *((volatile uint32_t*)DBSC_INITCOMP_0);	//Wait for DBSC_INITCOMP_0[0] is 1
+			if((dataL & 0x00000001) == 0x1)	break;
+		}
+
+		while(1)
+		{
+			dataL = *((volatile uint32_t*)DBSC_INITCOMP_1);	//Wait for DBSC_INITCOMP_1[0] is 1
+			if((dataL & 0x00000001) == 0x1)	break;
+		}
+
+		while(1)
+		{
+			dataL = *((volatile uint32_t*)DBSC_INITCOMP_2);	//Wait for DBSC_INITCOMP_2[0] is 1
+			if((dataL & 0x00000001) == 0x1)	break;
+		}
+
+		while(1)
+		{
+			dataL = *((volatile uint32_t*)DBSC_INITCOMP_3);	//Wait for DBSC_INITCOMP_3[0] is 1
+			if((dataL & 0x00000001) == 0x1)	break;
+		}
+	}
+
+	*((volatile uint32_t*)DBSC_DBBUS0CNF1) = 0x70000100;	//dbbus0cnf1
+	*((volatile uint32_t*)DBSC_DBBUS0CNF0) = 0x18010001;	//dbbus0cnf
+
+//Auto Refresh setting
+//	*((volatile uint32_t*)DBSC_DBRFCNF1) = 0x00081860;	//dbrfcnf1 refpmax=8 refint=6240
+	if(freq>0x53) *((volatile uint32_t*)DBSC_DBRFCNF1) = 0x00081860;	//dbrfcnf1 refpmax=8 refint=6240
+	else if(freq>0x47) *((volatile uint32_t*)DBSC_DBRFCNF1) = 0x00081554;	//dbrfcnf1 refpmax=8 refint=5460
+	else if(freq>0x2f) *((volatile uint32_t*)DBSC_DBRFCNF1) = 0x00081248;	//dbrfcnf1 refpmax=8 refint=4680
+	else *((volatile uint32_t*)DBSC_DBRFCNF1) = 0x00080C30;	//dbrfcnf1 refpmax=8 refint=3120
+
+	*((volatile uint32_t*)DBSC_DBRFCNF2) = 0x00010000;	//dbrfcnf2 refpmin=1 refints=0
+
+	*((volatile uint32_t*)DBSC_DBRFEN) = 0x00000001;	//dbrfen
+
+//DRAM ACCESS enable
+	*((volatile uint32_t*)DBSC_DBACEN) = 0x00000001;	//dbacen
+
+	return phytrainingok;
+}
+
+
+void freq2800_reg_set()
+{
+	uint32_t i;
+
+	for(i=0;i<4;i++)
+	{
+		REG_DDRPHY_WRITE(i,0x22B, (DDR2800_PI_CASLAT_LIN<<24)|(DDR2800_PI_WRLAT<<16)|(DDR2800_PI_CASLAT_LIN<<8)|(DDR2800_PI_WRLAT<<0));
+		REG_DDRPHY_WRITE(i,0x22C, 0x00020000|(DDR2800_PI_CASLAT_LIN<<8)|(DDR2800_PI_WRLAT<<0));
+
+		REG_DDRPHY_WRITE(i,0x252, (DDR2800_PI_RDLAT_ADJ<<16)|(DDR2800_PI_RDLAT_ADJ<<8)|(DDR2800_PI_RDLAT_ADJ<<0));
+		REG_DDRPHY_WRITE(i,0x253, (DDR2800_PI_WRLAT_ADJ<<16)|(DDR2800_PI_WRLAT_ADJ<<8)|(DDR2800_PI_WRLAT_ADJ<<0));
+
+		REG_DDRPHY_WRITE(i,0x28A, (DDR2800_PI_TFC<<16)|(DDR2800_PI_TFC<<0));
+		REG_DDRPHY_WRITE(i,0x28B, (DDR2800_PI_TRTP<<24)|(DDR2800_PI_TCCD<<16)|(DDR2800_PI_TFC<<0));
+		REG_DDRPHY_WRITE(i,0x28C, (DDR2800_PI_TWR<<24) |(DDR2800_PI_TWTR<<16)|(DDR2800_PI_TRCD<<8)|(DDR2800_PI_TRP<<0));
+		REG_DDRPHY_WRITE(i,0x28D, (DDR2800_PI_TRAS_MIN<<24)|(DDR2800_PI_TRAS_MAX<<0));
+		REG_DDRPHY_WRITE(i,0x28E, (DDR2800_PI_TMRW<<24) | (DDR2800_PI_TMRD<<16)|(DDR2800_PI_TCCDMW<<8)|(DDR2800_PI_TDQSCK_MAX<<0));
+		REG_DDRPHY_WRITE(i,0x28F, (DDR2800_PI_TWTR<<24) | (DDR2800_PI_TRCD<<16)|(DDR2800_PI_TRP<<8)   |(DDR2800_PI_TRTP<<0));
+		REG_DDRPHY_WRITE(i,0x290, (DDR2800_PI_TRAS_MAX<<8) | (DDR2800_PI_TWR<<0));
+		REG_DDRPHY_WRITE(i,0x291, (DDR2800_PI_TMRD<<24) | (DDR2800_PI_TCCDMW<<16) | (DDR2800_PI_TDQSCK_MAX<<8)|(DDR2800_PI_TRAS_MIN<<0));
+		REG_DDRPHY_WRITE(i,0x292, (DDR2800_PI_TRCD<<24) | (DDR2800_PI_TRP<<16) | (DDR2800_PI_TRTP<<8)|(DDR2800_PI_TMRW<<0));
+		REG_DDRPHY_WRITE(i,0x293, (DDR2800_PI_TWR<<8)|(DDR2800_PI_TWTR<<0));
+		REG_DDRPHY_WRITE(i,0x294, (DDR2800_PI_TRAS_MIN<<24)|(DDR2800_PI_TRAS_MAX<<0));
+		REG_DDRPHY_WRITE(i,0x295, (DDR2800_PI_TMRW<<24) | (DDR2800_PI_TMRD<<16)|(DDR2800_PI_TCCDMW<<8)|(DDR2800_PI_TDQSCK_MAX<<0));
+
+		REG_DDRPHY_WRITE(i,0x276, (DDR_MR3 <<24)|(DDR2800_PI_MR2 <<16)|(DDR2800_PI_MR1 <<8)|0x00);
+		REG_DDRPHY_WRITE(i,0x277, (DDR2800_PI_MR1 <<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0));
+		REG_DDRPHY_WRITE(i,0x278, (PI_MR12<<24)|(PI_MR11<<16)|(DDR_MR3 <<8)|(DDR2800_PI_MR2 <<0));
+		REG_DDRPHY_WRITE(i,0x279, (DDR_MR3 <<24)|(DDR2800_PI_MR2 <<16)|(DDR2800_PI_MR1 <<8)|(PI_MR14<<0));
+		REG_DDRPHY_WRITE(i,0x27A, (PI_MR13<<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0));
+		REG_DDRPHY_WRITE(i,0x27B, (PI_MR11<<24)|(DDR_MR3 <<16)|(DDR2800_PI_MR2 <<8)|(DDR2800_PI_MR1 <<0));
+		REG_DDRPHY_WRITE(i,0x27C, (DDR2800_PI_MR2 <<24)|(DDR2800_PI_MR1 <<16)|(PI_MR14<<8)|(PI_MR12<<0));
+		REG_DDRPHY_WRITE(i,0x27D, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(DDR_MR3 <<0));
+		REG_DDRPHY_WRITE(i,0x27E, (PI_MR11<<24)|(DDR_MR3 <<16)|(DDR2800_PI_MR2 <<8)|(DDR2800_PI_MR1 <<0));
+		REG_DDRPHY_WRITE(i,0x27F, (DDR2800_PI_MR1 <<24)|(PI_MR13<<16)|(PI_MR14<<8)|(PI_MR12<<0));
+		REG_DDRPHY_WRITE(i,0x280, (PI_MR12<<24)|(PI_MR11<<16)|(DDR_MR3 <<8)|(DDR2800_PI_MR2 <<0));
+		REG_DDRPHY_WRITE(i,0x281, (DDR_MR3 <<24)|(DDR2800_PI_MR2 <<16)|(DDR2800_PI_MR1 <<8)|(PI_MR14<<0));
+		REG_DDRPHY_WRITE(i,0x282, (DDR2800_PI_MR1 <<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0));
+		REG_DDRPHY_WRITE(i,0x283, (PI_MR12<<24)|(PI_MR11<<16)|(DDR_MR3 <<8)|(DDR2800_PI_MR2 <<0));
+		REG_DDRPHY_WRITE(i,0x284, (DDR2800_PI_MR2 <<24)|(DDR2800_PI_MR1 <<16)|(PI_MR13<<8)|(PI_MR14<<0));
+		REG_DDRPHY_WRITE(i,0x285, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(DDR_MR3 <<0));
+		REG_DDRPHY_WRITE(i,0x286, (PI_MR11<<24)|(DDR_MR3 <<16)|(DDR2800_PI_MR2 <<8)|(DDR2800_PI_MR1 <<0));
+		REG_DDRPHY_WRITE(i,0x287, (DDR2800_PI_MR2 <<24)|(DDR2800_PI_MR1 <<16)|(PI_MR14<<8)|(PI_MR12<<0));
+		REG_DDRPHY_WRITE(i,0x288, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(DDR_MR3 <<0));
+		REG_DDRPHY_WRITE(i,0x289, 0x00020000                              |(PI_MR13<<0));
+
+		REG_DDRPHY_WRITE(i,0x247, 0x0a0a0a05);	//PI_RD_TO_ODTH_F2:RW:24:6:=0x15 PI_RD_TO_ODTH_F1:RW:16:6:=0x15 PI_RD_TO_ODTH_F0:RW:8:6:=0x04 PI_WR_TO_ODTH_F2:RW:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x254, 0x02030303);	//PI_TDFI_PHY_WRDATA:RW:24:3:=0x02 PI_TDFI_WRCSLAT_F2:RW:16:7:=0x06 PI_TDFI_WRCSLAT_F1:RW:8:7:=0x06 PI_TDFI_WRCSLAT_F0:RW:0:7:=0x01
+		REG_DDRPHY_WRITE(i,0x257, 0x00201701);	//PI_TDFI_CALVL_CC_F0:RW:16:10:=0x0018 PI_TDFI_CALVL_EN:RW:8:8:=0x17 PI_CALVL_CS_MAP:RW:0:4:=0x03
+		REG_DDRPHY_WRITE(i,0x258, 0x0020000e);	//PI_TDFI_CALVL_CC_F1:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F0:RW:0:10:=0x000e
+		REG_DDRPHY_WRITE(i,0x259, 0x0020000e);	//PI_TDFI_CALVL_CC_F2:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F1:RW:0:10:=0x000e
+		REG_DDRPHY_WRITE(i,0x25A, 0x0000000e);	//PI_TDFI_CALVL_CAPTURE_F2:RW:0:10:=0x0016
+		REG_DDRPHY_WRITE(i,0x25F, 0x00C8020A);	//PI_TCAENT_F0:RW:16:14:=0x0005 PI_TMRZ_F0:RW:8:5:=0x01 PI_TCACKEH:RW:0:5:=0x0a
+		REG_DDRPHY_WRITE(i,0x260, 0x0200C802);	//PI_TMRZ_F2:RW:24:5:=0x03 PI_TCAENT_F1:RW:8:14:=0x018d PI_TMRZ_F1:RW:0:5:=0x03
+		REG_DDRPHY_WRITE(i,0x261, 0x000A00C8);	//PI_CA_TRAIN_VREF_EN:RW:24:1:=0x01 PI_TCAEXT:RW:16:5:=0x0a PI_TCAENT_F2:RW:0:14:=0x018d
+		REG_DDRPHY_WRITE(i,0x262, 0x00C90100);	//PI_TVREF_SHORT_F0:RW:16:10:=0x0006 PI_TDFI_CASEL_F0:RW:8:5:=0x01 PI_TDFI_CACSCA_F0:RW:0:5:=0x00
+		REG_DDRPHY_WRITE(i,0x263, 0x010000C9);	//PI_TDFI_CASEL_F1:RW:24:5:=0x01 PI_TDFI_CACSCA_F1:RW:16:5:=0x00 PI_TVREF_LONG_F0:RW:0:10:=0x0006
+		REG_DDRPHY_WRITE(i,0x268, 0x07070705);	//PI_TDFI_CALVL_STROBE_F2:RW:24:4:=0x09 PI_TDFI_CALVL_STROBE_F1:RW:16:4:=0x09 PI_TDFI_CALVL_STROBE_F0:RW:8:4:=0x06 PI_TDFI_INIT_COMPLETE_MIN:RW:0:8:=0x05
+		REG_DDRPHY_WRITE(i,0x26D, 0x10100100);	//PI_TCKEHDQS_F1:RW:24:6:=0x18 PI_TCKEHDQS_F0:RW:16:6:=0x02 PI_REFRESH_BETWEEN_SEGMENT_DISABLE:RW_D:8:1:=0x01 PI_DRAM_CLK_DISABLE_DEASSERT_SEL:RW:0:1:=0x00
+		REG_DDRPHY_WRITE(i,0x26E, 0x00010110);	//PI_WDQLVL_BST_NUM:RW:16:3:=0x01 PI_WDQLVL_VREF_EN:RW:8:1:=0x01 PI_TCKEHDQS_F2:RW:0:6:=0x18
+		REG_DDRPHY_WRITE(i,0x2A8, 0x00185000);	//PI_TDFI_CTRLUPD_MAX_F0:RW:8:16:=0x008c PI_TDFI_CTRLUPD_MIN:RD:0:4:=0x00
+		REG_DDRPHY_WRITE(i,0x2A9, 0x0000f320);	//PI_TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x00000578
+		REG_DDRPHY_WRITE(i,0x2AA, 0x00001850);	//PI_TDFI_CTRLUPD_MAX_F1:RW:0:16:=0x304c
+		REG_DDRPHY_WRITE(i,0x2AB, 0x0000f320);	//PI_TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x0001e2f8
+		REG_DDRPHY_WRITE(i,0x2AC, 0x00001850);	//PI_TDFI_CTRLUPD_MAX_F2:RW:0:16:=0x304c
+		REG_DDRPHY_WRITE(i,0x2AD, 0x0000f320);	//PI_TDFI_CTRLUPD_INTERVAL_F2:RW:0:32:=0x0001e2f8
+
+		REG_DDRPHY_WRITE(i,0x44C, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_0:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_0:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_0:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x452, 0x070000C0);	//PHY_RDDATA_EN_DLY_0:RW+:24:4:=0x0e PHY_IE_MODE_0:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_0:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_0:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x453, 0x00100006);	//PHY_MASTER_DELAY_START_0:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_0:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_0:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x454, 0x0C054208);	//PHY_WRLVL_DLY_STEP_0:RW+:24:4:=0x0c PHY_RPTR_UPDATE_0:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_0:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_0:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x4CC, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_1:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_1:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_1:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x4D2, 0x070000C0);	//PHY_RDDATA_EN_DLY_1:RW+:24:4:=0x0e PHY_IE_MODE_1:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_1:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_1:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x4D3, 0x00100006);	//PHY_MASTER_DELAY_START_1:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_1:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_1:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x4D4, 0x0C054208);	//PHY_WRLVL_DLY_STEP_1:RW+:24:4:=0x0c PHY_RPTR_UPDATE_1:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_1:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_1:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x54C, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_2:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_2:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_2:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x552, 0x070000C0);	//PHY_RDDATA_EN_DLY_2:RW+:24:4:=0x0e PHY_IE_MODE_2:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_2:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_2:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x553, 0x00100006);	//PHY_MASTER_DELAY_START_2:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_2:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_2:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x554, 0x0C054208);	//PHY_WRLVL_DLY_STEP_2:RW+:24:4:=0x0c PHY_RPTR_UPDATE_2:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_2:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_2:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x5CC, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_3:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_3:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_3:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x5D2, 0x070000C0);	//PHY_RDDATA_EN_DLY_3:RW+:24:4:=0x0e PHY_IE_MODE_3:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_3:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_3:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x5D3, 0x00100006);	//PHY_MASTER_DELAY_START_3:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_3:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_3:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x5D4, 0x0C054208);	//PHY_WRLVL_DLY_STEP_3:RW+:24:4:=0x0c PHY_RPTR_UPDATE_3:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_3:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_3:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x719, 0x00000303);	//PHY_LP_WAKEUP:RW:24:4:=0x00 PHY_LP4_BOOT_LOW_FREQ_SEL:RW:16:1:=0x01 PHY_TCKSRE_WAIT:RW:8:4:=0x05 PHY_PLL_TESTOUT_SEL:RW:0:3:=0x03
+	}
+}
+
+
+void freq2400_reg_set()
+{
+	uint32_t i;
+
+	for(i=0;i<4;i++)
+	{
+		REG_DDRPHY_WRITE(i,0x22B, (DDR2400_PI_CASLAT_LIN<<24)|(DDR2400_PI_WRLAT<<16)|(DDR2400_PI_CASLAT_LIN<<8)|(DDR2400_PI_WRLAT<<0));
+		REG_DDRPHY_WRITE(i,0x22C, 0x00020000|(DDR2400_PI_CASLAT_LIN<<8)|(DDR2400_PI_WRLAT<<0));
+
+		REG_DDRPHY_WRITE(i,0x252, (DDR2400_PI_RDLAT_ADJ<<16)|(DDR2400_PI_RDLAT_ADJ<<8)|(DDR2400_PI_RDLAT_ADJ<<0));
+		REG_DDRPHY_WRITE(i,0x253, (DDR2400_PI_WRLAT_ADJ<<16)|(DDR2400_PI_WRLAT_ADJ<<8)|(DDR2400_PI_WRLAT_ADJ<<0));
+
+		REG_DDRPHY_WRITE(i,0x28A, (DDR2400_PI_TFC<<16)|(DDR2400_PI_TFC<<0));
+		REG_DDRPHY_WRITE(i,0x28B, (DDR2400_PI_TRTP<<24)|(DDR2400_PI_TCCD<<16)|(DDR2400_PI_TFC<<0));
+		REG_DDRPHY_WRITE(i,0x28C, (DDR2400_PI_TWR<<24) |(DDR2400_PI_TWTR<<16)|(DDR2400_PI_TRCD<<8)|(DDR2400_PI_TRP<<0));
+		REG_DDRPHY_WRITE(i,0x28D, (DDR2400_PI_TRAS_MIN<<24)|(DDR2400_PI_TRAS_MAX<<0));
+		REG_DDRPHY_WRITE(i,0x28E, (DDR2400_PI_TMRW<<24) | (DDR2400_PI_TMRD<<16)|(DDR2400_PI_TCCDMW<<8)|(DDR2400_PI_TDQSCK_MAX<<0));
+		REG_DDRPHY_WRITE(i,0x28F, (DDR2400_PI_TWTR<<24) | (DDR2400_PI_TRCD<<16)|(DDR2400_PI_TRP<<8)   |(DDR2400_PI_TRTP<<0));
+		REG_DDRPHY_WRITE(i,0x290, (DDR2400_PI_TRAS_MAX<<8) | (DDR2400_PI_TWR<<0));
+		REG_DDRPHY_WRITE(i,0x291, (DDR2400_PI_TMRD<<24) | (DDR2400_PI_TCCDMW<<16) | (DDR2400_PI_TDQSCK_MAX<<8)|(DDR2400_PI_TRAS_MIN<<0));
+		REG_DDRPHY_WRITE(i,0x292, (DDR2400_PI_TRCD<<24) | (DDR2400_PI_TRP<<16) | (DDR2400_PI_TRTP<<8)|(DDR2400_PI_TMRW<<0));
+		REG_DDRPHY_WRITE(i,0x293, (DDR2400_PI_TWR<<8)|(DDR2400_PI_TWTR<<0));
+		REG_DDRPHY_WRITE(i,0x294, (DDR2400_PI_TRAS_MIN<<24)|(DDR2400_PI_TRAS_MAX<<0));
+		REG_DDRPHY_WRITE(i,0x295, (DDR2400_PI_TMRW<<24) | (DDR2400_PI_TMRD<<16)|(DDR2400_PI_TCCDMW<<8)|(DDR2400_PI_TDQSCK_MAX<<0));
+
+		REG_DDRPHY_WRITE(i,0x276, (DDR_MR3 <<24)|(DDR2400_PI_MR2 <<16)|(DDR2400_PI_MR1 <<8)|0x00);
+		REG_DDRPHY_WRITE(i,0x277, (DDR2400_PI_MR1 <<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0));
+		REG_DDRPHY_WRITE(i,0x278, (PI_MR12<<24)|(PI_MR11<<16)|(DDR_MR3 <<8)|(DDR2400_PI_MR2 <<0));
+		REG_DDRPHY_WRITE(i,0x279, (DDR_MR3 <<24)|(DDR2400_PI_MR2 <<16)|(DDR2400_PI_MR1 <<8)|(PI_MR14<<0));
+		REG_DDRPHY_WRITE(i,0x27A, (PI_MR13<<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0));
+		REG_DDRPHY_WRITE(i,0x27B, (PI_MR11<<24)|(DDR_MR3 <<16)|(DDR2400_PI_MR2 <<8)|(DDR2400_PI_MR1 <<0));
+		REG_DDRPHY_WRITE(i,0x27C, (DDR2400_PI_MR2 <<24)|(DDR2400_PI_MR1 <<16)|(PI_MR14<<8)|(PI_MR12<<0));
+		REG_DDRPHY_WRITE(i,0x27D, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(DDR_MR3 <<0));
+		REG_DDRPHY_WRITE(i,0x27E, (PI_MR11<<24)|(DDR_MR3 <<16)|(DDR2400_PI_MR2 <<8)|(DDR2400_PI_MR1 <<0));
+		REG_DDRPHY_WRITE(i,0x27F, (DDR2400_PI_MR1 <<24)|(PI_MR13<<16)|(PI_MR14<<8)|(PI_MR12<<0));
+		REG_DDRPHY_WRITE(i,0x280, (PI_MR12<<24)|(PI_MR11<<16)|(DDR_MR3 <<8)|(DDR2400_PI_MR2 <<0));
+		REG_DDRPHY_WRITE(i,0x281, (DDR_MR3 <<24)|(DDR2400_PI_MR2 <<16)|(DDR2400_PI_MR1 <<8)|(PI_MR14<<0));
+		REG_DDRPHY_WRITE(i,0x282, (DDR2400_PI_MR1 <<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0));
+		REG_DDRPHY_WRITE(i,0x283, (PI_MR12<<24)|(PI_MR11<<16)|(DDR_MR3 <<8)|(DDR2400_PI_MR2 <<0));
+		REG_DDRPHY_WRITE(i,0x284, (DDR2400_PI_MR2 <<24)|(DDR2400_PI_MR1 <<16)|(PI_MR13<<8)|(PI_MR14<<0));
+		REG_DDRPHY_WRITE(i,0x285, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(DDR_MR3 <<0));
+		REG_DDRPHY_WRITE(i,0x286, (PI_MR11<<24)|(DDR_MR3 <<16)|(DDR2400_PI_MR2 <<8)|(DDR2400_PI_MR1 <<0));
+		REG_DDRPHY_WRITE(i,0x287, (DDR2400_PI_MR2 <<24)|(DDR2400_PI_MR1 <<16)|(PI_MR14<<8)|(PI_MR12<<0));
+		REG_DDRPHY_WRITE(i,0x288, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(DDR_MR3 <<0));
+		REG_DDRPHY_WRITE(i,0x289, 0x00020000                              |(PI_MR13<<0));
+
+		REG_DDRPHY_WRITE(i,0x247, 0x0a0a0a05);	//PI_RD_TO_ODTH_F2:RW:24:6:=0x15 PI_RD_TO_ODTH_F1:RW:16:6:=0x15 PI_RD_TO_ODTH_F0:RW:8:6:=0x04 PI_WR_TO_ODTH_F2:RW:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x254, 0x02030303);	//PI_TDFI_PHY_WRDATA:RW:24:3:=0x02 PI_TDFI_WRCSLAT_F2:RW:16:7:=0x06 PI_TDFI_WRCSLAT_F1:RW:8:7:=0x06 PI_TDFI_WRCSLAT_F0:RW:0:7:=0x01
+		REG_DDRPHY_WRITE(i,0x257, 0x00201701);	//PI_TDFI_CALVL_CC_F0:RW:16:10:=0x0018 PI_TDFI_CALVL_EN:RW:8:8:=0x17 PI_CALVL_CS_MAP:RW:0:4:=0x03
+		REG_DDRPHY_WRITE(i,0x258, 0x0020000e);	//PI_TDFI_CALVL_CC_F1:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F0:RW:0:10:=0x000e
+		REG_DDRPHY_WRITE(i,0x259, 0x0020000e);	//PI_TDFI_CALVL_CC_F2:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F1:RW:0:10:=0x000e
+		REG_DDRPHY_WRITE(i,0x25A, 0x0000000e);	//PI_TDFI_CALVL_CAPTURE_F2:RW:0:10:=0x0016
+		REG_DDRPHY_WRITE(i,0x25F, 0x00C8020A);	//PI_TCAENT_F0:RW:16:14:=0x0005 PI_TMRZ_F0:RW:8:5:=0x01 PI_TCACKEH:RW:0:5:=0x0a
+		REG_DDRPHY_WRITE(i,0x260, 0x0200C802);	//PI_TMRZ_F2:RW:24:5:=0x03 PI_TCAENT_F1:RW:8:14:=0x018d PI_TMRZ_F1:RW:0:5:=0x03
+		REG_DDRPHY_WRITE(i,0x261, 0x000A00C8);	//PI_CA_TRAIN_VREF_EN:RW:24:1:=0x01 PI_TCAEXT:RW:16:5:=0x0a PI_TCAENT_F2:RW:0:14:=0x018d
+		REG_DDRPHY_WRITE(i,0x262, 0x00C90100);	//PI_TVREF_SHORT_F0:RW:16:10:=0x0006 PI_TDFI_CASEL_F0:RW:8:5:=0x01 PI_TDFI_CACSCA_F0:RW:0:5:=0x00
+		REG_DDRPHY_WRITE(i,0x263, 0x010000C9);	//PI_TDFI_CASEL_F1:RW:24:5:=0x01 PI_TDFI_CACSCA_F1:RW:16:5:=0x00 PI_TVREF_LONG_F0:RW:0:10:=0x0006
+		REG_DDRPHY_WRITE(i,0x268, 0x07070705);	//PI_TDFI_CALVL_STROBE_F2:RW:24:4:=0x09 PI_TDFI_CALVL_STROBE_F1:RW:16:4:=0x09 PI_TDFI_CALVL_STROBE_F0:RW:8:4:=0x06 PI_TDFI_INIT_COMPLETE_MIN:RW:0:8:=0x05
+		REG_DDRPHY_WRITE(i,0x26D, 0x10100100);	//PI_TCKEHDQS_F1:RW:24:6:=0x18 PI_TCKEHDQS_F0:RW:16:6:=0x02 PI_REFRESH_BETWEEN_SEGMENT_DISABLE:RW_D:8:1:=0x01 PI_DRAM_CLK_DISABLE_DEASSERT_SEL:RW:0:1:=0x00
+		REG_DDRPHY_WRITE(i,0x26E, 0x00010110);	//PI_WDQLVL_BST_NUM:RW:16:3:=0x01 PI_WDQLVL_VREF_EN:RW:8:1:=0x01 PI_TCKEHDQS_F2:RW:0:6:=0x18
+		REG_DDRPHY_WRITE(i,0x2A8, 0x00185000);	//PI_TDFI_CTRLUPD_MAX_F0:RW:8:16:=0x008c PI_TDFI_CTRLUPD_MIN:RD:0:4:=0x00
+		REG_DDRPHY_WRITE(i,0x2A9, 0x0000f320);	//PI_TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x00000578
+		REG_DDRPHY_WRITE(i,0x2AA, 0x00001850);	//PI_TDFI_CTRLUPD_MAX_F1:RW:0:16:=0x304c
+		REG_DDRPHY_WRITE(i,0x2AB, 0x0000f320);	//PI_TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x0001e2f8
+		REG_DDRPHY_WRITE(i,0x2AC, 0x00001850);	//PI_TDFI_CTRLUPD_MAX_F2:RW:0:16:=0x304c
+		REG_DDRPHY_WRITE(i,0x2AD, 0x0000f320);	//PI_TDFI_CTRLUPD_INTERVAL_F2:RW:0:32:=0x0001e2f8
+
+		REG_DDRPHY_WRITE(i,0x44C, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_0:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_0:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_0:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x452, 0x070000C0);	//PHY_RDDATA_EN_DLY_0:RW+:24:4:=0x0e PHY_IE_MODE_0:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_0:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_0:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x453, 0x00100006);	//PHY_MASTER_DELAY_START_0:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_0:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_0:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x454, 0x0C054208);	//PHY_WRLVL_DLY_STEP_0:RW+:24:4:=0x0c PHY_RPTR_UPDATE_0:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_0:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_0:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x4CC, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_1:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_1:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_1:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x4D2, 0x070000C0);	//PHY_RDDATA_EN_DLY_1:RW+:24:4:=0x0e PHY_IE_MODE_1:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_1:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_1:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x4D3, 0x00100006);	//PHY_MASTER_DELAY_START_1:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_1:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_1:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x4D4, 0x0C054208);	//PHY_WRLVL_DLY_STEP_1:RW+:24:4:=0x0c PHY_RPTR_UPDATE_1:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_1:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_1:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x54C, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_2:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_2:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_2:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x552, 0x070000C0);	//PHY_RDDATA_EN_DLY_2:RW+:24:4:=0x0e PHY_IE_MODE_2:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_2:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_2:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x553, 0x00100006);	//PHY_MASTER_DELAY_START_2:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_2:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_2:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x554, 0x0C054208);	//PHY_WRLVL_DLY_STEP_2:RW+:24:4:=0x0c PHY_RPTR_UPDATE_2:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_2:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_2:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x5CC, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_3:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_3:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_3:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x5D2, 0x070000C0);	//PHY_RDDATA_EN_DLY_3:RW+:24:4:=0x0e PHY_IE_MODE_3:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_3:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_3:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x5D3, 0x00100006);	//PHY_MASTER_DELAY_START_3:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_3:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_3:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x5D4, 0x0C054208);	//PHY_WRLVL_DLY_STEP_3:RW+:24:4:=0x0c PHY_RPTR_UPDATE_3:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_3:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_3:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x719, 0x00000303);	//PHY_LP_WAKEUP:RW:24:4:=0x00 PHY_LP4_BOOT_LOW_FREQ_SEL:RW:16:1:=0x01 PHY_TCKSRE_WAIT:RW:8:4:=0x05 PHY_PLL_TESTOUT_SEL:RW:0:3:=0x03
+	}
+}
+
+void freq1600_reg_set()
+{
+	uint32_t i;
+
+	for(i=0;i<4;i++)
+	{
+		REG_DDRPHY_WRITE(i,0x22B, (DDR1600_PI_CASLAT_LIN<<24)|(DDR1600_PI_WRLAT<<16)|(DDR1600_PI_CASLAT_LIN<<8)|(DDR1600_PI_WRLAT<<0));
+		REG_DDRPHY_WRITE(i,0x22C, 0x00020000|(DDR1600_PI_CASLAT_LIN<<8)|(DDR1600_PI_WRLAT<<0));
+
+		REG_DDRPHY_WRITE(i,0x252, (DDR1600_PI_RDLAT_ADJ<<16)|(DDR1600_PI_RDLAT_ADJ<<8)|(DDR1600_PI_RDLAT_ADJ<<0));
+		REG_DDRPHY_WRITE(i,0x253, (DDR1600_PI_WRLAT_ADJ<<16)|(DDR1600_PI_WRLAT_ADJ<<8)|(DDR1600_PI_WRLAT_ADJ<<0));
+
+		REG_DDRPHY_WRITE(i,0x28A, (DDR1600_PI_TFC<<16)|(DDR1600_PI_TFC<<0));
+		REG_DDRPHY_WRITE(i,0x28B, (DDR1600_PI_TRTP<<24)|(DDR1600_PI_TCCD<<16)|(DDR1600_PI_TFC<<0));
+		REG_DDRPHY_WRITE(i,0x28C, (DDR1600_PI_TWR<<24) |(DDR1600_PI_TWTR<<16)|(DDR1600_PI_TRCD<<8)|(DDR1600_PI_TRP<<0));
+		REG_DDRPHY_WRITE(i,0x28D, (DDR1600_PI_TRAS_MIN<<24)|(DDR1600_PI_TRAS_MAX<<0));
+		REG_DDRPHY_WRITE(i,0x28E, (DDR1600_PI_TMRW<<24) | (DDR1600_PI_TMRD<<16)|(DDR1600_PI_TCCDMW<<8)|(DDR1600_PI_TDQSCK_MAX<<0));
+		REG_DDRPHY_WRITE(i,0x28F, (DDR1600_PI_TWTR<<24) | (DDR1600_PI_TRCD<<16)|(DDR1600_PI_TRP<<8)   |(DDR1600_PI_TRTP<<0));
+		REG_DDRPHY_WRITE(i,0x290, (DDR1600_PI_TRAS_MAX<<8) | (DDR1600_PI_TWR<<0));
+		REG_DDRPHY_WRITE(i,0x291, (DDR1600_PI_TMRD<<24) | (DDR1600_PI_TCCDMW<<16) | (DDR1600_PI_TDQSCK_MAX<<8)|(DDR1600_PI_TRAS_MIN<<0));
+		REG_DDRPHY_WRITE(i,0x292, (DDR1600_PI_TRCD<<24) | (DDR1600_PI_TRP<<16) | (DDR1600_PI_TRTP<<8)|(DDR1600_PI_TMRW<<0));
+		REG_DDRPHY_WRITE(i,0x293, (DDR1600_PI_TWR<<8)|(DDR1600_PI_TWTR<<0));
+		REG_DDRPHY_WRITE(i,0x294, (DDR1600_PI_TRAS_MIN<<24)|(DDR1600_PI_TRAS_MAX<<0));
+		REG_DDRPHY_WRITE(i,0x295, (DDR1600_PI_TMRW<<24) | (DDR1600_PI_TMRD<<16)|(DDR1600_PI_TCCDMW<<8)|(DDR1600_PI_TDQSCK_MAX<<0));
+
+		REG_DDRPHY_WRITE(i,0x276, (PI_MR3 <<24)|(DDR1600_PI_MR2 <<16)|(DDR1600_PI_MR1 <<8)|0x00);
+		REG_DDRPHY_WRITE(i,0x277, (DDR1600_PI_MR1 <<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0));
+		REG_DDRPHY_WRITE(i,0x278, (PI_MR12<<24)|(PI_MR11<<16)|(PI_MR3 <<8)|(DDR1600_PI_MR2 <<0));
+		REG_DDRPHY_WRITE(i,0x279, (PI_MR3 <<24)|(DDR1600_PI_MR2 <<16)|(DDR1600_PI_MR1 <<8)|(PI_MR14<<0));
+		REG_DDRPHY_WRITE(i,0x27A, (PI_MR13<<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0));
+		REG_DDRPHY_WRITE(i,0x27B, (PI_MR11<<24)|(PI_MR3 <<16)|(DDR1600_PI_MR2 <<8)|(DDR1600_PI_MR1 <<0));
+		REG_DDRPHY_WRITE(i,0x27C, (DDR1600_PI_MR2 <<24)|(DDR1600_PI_MR1 <<16)|(PI_MR14<<8)|(PI_MR12<<0));
+		REG_DDRPHY_WRITE(i,0x27D, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(PI_MR3 <<0));
+		REG_DDRPHY_WRITE(i,0x27E, (PI_MR11<<24)|(PI_MR3 <<16)|(DDR1600_PI_MR2 <<8)|(DDR1600_PI_MR1 <<0));
+		REG_DDRPHY_WRITE(i,0x27F, (DDR1600_PI_MR1 <<24)|(PI_MR13<<16)|(PI_MR14<<8)|(PI_MR12<<0));
+		REG_DDRPHY_WRITE(i,0x280, (PI_MR12<<24)|(PI_MR11<<16)|(PI_MR3 <<8)|(DDR1600_PI_MR2 <<0));
+		REG_DDRPHY_WRITE(i,0x281, (PI_MR3 <<24)|(DDR1600_PI_MR2 <<16)|(DDR1600_PI_MR1 <<8)|(PI_MR14<<0));
+		REG_DDRPHY_WRITE(i,0x282, (DDR1600_PI_MR1 <<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0));
+		REG_DDRPHY_WRITE(i,0x283, (PI_MR12<<24)|(PI_MR11<<16)|(PI_MR3 <<8)|(DDR1600_PI_MR2 <<0));
+		REG_DDRPHY_WRITE(i,0x284, (DDR1600_PI_MR2 <<24)|(DDR1600_PI_MR1 <<16)|(PI_MR13<<8)|(PI_MR14<<0));
+		REG_DDRPHY_WRITE(i,0x285, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(PI_MR3 <<0));
+		REG_DDRPHY_WRITE(i,0x286, (PI_MR11<<24)|(PI_MR3 <<16)|(DDR1600_PI_MR2 <<8)|(DDR1600_PI_MR1 <<0));
+		REG_DDRPHY_WRITE(i,0x287, (DDR1600_PI_MR2 <<24)|(DDR1600_PI_MR1 <<16)|(PI_MR14<<8)|(PI_MR12<<0));
+		REG_DDRPHY_WRITE(i,0x288, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(PI_MR3 <<0));
+		REG_DDRPHY_WRITE(i,0x289, 0x00020000                              |(PI_MR13<<0));
+
+		REG_DDRPHY_WRITE(i,0x247, 0x0a0a0a05);	//PI_RD_TO_ODTH_F2:RW:24:6:=0x15 PI_RD_TO_ODTH_F1:RW:16:6:=0x15 PI_RD_TO_ODTH_F0:RW:8:6:=0x04 PI_WR_TO_ODTH_F2:RW:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x254, 0x02030303);	//PI_TDFI_PHY_WRDATA:RW:24:3:=0x02 PI_TDFI_WRCSLAT_F2:RW:16:7:=0x06 PI_TDFI_WRCSLAT_F1:RW:8:7:=0x06 PI_TDFI_WRCSLAT_F0:RW:0:7:=0x01
+		REG_DDRPHY_WRITE(i,0x257, 0x00201701);	//PI_TDFI_CALVL_CC_F0:RW:16:10:=0x0018 PI_TDFI_CALVL_EN:RW:8:8:=0x17 PI_CALVL_CS_MAP:RW:0:4:=0x03
+		REG_DDRPHY_WRITE(i,0x258, 0x0020000e);	//PI_TDFI_CALVL_CC_F1:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F0:RW:0:10:=0x000e
+		REG_DDRPHY_WRITE(i,0x259, 0x0020000e);	//PI_TDFI_CALVL_CC_F2:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F1:RW:0:10:=0x000e
+		REG_DDRPHY_WRITE(i,0x25A, 0x0000000e);	//PI_TDFI_CALVL_CAPTURE_F2:RW:0:10:=0x0016
+		REG_DDRPHY_WRITE(i,0x25F, 0x00C8020A);	//PI_TCAENT_F0:RW:16:14:=0x0005 PI_TMRZ_F0:RW:8:5:=0x01 PI_TCACKEH:RW:0:5:=0x0a
+		REG_DDRPHY_WRITE(i,0x260, 0x0200C802);	//PI_TMRZ_F2:RW:24:5:=0x03 PI_TCAENT_F1:RW:8:14:=0x018d PI_TMRZ_F1:RW:0:5:=0x03
+		REG_DDRPHY_WRITE(i,0x261, 0x000A00C8);	//PI_CA_TRAIN_VREF_EN:RW:24:1:=0x01 PI_TCAEXT:RW:16:5:=0x0a PI_TCAENT_F2:RW:0:14:=0x018d
+		REG_DDRPHY_WRITE(i,0x262, 0x00C90100);	//PI_TVREF_SHORT_F0:RW:16:10:=0x0006 PI_TDFI_CASEL_F0:RW:8:5:=0x01 PI_TDFI_CACSCA_F0:RW:0:5:=0x00
+		REG_DDRPHY_WRITE(i,0x263, 0x010000C9);	//PI_TDFI_CASEL_F1:RW:24:5:=0x01 PI_TDFI_CACSCA_F1:RW:16:5:=0x00 PI_TVREF_LONG_F0:RW:0:10:=0x0006
+		REG_DDRPHY_WRITE(i,0x268, 0x07070705);	//PI_TDFI_CALVL_STROBE_F2:RW:24:4:=0x09 PI_TDFI_CALVL_STROBE_F1:RW:16:4:=0x09 PI_TDFI_CALVL_STROBE_F0:RW:8:4:=0x06 PI_TDFI_INIT_COMPLETE_MIN:RW:0:8:=0x05
+		REG_DDRPHY_WRITE(i,0x26D, 0x10100100);	//PI_TCKEHDQS_F1:RW:24:6:=0x18 PI_TCKEHDQS_F0:RW:16:6:=0x02 PI_REFRESH_BETWEEN_SEGMENT_DISABLE:RW_D:8:1:=0x01 PI_DRAM_CLK_DISABLE_DEASSERT_SEL:RW:0:1:=0x00
+		REG_DDRPHY_WRITE(i,0x26E, 0x00010110);	//PI_WDQLVL_BST_NUM:RW:16:3:=0x01 PI_WDQLVL_VREF_EN:RW:8:1:=0x01 PI_TCKEHDQS_F2:RW:0:6:=0x18
+		REG_DDRPHY_WRITE(i,0x2A8, 0x00185000);	//PI_TDFI_CTRLUPD_MAX_F0:RW:8:16:=0x008c PI_TDFI_CTRLUPD_MIN:RD:0:4:=0x00
+		REG_DDRPHY_WRITE(i,0x2A9, 0x0000f320);	//PI_TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x00000578
+		REG_DDRPHY_WRITE(i,0x2AA, 0x00001850);	//PI_TDFI_CTRLUPD_MAX_F1:RW:0:16:=0x304c
+		REG_DDRPHY_WRITE(i,0x2AB, 0x0000f320);	//PI_TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x0001e2f8
+		REG_DDRPHY_WRITE(i,0x2AC, 0x00001850);	//PI_TDFI_CTRLUPD_MAX_F2:RW:0:16:=0x304c
+		REG_DDRPHY_WRITE(i,0x2AD, 0x0000f320);	//PI_TDFI_CTRLUPD_INTERVAL_F2:RW:0:32:=0x0001e2f8
+
+		REG_DDRPHY_WRITE(i,0x44C, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_0:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_0:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_0:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x452, 0x070000C0);	//PHY_RDDATA_EN_DLY_0:RW+:24:4:=0x0e PHY_IE_MODE_0:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_0:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_0:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x453, 0x00100006);	//PHY_MASTER_DELAY_START_0:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_0:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_0:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x454, 0x0C054208);	//PHY_WRLVL_DLY_STEP_0:RW+:24:4:=0x0c PHY_RPTR_UPDATE_0:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_0:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_0:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x4CC, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_1:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_1:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_1:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x4D2, 0x070000C0);	//PHY_RDDATA_EN_DLY_1:RW+:24:4:=0x0e PHY_IE_MODE_1:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_1:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_1:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x4D3, 0x00100006);	//PHY_MASTER_DELAY_START_1:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_1:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_1:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x4D4, 0x0C054208);	//PHY_WRLVL_DLY_STEP_1:RW+:24:4:=0x0c PHY_RPTR_UPDATE_1:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_1:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_1:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x54C, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_2:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_2:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_2:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x552, 0x070000C0);	//PHY_RDDATA_EN_DLY_2:RW+:24:4:=0x0e PHY_IE_MODE_2:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_2:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_2:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x553, 0x00100006);	//PHY_MASTER_DELAY_START_2:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_2:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_2:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x554, 0x0C054208);	//PHY_WRLVL_DLY_STEP_2:RW+:24:4:=0x0c PHY_RPTR_UPDATE_2:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_2:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_2:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x5CC, 0x00020109);	//PHY_WRITE_PATH_LAT_ADD_3:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_3:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_3:RW+:0:10:=0x0109
+		REG_DDRPHY_WRITE(i,0x5D2, 0x070000C0);	//PHY_RDDATA_EN_DLY_3:RW+:24:4:=0x0e PHY_IE_MODE_3:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_3:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_3:RW+:0:8:=0xc0
+		REG_DDRPHY_WRITE(i,0x5D3, 0x00100006);	//PHY_MASTER_DELAY_START_3:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_3:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_3:RW+:0:4:=0x0c
+		REG_DDRPHY_WRITE(i,0x5D4, 0x0C054208);	//PHY_WRLVL_DLY_STEP_3:RW+:24:4:=0x0c PHY_RPTR_UPDATE_3:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_3:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_3:RW+:0:6:=0x08
+		REG_DDRPHY_WRITE(i,0x719, 0x00000303);	//PHY_LP_WAKEUP:RW:24:4:=0x00 PHY_LP4_BOOT_LOW_FREQ_SEL:RW:16:1:=0x01 PHY_TCKSRE_WAIT:RW:8:4:=0x05 PHY_PLL_TESTOUT_SEL:RW:0:3:=0x03
+	}
+}
+
diff --git a/plat/renesas/rcar/ddr/boot_init_dram.h b/plat/renesas/rcar/ddr/boot_init_dram.h
new file mode 100644
index 0000000..0e02303
--- /dev/null
+++ b/plat/renesas/rcar/ddr/boot_init_dram.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	__BOOT_INIT_DRAM_
+#define	__BOOT_INIT_DRAM_
+
+extern void InitDram(void);
+extern uint32_t TpExtendDdrRamCheck(void);
+
+#endif /* __BOOT_INIT_DRAM_ */
diff --git a/plat/renesas/rcar/ddr/init_dram_tbl.h b/plat/renesas/rcar/ddr/init_dram_tbl.h
new file mode 100644
index 0000000..f571354
--- /dev/null
+++ b/plat/renesas/rcar/ddr/init_dram_tbl.h
@@ -0,0 +1,1383 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	__INIT_DRAM_TBL_
+#define	__INIT_DRAM_TBL_
+
+#define PI_WRLAT 0x0e //F2=0x0e,F1=0x0e,F0=4
+#define PI_WRLAT_ADJ 0x0c
+
+#define PI_TFC  0x018D
+#define PI_TRTP 0x0c
+#define PI_TCCD 0x08   //common for all F
+#define PI_TWR  0x1f
+#define PI_TWTR 0x12
+#define PI_TRCD 0x1d
+#define PI_TRP  0x22
+#define PI_TRAS_MIN 0x43
+#define PI_TRAS_MAX 0x01b267
+#define PI_TMRW 0x0a
+#define PI_TMRD 0x17
+#define PI_TCCDMW 0x20
+#define PI_TDQSCK_MAX 0x6
+//////////////////////////////////////////////////////////////////////////////
+#define PI_MR1  0xd4	//MRW DeviceFeature1(Post=1.5tck nWR=30 RDpre=static WRPre=2tCK BL=16//OK
+#define PI_MR2  0x2e	//MRW DeviceFeature2(0,0SetA,101=WL14,110=RL32(nRTP14))//NG
+#define PI_MR3  0x31
+#define PI_MR11 0x36
+#define PI_MR12 0x11
+#define PI_MR14 0x11
+#define PI_MR13 0x00
+
+/*RDLAT*/
+#define PI_RDLAT_ADJ (0x12) //try 0e+4 OK
+
+/*CASLAT*/
+#define PI_CASLAT_LIN 0x50 //try OK
+	
+
+#define DDR_PHY_NUM 827
+#define DDR_PI_NUM  181
+#define DDR_PHY_PVT_OVERWRITE_NUM 8
+
+
+#define DDR_PHY_DRIVE_TERM_OVERWRITE_NUM (8+1+2+7+3+1)
+static const uint32_t DDR_PHY_DDR_PHY_DRIVE_TERM_OVERWITE_1600[DDR_PHY_DRIVE_TERM_OVERWRITE_NUM][2] = 
+{
+	{	0x00000404, 0x03006E02}, // PHY_DQS_TSEL_ENABLE_0:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_0:RW:0:24:=0x665555
+	{	0x00000405, 0x02006E02}, // PHY_TWO_CYC_PREAMBLE_0:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_0:RW:0:24:=0x665555
+	{	0x00000484, 0x03006E02}, // PHY_DQS_TSEL_ENABLE_1:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_1:RW:0:24:=0x665555
+	{	0x00000485, 0x02006E02}, // PHY_TWO_CYC_PREAMBLE_1:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_1:RW:0:24:=0x665555
+	{	0x00000504, 0x03006E02}, // PHY_DQS_TSEL_ENABLE_2:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_2:RW:0:24:=0x665555
+	{	0x00000505, 0x02006E02}, // PHY_TWO_CYC_PREAMBLE_2:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_2:RW:0:24:=0x665555
+	{	0x00000584, 0x03006E02}, // PHY_DQS_TSEL_ENABLE_3:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_3:RW:0:24:=0x665555
+	{	0x00000585, 0x02006E02}, // PHY_TWO_CYC_PREAMBLE_3:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_3:RW:0:24:=0x665555
+
+	//CKE 27F6E(LVSTL) -> 03fee(CMOS40orm)
+	{	0x00000723, 0x00003fee}, // PHY_PAD_CKE_DRIVE:RW+:0:18:=0x000411
+	//RST 27F6E(LVSTL) -> 03fee(CMOS40orm)
+	{	0x00000725, 0x00003fee}, // PHY_PAD_RST_DRIVE:RW+:0:18:=0x000411
+	{	0x00000726, 0x0001154f}, // PHY_PAD_RST_TERM:RW+:0:18:=0x004410
+
+	// TERM 10F68(PVTR=10,PVTN=3D,PVTP=28) -> 1154f(PVTR=11,PVTN=15,PVTP=0f
+	{	0x0000071E, 0x0003154f}, // PHY_PAD_FDBK_TERM:RW+:0:18:=0x004410 // TSEL = ON
+	{	0x0000071F, 0x0001154f}, // PHY_PAD_DATA_TERM:RW+:0:17:=0x004410
+	{	0x00000720, 0x0001154f}, // PHY_PAD_DQS_TERM:RW+:0:17:=0x004410
+	{	0x00000721, 0x0001154f}, // PHY_PAD_ADDR_TERM:RW+:0:18:=0x004410
+	{	0x00000722, 0x0001154f}, // PHY_PAD_CLK_TERM:RW+:0:18:=0x004410
+	{	0x00000724, 0x0001154f}, // PHY_PAD_CKE_TERM:RW+:0:18:=0x004410
+	{	0x00000728, 0x0001154f}, // PHY_PAD_CS_TERM:RW+:0:18:=0x004410
+
+	// VREF
+	{	0x0000070F, 0x000F1900}, // PHY_PAD_VREF_CTRL_DQ_0:RW+:8:14:=0x0100 PHY_LOW_FREQ_SEL:RW+:0:1:=0x00
+//	{	0x0000070F, 0x000F1901}, // PHY_PAD_VREF_CTRL_DQ_0:RW+:8:14:=0x0100 PHY_LOW_FREQ_SEL:RW+:0:1:=0x01
+	{	0x00000710, 0x0F190F19}, // PHY_PAD_VREF_CTRL_DQ_2:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_1:RW+:0:14:=0x0100
+	{	0x00000711, 0x0F190F19}, // PHY_PAD_VREF_CTRL_AC:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_3:RW+:0:14:=0x0100
+	// PAD CAL?
+	{	0x0000072C, 0x75000000}, // PHY_CAL_MODE_0:RW:24:8:=0x64 PHY_TST_CLK_PAD_CTRL2:RW:0:23:=0x000000		
+};
+
+
+// 2015/07/20 suresh regconfig
+static const uint32_t DDR_PHY_suresh[827][2] = 
+{
+	{	0x00000400, 0x000004F0}, // PHY_SW_WRDQ0_SHIFT_0:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_0:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_0:RW:0:11:=0x04f0
+	{	0x00000401, 0x00000000}, // PHY_SW_WRDQ4_SHIFT_0:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_0:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_0:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_0:RW:0:5:=0x00
+	{	0x00000402, 0x00000000}, // PHY_SW_WRDM_SHIFT_0:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_0:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_0:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_0:RW:0:5:=0x00
+//	{	0x00000403, 0x00000100}, // PHY_DQ_TSEL_ENABLE_0:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_0:RW:0:4:=0x00
+	{	0x00000403, 0x00000300}, // PHY_DQ_TSEL_ENABLE_0:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_0:RW:0:4:=0x00
+//	{	0x00000404, 0x01CC6E0C}, // PHY_DQS_TSEL_ENABLE_0:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_0:RW:0:24:=0x665555
+	{	0x00000404, 0x030e6E0E}, // PHY_DQS_TSEL_ENABLE_0:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_0:RW:0:24:=0x665555
+//	{	0x00000404, 0x036e6E0E}, // PHY_DQS_TSEL_ENABLE_0:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_0:RW:0:24:=0x665555
+//	{	0x00000405, 0x02CC6E0C}, // PHY_TWO_CYC_PREAMBLE_0:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_0:RW:0:24:=0x665555
+	{	0x00000405, 0x020e6E0E}, // PHY_TWO_CYC_PREAMBLE_0:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_0:RW:0:24:=0x665555
+//	{	0x00000405, 0x026e6E0E}, // PHY_TWO_CYC_PREAMBLE_0:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_0:RW:0:24:=0x665555
+	{	0x00000406, 0x00010F00}, // PHY_PER_CS_TRAINING_INDEX_0:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_0:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_0:RW:8:2:=0x0f PHY_DBI_MODE_0:RW:0:1:=0x00
+	{	0x00000407, 0x04000100}, // PHY_LP4_BOOT_RPTR_UPDATE_0:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_0:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_0:RW:0:2:=0x00
+	{	0x00000408, 0x00000133}, // PHY_LPBK_CONTROL_0:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_0:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_0:RW:0:10:=0x0133
+	{	0x00000409, 0x000700C0}, // SC_PHY_SNAP_OBS_REGS_0:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_0:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_0:RW:0:10:=0x00c0
+	{	0x0000040A, 0x00CC0201}, // PHY_GATE_SMPL1_SLAVE_DELAY_0:RW:16:9:=0x00cc PHY_LPDDR_TYPE_0:RW:8:2:=0x02 PHY_LPDDR_0:RW:0:1:=0x01
+	{	0x0000040B, 0x00030066}, // ON_FLY_GATE_ADJUST_EN_0:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_0:RW:0:9:=0x0066
+	{	0x0000040C, 0x00000000}, // PHY_GATE_TRACKING_OBS_0:RD:0:32:=0x00000000
+	{	0x0000040D, 0x00000000}, // PHY_LP4_PST_AMBLE_0:RW:0:1:=0x00
+	{	0x0000040E, 0x00000000}, // PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000
+	{	0x0000040F, 0x00000000}, // PHY_LP4_RDLVL_PATT9_0:RW:0:32:=0x00000000
+	{	0x00000410, 0x00000000}, // PHY_LP4_RDLVL_PATT10_0:RW:0:32:=0x00000000
+	{	0x00000411, 0x00000000}, // PHY_LP4_RDLVL_PATT11_0:RW:0:32:=0x00000000
+	{	0x00000412, 0x00000000}, // PHY_RDDQ_ENC_OBS_SELECT_0:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_0:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_0:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_0:RW:0:3:=0x00
+	{	0x00000413, 0x00000000}, // PHY_FIFO_PTR_OBS_SELECT_0:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_0:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_0:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_0:RW:0:4:=0x00
+	{	0x00000414, 0x04080000}, // PHY_WRLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_0:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_0:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_0:RW:0:1:=0x00
+	{	0x00000415, 0x04080a04}, // PHY_RDLVL_UPDT_WAIT_CNT_0:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_0:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_0:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_0:RW:0:6:=0x00
+	{	0x00000416, 0x00000000}, // PHY_RDLVL_DATA_MASK_0:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_0:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_0:RW:0:2:=0x00
+	{	0x00000417, 0x32103210}, // PHY_RDLVL_DATA_SWIZZLE_0:RW:0:32:=0x32103210
+	{	0x00000418, 0x00C00208}, // PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_0:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_0:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_0:RW:0:6:=0x08
+	{	0x00000419, 0x0001000C}, // PHY_WDQLVL_CLR_PREV_RESULTS_0:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_0:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_0:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_0:RW:0:4:=0x0c
+	{	0x0000041A, 0x00000100}, // PHY_WDQLVL_DATADM_MASK_0:RW:0:9:=0x0100
+	{	0x0000041B, 0x55555555}, // PHY_USER_PATT0_0:RW:0:32:=0x55555555
+	{	0x0000041C, 0xAAAAAAAA}, // PHY_USER_PATT1_0:RW:0:32:=0xAAAAAAAA
+	{	0x0000041D, 0x55555555}, // PHY_USER_PATT2_0:RW:0:32:=0x55555555
+	{	0x0000041E, 0xAAAAAAAA}, // PHY_USER_PATT3_0:RW:0:32:=0xAAAAAAAA
+	{	0x0000041F, 0x00005555}, // PHY_USER_PATT4_0:RW:0:16:=0x5555
+	{	0x00000420, 0x76543210}, // PHY_DQ_SWIZZLING_0:RW:0:32:=0x76543210
+	{	0x00000421, 0x00000001}, // PHY_FIFO_PTR_OBS_0:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_0:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_0:RW:0:1:=0x01
+	{	0x00000422, 0x00000000}, // PHY_LPBK_RESULT_OBS_0:RD:0:32:=0x00000000
+	{	0x00000423, 0x00000000}, // PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_0:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_0:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_0:RD:0:10:=0x0000
+	{	0x00000424, 0x00000000}, // PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_0:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_0:RD:0:8:=0x00
+	{	0x00000425, 0x00000000}, // PHY_WR_SHIFT_OBS_0:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_0:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_0:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_0:RD:0:7:=0x00
+	{	0x00000426, 0x00000000}, // PHY_WRLVL_HARD1_DELAY_OBS_0:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_0:RD:0:10:=0x0000
+	{	0x00000427, 0x00000000}, // PHY_WRLVL_STATUS_OBS_0:RD:0:17:=0x000000
+	{	0x00000428, 0x00000000}, // PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_0:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_0:RD:0:9:=0x0000
+	{	0x00000429, 0x00000000}, // PHY_GTLVL_HARD0_DELAY_OBS_0:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_0:RD:0:16:=0x0000
+	{	0x0000042A, 0x00000000}, // PHY_GTLVL_STATUS_OBS_0:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_0:RD:0:14:=0x0000
+	{	0x0000042B, 0x00000000}, // PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_0:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_0:RD:0:10:=0x0000
+	{	0x0000042C, 0x00000000}, // PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_0:RD:0:2:=0x00
+	{	0x0000042D, 0x00000000}, // PHY_RDLVL_STATUS_OBS_0:RD:0:32:=0x00000000
+	{	0x0000042E, 0x00000000}, // PHY_WDQLVL_DQDM_TE_DLY_OBS_0:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_0:RD:0:11:=0x0000
+	{	0x0000042F, 0x00000000}, // PHY_WDQLVL_STATUS_OBS_0:RD:0:32:=0x00000000
+	{	0x00000430, 0x00000000}, // PHY_DDL_MODE_0:RW:0:18:=0x000000
+	{	0x00000431, 0x00000000}, // PHY_DDL_TEST_OBS_0:RD:0:32:=0x00000000
+	{	0x00000432, 0x00000000}, // PHY_DDL_TEST_MSTR_DLY_OBS_0:RD:0:32:=0x00000000
+	{	0x00000433, 0x00200000}, // PHY_RX_CAL_SAMPLE_WAIT_0:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_0:RW:8:1:=0x00 SC_PHY_RX_CAL_START_0:WR:0:1:=0x00
+	{	0x00000434, 0x00000000}, // PHY_RX_CAL_DQ1_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_0:RW+:0:12:=0x0000
+	{	0x00000435, 0x00000000}, // PHY_RX_CAL_DQ3_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_0:RW+:0:12:=0x0000
+	{	0x00000436, 0x00000000}, // PHY_RX_CAL_DQ5_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_0:RW+:0:12:=0x0000
+	{	0x00000437, 0x00000000}, // PHY_RX_CAL_DQ7_0:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_0:RW+:0:12:=0x0000
+	{	0x00000438, 0x00000000}, // PHY_RX_CAL_DQS_0:RW+:16:12:=0x0000 PHY_RX_CAL_DM_0:RW+:0:12:=0x0000
+	{	0x00000439, 0x00000000}, // PHY_RX_CAL_OBS_0:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_0:RW+:0:12:=0x0000
+	{	0x0000043A, 0x02800280}, // PHY_CLK_WRDQ1_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_0:RW+:0:11:=0x0280
+	{	0x0000043B, 0x02800280}, // PHY_CLK_WRDQ3_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_0:RW+:0:11:=0x0280
+	{	0x0000043C, 0x02800280}, // PHY_CLK_WRDQ5_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_0:RW+:0:11:=0x0280
+	{	0x0000043D, 0x02800280}, // PHY_CLK_WRDQ7_SLAVE_DELAY_0:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_0:RW+:0:11:=0x0280
+	{	0x0000043E, 0x00000280}, // PHY_CLK_WRDQS_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_0:RW+:0:11:=0x0280
+	{	0x0000043F, 0x00000000}, // PHY_RDDQ1_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_0:RW+:0:10:=0x0000
+	{	0x00000440, 0x00000000}, // PHY_RDDQ3_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_0:RW+:0:10:=0x0000
+	{	0x00000441, 0x00000000}, // PHY_RDDQ5_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_0:RW+:0:10:=0x0000
+	{	0x00000442, 0x00000000}, // PHY_RDDQ7_SLAVE_DELAY_0:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_0:RW+:0:10:=0x0000
+	{	0x00000443, 0x00A000A0}, // PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0
+	{	0x00000444, 0x00A000A0}, // PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0
+	{	0x00000445, 0x00A000A0}, // PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0
+	{	0x00000446, 0x00A000A0}, // PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0
+	{	0x00000447, 0x00A000A0}, // PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0
+	{	0x00000448, 0x00A000A0}, // PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0
+	{	0x00000449, 0x00A000A0}, // PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0
+	{	0x0000044A, 0x00A000A0}, // PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0
+	{	0x0000044B, 0x00A000A0}, // PHY_RDDQS_DM_FALL_SLAVE_DELAY_0:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_0:RW+:0:10:=0x00a0
+	{	0x0000044C, 0x00040109}, // PHY_WRITE_PATH_LAT_ADD_0:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_0:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_0:RW+:0:10:=0x0109
+	{	0x0000044D, 0x000001D0}, // PHY_WRLVL_DELAY_PERIOD_THRESHOLD_0:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_0:RW+:0:10:=0x01d0
+	{	0x0000044E, 0x03000000}, // PHY_GTLVL_LAT_ADJ_START_0:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_0:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_0:RW+:0:1:=0x00
+	{	0x0000044F, 0x00000200}, // PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_0:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_0:RW+:0:11:=0x0200
+//	{	0x00000450, 0x41315141}, // PHY_DQS_OE_TIMING_0:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_0:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_0:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_0:RW+:0:8:=0x41
+	{	0x00000450, 0x41415141}, // PHY_DQS_OE_TIMING_0:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_0:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_0:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_0:RW+:0:8:=0x41
+//	{	0x00000451, 0xC0013150}, // PHY_DQ_IE_TIMING_0:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_0:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_0:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_0:RW+:0:8:=0x50
+	{	0x00000451, 0xC0014150}, // PHY_DQ_IE_TIMING_0:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_0:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_0:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_0:RW+:0:8:=0x50
+	{	0x00000452, 0x0E0000C0}, // PHY_RDDATA_EN_DLY_0:RW+:24:4:=0x0e PHY_IE_MODE_0:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_0:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_0:RW+:0:8:=0xc0
+	{	0x00000453, 0x0010000C}, // PHY_MASTER_DELAY_START_0:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_0:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_0:RW+:0:4:=0x0c
+	{	0x00000454, 0x0C064208}, // PHY_WRLVL_DLY_STEP_0:RW+:24:4:=0x0c PHY_RPTR_UPDATE_0:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_0:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_0:RW+:0:6:=0x08
+	{	0x00000455, 0x000F0C18}, // PHY_GTLVL_RESP_WAIT_CNT_0:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_0:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_0:RW+:0:5:=0x18
+	{	0x00000456, 0x01000140}, // PHY_GTLVL_FINAL_STEP_0:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_0:RW+:0:10:=0x0140
+	{	0x00000457, 0x00000C20}, // PHY_RDLVL_DLY_STEP_0:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_0:RW+:0:8:=0x20
+	{	0x00000458, 0x00000000}, //
+	{	0x00000459, 0x00000000}, //
+	{	0x0000045A, 0x00000000}, //
+	{	0x0000045B, 0x00000000}, //
+	{	0x0000045C, 0x00000000}, //
+	{	0x0000045D, 0x00000000}, //
+	{	0x0000045E, 0x00000000}, //
+	{	0x0000045F, 0x00000000}, //
+	{	0x00000460, 0x00000000}, //
+	{	0x00000461, 0x00000000}, //
+	{	0x00000462, 0x00000000}, //
+	{	0x00000463, 0x00000000}, //
+	{	0x00000464, 0x00000000}, //
+	{	0x00000465, 0x00000000}, //
+	{	0x00000466, 0x00000000}, //
+	{	0x00000467, 0x00000000}, //
+	{	0x00000468, 0x00000000}, //
+	{	0x00000469, 0x00000000}, //
+	{	0x0000046A, 0x00000000}, //
+	{	0x0000046B, 0x00000000}, //
+	{	0x0000046C, 0x00000000}, //
+	{	0x0000046D, 0x00000000}, //
+	{	0x0000046E, 0x00000000}, //
+	{	0x0000046F, 0x00000000}, //
+	{	0x00000470, 0x00000000}, //
+	{	0x00000471, 0x00000000}, //
+	{	0x00000472, 0x00000000}, //
+	{	0x00000473, 0x00000000}, //
+	{	0x00000474, 0x00000000}, //
+	{	0x00000475, 0x00000000}, //
+	{	0x00000476, 0x00000000}, //
+	{	0x00000477, 0x00000000}, //
+	{	0x00000478, 0x00000000}, //
+	{	0x00000479, 0x00000000}, //
+	{	0x0000047A, 0x00000000}, //
+	{	0x0000047B, 0x00000000}, //
+	{	0x0000047C, 0x00000000}, //
+	{	0x0000047D, 0x00000000}, //
+	{	0x0000047E, 0x00000000}, //
+	{	0x0000047F, 0x00000000}, //
+	{	0x00000480, 0x000004F0}, // PHY_SW_WRDQ0_SHIFT_1:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_1:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:0:11:=0x04f0
+	{	0x00000481, 0x00000000}, // PHY_SW_WRDQ4_SHIFT_1:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_1:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_1:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_1:RW:0:5:=0x00
+	{	0x00000482, 0x00000000}, // PHY_SW_WRDM_SHIFT_1:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_1:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_1:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_1:RW:0:5:=0x00
+//	{	0x00000483, 0x00000100}, // PHY_DQ_TSEL_ENABLE_1:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_1:RW:0:4:=0x00
+	{	0x00000483, 0x00000300}, // PHY_DQ_TSEL_ENABLE_1:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_1:RW:0:4:=0x00
+//	{	0x00000484, 0x01CC6E0C}, // PHY_DQS_TSEL_ENABLE_1:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_1:RW:0:24:=0x665555
+	{	0x00000484, 0x030E6E0E}, // PHY_DQS_TSEL_ENABLE_1:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_1:RW:0:24:=0x665555
+//	{	0x00000484, 0x036E6E0E}, // PHY_DQS_TSEL_ENABLE_1:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_1:RW:0:24:=0x665555
+//	{	0x00000485, 0x02CC6E0C}, // PHY_TWO_CYC_PREAMBLE_1:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_1:RW:0:24:=0x665555
+	{	0x00000485, 0x020E6E0E}, // PHY_TWO_CYC_PREAMBLE_1:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_1:RW:0:24:=0x665555
+//	{	0x00000485, 0x026E6E0E}, // PHY_TWO_CYC_PREAMBLE_1:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_1:RW:0:24:=0x665555
+	{	0x00000486, 0x00010F00}, // PHY_PER_CS_TRAINING_INDEX_1:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_1:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_1:RW:8:2:=0x0f PHY_DBI_MODE_1:RW:0:1:=0x00
+	{	0x00000487, 0x04000100}, // PHY_LP4_BOOT_RPTR_UPDATE_1:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_1:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_1:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_1:RW:0:2:=0x00
+	{	0x00000488, 0x00000133}, // PHY_LPBK_CONTROL_1:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_1:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_1:RW:0:10:=0x0133
+	{	0x00000489, 0x000700C0}, // SC_PHY_SNAP_OBS_REGS_1:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_1:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_1:RW:0:10:=0x00c0
+	{	0x0000048A, 0x00CC0201}, // PHY_GATE_SMPL1_SLAVE_DELAY_1:RW:16:9:=0x00cc PHY_LPDDR_TYPE_1:RW:8:2:=0x02 PHY_LPDDR_1:RW:0:1:=0x01
+	{	0x0000048B, 0x00030066}, // ON_FLY_GATE_ADJUST_EN_1:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_1:RW:0:9:=0x0066
+	{	0x0000048C, 0x00000000}, // PHY_GATE_TRACKING_OBS_1:RD:0:32:=0x00000000
+	{	0x0000048D, 0x00000000}, // PHY_LP4_PST_AMBLE_1:RW:0:1:=0x00
+	{	0x0000048E, 0x00000000}, // PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000
+	{	0x0000048F, 0x00000000}, // PHY_LP4_RDLVL_PATT9_1:RW:0:32:=0x00000000
+	{	0x00000490, 0x00000000}, // PHY_LP4_RDLVL_PATT10_1:RW:0:32:=0x00000000
+	{	0x00000491, 0x00000000}, // PHY_LP4_RDLVL_PATT11_1:RW:0:32:=0x00000000
+	{	0x00000492, 0x00000000}, // PHY_RDDQ_ENC_OBS_SELECT_1:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_1:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_1:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_1:RW:0:3:=0x00
+	{	0x00000493, 0x00000000}, // PHY_FIFO_PTR_OBS_SELECT_1:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_1:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_1:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_1:RW:0:4:=0x00
+	{	0x00000494, 0x04080000}, // PHY_WRLVL_UPDT_WAIT_CNT_1:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_1:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_1:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_1:RW:0:1:=0x00
+	{	0x00000495, 0x04080a04}, // PHY_RDLVL_UPDT_WAIT_CNT_1:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_1:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_1:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_1:RW:0:6:=0x00
+	{	0x00000496, 0x00000000}, // PHY_RDLVL_DATA_MASK_1:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_1:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_1:RW:0:2:=0x00
+	{	0x00000497, 0x32103210}, // PHY_RDLVL_DATA_SWIZZLE_1:RW:0:32:=0x32103210
+	{	0x00000498, 0x00C00208}, // PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_1:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_1:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_1:RW:0:6:=0x08
+	{	0x00000499, 0x0001000C}, // PHY_WDQLVL_CLR_PREV_RESULTS_1:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_1:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_1:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_1:RW:0:4:=0x0c
+	{	0x0000049A, 0x00000100}, // PHY_WDQLVL_DATADM_MASK_1:RW:0:9:=0x0100
+	{	0x0000049B, 0x55555555}, // PHY_USER_PATT0_1:RW:0:32:=0x55555555
+	{	0x0000049C, 0xAAAAAAAA}, // PHY_USER_PATT1_1:RW:0:32:=0xAAAAAAAA
+	{	0x0000049D, 0x55555555}, // PHY_USER_PATT2_1:RW:0:32:=0x55555555
+	{	0x0000049E, 0xAAAAAAAA}, // PHY_USER_PATT3_1:RW:0:32:=0xAAAAAAAA
+	{	0x0000049F, 0x00005555}, // PHY_USER_PATT4_1:RW:0:16:=0x5555
+	{	0x000004A0, 0x76543210}, // PHY_DQ_SWIZZLING_1:RW:0:32:=0x76543210
+	{	0x000004A1, 0x00000000}, // PHY_FIFO_PTR_OBS_1:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_1:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_1:RW:0:1:=0x00
+	{	0x000004A2, 0x00000000}, // PHY_LPBK_RESULT_OBS_1:RD:0:32:=0x00000000
+	{	0x000004A3, 0x00000000}, // PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_1:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_1:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_1:RD:0:10:=0x0000
+	{	0x000004A4, 0x00000000}, // PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_1:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_1:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_1:RD:0:8:=0x00
+	{	0x000004A5, 0x00000000}, // PHY_WR_SHIFT_OBS_1:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_1:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_1:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_1:RD:0:7:=0x00
+	{	0x000004A6, 0x00000000}, // PHY_WRLVL_HARD1_DELAY_OBS_1:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_1:RD:0:10:=0x0000
+	{	0x000004A7, 0x00000000}, // PHY_WRLVL_STATUS_OBS_1:RD:0:17:=0x000000
+	{	0x000004A8, 0x00000000}, // PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_1:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_1:RD:0:9:=0x0000
+	{	0x000004A9, 0x00000000}, // PHY_GTLVL_HARD0_DELAY_OBS_1:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_1:RD:0:16:=0x0000
+	{	0x000004AA, 0x00000000}, // PHY_GTLVL_STATUS_OBS_1:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_1:RD:0:14:=0x0000
+	{	0x000004AB, 0x00000000}, // PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_1:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_1:RD:0:10:=0x0000
+	{	0x000004AC, 0x00000000}, // PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_1:RD:0:2:=0x00
+	{	0x000004AD, 0x00000000}, // PHY_RDLVL_STATUS_OBS_1:RD:0:32:=0x00000000
+	{	0x000004AE, 0x00000000}, // PHY_WDQLVL_DQDM_TE_DLY_OBS_1:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_1:RD:0:11:=0x0000
+	{	0x000004AF, 0x00000000}, // PHY_WDQLVL_STATUS_OBS_1:RD:0:32:=0x00000000
+	{	0x000004B0, 0x00000000}, // PHY_DDL_MODE_1:RW:0:18:=0x000000
+	{	0x000004B1, 0x00000000}, // PHY_DDL_TEST_OBS_1:RD:0:32:=0x00000000
+	{	0x000004B2, 0x00000000}, // PHY_DDL_TEST_MSTR_DLY_OBS_1:RD:0:32:=0x00000000
+	{	0x000004B3, 0x00200000}, // PHY_RX_CAL_SAMPLE_WAIT_1:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_1:RW:8:1:=0x00 SC_PHY_RX_CAL_START_1:WR:0:1:=0x00
+	{	0x000004B4, 0x00000000}, // PHY_RX_CAL_DQ1_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_1:RW+:0:12:=0x0000
+	{	0x000004B5, 0x00000000}, // PHY_RX_CAL_DQ3_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_1:RW+:0:12:=0x0000
+	{	0x000004B6, 0x00000000}, // PHY_RX_CAL_DQ5_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_1:RW+:0:12:=0x0000
+	{	0x000004B7, 0x00000000}, // PHY_RX_CAL_DQ7_1:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_1:RW+:0:12:=0x0000
+	{	0x000004B8, 0x00000000}, // PHY_RX_CAL_DQS_1:RW+:16:12:=0x0000 PHY_RX_CAL_DM_1:RW+:0:12:=0x0000
+	{	0x000004B9, 0x00000000}, // PHY_RX_CAL_OBS_1:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_1:RW+:0:12:=0x0000
+	{	0x000004BA, 0x02800280}, // PHY_CLK_WRDQ1_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_1:RW+:0:11:=0x0280
+	{	0x000004BB, 0x02800280}, // PHY_CLK_WRDQ3_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_1:RW+:0:11:=0x0280
+	{	0x000004BC, 0x02800280}, // PHY_CLK_WRDQ5_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_1:RW+:0:11:=0x0280
+	{	0x000004BD, 0x02800280}, // PHY_CLK_WRDQ7_SLAVE_DELAY_1:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_1:RW+:0:11:=0x0280
+	{	0x000004BE, 0x00000280}, // PHY_CLK_WRDQS_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_1:RW+:0:11:=0x0280
+	{	0x000004BF, 0x00000000}, // PHY_RDDQ1_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_1:RW+:0:10:=0x0000
+	{	0x000004C0, 0x00000000}, // PHY_RDDQ3_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_1:RW+:0:10:=0x0000
+	{	0x000004C1, 0x00000000}, // PHY_RDDQ5_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_1:RW+:0:10:=0x0000
+	{	0x000004C2, 0x00000000}, // PHY_RDDQ7_SLAVE_DELAY_1:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_1:RW+:0:10:=0x0000
+	{	0x000004C3, 0x00A000A0}, // PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0
+	{	0x000004C4, 0x00A000A0}, // PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0
+	{	0x000004C5, 0x00A000A0}, // PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0
+	{	0x000004C6, 0x00A000A0}, // PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0
+	{	0x000004C7, 0x00A000A0}, // PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0
+	{	0x000004C8, 0x00A000A0}, // PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0
+	{	0x000004C9, 0x00A000A0}, // PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0
+	{	0x000004CA, 0x00A000A0}, // PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0
+	{	0x000004CB, 0x00A000A0}, // PHY_RDDQS_DM_FALL_SLAVE_DELAY_1:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_1:RW+:0:10:=0x00a0
+	{	0x000004CC, 0x00040109}, // PHY_WRITE_PATH_LAT_ADD_1:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_1:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_1:RW+:0:10:=0x0109
+	{	0x000004CD, 0x000001D0}, // PHY_WRLVL_DELAY_PERIOD_THRESHOLD_1:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_1:RW+:0:10:=0x01d0
+	{	0x000004CE, 0x03000000}, // PHY_GTLVL_LAT_ADJ_START_1:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_1:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_1:RW+:0:1:=0x00
+	{	0x000004CF, 0x00000200}, // PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_1:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_1:RW+:0:11:=0x0200
+//	{	0x000004D0, 0x41315141}, // PHY_DQS_OE_TIMING_1:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_1:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_1:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_1:RW+:0:8:=0x41
+	{	0x000004D0, 0x41415141}, // PHY_DQS_OE_TIMING_1:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_1:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_1:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_1:RW+:0:8:=0x41
+//	{	0x000004D1, 0xC0013150}, // PHY_DQ_IE_TIMING_1:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_1:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_1:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_1:RW+:0:8:=0x50
+	{	0x000004D1, 0xC0014150}, // PHY_DQ_IE_TIMING_1:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_1:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_1:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_1:RW+:0:8:=0x50
+	{	0x000004D2, 0x0E0000C0}, // PHY_RDDATA_EN_DLY_1:RW+:24:4:=0x0e PHY_IE_MODE_1:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_1:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_1:RW+:0:8:=0xc0
+	{	0x000004D3, 0x0010000C}, // PHY_MASTER_DELAY_START_1:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_1:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_1:RW+:0:4:=0x0c
+	{	0x000004D4, 0x0C064208}, // PHY_WRLVL_DLY_STEP_1:RW+:24:4:=0x0c PHY_RPTR_UPDATE_1:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_1:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_1:RW+:0:6:=0x08
+	{	0x000004D5, 0x000F0C18}, // PHY_GTLVL_RESP_WAIT_CNT_1:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_1:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_1:RW+:0:5:=0x18
+	{	0x000004D6, 0x01000140}, // PHY_GTLVL_FINAL_STEP_1:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_1:RW+:0:10:=0x0140
+	{	0x000004D7, 0x00000C20}, // PHY_RDLVL_DLY_STEP_1:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_1:RW+:0:8:=0x20
+	{	0x000004D8, 0x00000000}, //
+	{	0x000004D9, 0x00000000}, //
+	{	0x000004DA, 0x00000000}, //
+	{	0x000004DB, 0x00000000}, //
+	{	0x000004DC, 0x00000000}, //
+	{	0x000004DD, 0x00000000}, //
+	{	0x000004DE, 0x00000000}, //
+	{	0x000004DF, 0x00000000}, //
+	{	0x000004E0, 0x00000000}, //
+	{	0x000004E1, 0x00000000}, //
+	{	0x000004E2, 0x00000000}, //
+	{	0x000004E3, 0x00000000}, //
+	{	0x000004E4, 0x00000000}, //
+	{	0x000004E5, 0x00000000}, //
+	{	0x000004E6, 0x00000000}, //
+	{	0x000004E7, 0x00000000}, //
+	{	0x000004E8, 0x00000000}, //
+	{	0x000004E9, 0x00000000}, //
+	{	0x000004EA, 0x00000000}, //
+	{	0x000004EB, 0x00000000}, //
+	{	0x000004EC, 0x00000000}, //
+	{	0x000004ED, 0x00000000}, //
+	{	0x000004EE, 0x00000000}, //
+	{	0x000004EF, 0x00000000}, //
+	{	0x000004F0, 0x00000000}, //
+	{	0x000004F1, 0x00000000}, //
+	{	0x000004F2, 0x00000000}, //
+	{	0x000004F3, 0x00000000}, //
+	{	0x000004F4, 0x00000000}, //
+	{	0x000004F5, 0x00000000}, //
+	{	0x000004F6, 0x00000000}, //
+	{	0x000004F7, 0x00000000}, //
+	{	0x000004F8, 0x00000000}, //
+	{	0x000004F9, 0x00000000}, //
+	{	0x000004FA, 0x00000000}, //
+	{	0x000004FB, 0x00000000}, //
+	{	0x000004FC, 0x00000000}, //
+	{	0x000004FD, 0x00000000}, //
+	{	0x000004FE, 0x00000000}, //
+	{	0x000004FF, 0x00000000}, //
+	{	0x00000500, 0x000004F0}, // PHY_SW_WRDQ0_SHIFT_2:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_2:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_2:RW:0:11:=0x04f0
+	{	0x00000501, 0x00000000}, // PHY_SW_WRDQ4_SHIFT_2:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_2:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_2:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_2:RW:0:5:=0x00
+	{	0x00000502, 0x00000000}, // PHY_SW_WRDM_SHIFT_2:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_2:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_2:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_2:RW:0:5:=0x00
+//	{	0x00000503, 0x00000100}, // PHY_DQ_TSEL_ENABLE_2:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_2:RW:0:4:=0x00
+	{	0x00000503, 0x00000300}, // PHY_DQ_TSEL_ENABLE_2:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_2:RW:0:4:=0x00
+//	{	0x00000504, 0x01CC6E0C}, // PHY_DQS_TSEL_ENABLE_2:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_2:RW:0:24:=0x665555
+	{	0x00000504, 0x030E6E0E}, // PHY_DQS_TSEL_ENABLE_2:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_2:RW:0:24:=0x665555
+//	{	0x00000504, 0x036E6E0E}, // PHY_DQS_TSEL_ENABLE_2:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_2:RW:0:24:=0x665555
+//	{	0x00000505, 0x02CC6E0C}, // PHY_TWO_CYC_PREAMBLE_2:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_2:RW:0:24:=0x665555
+	{	0x00000505, 0x020E6E0E}, // PHY_TWO_CYC_PREAMBLE_2:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_2:RW:0:24:=0x665555
+//	{	0x00000505, 0x026E6E0E}, // PHY_TWO_CYC_PREAMBLE_2:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_2:RW:0:24:=0x665555
+	{	0x00000506, 0x00010F00}, // PHY_PER_CS_TRAINING_INDEX_2:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_2:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_2:RW:8:2:=0x0f PHY_DBI_MODE_2:RW:0:1:=0x00
+	{	0x00000507, 0x04000100}, // PHY_LP4_BOOT_RPTR_UPDATE_2:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_2:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_2:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_2:RW:0:2:=0x00
+	{	0x00000508, 0x00000133}, // PHY_LPBK_CONTROL_2:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_2:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_2:RW:0:10:=0x0133
+	{	0x00000509, 0x000700C0}, // SC_PHY_SNAP_OBS_REGS_2:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_2:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_2:RW:0:10:=0x00c0
+	{	0x0000050A, 0x00CC0201}, // PHY_GATE_SMPL1_SLAVE_DELAY_2:RW:16:9:=0x00cc PHY_LPDDR_TYPE_2:RW:8:2:=0x02 PHY_LPDDR_2:RW:0:1:=0x01
+	{	0x0000050B, 0x00030066}, // ON_FLY_GATE_ADJUST_EN_2:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_2:RW:0:9:=0x0066
+	{	0x0000050C, 0x00000000}, // PHY_GATE_TRACKING_OBS_2:RD:0:32:=0x00000000
+	{	0x0000050D, 0x00000000}, // PHY_LP4_PST_AMBLE_2:RW:0:1:=0x00
+	{	0x0000050E, 0x00000000}, // PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000
+	{	0x0000050F, 0x00000000}, // PHY_LP4_RDLVL_PATT9_2:RW:0:32:=0x00000000
+	{	0x00000510, 0x00000000}, // PHY_LP4_RDLVL_PATT10_2:RW:0:32:=0x00000000
+	{	0x00000511, 0x00000000}, // PHY_LP4_RDLVL_PATT11_2:RW:0:32:=0x00000000
+	{	0x00000512, 0x00000000}, // PHY_RDDQ_ENC_OBS_SELECT_2:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_2:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_2:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_2:RW:0:3:=0x00
+	{	0x00000513, 0x00000000}, // PHY_FIFO_PTR_OBS_SELECT_2:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_2:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_2:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_2:RW:0:4:=0x00
+	{	0x00000514, 0x04080000}, // PHY_WRLVL_UPDT_WAIT_CNT_2:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_2:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_2:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_2:RW:0:1:=0x00
+	{	0x00000515, 0x04080a04}, // PHY_RDLVL_UPDT_WAIT_CNT_2:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_2:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_2:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_2:RW:0:6:=0x00
+	{	0x00000516, 0x00000000}, // PHY_RDLVL_DATA_MASK_2:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_2:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_2:RW:0:2:=0x00
+	{	0x00000517, 0x32103210}, // PHY_RDLVL_DATA_SWIZZLE_2:RW:0:32:=0x32103210
+	{	0x00000518, 0x00C00208}, // PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_2:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_2:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_2:RW:0:6:=0x08
+	{	0x00000519, 0x0001000C}, // PHY_WDQLVL_CLR_PREV_RESULTS_2:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_2:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_2:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_2:RW:0:4:=0x0c
+	{	0x0000051A, 0x00000100}, // PHY_WDQLVL_DATADM_MASK_2:RW:0:9:=0x0100
+	{	0x0000051B, 0x55555555}, // PHY_USER_PATT0_2:RW:0:32:=0x55555555
+	{	0x0000051C, 0xAAAAAAAA}, // PHY_USER_PATT1_2:RW:0:32:=0xAAAAAAAA
+	{	0x0000051D, 0x55555555}, // PHY_USER_PATT2_2:RW:0:32:=0x55555555
+	{	0x0000051E, 0xAAAAAAAA}, // PHY_USER_PATT3_2:RW:0:32:=0xAAAAAAAA
+	{	0x0000051F, 0x00005555}, // PHY_USER_PATT4_2:RW:0:16:=0x5555
+	{	0x00000520, 0x76543210}, // PHY_DQ_SWIZZLING_2:RW:0:32:=0x76543210
+	{	0x00000521, 0x00000001}, // PHY_FIFO_PTR_OBS_2:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_2:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_2:RW:0:1:=0x01
+	{	0x00000522, 0x00000000}, // PHY_LPBK_RESULT_OBS_2:RD:0:32:=0x00000000
+	{	0x00000523, 0x00000000}, // PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_2:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_2:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_2:RD:0:10:=0x0000
+	{	0x00000524, 0x00000000}, // PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_2:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_2:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_2:RD:0:8:=0x00
+	{	0x00000525, 0x00000000}, // PHY_WR_SHIFT_OBS_2:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_2:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_2:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_2:RD:0:7:=0x00
+	{	0x00000526, 0x00000000}, // PHY_WRLVL_HARD1_DELAY_OBS_2:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_2:RD:0:10:=0x0000
+	{	0x00000527, 0x00000000}, // PHY_WRLVL_STATUS_OBS_2:RD:0:17:=0x000000
+	{	0x00000528, 0x00000000}, // PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_2:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_2:RD:0:9:=0x0000
+	{	0x00000529, 0x00000000}, // PHY_GTLVL_HARD0_DELAY_OBS_2:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_2:RD:0:16:=0x0000
+	{	0x0000052A, 0x00000000}, // PHY_GTLVL_STATUS_OBS_2:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_2:RD:0:14:=0x0000
+	{	0x0000052B, 0x00000000}, // PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_2:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_2:RD:0:10:=0x0000
+	{	0x0000052C, 0x00000000}, // PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_2:RD:0:2:=0x00
+	{	0x0000052D, 0x00000000}, // PHY_RDLVL_STATUS_OBS_2:RD:0:32:=0x00000000
+	{	0x0000052E, 0x00000000}, // PHY_WDQLVL_DQDM_TE_DLY_OBS_2:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_2:RD:0:11:=0x0000
+	{	0x0000052F, 0x00000000}, // PHY_WDQLVL_STATUS_OBS_2:RD:0:32:=0x00000000
+	{	0x00000530, 0x00000000}, // PHY_DDL_MODE_2:RW:0:18:=0x000000
+	{	0x00000531, 0x00000000}, // PHY_DDL_TEST_OBS_2:RD:0:32:=0x00000000
+	{	0x00000532, 0x00000000}, // PHY_DDL_TEST_MSTR_DLY_OBS_2:RD:0:32:=0x00000000
+	{	0x00000533, 0x00200000}, // PHY_RX_CAL_SAMPLE_WAIT_2:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_2:RW:8:1:=0x00 SC_PHY_RX_CAL_START_2:WR:0:1:=0x00
+	{	0x00000534, 0x00000000}, // PHY_RX_CAL_DQ1_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_2:RW+:0:12:=0x0000
+	{	0x00000535, 0x00000000}, // PHY_RX_CAL_DQ3_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_2:RW+:0:12:=0x0000
+	{	0x00000536, 0x00000000}, // PHY_RX_CAL_DQ5_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_2:RW+:0:12:=0x0000
+	{	0x00000537, 0x00000000}, // PHY_RX_CAL_DQ7_2:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_2:RW+:0:12:=0x0000
+	{	0x00000538, 0x00000000}, // PHY_RX_CAL_DQS_2:RW+:16:12:=0x0000 PHY_RX_CAL_DM_2:RW+:0:12:=0x0000
+	{	0x00000539, 0x00000000}, // PHY_RX_CAL_OBS_2:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_2:RW+:0:12:=0x0000
+	{	0x0000053A, 0x02800280}, // PHY_CLK_WRDQ1_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_2:RW+:0:11:=0x0280
+	{	0x0000053B, 0x02800280}, // PHY_CLK_WRDQ3_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_2:RW+:0:11:=0x0280
+	{	0x0000053C, 0x02800280}, // PHY_CLK_WRDQ5_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_2:RW+:0:11:=0x0280
+	{	0x0000053D, 0x02800280}, // PHY_CLK_WRDQ7_SLAVE_DELAY_2:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_2:RW+:0:11:=0x0280
+	{	0x0000053E, 0x00000280}, // PHY_CLK_WRDQS_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_2:RW+:0:11:=0x0280
+	{	0x0000053F, 0x00000000}, // PHY_RDDQ1_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_2:RW+:0:10:=0x0000
+	{	0x00000540, 0x00000000}, // PHY_RDDQ3_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_2:RW+:0:10:=0x0000
+	{	0x00000541, 0x00000000}, // PHY_RDDQ5_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_2:RW+:0:10:=0x0000
+	{	0x00000542, 0x00000000}, // PHY_RDDQ7_SLAVE_DELAY_2:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_2:RW+:0:10:=0x0000
+	{	0x00000543, 0x00A000A0}, // PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0
+	{	0x00000544, 0x00A000A0}, // PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0
+	{	0x00000545, 0x00A000A0}, // PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0
+	{	0x00000546, 0x00A000A0}, // PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0
+	{	0x00000547, 0x00A000A0}, // PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0
+	{	0x00000548, 0x00A000A0}, // PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0
+	{	0x00000549, 0x00A000A0}, // PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0
+	{	0x0000054A, 0x00A000A0}, // PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0
+	{	0x0000054B, 0x00A000A0}, // PHY_RDDQS_DM_FALL_SLAVE_DELAY_2:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_2:RW+:0:10:=0x00a0
+	{	0x0000054C, 0x00040109}, // PHY_WRITE_PATH_LAT_ADD_2:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_2:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_2:RW+:0:10:=0x0109
+	{	0x0000054D, 0x000001D0}, // PHY_WRLVL_DELAY_PERIOD_THRESHOLD_2:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_2:RW+:0:10:=0x01d0
+	{	0x0000054E, 0x03000000}, // PHY_GTLVL_LAT_ADJ_START_2:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_2:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_2:RW+:0:1:=0x00
+	{	0x0000054F, 0x00000200}, // PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_2:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_2:RW+:0:11:=0x0200
+//	{	0x00000550, 0x41315141}, // PHY_DQS_OE_TIMING_2:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_2:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_2:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_2:RW+:0:8:=0x41
+	{	0x00000550, 0x41415141}, // PHY_DQS_OE_TIMING_2:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_2:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_2:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_2:RW+:0:8:=0x41
+//	{	0x00000551, 0xC0013150}, // PHY_DQ_IE_TIMING_2:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_2:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_2:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_2:RW+:0:8:=0x50
+	{	0x00000551, 0xC0014150}, // PHY_DQ_IE_TIMING_2:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_2:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_2:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_2:RW+:0:8:=0x50
+	{	0x00000552, 0x0E0000C0}, // PHY_RDDATA_EN_DLY_2:RW+:24:4:=0x0e PHY_IE_MODE_2:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_2:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_2:RW+:0:8:=0xc0
+	{	0x00000553, 0x0010000C}, // PHY_MASTER_DELAY_START_2:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_2:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_2:RW+:0:4:=0x0c
+	{	0x00000554, 0x0C064208}, // PHY_WRLVL_DLY_STEP_2:RW+:24:4:=0x0c PHY_RPTR_UPDATE_2:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_2:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_2:RW+:0:6:=0x08
+	{	0x00000555, 0x000F0C18}, // PHY_GTLVL_RESP_WAIT_CNT_2:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_2:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_2:RW+:0:5:=0x18
+	{	0x00000556, 0x01000140}, // PHY_GTLVL_FINAL_STEP_2:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_2:RW+:0:10:=0x0140
+	{	0x00000557, 0x00000C20}, // PHY_RDLVL_DLY_STEP_2:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_2:RW+:0:8:=0x20
+	{	0x00000558, 0x00000000}, //
+	{	0x00000559, 0x00000000}, //
+	{	0x0000055A, 0x00000000}, //
+	{	0x0000055B, 0x00000000}, //
+	{	0x0000055C, 0x00000000}, //
+	{	0x0000055D, 0x00000000}, //
+	{	0x0000055E, 0x00000000}, //
+	{	0x0000055F, 0x00000000}, //
+	{	0x00000560, 0x00000000}, //
+	{	0x00000561, 0x00000000}, //
+	{	0x00000562, 0x00000000}, //
+	{	0x00000563, 0x00000000}, //
+	{	0x00000564, 0x00000000}, //
+	{	0x00000565, 0x00000000}, //
+	{	0x00000566, 0x00000000}, //
+	{	0x00000567, 0x00000000}, //
+	{	0x00000568, 0x00000000}, //
+	{	0x00000569, 0x00000000}, //
+	{	0x0000056A, 0x00000000}, //
+	{	0x0000056B, 0x00000000}, //
+	{	0x0000056C, 0x00000000}, //
+	{	0x0000056D, 0x00000000}, //
+	{	0x0000056E, 0x00000000}, //
+	{	0x0000056F, 0x00000000}, //
+	{	0x00000570, 0x00000000}, //
+	{	0x00000571, 0x00000000}, //
+	{	0x00000572, 0x00000000}, //
+	{	0x00000573, 0x00000000}, //
+	{	0x00000574, 0x00000000}, //
+	{	0x00000575, 0x00000000}, //
+	{	0x00000576, 0x00000000}, //
+	{	0x00000577, 0x00000000}, //
+	{	0x00000578, 0x00000000}, //
+	{	0x00000579, 0x00000000}, //
+	{	0x0000057A, 0x00000000}, //
+	{	0x0000057B, 0x00000000}, //
+	{	0x0000057C, 0x00000000}, //
+	{	0x0000057D, 0x00000000}, //
+	{	0x0000057E, 0x00000000}, //
+	{	0x0000057F, 0x00000000}, //
+	{	0x00000580, 0x000004F0}, // PHY_SW_WRDQ0_SHIFT_3:RW:24:5:=0x00 PHY_CLK_BYPASS_OVERRIDE_3:RW:16:1:=0x00 PHY_CLK_WR_BYPASS_SLAVE_DELAY_3:RW:0:11:=0x04f0
+	{	0x00000581, 0x00000000}, // PHY_SW_WRDQ4_SHIFT_3:RW:24:5:=0x00 PHY_SW_WRDQ3_SHIFT_3:RW:16:5:=0x00 PHY_SW_WRDQ2_SHIFT_3:RW:8:5:=0x00 PHY_SW_WRDQ1_SHIFT_3:RW:0:5:=0x00
+	{	0x00000582, 0x00000000}, // PHY_SW_WRDM_SHIFT_3:RW:24:5:=0x00 PHY_SW_WRDQ7_SHIFT_3:RW:16:5:=0x00 PHY_SW_WRDQ6_SHIFT_3:RW:8:5:=0x00 PHY_SW_WRDQ5_SHIFT_3:RW:0:5:=0x00
+//	{	0x00000583, 0x00000100}, // PHY_DQ_TSEL_ENABLE_3:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_3:RW:0:4:=0x00
+	{	0x00000583, 0x00000300}, // PHY_DQ_TSEL_ENABLE_3:RW:8:3:=0x01 PHY_SW_WRDQS_SHIFT_3:RW:0:4:=0x00
+//	{	0x00000584, 0x01CC6E0C}, // PHY_DQS_TSEL_ENABLE_3:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_3:RW:0:24:=0x665555
+	{	0x00000584, 0x030E6E0E}, // PHY_DQS_TSEL_ENABLE_3:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_3:RW:0:24:=0x665555
+//	{	0x00000584, 0x036E6E0E}, // PHY_DQS_TSEL_ENABLE_3:RW:24:3:=0x01 PHY_DQ_TSEL_SELECT_3:RW:0:24:=0x665555
+//	{	0x00000585, 0x02CC6E0C}, // PHY_TWO_CYC_PREAMBLE_3:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_3:RW:0:24:=0x665555
+	{	0x00000585, 0x020E6E0E}, // PHY_TWO_CYC_PREAMBLE_3:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_3:RW:0:24:=0x665555
+//	{	0x00000585, 0x026E6E0E}, // PHY_TWO_CYC_PREAMBLE_3:RW:24:2:=0x02 PHY_DQS_TSEL_SELECT_3:RW:0:24:=0x665555
+	{	0x00000586, 0x00010F00}, // PHY_PER_CS_TRAINING_INDEX_3:RW:24:1:=0x00 PHY_PER_CS_TRAINING_MULTICAST_EN_3:RW_D:16:1:=0x01 PHY_PER_RANK_CS_MAP_3:RW:8:2:=0x0f PHY_DBI_MODE_3:RW:0:1:=0x00
+	{	0x00000587, 0x04000100}, // PHY_LP4_BOOT_RPTR_UPDATE_3:RW:24:4:=0x04 PHY_LP4_BOOT_RDDATA_EN_TSEL_DLY_3:RW:16:4:=0x00 PHY_LP4_BOOT_RDDATA_EN_DLY_3:RW:8:4:=0x01 PHY_LP4_BOOT_RDDATA_EN_IE_DLY_3:RW:0:2:=0x00
+	{	0x00000588, 0x00000133}, // PHY_LPBK_CONTROL_3:RW:24:7:=0x00 PHY_LP4_BOOT_RDDQS_LATENCY_ADJUST_3:RW:16:4:=0x00 PHY_LP4_BOOT_RDDQS_GATE_SLAVE_DELAY_3:RW:0:10:=0x0133
+	{	0x00000589, 0x000700C0}, // SC_PHY_SNAP_OBS_REGS_3:WR:24:1:=0x00 PHY_GATE_ERROR_DELAY_SELECT_3:RW:16:4:=0x07 PHY_RDDQS_DQ_BYPASS_SLAVE_DELAY_3:RW:0:10:=0x00c0
+	{	0x0000058A, 0x00CC0201}, // PHY_GATE_SMPL1_SLAVE_DELAY_3:RW:16:9:=0x00cc PHY_LPDDR_TYPE_3:RW:8:2:=0x02 PHY_LPDDR_3:RW:0:1:=0x01
+	{	0x0000058B, 0x00030066}, // ON_FLY_GATE_ADJUST_EN_3:RW:16:2:=0x03 PHY_GATE_SMPL2_SLAVE_DELAY_3:RW:0:9:=0x0066
+	{	0x0000058C, 0x00000000}, // PHY_GATE_TRACKING_OBS_3:RD:0:32:=0x00000000
+	{	0x0000058D, 0x00000000}, // PHY_LP4_PST_AMBLE_3:RW:0:1:=0x00
+	{	0x0000058E, 0x00000000}, // PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000
+	{	0x0000058F, 0x00000000}, // PHY_LP4_RDLVL_PATT9_3:RW:0:32:=0x00000000
+	{	0x00000590, 0x00000000}, // PHY_LP4_RDLVL_PATT10_3:RW:0:32:=0x00000000
+	{	0x00000591, 0x00000000}, // PHY_LP4_RDLVL_PATT11_3:RW:0:32:=0x00000000
+	{	0x00000592, 0x00000000}, // PHY_RDDQ_ENC_OBS_SELECT_3:RW:24:3:=0x00 PHY_MASTER_DLY_LOCK_OBS_SELECT_3:RW:16:3:=0x00 PHY_SW_FIFO_PTR_RST_DISABLE_3:RW:8:1:=0x00 PHY_SLAVE_LOOP_CNT_UPDATE_3:RW:0:3:=0x00
+	{	0x00000593, 0x00000000}, // PHY_FIFO_PTR_OBS_SELECT_3:RW:24:4:=0x00 PHY_WR_SHIFT_OBS_SELECT_3:RW:16:4:=0x00 PHY_WR_ENC_OBS_SELECT_3:RW:8:4:=0x00 PHY_RDDQS_DQ_ENC_OBS_SELECT_3:RW:0:4:=0x00
+	{	0x00000594, 0x04080000}, // PHY_WRLVL_UPDT_WAIT_CNT_3:RW:24:4:=0x04 PHY_WRLVL_CAPTURE_CNT_3:RW:16:6:=0x08 SC_PHY_LVL_DEBUG_CONT_3:WR:8:1:=0x00 PHY_LVL_DEBUG_MODE_3:RW:0:1:=0x00
+	{	0x00000595, 0x04080a04}, // PHY_RDLVL_UPDT_WAIT_CNT_3:RW:24:4:=0x04 PHY_RDLVL_CAPTURE_CNT_3:RW:16:6:=0x08 PHY_GTLVL_UPDT_WAIT_CNT_3:RW:8:4:=0x04 PHY_GTLVL_CAPTURE_CNT_3:RW:0:6:=0x00
+	{	0x00000596, 0x00000000}, // PHY_RDLVL_DATA_MASK_3:RW:16:8:=0x00 PHY_RDLVL_RDDQS_DQ_OBS_SELECT_3:RW:8:5:=0x00 PHY_RDLVL_OP_MODE_3:RW:0:2:=0x00
+	{	0x00000597, 0x32103210}, // PHY_RDLVL_DATA_SWIZZLE_3:RW:0:32:=0x32103210
+	{	0x00000598, 0x00C00208}, // PHY_WDQLVL_DQDM_SLV_DLY_JUMP_OFFSET_3:RW:16:11:=0x00C0 PHY_WDQLVL_PATT_3:RW:8:3:=0x07 PHY_WDQLVL_BURST_CNT_3:RW:0:6:=0x08
+	{	0x00000599, 0x0001000C}, // PHY_WDQLVL_CLR_PREV_RESULTS_3:WR:24:1:=0x00 PHY_WDQLVL_QTR_DLY_STEP_3:RW:16:4:=0x01 PHY_WDQLVL_DQDM_OBS_SELECT_3:RW:8:4:=0x00 PHY_WDQLVL_UPDT_WAIT_CNT_3:RW:0:4:=0x0c
+	{	0x0000059A, 0x00000100}, // PHY_WDQLVL_DATADM_MASK_3:RW:0:9:=0x0100
+	{	0x0000059B, 0x55555555}, // PHY_USER_PATT0_3:RW:0:32:=0x55555555
+	{	0x0000059C, 0xAAAAAAAA}, // PHY_USER_PATT1_3:RW:0:32:=0xAAAAAAAA
+	{	0x0000059D, 0x55555555}, // PHY_USER_PATT2_3:RW:0:32:=0x55555555
+	{	0x0000059E, 0xAAAAAAAA}, // PHY_USER_PATT3_3:RW:0:32:=0xAAAAAAAA
+	{	0x0000059F, 0x00005555}, // PHY_USER_PATT4_3:RW:0:16:=0x5555
+	{	0x000005A0, 0x76543210}, // PHY_DQ_SWIZZLING_3:RW:0:32:=0x76543210
+	{	0x000005A1, 0x00000000}, // PHY_FIFO_PTR_OBS_3:RD:16:8:=0x00 SC_PHY_MANUAL_CLEAR_3:WR:8:6:=0x00 PHY_CALVL_VREF_DRIVING_SLICE_3:RW:0:1:=0x00
+	{	0x000005A2, 0x00000000}, // PHY_LPBK_RESULT_OBS_3:RD:0:32:=0x00000000
+	{	0x000005A3, 0x00000000}, // PHY_RDDQS_BASE_SLV_DLY_ENC_OBS_3:RD:24:7:=0x00 PHY_RDDQ_SLV_DLY_ENC_OBS_3:RD:16:6:=0x00 PHY_MASTER_DLY_LOCK_OBS_3:RD:0:10:=0x0000
+	{	0x000005A4, 0x00000000}, // PHY_RDDQS_GATE_SLV_DLY_ENC_OBS_3:RD:16:10:=0x0000 PHY_RDDQS_DQ_FALL_ADDER_SLV_DLY_ENC_OBS_3:RD:8:8:=0x00 PHY_RDDQS_DQ_RISE_ADDER_SLV_DLY_ENC_OBS_3:RD:0:8:=0x00
+	{	0x000005A5, 0x00000000}, // PHY_WR_SHIFT_OBS_3:RD:24:3:=0x00 PHY_WR_ADDER_SLV_DLY_ENC_OBS_3:RD:16:8:=0x00 PHY_WRDQ_BASE_SLV_DLY_ENC_OBS_3:RD:8:8:=0x00 PHY_WRDQS_BASE_SLV_DLY_ENC_OBS_3:RD:0:7:=0x00
+	{	0x000005A6, 0x00000000}, // PHY_WRLVL_HARD1_DELAY_OBS_3:RD:16:10:=0x0000 PHY_WRLVL_HARD0_DELAY_OBS_3:RD:0:10:=0x0000
+	{	0x000005A7, 0x00000000}, // PHY_WRLVL_STATUS_OBS_3:RD:0:17:=0x000000
+	{	0x000005A8, 0x00000000}, // PHY_GATE_SMPL2_SLV_DLY_ENC_OBS_3:RD:16:9:=0x0000 PHY_GATE_SMPL1_SLV_DLY_ENC_OBS_3:RD:0:9:=0x0000
+	{	0x000005A9, 0x00000000}, // PHY_GTLVL_HARD0_DELAY_OBS_3:RD:16:14:=0x0000 PHY_WRLVL_ERROR_OBS_3:RD:0:16:=0x0000
+	{	0x000005AA, 0x00000000}, // PHY_GTLVL_STATUS_OBS_3:RD:16:12:=0x0000 PHY_GTLVL_HARD1_DELAY_OBS_3:RD:0:14:=0x0000
+	{	0x000005AB, 0x00000000}, // PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS_3:RD:16:10:=0x0000 PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS_3:RD:0:10:=0x0000
+	{	0x000005AC, 0x00000000}, // PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS_3:RD:0:2:=0x00
+	{	0x000005AD, 0x00000000}, // PHY_RDLVL_STATUS_OBS_3:RD:0:32:=0x00000000
+	{	0x000005AE, 0x00000000}, // PHY_WDQLVL_DQDM_TE_DLY_OBS_3:RD:16:11:=0x0000 PHY_WDQLVL_DQDM_LE_DLY_OBS_3:RD:0:11:=0x0000
+	{	0x000005AF, 0x00000000}, // PHY_WDQLVL_STATUS_OBS_3:RD:0:32:=0x00000000
+	{	0x000005B0, 0x00000000}, // PHY_DDL_MODE_3:RW:0:18:=0x000000
+	{	0x000005B1, 0x00000000}, // PHY_DDL_TEST_OBS_3:RD:0:32:=0x00000000
+	{	0x000005B2, 0x00000000}, // PHY_DDL_TEST_MSTR_DLY_OBS_3:RD:0:32:=0x00000000
+	{	0x000005B3, 0x00200000}, // PHY_RX_CAL_SAMPLE_WAIT_3:RW:16:8:=0x20 PHY_RX_CAL_OVERRIDE_3:RW:8:1:=0x00 SC_PHY_RX_CAL_START_3:WR:0:1:=0x00
+	{	0x000005B4, 0x00000000}, // PHY_RX_CAL_DQ1_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ0_3:RW+:0:12:=0x0000
+	{	0x000005B5, 0x00000000}, // PHY_RX_CAL_DQ3_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ2_3:RW+:0:12:=0x0000
+	{	0x000005B6, 0x00000000}, // PHY_RX_CAL_DQ5_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ4_3:RW+:0:12:=0x0000
+	{	0x000005B7, 0x00000000}, // PHY_RX_CAL_DQ7_3:RW+:16:12:=0x0000 PHY_RX_CAL_DQ6_3:RW+:0:12:=0x0000
+	{	0x000005B8, 0x00000000}, // PHY_RX_CAL_DQS_3:RW+:16:12:=0x0000 PHY_RX_CAL_DM_3:RW+:0:12:=0x0000
+	{	0x000005B9, 0x00000000}, // PHY_RX_CAL_OBS_3:RD:16:11:=0x0000 PHY_RX_CAL_FDBK_3:RW+:0:12:=0x0000
+
+	{	0x000005BA, 0x02800280}, // PHY_CLK_WRDQ1_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ0_SLAVE_DELAY_3:RW+:0:11:=0x0280
+	{	0x000005BB, 0x02800280}, // PHY_CLK_WRDQ3_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ2_SLAVE_DELAY_3:RW+:0:11:=0x0280
+	{	0x000005BC, 0x02800280}, // PHY_CLK_WRDQ5_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ4_SLAVE_DELAY_3:RW+:0:11:=0x0280
+	{	0x000005BD, 0x02800280}, // PHY_CLK_WRDQ7_SLAVE_DELAY_3:RW+:16:11:=0x0280 PHY_CLK_WRDQ6_SLAVE_DELAY_3:RW+:0:11:=0x0280
+	{	0x000005BE, 0x00000280}, // PHY_CLK_WRDQS_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_CLK_WRDM_SLAVE_DELAY_3:RW+:0:11:=0x0280
+
+	{	0x000005BF, 0x00000000}, // PHY_RDDQ1_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ0_SLAVE_DELAY_3:RW+:0:10:=0x0000
+	{	0x000005C0, 0x00000000}, // PHY_RDDQ3_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ2_SLAVE_DELAY_3:RW+:0:10:=0x0000
+	{	0x000005C1, 0x00000000}, // PHY_RDDQ5_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ4_SLAVE_DELAY_3:RW+:0:10:=0x0000
+	{	0x000005C2, 0x00000000}, // PHY_RDDQ7_SLAVE_DELAY_3:RW+:16:10:=0x0000 PHY_RDDQ6_SLAVE_DELAY_3:RW+:0:10:=0x0000
+	{	0x000005C3, 0x00A000A0}, // PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0
+	{	0x000005C4, 0x00A000A0}, // PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0
+	{	0x000005C5, 0x00A000A0}, // PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0
+	{	0x000005C6, 0x00A000A0}, // PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0
+	{	0x000005C7, 0x00A000A0}, // PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0
+	{	0x000005C8, 0x00A000A0}, // PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0
+	{	0x000005C9, 0x00A000A0}, // PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0
+	{	0x000005CA, 0x00A000A0}, // PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0
+	{	0x000005CB, 0x00A000A0}, // PHY_RDDQS_DM_FALL_SLAVE_DELAY_3:RW+:16:10:=0x00A0 PHY_RDDQS_DM_RISE_SLAVE_DELAY_3:RW+:0:10:=0x00a0
+	{	0x000005CC, 0x00040109}, // PHY_WRITE_PATH_LAT_ADD_3:RW+:24:3:=0x00 PHY_RDDQS_LATENCY_ADJUST_3:RW+:16:4:=0x04 PHY_RDDQS_GATE_SLAVE_DELAY_3:RW+:0:10:=0x0109
+	{	0x000005CD, 0x000001D0}, // PHY_WRLVL_DELAY_PERIOD_THRESHOLD_3:RW+:16:10:=0x0000 PHY_WRLVL_DELAY_EARLY_THRESHOLD_3:RW+:0:10:=0x01d0
+	{	0x000005CE, 0x03000000}, // PHY_GTLVL_LAT_ADJ_START_3:RW+:24:4:=0x07 PHY_GTLVL_RDDQS_SLV_DLY_START_3:RW+:8:10:=0x0000 PHY_WRLVL_EARLY_FORCE_ZERO_3:RW+:0:1:=0x00
+	{	0x000005CF, 0x00000200}, // PHY_RDLVL_RDDQS_DQ_SLV_DLY_START_3:RW+:16:10:=0x0000 PHY_WDQLVL_DQDM_SLV_DLY_START_3:RW+:0:11:=0x0200
+//	{	0x000005D0, 0x41315141}, // PHY_DQS_OE_TIMING_3:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_3:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_3:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_3:RW+:0:8:=0x41
+	{	0x000005D0, 0x41415141}, // PHY_DQS_OE_TIMING_3:RW+:24:8:=0x41 PHY_DQ_TSEL_WR_TIMING_3:RW+:16:8:=0x31 PHY_DQ_TSEL_RD_TIMING_3:RW+:8:8:=0x51 PHY_DQ_OE_TIMING_3:RW+:0:8:=0x41
+//	{	0x000005D1, 0xC0013150}, // PHY_DQ_IE_TIMING_3:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_3:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_3:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_3:RW+:0:8:=0x50
+	{	0x000005D1, 0xC0014150}, // PHY_DQ_IE_TIMING_3:RW+:24:8:=0xc0 PHY_PER_CS_TRAINING_EN_3:RW+:16:1:=0x01 PHY_DQS_TSEL_WR_TIMING_3:RW+:8:8:=0x31 PHY_DQS_TSEL_RD_TIMING_3:RW+:0:8:=0x50
+	{	0x000005D2, 0x0E0000C0}, // PHY_RDDATA_EN_DLY_3:RW+:24:4:=0x0e PHY_IE_MODE_3:RW+:16:2:=0x00 PHY_RDDATA_EN_IE_DLY_3:RW+:8:2:=0x00 PHY_DQS_IE_TIMING_3:RW+:0:8:=0xc0
+	{	0x000005D3, 0x0010000C}, // PHY_MASTER_DELAY_START_3:RW+:16:10:=0x0010 PHY_SW_MASTER_MODE_3:RW+:8:4:=0x00 PHY_RDDATA_EN_TSEL_DLY_3:RW+:0:4:=0x0c
+	{	0x000005D4, 0x0C064208}, // PHY_WRLVL_DLY_STEP_3:RW+:24:4:=0x0c PHY_RPTR_UPDATE_3:RW+:16:4:=0x06 PHY_MASTER_DELAY_WAIT_3:RW+:8:8:=0x42 PHY_MASTER_DELAY_STEP_3:RW+:0:6:=0x08
+	{	0x000005D5, 0x000F0C18}, // PHY_GTLVL_RESP_WAIT_CNT_3:RW+:16:5:=0x0f PHY_GTLVL_DLY_STEP_3:RW+:8:4:=0x0c PHY_WRLVL_RESP_WAIT_CNT_3:RW+:0:5:=0x18
+	{	0x000005D6, 0x01000140}, // PHY_GTLVL_FINAL_STEP_3:RW+:16:10:=0x0100 PHY_GTLVL_BACK_STEP_3:RW+:0:10:=0x0140
+	{	0x000005D7, 0x00000C20}, // PHY_RDLVL_DLY_STEP_3:RW+:8:4:=0x0c PHY_WDQLVL_DLY_STEP_3:RW+:0:8:=0x20
+	{	0x000005D8, 0x00000000}, //
+	{	0x000005D9, 0x00000000}, //
+	{	0x000005DA, 0x00000000}, //
+	{	0x000005DB, 0x00000000}, //
+	{	0x000005DC, 0x00000000}, //
+	{	0x000005DD, 0x00000000}, //
+	{	0x000005DE, 0x00000000}, //
+	{	0x000005DF, 0x00000000}, //
+	{	0x000005E0, 0x00000000}, //
+	{	0x000005E1, 0x00000000}, //
+	{	0x000005E2, 0x00000000}, //
+	{	0x000005E3, 0x00000000}, //
+	{	0x000005E4, 0x00000000}, //
+	{	0x000005E5, 0x00000000}, //
+	{	0x000005E6, 0x00000000}, //
+	{	0x000005E7, 0x00000000}, //
+	{	0x000005E8, 0x00000000}, //
+	{	0x000005E9, 0x00000000}, //
+	{	0x000005EA, 0x00000000}, //
+	{	0x000005EB, 0x00000000}, //
+	{	0x000005EC, 0x00000000}, //
+	{	0x000005ED, 0x00000000}, //
+	{	0x000005EE, 0x00000000}, //
+	{	0x000005EF, 0x00000000}, //
+	{	0x000005F0, 0x00000000}, //
+	{	0x000005F1, 0x00000000}, //
+	{	0x000005F2, 0x00000000}, //
+	{	0x000005F3, 0x00000000}, //
+	{	0x000005F4, 0x00000000}, //
+	{	0x000005F5, 0x00000000}, //
+	{	0x000005F6, 0x00000000}, //
+	{	0x000005F7, 0x00000000}, //
+	{	0x000005F8, 0x00000000}, //
+	{	0x000005F9, 0x00000000}, //
+	{	0x000005FA, 0x00000000}, //
+	{	0x000005FB, 0x00000000}, //
+	{	0x000005FC, 0x00000000}, //
+	{	0x000005FD, 0x00000000}, //
+	{	0x000005FE, 0x00000000}, //
+	{	0x000005FF, 0x00000000}, //
+	{	0x00000600, 0x00000000}, // PHY_ADR3_SW_WRADDR_SHIFT_0:RW+:24:5:=0x00 PHY_ADR2_SW_WRADDR_SHIFT_0:RW+:16:5:=0x00 PHY_ADR1_SW_WRADDR_SHIFT_0:RW+:8:5:=0x00 PHY_ADR0_SW_WRADDR_SHIFT_0:RW+:0:5:=0x00
+	{	0x00000601, 0x00000000}, // PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_0:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_0:RW+:8:5:=0x00 PHY_ADR4_SW_WRADDR_SHIFT_0:RW+:0:5:=0x00
+	{	0x00000602, 0x00000000}, // SC_PHY_ADR_MANUAL_CLEAR_0:WR:8:3:=0x00 PHY_ADR_CLK_BYPASS_OVERRIDE_0:RW:0:1:=0x00
+	{	0x00000603, 0x00000000}, // PHY_ADR_LPBK_RESULT_OBS_0:RD:0:32:=0x00000000
+	{	0x00000604, 0x00000000}, // PHY_ADR_SLAVE_LOOP_CNT_UPDATE_0:RW:24:3:=0x00 PHY_ADR_MASTER_DLY_LOCK_OBS_0:RD:8:10:=0x0000 PHY_ADR_MASTER_DLY_LOCK_OBS_SELECT_0:RW:0:3:=0x00
+	{	0x00000605, 0x00000000}, // PHY_ADR_LPBK_CONTROL_0:RW:24:6:=0x00 PHY_ADR_TSEL_ENABLE_0:RW:16:1:=0x00 SC_PHY_ADR_SNAP_OBS_REGS_0:WR:8:1:=0x00 PHY_ADR_SLV_DLY_ENC_OBS_SELECT_0:RW:0:3:=0x00
+	{	0x00000606, 0x00000002}, // PHY_ADR_IE_MODE_0:RW:16:1:=0x00 PHY_ADR_WRADDR_SHIFT_OBS_0:RD:8:3:=0x00 PHY_ADR_TYPE_0:RW:0:2:=0x02
+	{	0x00000607, 0x00000000}, // PHY_ADR_DDL_MODE_0:RW:0:15:=0x0000
+	{	0x00000608, 0x00000000}, // PHY_ADR_DDL_TEST_OBS_0:RD:0:32:=0x00000000
+	{	0x00000609, 0x00000000}, // PHY_ADR_DDL_TEST_MSTR_DLY_OBS_0:RD:0:32:=0x00000000
+	{	0x0000060A, 0x00400320}, // PHY_ADR_CALVL_COARSE_DLY_0:RW:16:11:=0x0040 PHY_ADR_CALVL_START_0:RW:0:11:=0x0320
+	{	0x0000060B, 0x00000040}, // PHY_ADR_CALVL_QTR_0:RW:0:11:=0x0040
+	{	0x0000060C, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE0_0_0:RW:0:24:=0xdcba98
+	{	0x0000060D, 0x00000000}, // PHY_ADR_CALVL_SWIZZLE1_0_0:RW:0:24:=0x000000
+	{	0x0000060E, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE0_1_0:RW:0:24:=0xdcba98
+	{	0x0000060F, 0x01000000}, // PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000
+	{	0x00000610, 0x00020010}, // PHY_ADR_CALVL_RESP_WAIT_CNT_0:RW:24:4:=0x00 PHY_ADR_CALVL_CAPTURE_CNT_0:RW:16:4:=0x02 PHY_ADR_CALVL_NUM_PATTERNS_0:RW:8:2:=0x00 PHY_ADR_CALVL_RANK_CTRL_0:RW:0:5:=0x10
+	{	0x00000611, 0x00000000}, // PHY_ADR_CALVL_OBS_SELECT_0:RW:24:3:=0x00 SC_PHY_ADR_CALVL_ERROR_CLR_0:WR:16:1:=0x00 SC_PHY_ADR_CALVL_DEBUG_CONT_0:WR:8:1:=0x00 PHY_ADR_CALVL_DEBUG_MODE_0:RW:0:1:=0x00
+	{	0x00000612, 0x00000000}, // PHY_ADR_CALVL_OBS0_0:RD:0:32:=0x00000000
+	{	0x00000613, 0x00000000}, // PHY_ADR_CALVL_OBS1_0:RD:0:32:=0x00000000
+	{	0x00000614, 0x00002A01}, // PHY_ADR_CALVL_FG_0_0:RW:8:20:=0x00002A PHY_ADR_CALVL_RESULT_0:RW:0:1:=0x01
+	{	0x00000615, 0x00000015}, // PHY_ADR_CALVL_BG_0_0:RW:0:20:=0x000015
+	{	0x00000616, 0x00000015}, // PHY_ADR_CALVL_FG_1_0:RW:0:20:=0x000015
+	{	0x00000617, 0x0000002A}, // PHY_ADR_CALVL_BG_1_0:RW:0:20:=0x00002a
+	{	0x00000618, 0x00000033}, // PHY_ADR_CALVL_FG_2_0:RW:0:20:=0x000033
+	{	0x00000619, 0x0000000C}, // PHY_ADR_CALVL_BG_2_0:RW:0:20:=0x00000c
+	{	0x0000061A, 0x0000000C}, // PHY_ADR_CALVL_FG_3_0:RW:0:20:=0x00000c
+	{	0x0000061B, 0x00000033}, // PHY_ADR_CALVL_BG_3_0:RW:0:20:=0x000033
+	{	0x0000061C, 0x00543210}, // PHY_ADR_ADDR_SEL_0:RW:0:24:=0x543210
+	{	0x0000061D, 0x003F0000}, // PHY_ADR_SEG_MASK_0:RW:24:6:=0x00 PHY_ADR_BIT_MASK_0:RW:16:6:=0x3f PHY_ADR_LP4_BOOT_SLV_DELAY_0:RW:0:10:=0x0000
+	{	0x0000061E, 0x0000003F}, // PHY_ADR_CALVL_TRAIN_MASK_0:RW:0:6:=0x3f
+//	{	0x0000061F, 0x0003006E}, // PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55
+//	{	0x00000620, 0x03000300}, // PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300
+//	{	0x00000621, 0x03000300}, // PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300
+//	{	0x00000622, 0x00000300}, // PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300
+	{	0x0000061F, 0x0002c06E}, // PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55
+	{	0x00000620, 0x02c002c0}, // PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300
+	{	0x00000621, 0x02c002c0}, // PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300
+	{	0x00000622, 0x000002c0}, // PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300
+	{	0x00000623, 0x42080010}, // PHY_ADR_MASTER_DELAY_WAIT_0:RW+:24:8:=0x42 PHY_ADR_MASTER_DELAY_STEP_0:RW+:16:6:=0x08 PHY_ADR_MASTER_DELAY_START_0:RW+:0:10:=0x0010
+	{	0x00000624, 0x00000003}, // PHY_ADR_CALVL_DLY_STEP_0:RW+:0:4:=0x03
+	{	0x00000625, 0x00000000}, //
+	{	0x00000626, 0x00000000}, //
+	{	0x00000627, 0x00000000}, //
+	{	0x00000628, 0x00000000}, //
+	{	0x00000629, 0x00000000}, //
+	{	0x0000062A, 0x00000000}, //
+	{	0x0000062B, 0x00000000}, //
+	{	0x0000062C, 0x00000000}, //
+	{	0x0000062D, 0x00000000}, //
+	{	0x0000062E, 0x00000000}, //
+	{	0x0000062F, 0x00000000}, //
+	{	0x00000630, 0x00000000}, //
+	{	0x00000631, 0x00000000}, //
+	{	0x00000632, 0x00000000}, //
+	{	0x00000633, 0x00000000}, //
+	{	0x00000634, 0x00000000}, //
+	{	0x00000635, 0x00000000}, //
+	{	0x00000636, 0x00000000}, //
+	{	0x00000637, 0x00000000}, //
+	{	0x00000638, 0x00000000}, //
+	{	0x00000639, 0x00000000}, //
+	{	0x0000063A, 0x00000000}, //
+	{	0x0000063B, 0x00000000}, //
+	{	0x0000063C, 0x00000000}, //
+	{	0x0000063D, 0x00000000}, //
+	{	0x0000063E, 0x00000000}, //
+	{	0x0000063F, 0x00000000}, //
+	{	0x00000640, 0x00000000}, //
+	{	0x00000641, 0x00000000}, //
+	{	0x00000642, 0x00000000}, //
+	{	0x00000643, 0x00000000}, //
+	{	0x00000644, 0x00000000}, //
+	{	0x00000645, 0x00000000}, //
+	{	0x00000646, 0x00000000}, //
+	{	0x00000647, 0x00000000}, //
+	{	0x00000648, 0x00000000}, //
+	{	0x00000649, 0x00000000}, //
+	{	0x0000064A, 0x00000000}, //
+	{	0x0000064B, 0x00000000}, //
+	{	0x0000064C, 0x00000000}, //
+	{	0x0000064D, 0x00000000}, //
+	{	0x0000064E, 0x00000000}, //
+	{	0x0000064F, 0x00000000}, //
+	{	0x00000650, 0x00000000}, //
+	{	0x00000651, 0x00000000}, //
+	{	0x00000652, 0x00000000}, //
+	{	0x00000653, 0x00000000}, //
+	{	0x00000654, 0x00000000}, //
+	{	0x00000655, 0x00000000}, //
+	{	0x00000656, 0x00000000}, //
+	{	0x00000657, 0x00000000}, //
+	{	0x00000658, 0x00000000}, //
+	{	0x00000659, 0x00000000}, //
+	{	0x0000065A, 0x00000000}, //
+	{	0x0000065B, 0x00000000}, //
+	{	0x0000065C, 0x00000000}, //
+	{	0x0000065D, 0x00000000}, //
+	{	0x0000065E, 0x00000000}, //
+	{	0x0000065F, 0x00000000}, //
+	{	0x00000660, 0x00000000}, //
+	{	0x00000661, 0x00000000}, //
+	{	0x00000662, 0x00000000}, //
+	{	0x00000663, 0x00000000}, //
+	{	0x00000664, 0x00000000}, //
+	{	0x00000665, 0x00000000}, //
+	{	0x00000666, 0x00000000}, //
+	{	0x00000667, 0x00000000}, //
+	{	0x00000668, 0x00000000}, //
+	{	0x00000669, 0x00000000}, //
+	{	0x0000066A, 0x00000000}, //
+	{	0x0000066B, 0x00000000}, //
+	{	0x0000066C, 0x00000000}, //
+	{	0x0000066D, 0x00000000}, //
+	{	0x0000066E, 0x00000000}, //
+	{	0x0000066F, 0x00000000}, //
+	{	0x00000670, 0x00000000}, //
+	{	0x00000671, 0x00000000}, //
+	{	0x00000672, 0x00000000}, //
+	{	0x00000673, 0x00000000}, //
+	{	0x00000674, 0x00000000}, //
+	{	0x00000675, 0x00000000}, //
+	{	0x00000676, 0x00000000}, //
+	{	0x00000677, 0x00000000}, //
+	{	0x00000678, 0x00000000}, //
+	{	0x00000679, 0x00000000}, //
+	{	0x0000067A, 0x00000000}, //
+	{	0x0000067B, 0x00000000}, //
+	{	0x0000067C, 0x00000000}, //
+	{	0x0000067D, 0x00000000}, //
+	{	0x0000067E, 0x00000000}, //
+	{	0x0000067F, 0x00000000}, //
+	{	0x00000680, 0x04040404}, // PHY_ADR3_SW_WRADDR_SHIFT_1:RW+:24:5:=0x04 PHY_ADR2_SW_WRADDR_SHIFT_1:RW+:16:5:=0x04 PHY_ADR1_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR0_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04
+	{	0x00000681, 0x00000404}, // PHY_ADR_CLK_WR_BYPASS_SLAVE_DELAY_1:RW:16:11:=0x0000 PHY_ADR5_SW_WRADDR_SHIFT_1:RW+:8:5:=0x04 PHY_ADR4_SW_WRADDR_SHIFT_1:RW+:0:5:=0x04
+	{	0x00000682, 0x00000000}, // SC_PHY_ADR_MANUAL_CLEAR_1:WR:8:3:=0x00 PHY_ADR_CLK_BYPASS_OVERRIDE_1:RW:0:1:=0x00
+	{	0x00000683, 0x00000000}, // PHY_ADR_LPBK_RESULT_OBS_1:RD:0:32:=0x00000000
+	{	0x00000684, 0x00000000}, // PHY_ADR_SLAVE_LOOP_CNT_UPDATE_1:RW:24:3:=0x00 PHY_ADR_MASTER_DLY_LOCK_OBS_1:RD:8:10:=0x0000 PHY_ADR_MASTER_DLY_LOCK_OBS_SELECT_1:RW:0:3:=0x00
+	{	0x00000685, 0x00000000}, // PHY_ADR_LPBK_CONTROL_1:RW:24:6:=0x00 PHY_ADR_TSEL_ENABLE_1:RW:16:1:=0x00 SC_PHY_ADR_SNAP_OBS_REGS_1:WR:8:1:=0x00 PHY_ADR_SLV_DLY_ENC_OBS_SELECT_1:RW:0:3:=0x00
+	{	0x00000686, 0x00000002}, // PHY_ADR_IE_MODE_1:RW:16:1:=0x00 PHY_ADR_WRADDR_SHIFT_OBS_1:RD:8:3:=0x00 PHY_ADR_TYPE_1:RW:0:2:=0x02
+	{	0x00000687, 0x00000000}, // PHY_ADR_DDL_MODE_1:RW:0:15:=0x0000
+	{	0x00000688, 0x00000000}, // PHY_ADR_DDL_TEST_OBS_1:RD:0:32:=0x00000000
+	{	0x00000689, 0x00000000}, // PHY_ADR_DDL_TEST_MSTR_DLY_OBS_1:RD:0:32:=0x00000000
+	{	0x0000068A, 0x00400320}, // PHY_ADR_CALVL_COARSE_DLY_1:RW:16:11:=0x0040 PHY_ADR_CALVL_START_1:RW:0:11:=0x0320
+	{	0x0000068B, 0x00000040}, // PHY_ADR_CALVL_QTR_1:RW:0:11:=0x0040
+	{	0x0000068C, 0x00000000}, // PHY_ADR_CALVL_SWIZZLE0_0_1:RW:0:24:=0x000000
+	{	0x0000068D, 0x00000000}, // PHY_ADR_CALVL_SWIZZLE1_0_1:RW:0:24:=0x000000
+	{	0x0000068E, 0x00000000}, // PHY_ADR_CALVL_SWIZZLE0_1_1:RW:0:24:=0x000000
+	{	0x0000068F, 0x01000000}, // PHY_ADR_CALVL_DEVICE_MAP_1:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_1:RW:0:24:=0x000000
+	{	0x00000690, 0x00020010}, // PHY_ADR_CALVL_RESP_WAIT_CNT_1:RW:24:4:=0x00 PHY_ADR_CALVL_CAPTURE_CNT_1:RW:16:4:=0x02 PHY_ADR_CALVL_NUM_PATTERNS_1:RW:8:2:=0x00 PHY_ADR_CALVL_RANK_CTRL_1:RW:0:5:=0x10
+	{	0x00000691, 0x00000000}, // PHY_ADR_CALVL_OBS_SELECT_1:RW:24:3:=0x00 SC_PHY_ADR_CALVL_ERROR_CLR_1:WR:16:1:=0x00 SC_PHY_ADR_CALVL_DEBUG_CONT_1:WR:8:1:=0x00 PHY_ADR_CALVL_DEBUG_MODE_1:RW:0:1:=0x00
+	{	0x00000692, 0x00000000}, // PHY_ADR_CALVL_OBS0_1:RD:0:32:=0x00000000
+	{	0x00000693, 0x00000000}, // PHY_ADR_CALVL_OBS1_1:RD:0:32:=0x00000000
+	{	0x00000694, 0x00002A01}, // PHY_ADR_CALVL_FG_0_1:RW:8:20:=0x00002A PHY_ADR_CALVL_RESULT_1:RW:0:1:=0x01
+	{	0x00000695, 0x00000015}, // PHY_ADR_CALVL_BG_0_1:RW:0:20:=0x000015
+	{	0x00000696, 0x00000015}, // PHY_ADR_CALVL_FG_1_1:RW:0:20:=0x000015
+	{	0x00000697, 0x0000002A}, // PHY_ADR_CALVL_BG_1_1:RW:0:20:=0x00002a
+	{	0x00000698, 0x00000033}, // PHY_ADR_CALVL_FG_2_1:RW:0:20:=0x000033
+	{	0x00000699, 0x0000000C}, // PHY_ADR_CALVL_BG_2_1:RW:0:20:=0x00000c
+	{	0x0000069A, 0x0000000C}, // PHY_ADR_CALVL_FG_3_1:RW:0:20:=0x00000c
+	{	0x0000069B, 0x00000033}, // PHY_ADR_CALVL_BG_3_1:RW:0:20:=0x000033
+	{	0x0000069C, 0x00000000}, // PHY_ADR_ADDR_SEL_1:RW:0:24:=0x000000
+	{	0x0000069D, 0x00000000}, // PHY_ADR_SEG_MASK_1:RW:24:6:=0x00 PHY_ADR_BIT_MASK_1:RW:16:6:=0x00 PHY_ADR_LP4_BOOT_SLV_DELAY_1:RW:0:10:=0x0000
+	{	0x0000069E, 0x00000000}, // PHY_ADR_CALVL_TRAIN_MASK_1:RW:0:6:=0x00
+//	{	0x0000069F, 0x0003006E}, // PHY_ADR0_CLK_WR_SLAVE_DELAY_1:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_1:RW+:0:8:=0x55
+//	{	0x000006A0, 0x03000300}, // PHY_ADR2_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300
+//	{	0x000006A1, 0x03000300}, // PHY_ADR4_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300
+//	{	0x000006A2, 0x00000300}, // PHY_ADR_SW_MASTER_MODE_1:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300
+	{	0x0000069F, 0x0003006E}, // PHY_ADR0_CLK_WR_SLAVE_DELAY_1:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_1:RW+:0:8:=0x55
+	{	0x000006A0, 0x03000300}, // PHY_ADR2_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300
+	{	0x000006A1, 0x03000300}, // PHY_ADR4_CLK_WR_SLAVE_DELAY_1:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300
+	{	0x000006A2, 0x00000300}, // PHY_ADR_SW_MASTER_MODE_1:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_1:RW+:0:11:=0x0300
+	{	0x000006A3, 0x42080010}, // PHY_ADR_MASTER_DELAY_WAIT_1:RW+:24:8:=0x42 PHY_ADR_MASTER_DELAY_STEP_1:RW+:16:6:=0x08 PHY_ADR_MASTER_DELAY_START_1:RW+:0:10:=0x0010
+	{	0x000006A4, 0x00000003}, // PHY_ADR_CALVL_DLY_STEP_1:RW+:0:4:=0x03
+	{	0x000006A5, 0x00000000}, //
+	{	0x000006A6, 0x00000000}, //
+	{	0x000006A7, 0x00000000}, //
+	{	0x000006A8, 0x00000000}, //
+	{	0x000006A9, 0x00000000}, //
+	{	0x000006AA, 0x00000000}, //
+	{	0x000006AB, 0x00000000}, //
+	{	0x000006AC, 0x00000000}, //
+	{	0x000006AD, 0x00000000}, //
+	{	0x000006AE, 0x00000000}, //
+	{	0x000006AF, 0x00000000}, //
+	{	0x000006B0, 0x00000000}, //
+	{	0x000006B1, 0x00000000}, //
+	{	0x000006B2, 0x00000000}, //
+	{	0x000006B3, 0x00000000}, //
+	{	0x000006B4, 0x00000000}, //
+	{	0x000006B5, 0x00000000}, //
+	{	0x000006B6, 0x00000000}, //
+	{	0x000006B7, 0x00000000}, //
+	{	0x000006B8, 0x00000000}, //
+	{	0x000006B9, 0x00000000}, //
+	{	0x000006BA, 0x00000000}, //
+	{	0x000006BB, 0x00000000}, //
+	{	0x000006BC, 0x00000000}, //
+	{	0x000006BD, 0x00000000}, //
+	{	0x000006BE, 0x00000000}, //
+	{	0x000006BF, 0x00000000}, //
+	{	0x000006C0, 0x00000000}, //
+	{	0x000006C1, 0x00000000}, //
+	{	0x000006C2, 0x00000000}, //
+	{	0x000006C3, 0x00000000}, //
+	{	0x000006C4, 0x00000000}, //
+	{	0x000006C5, 0x00000000}, //
+	{	0x000006C6, 0x00000000}, //
+	{	0x000006C7, 0x00000000}, //
+	{	0x000006C8, 0x00000000}, //
+	{	0x000006C9, 0x00000000}, //
+	{	0x000006CA, 0x00000000}, //
+	{	0x000006CB, 0x00000000}, //
+	{	0x000006CC, 0x00000000}, //
+	{	0x000006CD, 0x00000000}, //
+	{	0x000006CE, 0x00000000}, //
+	{	0x000006CF, 0x00000000}, //
+	{	0x000006D0, 0x00000000}, //
+	{	0x000006D1, 0x00000000}, //
+	{	0x000006D2, 0x00000000}, //
+	{	0x000006D3, 0x00000000}, //
+	{	0x000006D4, 0x00000000}, //
+	{	0x000006D5, 0x00000000}, //
+	{	0x000006D6, 0x00000000}, //
+	{	0x000006D7, 0x00000000}, //
+	{	0x000006D8, 0x00000000}, //
+	{	0x000006D9, 0x00000000}, //
+	{	0x000006DA, 0x00000000}, //
+	{	0x000006DB, 0x00000000}, //
+	{	0x000006DC, 0x00000000}, //
+	{	0x000006DD, 0x00000000}, //
+	{	0x000006DE, 0x00000000}, //
+	{	0x000006DF, 0x00000000}, //
+	{	0x000006E0, 0x00000000}, //
+	{	0x000006E1, 0x00000000}, //
+	{	0x000006E2, 0x00000000}, //
+	{	0x000006E3, 0x00000000}, //
+	{	0x000006E4, 0x00000000}, //
+	{	0x000006E5, 0x00000000}, //
+	{	0x000006E6, 0x00000000}, //
+	{	0x000006E7, 0x00000000}, //
+	{	0x000006E8, 0x00000000}, //
+	{	0x000006E9, 0x00000000}, //
+	{	0x000006EA, 0x00000000}, //
+	{	0x000006EB, 0x00000000}, //
+	{	0x000006EC, 0x00000000}, //
+	{	0x000006ED, 0x00000000}, //
+	{	0x000006EE, 0x00000000}, //
+	{	0x000006EF, 0x00000000}, //
+	{	0x000006F0, 0x00000000}, //
+	{	0x000006F1, 0x00000000}, //
+	{	0x000006F2, 0x00000000}, //
+	{	0x000006F3, 0x00000000}, //
+	{	0x000006F4, 0x00000000}, //
+	{	0x000006F5, 0x00000000}, //
+	{	0x000006F6, 0x00000000}, //
+	{	0x000006F7, 0x00000000}, //
+	{	0x000006F8, 0x00000000}, //
+	{	0x000006F9, 0x00000000}, //
+	{	0x000006FA, 0x00000000}, //
+	{	0x000006FB, 0x00000000}, //
+	{	0x000006FC, 0x00000000}, //
+	{	0x000006FD, 0x00000000}, //
+	{	0x000006FE, 0x00000000}, //
+	{	0x000006FF, 0x00000000}, //
+	{	0x00000700, 0x00000001}, // PHY_SW_GRP_SHIFT_1:RW+:24:5:=0x00 PHY_SW_GRP_SHIFT_0:RW+:16:5:=0x00 PHY_FREQ_SEL_INDEX:RW:8:2:=0x00 PHY_FREQ_SEL_MULTICAST_EN:RW_D:0:1:=0x01
+	{	0x00000701, 0x00000000}, // PHY_GRP_BYPASS_SLAVE_DELAY:RW:16:11:=0x0000 PHY_SW_GRP_SHIFT_3:RW+:8:5:=0x00 PHY_SW_GRP_SHIFT_2:RW+:0:5:=0x00
+	{	0x00000702, 0x00000005}, // PHY_LP4_BOOT_DISABLE:RW:24:1:=0x01 SC_PHY_MANUAL_UPDATE:WR:16:1:=0x00 PHY_GRP_BYPASS_OVERRIDE:RW:8:1:=0x00 PHY_SW_GRP_BYPASS_SHIFT:RW:0:5:=0x05
+//	{	0x00000702, 0x01000005}, // PHY_LP4_BOOT_DISABLE:RW:24:1:=0x01 SC_PHY_MANUAL_UPDATE:WR:16:1:=0x00 PHY_GRP_BYPASS_OVERRIDE:RW:8:1:=0x00 PHY_SW_GRP_BYPASS_SHIFT:RW:0:5:=0x05
+//	{	0x00000703, 0x04003100}, // PHY_CSLVL_START:RW:16:11:=0x0400 PHY_CSLVL_CS_MAP:RW:8:4:=0x31 PHY_CSLVL_ENABLE:RW:0:1:=0x01
+	{	0x00000703, 0x04000300}, // PHY_CSLVL_START:RW:16:11:=0x0400 PHY_CSLVL_CS_MAP:RW:8:4:=0x31 PHY_CSLVL_ENABLE:RW:0:1:=0x01
+	{	0x00000704, 0x00020040}, // PHY_CSLVL_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_QTR:RW:0:11:=0x0040
+	{	0x00000705, 0x00020055}, // PHY_CSLVL_DEBUG_MODE:RW:24:1:=0x00 PHY_CSLVL_COARSE_CAPTURE_CNT:RW:16:4:=0x02 PHY_CSLVL_COARSE_DLY:RW:0:11:=0x0055
+	{	0x00000706, 0x00000000}, // SC_PHY_CSLVL_ERROR_CLR:WR:8:1:=0x00 SC_PHY_CSLVL_DEBUG_CONT:WR:0:1:=0x00
+	{	0x00000707, 0x00000000}, // PHY_CSLVL_OBS0:RD:0:32:=0x00000000
+	{	0x00000708, 0x00000000}, // PHY_CSLVL_OBS1:RD:0:32:=0x00000000
+	{	0x00000709, 0x00000050}, // PHY_GRP_SHIFT_OBS_SELECT:RW:24:5:=0x00 PHY_GRP_SLV_DLY_ENC_OBS_SELECT:RW:8:10:=0x0000 PHY_CALVL_CS_MAP:RW:0:8:=0x50
+	{	0x0000070A, 0x00000000}, // PHY_ADRCTL_SLAVE_LOOP_CNT_UPDATE:RW:24:3:=0x00 PHY_GRP_SHIFT_OBS:RD:16:3:=0x00 PHY_GRP_SLV_DLY_ENC_OBS:RD:0:10:=0x0000
+	{	0x0000070B, 0x01010100}, // PHY_LP4_ACTIVE:RW:24:1:=0x01 PHY_ADRCTL_LPDDR:RW:16:1:=0x01 PHY_DFI_PHYUPD_TYPE:RW:8:2:=0x01 PHY_ADRCTL_SNAP_OBS_REGS:WR:0:1:=0x00
+	{	0x0000070C, 0x00000000}, // PHY_CONTINUOUS_CLK_CAL_UPDATE:RW:24:1:=0x00 PHY_UPDATE_CLK_CAL_VALUES:RW:16:1:=0x00 PHY_CALVL_RESULT_MASK:RW:8:2:=0x00 PHY_LPDDR3_CS:RW_D:0:1:=0x00
+	{	0x0000070D, 0x00001102}, // PHY_PLL_CTRL:RW+:0:13:=0x1102
+	{	0x0000070E, 0x00000000}, // PHY_PLL_BYPASS:RW+:0:5:=0x00
+	{	0x0000070F, 0x000F1900}, // PHY_PAD_VREF_CTRL_DQ_0:RW+:8:14:=0x0100 PHY_LOW_FREQ_SEL:RW+:0:1:=0x00
+//	{	0x0000070F, 0x000F1901}, // PHY_PAD_VREF_CTRL_DQ_0:RW+:8:14:=0x0100 PHY_LOW_FREQ_SEL:RW+:0:1:=0x01
+	{	0x00000710, 0x0F190F19}, // PHY_PAD_VREF_CTRL_DQ_2:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_1:RW+:0:14:=0x0100
+	{	0x00000711, 0x0F190F19}, // PHY_PAD_VREF_CTRL_AC:RW+:16:14:=0x0100 PHY_PAD_VREF_CTRL_DQ_3:RW+:0:14:=0x0100
+//	{	0x00000712, 0x00030003}, // PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03
+//	{	0x00000713, 0x03000300}, // PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300
+//	{	0x00000714, 0x00000300}, // PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300
+	{	0x00000712, 0x0002c003}, // PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03
+	{	0x00000713, 0x02c002c0}, // PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300
+	{	0x00000714, 0x000002c0}, // PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300
+	{	0x00000715, 0x00001102}, // PHY_PLL_CTRL_OVERRIDE:RW:16:16:=0x0000 PHY_LP4_BOOT_PLL_CTRL:RW:0:13:=0x1b02
+//	{	0x00000715, 0x00001b02}, // PHY_PLL_CTRL_OVERRIDE:RW:16:16:=0x0000 PHY_LP4_BOOT_PLL_CTRL:RW:0:13:=0x1b02
+//NG	0x00000715, 0x00001b02, // PHY_PLL_CTRL_OVERRIDE:RW:16:16:=0x0000 PHY_LP4_BOOT_PLL_CTRL:RW:0:13:=0x1b02	
+//	{	0x00000715, 0x00001302}, // PHY_PLL_CTRL_OVERRIDE:RW:16:16:=0x0000 PHY_LP4_BOOT_PLL_CTRL:RW:0:13:=0x1b02	
+	{	0x00000716, 0x000000FF}, // PHY_PLL_OBS_0:RD:8:16:=0x0000 PHY_PLL_WAIT:RW:0:8:=0x64
+	{	0x00000717, 0x00000000}, // PHY_PLL_OBS_2:RD:16:16:=0x0000 PHY_PLL_OBS_1:RD:0:16:=0x0000
+	{	0x00000718, 0x00000000}, // PHY_PLL_OBS_4:RD:16:16:=0x0000 PHY_PLL_OBS_3:RD:0:16:=0x0000
+//	{	0x00000719, 0x00010503}, // PHY_LP_WAKEUP:RW:24:4:=0x00 PHY_LP4_BOOT_LOW_FREQ_SEL:RW:16:1:=0x01 PHY_TCKSRE_WAIT:RW:8:4:=0x05 PHY_PLL_TESTOUT_SEL:RW:0:3:=0x03
+	{	0x00000719, 0x00000503}, // PHY_LP_WAKEUP:RW:24:4:=0x00 PHY_LP4_BOOT_LOW_FREQ_SEL:RW:16:1:=0x01 PHY_TCKSRE_WAIT:RW:8:4:=0x05 PHY_PLL_TESTOUT_SEL:RW:0:3:=0x03
+	{	0x0000071A, 0x027F6E00}, // PHY_PAD_FDBK_DRIVE:RW+:8:18:=0x000411 PHY_TDFI_PHY_WRDELAY:RW:0:1:=0x00
+	{	0x0000071B, 0x047F027F}, // PHY_PAD_DQS_DRIVE:RW+:16:12:=0x0040 PHY_PAD_DATA_DRIVE:RW+:0:10:=0x0040
+	{	0x0000071C, 0x00027F6E}, // PHY_PAD_ADDR_DRIVE:RW+:0:18:=0x000411 // LPDDR4_EN bit 14 is it needed?
+	{	0x0000071D, 0x00047F6E}, // PHY_PAD_CLK_DRIVE:RW+:0:20:=0x000411
+	{	0x0000071E, 0x00030F68}, // PHY_PAD_FDBK_TERM:RW+:0:18:=0x004410 //PVTP = 0x28, PVTN=0x3d, PVTr=0x10
+	{	0x0000071F, 0x00010F68}, // PHY_PAD_DATA_TERM:RW+:0:17:=0x004410
+	{	0x00000720, 0x00010F68}, // PHY_PAD_DQS_TERM:RW+:0:17:=0x004410
+	{	0x00000721, 0x00010F68}, // PHY_PAD_ADDR_TERM:RW+:0:18:=0x004410
+	{	0x00000722, 0x00010F68}, // PHY_PAD_CLK_TERM:RW+:0:18:=0x004410
+	{	0x00000723, 0x00027F6E}, // PHY_PAD_CKE_DRIVE:RW+:0:18:=0x000411
+	{	0x00000724, 0x00010F68}, // PHY_PAD_CKE_TERM:RW+:0:18:=0x004410
+	{	0x00000725, 0x00027F6E}, // PHY_PAD_RST_DRIVE:RW+:0:18:=0x000411
+	{	0x00000726, 0x00010F68}, // PHY_PAD_RST_TERM:RW+:0:18:=0x004410
+	{	0x00000727, 0x00027F6E}, // PHY_PAD_CS_DRIVE:RW+:0:18:=0x000411
+	{	0x00000728, 0x00010F68}, // PHY_PAD_CS_TERM:RW+:0:18:=0x004410
+	{	0x00000729, 0x00000000}, // PHY_ADRCTL_RX_CAL:RW:0:25:=0x00000000
+	{	0x0000072A, 0x00000000}, // PHY_ADRCTL_LP3_RX_CAL:RW:0:25:=0x00000000
+	{	0x0000072B, 0x00000000}, // PHY_TST_CLK_PAD_CTRL:RW:0:32:=0x00000000
+	{	0x0000072C, 0x65000000}, // PHY_CAL_MODE_0:RW:24:8:=0x64 PHY_TST_CLK_PAD_CTRL2:RW:0:23:=0x000000
+	{	0x0000072D, 0x00000000}, // PHY_CAL_START_0:WR:8:1:=0x00 PHY_CAL_CLEAR_0:WR:0:1:=0x00
+	{	0x0000072E, 0x00000000}, // PHY_CAL_INTERVAL_COUNT_0:RW:0:32:=0x00000000
+	{	0x0000072F, 0x00000608}, // PHY_CAL_CLK_SELECT_0:RW:8:3:=0x01 PHY_CAL_SAMPLE_WAIT_0:RW:0:8:=0x08
+	{	0x00000730, 0x00000000}, // PHY_CAL_RESULT_OBS_0:RD:0:24:=0x000000
+	{	0x00000731, 0x00000000}, // PHY_CAL_RESULT2_OBS_0:RD:0:24:=0x000000
+	{	0x00000732, 0x00000000}, // PHY_AC_LPBK_ERR_CLEAR:WR:24:1:=0x00 PHY_ADRCTL_MANUAL_UPDATE:WR:16:1:=0x00 PHY_PAD_ATB_CTRL:RW:0:16:=0x0000
+	{	0x00000733, 0x00000000}, // PHY_AC_LPBK_OBS_SELECT:RW:0:5:=0x00
+	{	0x00000734, 0x00000000}, // PHY_AC_LPBK_ENABLE:RW:0:32:=0x00000000
+	{	0x00000735, 0x00000000}, // PHY_AC_LPBK_CONTROL:RW:0:9:=0x0000
+	{	0x00000736, 0x00000000}, // PHY_AC_LPBK_RESULT_OBS:RD:0:32:=0x00000000
+	{	0x00000737, 0x00000000}, // PHY_AC_CLK_LPBK_CONTROL:RW:24:6:=0x00 PHY_AC_CLK_LPBK_ENABLE:RW:8:16:=0x0000 PHY_AC_CLK_LPBK_OBS_SELECT:RW:0:4:=0x00
+	{	0x00000738, 0x00000000}, // PHY_AC_CLK_LPBK_RESULT_OBS:RD:0:16:=0x0000
+	{	0x00000739, 0x00000000}, // PHY_DDL_AC_ENABLE:RW:0:32:=0x00000000
+	{	0x0000073A, 0x00000000}, // PHY_DDL_AC_MODE:RW:0:11:=0x0000
+};
+
+
+static const uint32_t DDR_PI_suresh[181][2] = 
+{
+
+	{	0x00000200, 0x00000B00}, // PI_VERSION:RD:16:16:=0x0000 PI_DRAM_CLASS:RW:8:4:=0x0b PI_START:RW:0:1:=0x00
+	{	0x00000201, 0x00000100}, // PI_TCMD_GAP:RW:16:16:=0x0000 PI_INIT_LVL_EN:RW:8:1:=0x01 PI_NORMAL_LVL_SEQ:RW:0:1:=0x00
+	{	0x00000202, 0x00000118}, // PI_TDFI_PHYMSTR_MAX_F0:RW:0:32:=0x00000118
+//	{	0x00000202, 0x00006098}, // PI_TDFI_PHYMSTR_MAX_F0:RW:0:32:=0x00006098
+	{	0x00000203, 0x0000008C}, // PI_TDFI_PHYMSTR_RESP_F0:RW:0:16:=0x008c
+//	{	0x00000203, 0x0000304C}, // PI_TDFI_PHYMSTR_RESP_F0:RW:0:16:=0x304c
+	{	0x00000204, 0x00006098}, // PI_TDFI_PHYMSTR_MAX_F1:RW:0:32:=0x00006098
+	{	0x00000205, 0x0000304C}, // PI_TDFI_PHYMSTR_RESP_F1:RW:0:16:=0x304c
+	{	0x00000206, 0x00006098}, // PI_TDFI_PHYMSTR_MAX_F2:RW:0:32:=0x00006098
+	{	0x00000207, 0x008C304C}, // PI_TDFI_PHYUPD_RESP_F0:RW:16:16:=0x008c PI_TDFI_PHYMSTR_RESP_F2:RW:0:16:=0x304c
+//	{	0x00000207, 0x304C304C}, // PI_TDFI_PHYUPD_RESP_F0:RW:16:16:=0x008c PI_TDFI_PHYMSTR_RESP_F2:RW:0:16:=0x304c
+	{	0x00000208, 0x00000200}, // PI_TDFI_PHYUPD_TYPE0_F0:RW:0:32:=0x00000200
+	{	0x00000209, 0x00000200}, // PI_TDFI_PHYUPD_TYPE1_F0:RW:0:32:=0x00000200
+	{	0x0000020A, 0x00000200}, // PI_TDFI_PHYUPD_TYPE2_F0:RW:0:32:=0x00000200
+	{	0x0000020B, 0x00000200}, // PI_TDFI_PHYUPD_TYPE3_F0:RW:0:32:=0x00000200
+	{	0x0000020C, 0x0000304C}, // PI_TDFI_PHYUPD_RESP_F1:RW:0:16:=0x304c
+	{	0x0000020D, 0x00000200}, // PI_TDFI_PHYUPD_TYPE0_F1:RW:0:32:=0x00000200
+	{	0x0000020E, 0x00000200}, // PI_TDFI_PHYUPD_TYPE1_F1:RW:0:32:=0x00000200
+	{	0x0000020F, 0x00000200}, // PI_TDFI_PHYUPD_TYPE2_F1:RW:0:32:=0x00000200
+	{	0x00000210, 0x00000200}, // PI_TDFI_PHYUPD_TYPE3_F1:RW:0:32:=0x00000200
+	{	0x00000211, 0x0000304C}, // PI_TDFI_PHYUPD_RESP_F2:RW:0:16:=0x304c
+	{	0x00000212, 0x00000200}, // PI_TDFI_PHYUPD_TYPE0_F2:RW:0:32:=0x00000200
+	{	0x00000213, 0x00000200}, // PI_TDFI_PHYUPD_TYPE1_F2:RW:0:32:=0x00000200
+	{	0x00000214, 0x00000200}, // PI_TDFI_PHYUPD_TYPE2_F2:RW:0:32:=0x00000200
+	{	0x00000215, 0x00000200}, // PI_TDFI_PHYUPD_TYPE3_F2:RW:0:32:=0x00000200
+	{	0x00000216, 0x00010000}, // PI_EXIT_AFTER_INIT_CALVL:RW_D:16:1:=0x01 PI_CONTROL_ERROR_STATUS:RD:0:9:=0x0000
+//	{	0x00000217, 0x00000005}, // PI_FREQ_MAP:RW:0:32:=0x00000007
+	{	0x00000217, 0x00000003}, // PI_FREQ_MAP:RW:0:32:=0x00000007
+//	{	0x00000218, 0x01000002}, // PI_POWER_ON_SEQ_END_ARRAY:RW:24:8:=0x01 PI_POWER_ON_SEQ_BYPASS_ARRAY:RW:16:8:=0x00 PI_INIT_DFS_CALVL_ONLY:RW:8:1:=0x00 PI_INIT_WORK_FREQ:RW:0:5:=0x01
+	{	0x00000218, 0x01000001}, // PI_POWER_ON_SEQ_END_ARRAY:RW:24:8:=0x01 PI_POWER_ON_SEQ_BYPASS_ARRAY:RW:16:8:=0x00 PI_INIT_DFS_CALVL_ONLY:RW:8:1:=0x00 PI_INIT_WORK_FREQ:RW:0:5:=0x01
+	{	0x00000219, 0x00000000}, // PI_SEQ1_PAT:RW:0:28:=0x00000000
+	{	0x0000021A, 0x00000000}, // PI_SEQ1_PAT_MASK:RW:0:28:=0x00000000
+	{	0x0000021B, 0x00000000}, // PI_SEQ2_PAT:RW:0:28:=0x00000000
+	{	0x0000021C, 0x00000000}, // PI_SEQ2_PAT_MASK:RW:0:28:=0x00000000
+	{	0x0000021D, 0x00000000}, // PI_SEQ3_PAT:RW:0:28:=0x00000000
+	{	0x0000021E, 0x00000000}, // PI_SEQ3_PAT_MASK:RW:0:28:=0x00000000
+	{	0x0000021F, 0x00000000}, // PI_SEQ4_PAT:RW:0:28:=0x00000000
+	{	0x00000220, 0x00000000}, // PI_SEQ4_PAT_MASK:RW:0:28:=0x00000000
+	{	0x00000221, 0x00000000}, // PI_SEQ5_PAT:RW:0:28:=0x00000000
+	{	0x00000222, 0x00000000}, // PI_SEQ5_PAT_MASK:RW:0:28:=0x00000000
+	{	0x00000223, 0x00000000}, // PI_SEQ6_PAT:RW:0:28:=0x00000000
+	{	0x00000224, 0x00000000}, // PI_SEQ6_PAT_MASK:RW:0:28:=0x00000000
+	{	0x00000225, 0x00000000}, // PI_SEQ7_PAT:RW:0:28:=0x00000000
+	{	0x00000226, 0x00000000}, // PI_SEQ7_PAT_MASK:RW:0:28:=0x00000000
+	{	0x00000227, 0x00000000}, // PI_SEQ8_PAT:RW:0:28:=0x00000000
+	{	0x00000228, 0x00000000}, // PI_SEQ8_PAT_MASK:RW:0:28:=0x00000000
+//	{	0x00000229, 0x0f000101}, // PI_CS_MAP:RW:24:4:=0x0f RESERVED:RW:16:1:=0x00 PI_SW_RST_N:RW_D:8:1:=0x01 PI_WDT_DISABLE:RW_D:0:1:=0x01
+//	{	0x00000229, 0x01000101}, // PI_CS_MAP:RW:24:4:=0x0f RESERVED:RW:16:1:=0x00 PI_SW_RST_N:RW_D:8:1:=0x01 PI_WDT_DISABLE:RW_D:0:1:=0x01
+	{	0x00000229, 0x05000101}, // PI_CS_MAP:RW:24:4:=0x0f RESERVED:RW:16:1:=0x00 PI_SW_RST_N:RW_D:8:1:=0x01 PI_WDT_DISABLE:RW_D:0:1:=0x01
+	{	0x0000022A, 0x08494925}, // PI_TMRR:RW:24:4:=0x08 PI_TDELAY_RDWR_2_BUS_IDLE_F2:RW:16:8:=0x49 PI_TDELAY_RDWR_2_BUS_IDLE_F1:RW:8:8:=0x49 PI_TDELAY_RDWR_2_BUS_IDLE_F0:RW:0:8:=0x25
+/*--150819
+	{	0x0000022B, 0x380E0C04}, // PI_CASLAT_LIN_F1:RW:24:7:=0x38 PI_WRLAT_F1:RW:16:6:=0x0e PI_CASLAT_LIN_F0:RW:8:7:=0x0c PI_WRLAT_F0:RW:0:6:=0x04
+	{	0x0000022C, 0x0002500E}, // PI_AREFRESH:WR:24:1:=0x00 PI_PREAMBLE_SUPPORT:RW:16:2:=0x02 PI_CASLAT_LIN_F2:RW:8:7:=0x38 PI_WRLAT_F2:RW:0:6:=0x0e
+*/
+//150819->
+	{	0x0000022B, (PI_CASLAT_LIN<<24)|(PI_WRLAT<<16)|(PI_CASLAT_LIN<<8)|(PI_WRLAT<<0)}, // PI_CASLAT_LIN_F1:RW:24:7:=0x38 PI_WRLAT_F1:RW:16:6:=0x0e PI_CASLAT_LIN_F0:RW:8:7:=0x0c PI_WRLAT_F0:RW:0:6:=0x04
+	{	0x0000022C, 0x00020000|(PI_CASLAT_LIN<<8)|(PI_WRLAT<<0)}, // PI_AREFRESH:WR:24:1:=0x00 PI_PREAMBLE_SUPPORT:RW:16:2:=0x02 PI_CASLAT_LIN_F2:RW:8:7:=0x38 PI_WRLAT_F2:RW:0:6:=0x0e
+//<-
+	{	0x0000022D, 0x00460003}, // PI_TREF_F0:RW:16:16:=0x0046 PI_TRFC_F0:RW:0:10:=0x0003
+	{	0x0000022E, 0x182600CF}, // PI_TREF_F1:RW:16:16:=0x1826 PI_TRFC_F1:RW:0:10:=0x00cf
+	{	0x0000022F, 0x182600CF}, // PI_TREF_F2:RW:16:16:=0x1826 PI_TRFC_F2:RW:0:10:=0x00cf
+	{	0x00000230, 0x00000005}, // PI_SWLVL_OP_DONE:RD:24:1:=0x00 PI_SWLVL_LOAD:WR:16:1:=0x00 PI_TREF_INTERVAL:RW:0:16:=0x0005
+	{	0x00000231, 0x00000000}, // PI_SW_WRLVL_RESP_3:RD:24:1:=0x00 PI_SW_WRLVL_RESP_2:RD:16:1:=0x00 PI_SW_WRLVL_RESP_1:RD:8:1:=0x00 PI_SW_WRLVL_RESP_0:RD:0:1:=0x00
+	{	0x00000232, 0x00000000}, // PI_SW_RDLVL_RESP_3:RD:24:2:=0x00 PI_SW_RDLVL_RESP_2:RD:16:2:=0x00 PI_SW_RDLVL_RESP_1:RD:8:2:=0x00 PI_SW_RDLVL_RESP_0:RD:0:2:=0x00
+	{	0x00000233, 0x00000000}, // PI_SWLVL_EXIT:WR:24:1:=0x00 PI_SWLVL_START:WR:16:1:=0x00 PI_SW_LEVELING_MODE:RW:8:3:=0x00 PI_SW_CALVL_RESP_0:RD:0:2:=0x00
+	{	0x00000234, 0x00000000}, // PI_SWLVL_WR_SLICE_1:WR:24:1:=0x00 PI_SW_WDQLVL_RESP_0:RD:16:2:=0x00 PI_SWLVL_RD_SLICE_0:WR:8:1:=0x00 PI_SWLVL_WR_SLICE_0:WR:0:1:=0x00
+	{	0x00000235, 0x00000000}, // PI_SWLVL_RD_SLICE_2:WR:24:1:=0x00 PI_SWLVL_WR_SLICE_2:WR:16:1:=0x00 PI_SW_WDQLVL_RESP_1:RD:8:2:=0x00 PI_SWLVL_RD_SLICE_1:WR:0:1:=0x00
+	{	0x00000236, 0x00000000}, // PI_SW_WDQLVL_RESP_3:RD:24:2:=0x00 PI_SWLVL_RD_SLICE_3:WR:16:1:=0x00 PI_SWLVL_WR_SLICE_3:WR:8:1:=0x00 PI_SW_WDQLVL_RESP_2:RD:0:2:=0x00
+	{	0x00000237, 0x00000000}, // PI_SWLVL_SM2_RD:WR:24:1:=0x00 PI_SWLVL_SM2_WR:WR:16:1:=0x00 PI_SWLVL_SM2_START:WR:8:1:=0x00 PI_SW_WDQLVL_VREF:RW:0:7:=0x00
+	{	0x00000238, 0x01000000}, // PI_16BIT_DRAM_CONNECT:RW_D:24:1:=0x01 PI_SRE_PERIOD_EN:RW:16:1:=0x00 PI_DFS_PERIOD_EN:RW:8:1:=0x00 PI_SEQUENTIAL_LVL_REQ:WR:0:1:=0x00
+	{	0x00000239, 0x00040404}, // PI_WRLVL_REQ:WR:24:1:=0x00 PI_TDFI_CTRL_DELAY_F2:RW_D:16:4:=0x04 PI_TDFI_CTRL_DELAY_F1:RW_D:8:4:=0x04 PI_TDFI_CTRL_DELAY_F0:RW_D:0:4:=0x04
+	{	0x0000023A, 0x01280A00}, // PI_WRLVL_EN:RW:24:2:=0x01 PI_WLMRD:RW:16:6:=0x28 PI_WLDQSEN:RW:8:6:=0x0a PI_WRLVL_CS:RW:0:2:=0x00
+	{	0x0000023B, 0x00000000}, // PI_WRLVL_ON_SREF_EXIT:RW:24:1:=0x00 PI_WRLVL_PERIODIC:RW:16:1:=0x00 PI_WRLVL_INTERVAL:RW:0:16:=0x0000
+//	{	0x0000023C, 0x00030000}, // PI_WRLVL_ERROR_STATUS:RD:24:2:=0x00 PI_WRLVL_CS_MAP:RW:16:4:=0x03 PI_WRLVL_ROTATE:RW:8:1:=0x00 PI_WRLVL_RESP_MASK:RW:0:4:=0x00
+	{	0x0000023C, 0x00010000}, // PI_WRLVL_ERROR_STATUS:RD:24:2:=0x00 PI_WRLVL_CS_MAP:RW:16:4:=0x03 PI_WRLVL_ROTATE:RW:8:1:=0x00 PI_WRLVL_RESP_MASK:RW:0:4:=0x00
+	{	0x0000023D, 0x00001440}, // PI_TDFI_WRLVL_WW:RW:8:10:=0x0014 PI_TDFI_WRLVL_EN:RW:0:8:=0x03
+	{	0x0000023E, 0x00000000}, // PI_TDFI_WRLVL_RESP:RW:0:32:=0x00000000
+	{	0x0000023F, 0x00000000}, // PI_TDFI_WRLVL_MAX:RW:0:32:=0x00000000
+	{	0x00000240, 0x00060102}, // PI_TODTL_2CMD_F0:RW:24:8:=0x00 PI_WRLVL_EN_DEASSERT_2_MRR:RW:16:5:=0x06 PI_WRLVL_MRR_DQ_RETURN_HIZ:RW:8:1:=0x01 PI_WRLVL_STROBE_NUM:RW:0:5:=0x02
+	{	0x00000241, 0x00010001}, // PI_TODTL_2CMD_F2:RW:24:8:=0x00 PI_ODT_EN_F1:RW:16:1:=0x01 PI_TODTL_2CMD_F1:RW:8:8:=0x00 PI_ODT_EN_F0:RW:0:1:=0x01
+	{	0x00000242, 0x01000101}, // PI_ODT_RD_MAP_CS0:RW:24:4:=0x01 PI_TODTH_RD:RW:16:4:=0x00 PI_TODTH_WR:RW:8:4:=0x01 PI_ODT_EN_F2:RW:0:1:=0x01
+	{	0x00000243, 0x04020201}, // PI_ODT_RD_MAP_CS2:RW:24:4:=0x04 PI_ODT_WR_MAP_CS1:RW:16:4:=0x02 PI_ODT_RD_MAP_CS1:RW:8:4:=0x02 PI_ODT_WR_MAP_CS0:RW:0:4:=0x01
+	{	0x00000244, 0x00080804}, // PI_EN_ODT_ASSERT_EXCEPT_RD:RW:24:1:=0x00 PI_ODT_WR_MAP_CS3:RW:16:4:=0x08 PI_ODT_RD_MAP_CS3:RW:8:4:=0x08 PI_ODT_WR_MAP_CS2:RW:0:4:=0x04
+	{	0x00000245, 0x00000000}, // PI_TODTON_MIN_F1:RW:24:4:=0x00 PI_ODTLON_F1:RW:16:4:=0x00 PI_TODTON_MIN_F0:RW:8:4:=0x00 PI_ODTLON_F0:RW:0:4:=0x00
+	{	0x00000246, 0x08030000}, // PI_WR_TO_ODTH_F1:RW:24:6:=0x08 PI_WR_TO_ODTH_F0:RW:16:6:=0x03 PI_TODTON_MIN_F2:RW:8:4:=0x00 PI_ODTLON_F2:RW:0:4:=0x00
+	{	0x00000247, 0x15150408}, // PI_RD_TO_ODTH_F2:RW:24:6:=0x15 PI_RD_TO_ODTH_F1:RW:16:6:=0x15 PI_RD_TO_ODTH_F0:RW:8:6:=0x04 PI_WR_TO_ODTH_F2:RW:0:6:=0x08
+	{	0x00000248, 0x00000000}, // PI_RDLVL_SEQ_EN:RW:24:4:=0x00 PI_RDLVL_CS:RW:16:2:=0x00 PI_RDLVL_GATE_REQ:WR:8:1:=0x00 PI_RDLVL_REQ:WR:0:1:=0x00
+	{	0x00000249, 0x00000000}, // PI_RDLVL_GATE_PERIODIC:RW:24:1:=0x00 PI_RDLVL_ON_SREF_EXIT:RW:16:1:=0x00 PI_RDLVL_PERIODIC:RW:8:1:=0x00 PI_RDLVL_GATE_SEQ_EN:RW:0:4:=0x00
+	{	0x0000024A, 0x00000000}, // PI_RDLVL_GATE_ROTATE:RW:24:1:=0x00 PI_RDLVL_ROTATE:RW:16:1:=0x00 RESERVED:RW:8:1:=0x00 PI_RDLVL_GATE_ON_SREF_EXIT:RW:0:1:=0x00
+//	{	0x0000024B, 0x001E0303}, // PI_TDFI_RDLVL_RR:RW:16:10:=0x001e PI_RDLVL_GATE_CS_MAP:RW:8:4:=0x03 PI_RDLVL_CS_MAP:RW:0:4:=0x03
+	{	0x0000024B, 0x001E0101}, // PI_TDFI_RDLVL_RR:RW:16:10:=0x001e PI_RDLVL_GATE_CS_MAP:RW:8:4:=0x03 PI_RDLVL_CS_MAP:RW:0:4:=0x03
+	{	0x0000024C, 0x00000000}, // PI_TDFI_RDLVL_RESP:RW:0:32:=0x00000000
+//	{	0x0000024D, 0x01010300}, // PI_RDLVL_GATE_EN:RW:24:2:=0x01 PI_RDLVL_EN:RW:16:2:=0x01 PI_TDFI_RDLVL_EN:RW:8:8:=0x03 PI_RDLVL_RESP_MASK:RW:0:4:=0x00
+//	{	0x0000024D, 0x01000300}, // PI_RDLVL_GATE_EN:RW:24:2:=0x01 PI_RDLVL_EN:RW:16:2:=0x01 PI_TDFI_RDLVL_EN:RW:8:8:=0x03 PI_RDLVL_RESP_MASK:RW:0:4:=0x00
+	{	0x0000024D, 0x01000100}, // PI_RDLVL_GATE_EN:RW:24:2:=0x01 PI_RDLVL_EN:RW:16:2:=0x01 PI_TDFI_RDLVL_EN:RW:8:8:=0x03 PI_RDLVL_RESP_MASK:RW:0:4:=0x00
+	{	0x0000024E, 0x00000000}, // PI_TDFI_RDLVL_MAX:RW:0:32:=0x00000000
+	{	0x0000024F, 0x00000000}, // PI_RDLVL_INTERVAL:RW:8:16:=0x0000 PI_RDLVL_ERROR_STATUS:RD:0:2:=0x00
+	{	0x00000250, 0x01000000}, // PI_RDLVL_PATTERN_NUM:RW:24:4:=0x01 PI_RDLVL_PATTERN_START:RW:16:4:=0x00 PI_RDLVL_GATE_INTERVAL:RW:0:16:=0x0000
+	{	0x00000251, 0x00010101}, // PI_REG_DIMM_ENABLE:RW:24:1:=0x00 PI_RD_PREAMBLE_TRAINING_EN:RW:16:1:=0x01 PI_RDLVL_GATE_STROBE_NUM:RW:8:5:=0x01 PI_RDLVL_STROBE_NUM:RW:0:5:=0x01
+/*--150819
+	{	0x00000252, 0x000E0E05}, // PI_TDFI_RDDATA_EN:RD:24:7:=0x00 PI_RDLAT_ADJ_F2:RW:16:7:=0x0e PI_RDLAT_ADJ_F1:RW:8:7:=0x0e PI_RDLAT_ADJ_F0:RW:0:7:=0x05
+	{	0x00000253, 0x000C0C02}, // PI_TDFI_PHY_WRLAT:RD:24:7:=0x00 PI_WRLAT_ADJ_F2:RW:16:7:=0x0c PI_WRLAT_ADJ_F1:RW:8:7:=0x0c PI_WRLAT_ADJ_F0:RW:0:7:=0x02
+*/
+//150819->
+	{	0x00000252, (PI_RDLAT_ADJ<<16)|(PI_RDLAT_ADJ<<8)|(PI_RDLAT_ADJ<<0)}, // PI_TDFI_RDDATA_EN:RD:24:7:=0x00 PI_RDLAT_ADJ_F2:RW:16:7:=0x0e PI_RDLAT_ADJ_F1:RW:8:7:=0x0e PI_RDLAT_ADJ_F0:RW:0:7:=0x05
+	{	0x00000253, (PI_WRLAT_ADJ<<16)|(PI_WRLAT_ADJ<<8)|(PI_WRLAT_ADJ<<0)}, // PI_TDFI_PHY_WRLAT:RD:24:7:=0x00 PI_WRLAT_ADJ_F2:RW:16:7:=0x0c PI_WRLAT_ADJ_F1:RW:8:7:=0x0c PI_WRLAT_ADJ_F0:RW:0:7:=0x02
+//<-
+	{	0x00000254, 0x02060601}, // PI_TDFI_PHY_WRDATA:RW:24:3:=0x02 PI_TDFI_WRCSLAT_F2:RW:16:7:=0x06 PI_TDFI_WRCSLAT_F1:RW:8:7:=0x06 PI_TDFI_WRCSLAT_F0:RW:0:7:=0x01
+	{	0x00000255, 0x00000000}, // RESERVED:RW:24:4:=0x00 RESERVED:RW:16:1:=0x00 PI_CALVL_CS:RW:8:2:=0x00 PI_CALVL_REQ:WR:0:1:=0x00
+	{	0x00000256, 0x00000003}, // PI_CALVL_ROTATE:RW:24:1:=0x00 PI_CALVL_ON_SREF_EXIT:RW:16:1:=0x00 PI_CALVL_PERIODIC:RW:8:1:=0x00 PI_CALVL_SEQ_EN:RW:0:2:=0x03
+//	{	0x00000257, 0x00181703}, // PI_TDFI_CALVL_CC_F0:RW:16:10:=0x0018 PI_TDFI_CALVL_EN:RW:8:8:=0x17 PI_CALVL_CS_MAP:RW:0:4:=0x03
+	{	0x00000257, 0x00181701}, // PI_TDFI_CALVL_CC_F0:RW:16:10:=0x0018 PI_TDFI_CALVL_EN:RW:8:8:=0x17 PI_CALVL_CS_MAP:RW:0:4:=0x03
+	{	0x00000258, 0x00280006}, // PI_TDFI_CALVL_CC_F1:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F0:RW:0:10:=0x0006
+	{	0x00000259, 0x00280016}, // PI_TDFI_CALVL_CC_F2:RW:16:10:=0x0028 PI_TDFI_CALVL_CAPTURE_F1:RW:0:10:=0x0016
+	{	0x0000025A, 0x00000016}, // PI_TDFI_CALVL_CAPTURE_F2:RW:0:10:=0x0016
+	{	0x0000025B, 0x00000000}, // PI_TDFI_CALVL_RESP:RW:0:32:=0x00000000
+	{	0x0000025C, 0x00000000}, // PI_TDFI_CALVL_MAX:RW:0:32:=0x00000000
+	{	0x0000025D, 0x00000000}, // PI_CALVL_ERROR_STATUS:RD:16:2:=0x00 PI_CALVL_EN:RW:8:2:=0x01 PI_CALVL_RESP_MASK:RW:0:1:=0x00
+	{	0x0000025E, 0x140A0000}, // PI_TCAMRD:RW:24:6:=0x14 PI_TCACKEL:RW:16:5:=0x0a PI_CALVL_INTERVAL:RW:0:16:=0x0000
+	{	0x0000025F, 0x00FF010A}, // PI_TCAENT_F0:RW:16:14:=0x0005 PI_TMRZ_F0:RW:8:5:=0x01 PI_TCACKEH:RW:0:5:=0x0a
+	{	0x00000260, 0x03018D03}, // PI_TMRZ_F2:RW:24:5:=0x03 PI_TCAENT_F1:RW:8:14:=0x018d PI_TMRZ_F1:RW:0:5:=0x03
+	{	0x00000261, 0x000A018D}, // PI_CA_TRAIN_VREF_EN:RW:24:1:=0x01 PI_TCAEXT:RW:16:5:=0x0a PI_TCAENT_F2:RW:0:14:=0x018d
+	{	0x00000262, 0x00060100}, // PI_TVREF_SHORT_F0:RW:16:10:=0x0006 PI_TDFI_CASEL_F0:RW:8:5:=0x01 PI_TDFI_CACSCA_F0:RW:0:5:=0x00
+	{	0x00000263, 0x01000006}, // PI_TDFI_CASEL_F1:RW:24:5:=0x01 PI_TDFI_CACSCA_F1:RW:16:5:=0x00 PI_TVREF_LONG_F0:RW:0:10:=0x0006
+	{	0x00000264, 0x018E018E}, // PI_TVREF_LONG_F1:RW:16:10:=0x018e PI_TVREF_SHORT_F1:RW:0:10:=0x018e
+	{	0x00000265, 0x018E0100}, // PI_TVREF_SHORT_F2:RW:16:10:=0x018e PI_TDFI_CASEL_F2:RW:8:5:=0x01 PI_TDFI_CACSCA_F2:RW:0:5:=0x00
+	{	0x00000266, 0x0F0F018E}, // PI_CALVL_VREF_INITIAL_STOP_POINT:RW:24:7:=0x1e PI_CALVL_VREF_INITIAL_START_POINT:RW:16:7:=0x1a PI_TVREF_LONG_F2:RW:0:10:=0x018e
+	{	0x00000267, 0x10010204}, // PI_TDFI_INIT_START_MIN:RW:24:8:=0x10 PI_CALVL_VREF_DELTA:RW:16:4:=0x01 PI_CALVL_VREF_NORMAL_STEPSIZE:RW:8:4:=0x02 PI_CALVL_VREF_INITIAL_STEPSIZE:RW:0:4:=0x04
+	{	0x00000268, 0x09090605}, // PI_TDFI_CALVL_STROBE_F2:RW:24:4:=0x09 PI_TDFI_CALVL_STROBE_F1:RW:16:4:=0x09 PI_TDFI_CALVL_STROBE_F0:RW:8:4:=0x06 PI_TDFI_INIT_COMPLETE_MIN:RW:0:8:=0x05
+//	{	0x00000268, 0x090906ff}, // PI_TDFI_CALVL_STROBE_F2:RW:24:4:=0x09 PI_TDFI_CALVL_STROBE_F1:RW:16:4:=0x09 PI_TDFI_CALVL_STROBE_F0:RW:8:4:=0x06 PI_TDFI_INIT_COMPLETE_MIN:RW:0:8:=0x05
+	{	0x00000269, 0x20000202}, // PI_TDFI_INIT_START_F0:RW:24:8:=0x20 PI_SW_CA_TRAIN_VREF:RW:16:7:=0x00 PI_CALVL_STROBE_NUM:RW:8:5:=0x02 PI_TCKCKEH:RW:0:4:=0x02
+	{	0x0000026A, 0x00201000}, // PI_TDFI_INIT_START_F1:RW:16:8:=0x20 PI_TDFI_INIT_COMPLETE_F0:RW:0:16:=0x1000
+	{	0x0000026B, 0x00201000}, // PI_TDFI_INIT_START_F2:RW:16:8:=0x20 PI_TDFI_INIT_COMPLETE_F1:RW:0:16:=0x1000
+	{	0x0000026C, 0x04041000}, // PI_INIT_STARTORCOMPLETE_2_CLKDISABLE:RW:24:8:=0x04 PI_CLKDISABLE_2_INIT_START:RW:16:8:=0x04 PI_TDFI_INIT_COMPLETE_F2:RW:0:16:=0x1000
+	{	0x0000026D, 0x18020100}, // PI_TCKEHDQS_F1:RW:24:6:=0x18 PI_TCKEHDQS_F0:RW:16:6:=0x02 PI_REFRESH_BETWEEN_SEGMENT_DISABLE:RW_D:8:1:=0x01 PI_DRAM_CLK_DISABLE_DEASSERT_SEL:RW:0:1:=0x00
+	{	0x0000026E, 0x00010118}, // PI_WDQLVL_BST_NUM:RW:16:3:=0x01 PI_WDQLVL_VREF_EN:RW:8:1:=0x01 PI_TCKEHDQS_F2:RW:0:6:=0x18
+	{	0x0000026F, 0x004B004A}, // PI_TDFI_WDQLVL_RW:RW:16:10:=0x004b PI_TDFI_WDQLVL_WR:RW:0:10:=0x004a
+//	{	0x00000270, 0x0F010000}, // PI_WDQLVL_VREF_INITIAL_START_POINT:RW:24:7:=0x1a PI_WDQLVL_CS_MAP:RW:16:4:=0x01 PI_WDQLVL_ROTATE:RW:8:1:=0x00 PI_WDQLVL_RESP_MASK:RW:0:4:=0x00
+	{	0x00000270, 0x0F050000}, // PI_WDQLVL_VREF_INITIAL_START_POINT:RW:24:7:=0x1a PI_WDQLVL_CS_MAP:RW:16:4:=0x01 PI_WDQLVL_ROTATE:RW:8:1:=0x00 PI_WDQLVL_RESP_MASK:RW:0:4:=0x00
+	{	0x00000271, 0x0102040F}, // PI_WDQLVL_VREF_DELTA:RW:24:4:=0x01 PI_WDQLVL_VREF_NORMAL_STEPSIZE:RW:16:5:=0x02 PI_WDQLVL_VREF_INITIAL_STEPSIZE:RW:8:5:=0x04 PI_WDQLVL_VREF_INITIAL_STOP_POINT:RW:0:7:=0x1e
+	{	0x00000272, 0x34000000}, // PI_TDFI_WDQLVL_EN:RW:24:8:=0x34 PI_WDQLVL_CS:RW:16:2:=0x00 PI_WDQLVL_REQ:WR:8:1:=0x00 PI_WDQLVL_PERIODIC:RW:0:1:=0x00
+	{	0x00000273, 0x00000000}, // PI_TDFI_WDQLVL_RESP:RW:0:32:=0x00000000
+	{	0x00000274, 0x00000000}, // PI_TDFI_WDQLVL_MAX:RW:0:32:=0x00000000
+	{	0x00000275, 0x00010000}, // PI_WDQLVL_ON_SREF_EXIT:RW:24:1:=0x00 PI_WDQLVL_EN:RW:16:2:=0x01 PI_WDQLVL_INTERVAL:RW:0:16:=0x0000
+
+// 150819 :
+	{	0x00000276, (PI_MR3 <<24)|(PI_MR2 <<16)|(PI_MR1 <<8)|0x00}, // PI_MR3_DATA_F0_0:RW+:24:8:=0x31 PI_MR2_DATA_F0_0:RW+:16:8:=0x00 PI_MR1_DATA_F0_0:RW+:8:8:=0x00 PI_WDQLVL_ERROR_STATUS:RD:0:2:=0x00
+	{	0x00000277, (PI_MR1 <<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0)}, // PI_MR1_DATA_F1_0:RW+:24:8:=0x50 PI_MR14_DATA_F0_0:RW+:16:8:=0x11 PI_MR12_DATA_F0_0:RW+:8:8:=0x11 PI_MR11_DATA_F0_0:RW+:0:8:=0x00
+	{	0x00000278, (PI_MR12<<24)|(PI_MR11<<16)|(PI_MR3 <<8)|(PI_MR2 <<0)}, // PI_MR12_DATA_F1_0:RW+:24:8:=0x11 PI_MR11_DATA_F1_0:RW+:16:8:=0x00 PI_MR3_DATA_F1_0:RW+:8:8:=0x31 PI_MR2_DATA_F1_0:RW+:0:8:=0x2d
+	{	0x00000279, (PI_MR3 <<24)|(PI_MR2 <<16)|(PI_MR1 <<8)|(PI_MR14<<0)}, // PI_MR3_DATA_F2_0:RW+:24:8:=0x31 PI_MR2_DATA_F2_0:RW+:16:8:=0x2d PI_MR1_DATA_F2_0:RW+:8:8:=0x50 PI_MR14_DATA_F1_0:RW+:0:8:=0x11
+	{	0x0000027A, (PI_MR13<<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0)}, // PI_MR13_DATA_0:RW+:24:8:=0x00 PI_MR14_DATA_F2_0:RW+:16:8:=0x11 PI_MR12_DATA_F2_0:RW+:8:8:=0x11 PI_MR11_DATA_F2_0:RW+:0:8:=0x00
+	{	0x0000027B, (PI_MR11<<24)|(PI_MR3 <<16)|(PI_MR2 <<8)|(PI_MR1 <<0)}, // PI_MR11_DATA_F0_1:RW+:24:8:=0x00 PI_MR3_DATA_F0_1:RW+:16:8:=0x31 PI_MR2_DATA_F0_1:RW+:8:8:=0x00 PI_MR1_DATA_F0_1:RW+:0:8:=0x00
+	{	0x0000027C, (PI_MR2 <<24)|(PI_MR1 <<16)|(PI_MR14<<8)|(PI_MR12<<0)}, // PI_MR2_DATA_F1_1:RW+:24:8:=0x2d PI_MR1_DATA_F1_1:RW+:16:8:=0x50 PI_MR14_DATA_F0_1:RW+:8:8:=0x11 PI_MR12_DATA_F0_1:RW+:0:8:=0x11
+	{	0x0000027D, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(PI_MR3 <<0)}, // PI_MR14_DATA_F1_1:RW+:24:8:=0x11 PI_MR12_DATA_F1_1:RW+:16:8:=0x11 PI_MR11_DATA_F1_1:RW+:8:8:=0x00 PI_MR3_DATA_F1_1:RW+:0:8:=0x31
+	{	0x0000027E, (PI_MR11<<24)|(PI_MR3 <<16)|(PI_MR2 <<8)|(PI_MR1 <<0)}, // PI_MR11_DATA_F2_1:RW+:24:8:=0x00 PI_MR3_DATA_F2_1:RW+:16:8:=0x31 PI_MR2_DATA_F2_1:RW+:8:8:=0x2d PI_MR1_DATA_F2_1:RW+:0:8:=0x50
+	{	0x0000027F, (PI_MR1 <<24)|(PI_MR13<<16)|(PI_MR14<<8)|(PI_MR12<<0)}, // PI_MR1_DATA_F0_2:RW+:24:8:=0x00 PI_MR13_DATA_1:RW+:16:8:=0x00 PI_MR14_DATA_F2_1:RW+:8:8:=0x11 PI_MR12_DATA_F2_1:RW+:0:8:=0x11
+	{	0x00000280, (PI_MR12<<24)|(PI_MR11<<16)|(PI_MR3 <<8)|(PI_MR2 <<0)}, // PI_MR12_DATA_F0_2:RW+:24:8:=0x11 PI_MR11_DATA_F0_2:RW+:16:8:=0x00 PI_MR3_DATA_F0_2:RW+:8:8:=0x31 PI_MR2_DATA_F0_2:RW+:0:8:=0x00
+	{	0x00000281, (PI_MR3 <<24)|(PI_MR2 <<16)|(PI_MR1 <<8)|(PI_MR14<<0)}, // PI_MR3_DATA_F1_2:RW+:24:8:=0x31 PI_MR2_DATA_F1_2:RW+:16:8:=0x2d PI_MR1_DATA_F1_2:RW+:8:8:=0x50 PI_MR14_DATA_F0_2:RW+:0:8:=0x11
+	{	0x00000282, (PI_MR1 <<24)|(PI_MR14<<16)|(PI_MR12<<8)|(PI_MR11<<0)}, // PI_MR1_DATA_F2_2:RW+:24:8:=0x50 PI_MR14_DATA_F1_2:RW+:16:8:=0x11 PI_MR12_DATA_F1_2:RW+:8:8:=0x11 PI_MR11_DATA_F1_2:RW+:0:8:=0x00
+	{	0x00000283, (PI_MR12<<24)|(PI_MR11<<16)|(PI_MR3 <<8)|(PI_MR2 <<0)}, // PI_MR12_DATA_F2_2:RW+:24:8:=0x11 PI_MR11_DATA_F2_2:RW+:16:8:=0x00 PI_MR3_DATA_F2_2:RW+:8:8:=0x31 PI_MR2_DATA_F2_2:RW+:0:8:=0x2d
+	{	0x00000284, (PI_MR2 <<24)|(PI_MR1 <<16)|(PI_MR13<<8)|(PI_MR14<<0)}, // PI_MR2_DATA_F0_3:RW+:24:8:=0x00 PI_MR1_DATA_F0_3:RW+:16:8:=0x00 PI_MR13_DATA_2:RW+:8:8:=0x00 PI_MR14_DATA_F2_2:RW+:0:8:=0x11
+	{	0x00000285, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(PI_MR3 <<0)}, // PI_MR14_DATA_F0_3:RW+:24:8:=0x11 PI_MR12_DATA_F0_3:RW+:16:8:=0x11 PI_MR11_DATA_F0_3:RW+:8:8:=0x00 PI_MR3_DATA_F0_3:RW+:0:8:=0x31
+	{	0x00000286, (PI_MR11<<24)|(PI_MR3 <<16)|(PI_MR2 <<8)|(PI_MR1 <<0)}, // PI_MR11_DATA_F1_3:RW+:24:8:=0x00 PI_MR3_DATA_F1_3:RW+:16:8:=0x31 PI_MR2_DATA_F1_3:RW+:8:8:=0x2d PI_MR1_DATA_F1_3:RW+:0:8:=0x50
+	{	0x00000287, (PI_MR2 <<24)|(PI_MR1 <<16)|(PI_MR14<<8)|(PI_MR12<<0)}, // PI_MR2_DATA_F2_3:RW+:24:8:=0x2d PI_MR1_DATA_F2_3:RW+:16:8:=0x50 PI_MR14_DATA_F1_3:RW+:8:8:=0x11 PI_MR12_DATA_F1_3:RW+:0:8:=0x11
+	{	0x00000288, (PI_MR14<<24)|(PI_MR12<<16)|(PI_MR11<<8)|(PI_MR3 <<0)}, // PI_MR14_DATA_F2_3:RW+:24:8:=0x11 PI_MR12_DATA_F2_3:RW+:16:8:=0x11 PI_MR11_DATA_F2_3:RW+:8:8:=0x00 PI_MR3_DATA_F2_3:RW+:0:8:=0x31
+	{	0x00000289, 0x00020000                              |(PI_MR13<<0)}, // PI_ROW_DIFF:RW:16:3:=0x02 PI_BANK_DIFF:RW:8:2:=0x00 PI_MR13_DATA_3:RW+:0:8:=0x00
+
+//150819-> //F0-F2 have same value
+	{	0x0000028A, (PI_TFC<<16)|(PI_TFC<<0)}, // PI_TFC_F1:RW:16:10:=0x018d PI_TFC_F0:RW:0:10:=0x0005
+	{	0x0000028B, (PI_TRTP<<24)|(PI_TCCD<<16)|(PI_TFC<<0)}, // PI_TRTP_F0:RW:24:4:=0x08 PI_TCCD:RW:16:5:=0x08 PI_TFC_F2:RW:0:10:=0x018d
+	{	0x0000028C, (PI_TWR<<24) |(PI_TWTR<<16)|(PI_TRCD<<8)|(PI_TRP<<0)}, // PI_TWR_F0:RW:24:6:=0x04 PI_TWTR_F0:RW:16:6:=0x06 PI_TRCD_F0:RW:8:8:=0x04 PI_TRP_F0:RW:0:8:=0x03
+	{	0x0000028D, (PI_TRAS_MIN<<24)|(PI_TRAS_MAX<<0)}, // PI_TRAS_MIN_F0:RW:24:8:=0x03 PI_TRAS_MAX_F0:RW:0:17:=0x000578
+	{	0x0000028E, (PI_TMRW<<24) | (PI_TMRD<<16)|(PI_TCCDMW<<8)|(PI_TDQSCK_MAX<<0)}, // PI_TMRW_F0:RW:24:8:=0x0a PI_TMRD_F0:RW:16:6:=0x0a PI_TCCDMW_F0:RW:8:6:=0x20 PI_TDQSCK_MAX_F0:RW:0:4:=0x01
+	{	0x0000028F, (PI_TWTR<<24) | (PI_TRCD<<16)|(PI_TRP<<8)   |(PI_TRTP<<0)}, // PI_TWTR_F1:RW:24:6:=0x12 PI_TRCD_F1:RW:16:8:=0x1d PI_TRP_F1:RW:8:8:=0x22 PI_TRTP_F1:RW:0:4:=0x0c
+	{	0x00000290, (PI_TRAS_MAX<<8) | (PI_TWR<<0)}, // PI_TRAS_MAX_F1:RW:8:17:=0x01b207 PI_TWR_F1:RW:0:6:=0x1f
+	{	0x00000291, (PI_TMRD<<24) | (PI_TCCDMW<<16) | (PI_TDQSCK_MAX<<8)|(PI_TRAS_MIN<<0)}, // PI_TMRD_F1:RW:24:6:=0x17 PI_TCCDMW_F1:RW:16:6:=0x20 PI_TDQSCK_MAX_F1:RW:8:4:=0x06 PI_TRAS_MIN_F1:RW:0:8:=0x43
+	{	0x00000292, (PI_TRCD<<24) | (PI_TRP<<16) | (PI_TRTP<<8)|(PI_TMRW<<0)}, // PI_TRCD_F2:RW:24:8:=0x1d PI_TRP_F2:RW:16:8:=0x22 PI_TRTP_F2:RW:8:4:=0x0c PI_TMRW_F1:RW:0:8:=0x0a
+	{	0x00000293, (PI_TWR<<8)|(PI_TWTR<<0)}, // PI_TWR_F2:RW:8:6:=0x1f PI_TWTR_F2:RW:0:6:=0x12
+	{	0x00000294, (PI_TRAS_MIN<<24)|(PI_TRAS_MAX<<0)}, // PI_TRAS_MIN_F2:RW:24:8:=0x43 PI_TRAS_MAX_F2:RW:0:17:=0x01b207
+	{	0x00000295, (PI_TMRW<<24) | (PI_TMRD<<16)|(PI_TCCDMW<<8)|(PI_TDQSCK_MAX<<0)}, // PI_TMRW_F2:RW:24:8:=0x0a PI_TMRD_F2:RW:16:6:=0x17 PI_TCCDMW_F2:RW:8:6:=0x20 PI_TDQSCK_MAX_F2:RW:0:4:=0x06	
+//<-
+	{	0x00000296, 0x00020002}, // RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02
+	{	0x00000297, 0x00020002}, // RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02
+	{	0x00000298, 0x00020002}, // RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02
+	{	0x00000299, 0x00020002}, // RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02
+	{	0x0000029A, 0x00020002}, // RESERVED:RW_D:24:4:=0x00 RESERVED:RW_D:16:4:=0x02 RESERVED:RW_D:8:4:=0x00 RESERVED:RW_D:0:4:=0x02
+	{	0x0000029B, 0x00000000}, // PI_INT_STATUS:RD:0:17:=0x000000
+	{	0x0000029C, 0x00000000}, // PI_INT_ACK:WR:0:16:=0x0000
+	{	0x0000029D, 0x00000000}, // PI_INT_MASK:RW:0:17:=0x000000
+	{	0x0000029E, 0x00000000}, // PI_BIST_EXP_DATA:RD:0:128:=0x00000000
+	{	0x0000029F, 0x00000000}, // PI_BIST_EXP_DATA:RD:0:128:=0x00000000
+	{	0x000002A0, 0x00000000}, // PI_BIST_EXP_DATA:RD:0:128:=0x00000000
+	{	0x000002A1, 0x00000000}, // PI_BIST_EXP_DATA:RD:0:128:=0x00000000
+	{	0x000002A2, 0x00000000}, // PI_BIST_FAIL_DATA:RD:0:128:=0x00000000
+	{	0x000002A3, 0x00000000}, // PI_BIST_FAIL_DATA:RD:0:128:=0x00000000
+	{	0x000002A4, 0x00000000}, // PI_BIST_FAIL_DATA:RD:0:128:=0x00000000
+	{	0x000002A5, 0x00000000}, // PI_BIST_FAIL_DATA:RD:0:128:=0x00000000
+	{	0x000002A6, 0x00000000}, // PI_BIST_FAIL_ADDR:RD:0:34:=0x00000000
+	{	0x000002A7, 0x01000400}, // PI_CTRLUPD_REQ_PER_AREF_EN:RW:24:1:=0x01 PI_LONG_COUNT_MASK:RW:16:5:=0x00 PI_BSTLEN:RW_D:8:5:=0x04 PI_BIST_FAIL_ADDR:RD:0:34:=0x00
+	{	0x000002A8, 0x00008C00}, // PI_TDFI_CTRLUPD_MAX_F0:RW:8:16:=0x008c PI_TDFI_CTRLUPD_MIN:RD:0:4:=0x00
+	{	0x000002A9, 0x00000578}, // PI_TDFI_CTRLUPD_INTERVAL_F0:RW:0:32:=0x00000578
+	{	0x000002AA, 0x0000304C}, // PI_TDFI_CTRLUPD_MAX_F1:RW:0:16:=0x304c
+	{	0x000002AB, 0x0001E2F8}, // PI_TDFI_CTRLUPD_INTERVAL_F1:RW:0:32:=0x0001e2f8
+	{	0x000002AC, 0x0000304C}, // PI_TDFI_CTRLUPD_MAX_F2:RW:0:16:=0x304c
+	{	0x000002AD, 0x0001E2F8}, // PI_TDFI_CTRLUPD_INTERVAL_F2:RW:0:32:=0x0001e2f8
+	{	0x000002AE, 0x04000001}, // PI_ADDR_SPACE:RW:24:6:=0x08 PI_BIST_RESULT:RD:16:2:=0x00 PI_BIST_GO:WR:8:1:=0x00 PI_UPDATE_ERROR_STATUS:RD:0:7:=0x00
+	{	0x000002AF, 0x00000001}, // PI_BIST_ADDR_CHECK:RW:8:1:=0x01 PI_BIST_DATA_CHECK:RW:0:1:=0x00
+	{	0x000002B0, 0x00000000}, // PI_BIST_START_ADDRESS:RW:0:34:=0x00000000
+	{	0x000002B1, 0x00000000}, // PI_BIST_START_ADDRESS:RW:0:34:=0x00
+//	{	0x000002B2, 0x00000000}, // PI_BIST_DATA_MASK:RW:0:64:=0x00000000
+//	{	0x000002B3, 0x00000000}, // PI_BIST_DATA_MASK:RW:0:64:=0x00000000
+	{	0x000002B2, 0xFFFFFFff}, // PI_BIST_DATA_MASK:RW:0:64:=0x00000000
+	{	0x000002B3, 0xFFFFFFFF}, // PI_BIST_DATA_MASK:RW:0:64:=0x00000000
+	{	0x000002B4, 0x00000001}, // PI_COL_DIFF:RW:0:4:=0x01
+};
+
+
+
+static const uint32_t DDR_PHY_DDR_PHY_PVT_OVERWITE_1600[DDR_PHY_PVT_OVERWRITE_NUM][2] = 
+{
+
+// By JTAG
+	{	0x0000071E, ((0x31 << 12) |(0x20 << 6) |( 0x12))}, // PHY_PAD_FDBK_TERM:RW+:0:18:= pvtr[4:0] 0x11, pvtn[5:0] 0x20, pvtp[5:0] 0x12
+	{	0x0000071F, ((0x11 << 12) |(0x20 << 6) |( 0x12))}, // PHY_PAD_DATA_TERM:RW+:0:17:= pvtr[4:0] 0x11, pvtn[5:0] 0x20, pvtp[5:0] 0x12
+	{	0x00000720, ((0x11 << 12) |(0x20 << 6) |( 0x12))}, // PHY_PAD_DQS_TERM:RW+:0:17:=  pvtr[4:0] 0x11, pvtn[5:0] 0x20, pvtp[5:0] 0x12
+	{	0x00000721, ((0x11 << 12) |(0x20 << 6) |( 0x12))}, // PHY_PAD_ADDR_TERM:RW+:0:18:= pvtr[4:0] 0x11, pvtn[5:0] 0x20, pvtp[5:0] 0x12
+	{	0x00000722, ((0x11 << 12) |(0x20 << 6) |( 0x12))}, // PHY_PAD_CLK_TERM:RW+:0:18:= pvtr[4:0] 0x11, pvtn[5:0] 0x20, pvtp[5:0] 0x12
+	{	0x00000724, ((0x11 << 12) |(0x20 << 6) |( 0x12))}, // PHY_PAD_CKE_TERM:RW+:0:18:= pvtr[4:0] 0x11, pvtn[5:0] 0x20, pvtp[5:0] 0x12
+	{	0x00000726, ((0x11 << 12) |(0x20 << 6) |( 0x12))}, // PHY_PAD_RST_TERM:RW+:0:18:= pvtr[4:0] 0x11, pvtn[5:0] 0x20, pvtp[5:0] 0x12
+	{	0x00000728, ((0x11 << 12) |(0x20 << 6) |( 0x12))}, // PHY_PAD_CS_TERM:RW+:0:18:= pvtr[4:0] 0x11, pvtn[5:0] 0x20, pvtp[5:0] 0x12
+
+};
+
+static const uint32_t DDR_SIP_SWAP_CH0[9+5][2] = 
+{
+	{	0x00000420, 0x20741365}, // PHY_DQ_SWIZZLING_0:RW:0:32:=0x76543210	// SoC DQ7-0   -> SDRAM 20741365 : 00101101 : 2d -> d2
+	{	0x000004A0, 0x34256107}, // PHY_DQ_SWIZZLING_1:RW:0:32:=0x76543210	// SoC DQ15-8  -> SDRAM 34256107 : 10010101 : 95 -> 6a
+	{	0x00000520, 0x57460321}, // PHY_DQ_SWIZZLING_2:RW:0:32:=0x76543210	// SoC DQ23-16 -> SDRAM 57460321 : 11000101 : c5 -> 3a
+	{	0x000005A0, 0x70614532}, // PHY_DQ_SWIZZLING_3:RW:0:32:=0x76543210	// SoC DQ31-24 -> SDRAM 70614532 : 10010110 : 96 -> 69
+	{	0x0000061C, 0x00543210}, // PHY_ADR_ADDR_SEL_0:RW:0:24:=0x543210		// SoC AC5-0   -> DRAM 543210
+	{	0x0000060C, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE0_0_0:RW:0:24:=0xdcba98												// SoC Byte0   -> DRAM Byte 0
+	{	0x0000060D, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE1_0_0:RW:0:24:=0x000000												// SoC Byte1   -> DRAM Byte 1
+	{	0x0000060E, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE0_1_0:RW:0:24:=0xdcba98												// SoC Byte2   -> DRAM Byte 2
+	{	0x0000060F, 0x01DCBA98}, // PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000	// SoC Byte3   -> DRAM Byte 3
+	{	0x00000250, 0x01080000}, // PI_RDLVL_PATTERN_NUM:RW:24:4:=0x01 PI_RDLVL_PATTERN_START:RW:16:4:=0x00 PI_RDLVL_GATE_INTERVAL:RW:0:16:=0x0000
+//	{	0x0000040E, 0x6aca5a3c}, // PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000
+//	{	0x0000048E, 0x6aca5a3c}, // PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000
+//	{	0x0000050E, 0x693a5a3c}, // PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000
+//	{	0x0000058E, 0x693a5a3c}, // PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000
+	// MR15(inv_for_dql), MR20(inv_for_dqh), MR32(5a), MR40(3c)
+	{	0x0000040E, 0xd26a5a3c}, // PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000
+	{	0x0000048E, 0xd26a5a3c}, // PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000
+	{	0x0000050E, 0x3a695a3c}, // PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000
+	{	0x0000058E, 0x3a695a3c}, // PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000	
+};
+
+static const uint32_t DDR_SIP_SWAP_CH1[9+5][2] = 
+{
+	{	0x00000420, 0x23547610}, // PHY_DQ_SWIZZLING_0:RW:0:32:=0x76543210	// SoC DQ7-0   -> SDRAM 23547610 : 01101010 : 6a -> 95
+	{	0x000004A0, 0x34526107}, // PHY_DQ_SWIZZLING_1:RW:0:32:=0x76543210	// SoC DQ15-8  -> SDRAM 34526107 : 10100101 : a5 -> 5a
+	{	0x00000520, 0x67452310}, // PHY_DQ_SWIZZLING_2:RW:0:32:=0x76543210	// SoC DQ23-16 -> SDRAM 67452310 : 01010110 : 56 -> a9
+	{	0x000005A0, 0x32106754}, // PHY_DQ_SWIZZLING_3:RW:0:32:=0x76543210	// SoC DQ31-24 -> SDRAM 32106754 : 10100110 : a6 -> 59
+	{	0x0000061C, 0x00543210}, // PHY_ADR_ADDR_SEL_0:RW:0:24:=0x543210		// SoC AC5-0   -> DRAM 543210
+//	{	0x0000060C, 0x00543210}, // PHY_ADR_CALVL_SWIZZLE0_0_0:RW:0:24:=0xdcba98												// SoC Byte0   -> DRAM Byte 2
+//	{	0x0000060D, 0x00543210}, // PHY_ADR_CALVL_SWIZZLE1_0_0:RW:0:24:=0x000000												// SoC Byte1   -> DRAM Byte 0
+//	{	0x0000060E, 0x00543210}, // PHY_ADR_CALVL_SWIZZLE0_1_0:RW:0:24:=0xdcba98												// SoC Byte2   -> DRAM Byte 1
+////	{	0x0000060F, 0x02543210}, // PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000	// SoC Byte3   -> DRAM Byte 3
+//	{	0x0000060F, 0x01543210}, // PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000	// SoC Byte3   -> DRAM Byte 3
+
+//	{	0x0000061C, 0x00dcba98}, // PHY_ADR_ADDR_SEL_0:RW:0:24:=0x543210		// SoC AC5-0   -> DRAM 543210
+	{	0x0000060C, 0x00dcba98}, // PHY_ADR_CALVL_SWIZZLE0_0_0:RW:0:24:=0xdcba98												// SoC Byte0   -> DRAM Byte 2
+	{	0x0000060D, 0x00dcba98}, // PHY_ADR_CALVL_SWIZZLE1_0_0:RW:0:24:=0x000000												// SoC Byte1   -> DRAM Byte 0
+	{	0x0000060E, 0x00dcba98}, // PHY_ADR_CALVL_SWIZZLE0_1_0:RW:0:24:=0xdcba98												// SoC Byte2   -> DRAM Byte 1
+	{	0x0000060F, 0x02dcba98}, // PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000	// SoC Byte3   -> DRAM Byte 3
+//	{	0x0000060F, 0x01dcba98}, // PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000	// SoC Byte3   -> DRAM Byte 3
+
+	{	0x00000250, 0x01080000}, // PI_RDLVL_PATTERN_NUM:RW:24:4:=0x01 PI_RDLVL_PATTERN_START:RW:16:4:=0x00 PI_RDLVL_GATE_INTERVAL:RW:0:16:=0x0000
+//	{	0x0000040E, 0x59555a3c}, // PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000
+//	{	0x0000048E, 0x59555a3c}, // PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000
+//	{	0x0000050E, 0xa9595a3c}, // PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000
+//	{	0x0000058E, 0xa9595a3c}, // PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000
+	// MR15(inv_for_dql), MR20(inv_for_dqh), MR32(5a), MR40(3c)	
+	{	0x0000040E, 0x955a5a3c}, // PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000
+	{	0x0000048E, 0x955a5a3c}, // PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000
+	{	0x0000050E, 0xa9595a3c}, // PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000
+	{	0x0000058E, 0xa9595a3c}, // PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000
+};
+
+static const uint32_t DDR_SIP_SWAP_CH2[9+5][2] = 
+{
+	{	0x00000420, 0x30216754}, // PHY_DQ_SWIZZLING_0:RW:0:32:=0x76543210	// SoC DQ7-0   -> SDRAM 30216754 : 10010110 : 96 -> 69
+	{	0x000004A0, 0x67453210}, // PHY_DQ_SWIZZLING_1:RW:0:32:=0x76543210	// SoC DQ15-8  -> SDRAM 67453210 : 01011010 : 5a -> a5
+	{	0x00000520, 0x70165243}, // PHY_DQ_SWIZZLING_2:RW:0:32:=0x76543210	// SoC DQ23-16 -> SDRAM 70165243 : 10101001 : a9 -> 56
+	{	0x000005A0, 0x07162345}, // PHY_DQ_SWIZZLING_3:RW:0:32:=0x76543210	// SoC DQ31-24 -> SDRAM 07162345 : 01100101 : 65 -> 9a
+	{	0x0000061C, 0x00543210}, // PHY_ADR_ADDR_SEL_0:RW:0:24:=0x543210		// SoC AC5-0   -> DRAM 543210
+	{	0x0000060C, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE0_0_0:RW:0:24:=0xdcba98												// SoC Byte0   -> DRAM Byte 3
+	{	0x0000060D, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE1_0_0:RW:0:24:=0x000000												// SoC Byte1   -> DRAM Byte 1
+	{	0x0000060E, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE0_1_0:RW:0:24:=0xdcba98												// SoC Byte2   -> DRAM Byte 2
+	{	0x0000060F, 0x01DCBA98}, // PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000	// SoC Byte3   -> DRAM Byte 0
+	{	0x00000250, 0x01080000}, // PI_RDLVL_PATTERN_NUM:RW:24:4:=0x01 PI_RDLVL_PATTERN_START:RW:16:4:=0x00 PI_RDLVL_GATE_INTERVAL:RW:0:16:=0x0000
+//	{	0x0000040E, 0xa5695a3c}, // PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000
+//	{	0x0000048E, 0xa5695a3c}, // PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000
+//	{	0x0000050E, 0x9a565a3c}, // PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000
+//	{	0x0000058E, 0x9a565a3c}, // PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000
+	// MR15(inv_for_dql), MR20(inv_for_dqh), MR32(5a), MR40(3c)		
+	{	0x0000040E, 0x69a55a3c}, // PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000
+	{	0x0000048E, 0x69a55a3c}, // PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000
+	{	0x0000050E, 0x569a5a3c}, // PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000
+	{	0x0000058E, 0x569a5a3c}, // PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000	
+};
+
+static const uint32_t DDR_SIP_SWAP_CH3[9+5][2] = 
+{
+	{	0x00000420, 0x01327654}, // PHY_DQ_SWIZZLING_0:RW:0:32:=0x76543210	// SoC DQ7-0   -> SDRAM : 01327654 : 01101010 : 6a -> 95
+	{	0x000004A0, 0x70615432}, // PHY_DQ_SWIZZLING_1:RW:0:32:=0x76543210	// SoC DQ15-8  -> SDRAM : 70615432 : 10011010 : 9a -> 65
+	{	0x00000520, 0x54760123}, // PHY_DQ_SWIZZLING_2:RW:0:32:=0x76543210	// SoC DQ23-16 -> SDRAM : 54760123 : 10100101 : a5 -> 5a
+	{	0x000005A0, 0x07162345}, // PHY_DQ_SWIZZLING_3:RW:0:32:=0x76543210	// SoC DQ31-24 -> SDRAM : 07162345 : 01100101 : 65 -> 9a
+	{	0x0000061C, 0x00543210}, // PHY_ADR_ADDR_SEL_0:RW:0:24:=0x543210		// SoC AC5-0   -> DRAM 543210
+	{	0x0000060C, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE0_0_0:RW:0:24:=0xdcba98												// SoC Byte0   -> DRAM Byte 3
+	{	0x0000060D, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE1_0_0:RW:0:24:=0x000000												// SoC Byte1   -> DRAM Byte 1
+	{	0x0000060E, 0x00DCBA98}, // PHY_ADR_CALVL_SWIZZLE0_1_0:RW:0:24:=0xdcba98												// SoC Byte2   -> DRAM Byte 2
+	{	0x0000060F, 0x01DCBA98}, // PHY_ADR_CALVL_DEVICE_MAP_0:RW:24:4:=0x01 PHY_ADR_CALVL_SWIZZLE1_1_0:RW:0:24:=0x000000	// SoC Byte3   -> DRAM Byte 0
+	{	0x00000250, 0x01080000}, // PI_RDLVL_PATTERN_NUM:RW:24:4:=0x01 PI_RDLVL_PATTERN_START:RW:16:4:=0x00 PI_RDLVL_GATE_INTERVAL:RW:0:16:=0x0000
+//	{	0x0000040E, 0x65955a3c}, // PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000
+//	{	0x0000048E, 0x65955a3c}, // PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000
+//	{	0x0000050E, 0x9a5a5a3c}, // PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000
+//	{	0x0000058E, 0x9a5a5a3c}, // PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000
+	// MR15(inv_for_dql), MR20(inv_for_dqh), MR32(5a), MR40(3c)			
+	{	0x0000040E, 0x95655a3c}, // PHY_LP4_RDLVL_PATT8_0:RW:0:32:=0x00000000
+	{	0x0000048E, 0x95655a3c}, // PHY_LP4_RDLVL_PATT8_1:RW:0:32:=0x00000000
+	{	0x0000050E, 0x5a9a5a3c}, // PHY_LP4_RDLVL_PATT8_2:RW:0:32:=0x00000000
+	{	0x0000058E, 0x5a9a5a3c}, // PHY_LP4_RDLVL_PATT8_3:RW:0:32:=0x00000000	
+};
+
+static const uint32_t DDR_CA_DELAY[7][2] = 
+{
+	{	0x0000061F, 0x0002A06E}, // PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55				//CA0 delay this means 768/512 tCK delay for address bit
+	{	0x00000620, 0x02A002A0}, // PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA1/2 delay
+	{	0x00000621, 0x02A002A0}, // PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA3/4 delay
+	{	0x00000622, 0x000002A0}, // PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300			//CA5 delay
+	{	0x00000712, 0x0002A003}, // PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03							//CS0 group delay
+	{	0x00000713, 0x02A002A0}, // PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300					//CS1/2 group delay
+	{	0x00000714, 0x000002A0}, // PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300															//CS3 group delay
+};
+
+
+static const uint32_t DDR_CA_DELAY_CH0[7][2] = 
+{
+	{	0x0000061F, 0x0002c06E}, // PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55				//CA0 delay this means 768/512 tCK delay for address bit
+	{	0x00000620, 0x02c002c0}, // PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA1/2 delay
+	{	0x00000621, 0x02c002c0}, // PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA3/4 delay
+	{	0x00000622, 0x000002c0}, // PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300			//CA5 delay
+	{	0x00000712, 0x0002c003}, // PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03							//CS0 group delay
+	{	0x00000713, 0x02c002c0}, // PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300					//CS1/2 group delay
+	{	0x00000714, 0x000002c0}, // PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300															//CS3 group delay
+};
+
+static const uint32_t DDR_CA_DELAY_CH1[7][2] = 
+{
+	{	0x0000061F, 0x0002C06E}, // PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55				//CA0 delay this means 768/512 tCK delay for address bit
+	{	0x00000620, 0x02C002C0}, // PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA1/2 delay
+	{	0x00000621, 0x02C002C0}, // PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA3/4 delay
+	{	0x00000622, 0x000002C0}, // PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300			//CA5 delay
+	{	0x00000712, 0x0002D003}, // PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03							//CS0 group delay
+	{	0x00000713, 0x02D002D0}, // PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300					//CS1/2 group delay
+	{	0x00000714, 0x000002D0}, // PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300															//CS3 group delay
+};
+
+static const uint32_t DDR_CA_DELAY_CH2[7][2] = 
+{
+	{	0x0000061F, 0x0002C06E}, // PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55				//CA0 delay this means 768/512 tCK delay for address bit
+	{	0x00000620, 0x02C002C0}, // PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA1/2 delay
+	{	0x00000621, 0x02C002C0}, // PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA3/4 delay
+	{	0x00000622, 0x000002C0}, // PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300			//CA5 delay
+	{	0x00000712, 0x0002C003}, // PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03							//CS0 group delay
+	{	0x00000713, 0x02C002C0}, // PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300					//CS1/2 group delay
+	{	0x00000714, 0x000002C0}, // PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300															//CS3 group delay
+};
+
+static const uint32_t DDR_CA_DELAY_CH3[7][2] = 
+{
+	{	0x0000061F, 0x0002C06E}, // PHY_ADR0_CLK_WR_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_ADR_TSEL_SELECT_0:RW+:0:8:=0x55				//CA0 delay this means 768/512 tCK delay for address bit
+	{	0x00000620, 0x02C002C0}, // PHY_ADR2_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR1_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA1/2 delay
+	{	0x00000621, 0x02C002C0}, // PHY_ADR4_CLK_WR_SLAVE_DELAY_0:RW+:16:11:=0x0300 PHY_ADR3_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300	//CA3/4 delay
+	{	0x00000622, 0x000002C0}, // PHY_ADR_SW_MASTER_MODE_0:RW+:16:4:=0x00 PHY_ADR5_CLK_WR_SLAVE_DELAY_0:RW+:0:11:=0x0300			//CA5 delay
+	{	0x00000712, 0x0002C003}, // PHY_GRP_SLAVE_DELAY_0:RW+:8:11:=0x0300 PHY_CSLVL_DLY_STEP:RW+:0:4:=0x03							//CS0 group delay
+	{	0x00000713, 0x02C002C0}, // PHY_GRP_SLAVE_DELAY_2:RW+:16:11:=0x0300 PHY_GRP_SLAVE_DELAY_1:RW+:0:11:=0x0300					//CS1/2 group delay
+	{	0x00000714, 0x000002C0}, // PHY_GRP_SLAVE_DELAY_3:RW+:0:11:=0x0300															//CS3 group delay
+};
+
+#endif /* __INIT_DRAM_TBL_ */
diff --git a/plat/renesas/rcar/drivers/dma/dma_driver.c b/plat/renesas/rcar/drivers/dma/dma_driver.c
new file mode 100644
index 0000000..c4d5519
--- /dev/null
+++ b/plat/renesas/rcar/drivers/dma/dma_driver.c
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include "bl2_cpg_register.h"
+#include "bl2_cpg_write.h"
+#include "bl2_dma_register.h"
+#include "dma_driver.h"
+#include "debug.h"
+
+static void regdump(void);
+
+static void enableDMA(void);
+static void setupDMA(void);
+static void startDMA(uint32_t dst, uint32_t src, uint32_t len);
+static void endDMA(void);
+#if DEBUG
+static void disableDMA(void);
+#endif
+
+static void regdump(void)
+{
+#if DEBUG
+	INFO("BL2:\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n",
+		"CPG_SMSTPCR2",CPG_SMSTPCR2,mmio_read_32(CPG_SMSTPCR2),
+		"CPG_SRCR2   ",CPG_SRCR2,mmio_read_32(CPG_SRCR2),
+		"CPG_MSTPSR2 ",CPG_MSTPSR2,mmio_read_32(CPG_MSTPSR2),
+		"DMAOR2      ",DMA_DMAOR2,mmio_read_16(DMA_DMAOR2),
+		"DMASEC2     ",DMA_DMASEC2,mmio_read_32(DMA_DMASEC2),
+		"DMACHCLR2   ",DMA_DMACHCLR2,mmio_read_32(DMA_DMACHCLR2),
+		"DMASAR32    ",DMA_DMASAR32,mmio_read_32(DMA_DMASAR32),
+		"DMADAR32    ",DMA_DMADAR32,mmio_read_32(DMA_DMADAR32),
+		"DMATCR32    ",DMA_DMATCR32,mmio_read_32(DMA_DMATCR32),
+		"DMACHCR32   ",DMA_DMACHCR32,mmio_read_32(DMA_DMACHCR32)
+	);
+#endif
+}
+
+static void enableDMA(void)
+{
+	/* Is the clock supply to the CPG disabled ? */
+	while((mmio_read_32(CPG_MSTPSR2) & SYS_DMAC2_BIT) != 0U) {
+		/* Enables the clock supply to the CPG. */
+		cpg_write(CPG_SMSTPCR2,
+			mmio_read_32(CPG_SMSTPCR2) & (~SYS_DMAC2_BIT));
+	}
+}
+
+static void setupDMA(void)
+{
+	/* DMA operation 2 */
+	mmio_write_16(DMA_DMAOR2,0x0000U);
+	/* DMA channel clear 2 */
+	mmio_write_32(DMA_DMACHCLR2,0x0000FFFFU);
+	mmio_write_32(DMA_DMACHCLR2,0x00000000U);
+}
+
+static void startDMA(uint32_t dst, uint32_t src, uint32_t len)
+{
+	/* DMA operation 2 */
+	mmio_write_16(DMA_DMAOR2,0x0301U);
+	/* DMA destination address 32 */
+	mmio_write_32(DMA_DMADAR32,dst);
+	/* DMA source address 32 */
+	mmio_write_32(DMA_DMASAR32,src);
+	/* DMA 64bytes-unit transfer  count 32 */
+	mmio_write_32(DMA_DMATCR32,len >> 6);
+	/* DMA channel control 32 */
+	mmio_write_32(DMA_DMACHCR32,0x00105409U);
+}
+
+static void endDMA(void)
+{
+	/* DMA channel control 32 */
+	while((mmio_read_32(DMA_DMACHCR32) & 0x00000002U) == 0x00000000U) {
+		/* DMA channel control 32 */
+		if ((mmio_read_32(DMA_DMACHCR32) & 0x80000000U) != 0U) {
+			ERROR("BL2: DMA - Channel Address Error\n");
+			regdump();
+			break;
+		}
+	}
+	/* DMA operation 2 */
+	mmio_write_16(DMA_DMAOR2,0x0000U);
+	/* DMA channel clear 2 */
+	mmio_write_32(DMA_DMACHCLR2,0x00000001U);
+	mmio_write_32(DMA_DMACHCLR2,0x00000000U);
+}
+
+#if DEBUG
+static void disableDMA(void)
+{
+	/* Disable the clock supply to the CPG. */
+	cpg_write(CPG_SMSTPCR2,
+		mmio_read_32(CPG_SMSTPCR2) | SYS_DMAC2_BIT);
+}
+#endif
+
+void initDMA(void)
+{
+	enableDMA();
+	setupDMA();
+}
+
+void execDMA(uint32_t dst, uint32_t src, uint32_t len)
+{
+	uint32_t dmalen;
+	uint32_t memlen;
+
+	if (((dst & 0x3FU) != 0U) || ((src & 0x3FU) != 0U) ||
+		((len & 0xC0000000U) != 0U)) {
+		/* dst or src are not 64-bit alignment. */
+		dmalen = 0U;
+		memlen = len;
+	} else {
+		/* dst and src are 64-bit alignment. */
+		dmalen = len & 0x3FFFFFC0U;
+		memlen = len & 0x3FU;
+	}
+	if (dmalen != 0U) {
+		startDMA(dst, src, dmalen);
+		endDMA();
+		dst += dmalen;
+		src += dmalen;
+	} else {
+		if (memlen == 0U) {
+			startDMA(dst, src, 0U);
+			endDMA();
+			dmalen = 0x01000000U << 6;
+			dst += dmalen;
+			src += dmalen;
+		}
+	}
+	if (memlen != 0U) {
+		(void)memcpy((void*)(uint64_t)dst,
+			(const void*)(uint64_t)src,
+				(size_t)memlen);
+	}
+	if (dmalen != 0U) {
+		INFO("BL2: %s (%d) DMA    len=%d(0x%x)\n",
+			__FUNCTION__, __LINE__,	dmalen, dmalen);
+	}
+	if (memlen != 0U) {
+		INFO("BL2: %s (%d) memcpy len=%d(0x%x)\n",
+			__FUNCTION__, __LINE__, memlen, memlen);
+	}
+}
+
+#if DEBUG
+void termDMA(void)
+{
+	disableDMA();
+}
+#endif
diff --git a/plat/renesas/rcar/drivers/io/io_memdrv.c b/plat/renesas/rcar/drivers/io/io_memdrv.c
new file mode 100644
index 0000000..c864b6b
--- /dev/null
+++ b/plat/renesas/rcar/drivers/io/io_memdrv.c
@@ -0,0 +1,237 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <debug.h>
+#include <io_driver.h>
+#include <io_storage.h>
+#include <string.h>
+#include "io_memdrv.h"
+#include "dma_driver.h"
+
+/* As we need to be able to keep state for seek, only one file can be open
+ * at a time. Make this a structure and point to the entity->info. When we
+ * can malloc memory we can change this to support more open files.
+ */
+typedef struct {
+	/* Use the 'in_use' flag as any value for base and file_pos could be
+	 * valid.
+	 */
+	uint32_t	in_use;
+	uintptr_t	base;
+	ssize_t		file_pos;
+} file_state_t;
+
+static file_state_t current_file = {0};
+
+/* memdrv device functions */
+static io_type_t device_type_memdrv(void);
+static int32_t memdrv_dev_open(const uintptr_t dev_spec,
+				io_dev_info_t **dev_info);
+static int32_t memdrv_block_open(io_dev_info_t *dev_info, const uintptr_t spec,
+			     io_entity_t *entity);
+static int32_t memdrv_block_seek(io_entity_t *entity, int32_t mode,
+			     ssize_t offset);
+static int32_t memdrv_block_read(io_entity_t *entity, uintptr_t buffer,
+			     size_t length, size_t *length_read);
+static int32_t memdrv_block_close(io_entity_t *entity);
+static int32_t memdrv_dev_close(io_dev_info_t *dev_info);
+
+
+static const io_dev_connector_t memdrv_dev_connector = {
+	.dev_open = &memdrv_dev_open
+};
+
+
+static const io_dev_funcs_t memdrv_dev_funcs = {
+	.type = &device_type_memdrv,
+	.open = &memdrv_block_open,
+	.seek = &memdrv_block_seek,
+	.size = NULL,
+	.read = &memdrv_block_read,
+	.write = NULL,
+	.close = &memdrv_block_close,
+	.dev_init = NULL,
+	.dev_close = &memdrv_dev_close,
+};
+
+
+/* No state associated with this device so structure can be const */
+static const io_dev_info_t memdrv_dev_info = {
+	.funcs = &memdrv_dev_funcs,
+	.info = (uintptr_t)0
+};
+
+/* Identify the device type as memdrv */
+static io_type_t device_type_memdrv(void)
+{
+	return IO_TYPE_MEMMAP;
+}
+
+
+/* Open a connection to the memdrv device */
+static int32_t memdrv_dev_open(
+			const uintptr_t dev_spec __attribute__((unused)),
+			io_dev_info_t **dev_info)
+{
+	assert(dev_info != NULL);
+	*dev_info = (io_dev_info_t *)&memdrv_dev_info; /* cast away const */
+
+	return IO_SUCCESS;
+}
+
+
+
+/* Close a connection to the memdrv device */
+static int32_t memdrv_dev_close(io_dev_info_t *dev_info)
+{
+	/* NOP */
+	/* TODO: Consider tracking open files and cleaning them up here */
+	return IO_SUCCESS;
+}
+
+
+/* Open a file on the memdrv device */
+/* TODO: Can we do any sensible limit checks on requested memory */
+static int32_t memdrv_block_open(io_dev_info_t *dev_info, const uintptr_t spec,
+			     io_entity_t *entity)
+{
+	int32_t result;
+	const io_block_spec_t *block_spec = (io_block_spec_t *)spec;
+
+	/* Since we need to track open state for seek() we only allow one open
+	 * spec at a time. When we have dynamic memory we can malloc and set
+	 * entity->info.
+	 */
+	if (current_file.in_use == 0U) {
+		assert(block_spec != NULL);
+		assert(entity != NULL);
+
+		current_file.in_use = 1U;
+		current_file.base = block_spec->offset;
+		/* File cursor offset for seek and incremental reads etc. */
+		current_file.file_pos = 0;
+		entity->info = (uintptr_t)&current_file;
+		result = IO_SUCCESS;
+	} else {
+		WARN("A memdrv device is already active. Close first.\n");
+		result = IO_RESOURCES_EXHAUSTED;
+	}
+
+	return result;
+}
+
+
+/* Seek to a particular file offset on the memdrv device */
+static int32_t memdrv_block_seek(io_entity_t *entity, int32_t mode,
+				ssize_t offset)
+{
+	int32_t result;
+
+	/* We only support IO_SEEK_SET for the moment. */
+	if ((io_seek_mode_t)mode == IO_SEEK_SET) {
+		assert(entity != NULL);
+		assert(entity->info != (uintptr_t)NULL);
+
+		/* TODO: can we do some basic limit checks on seek? */
+		((file_state_t *)entity->info)->file_pos = offset;
+		result = IO_SUCCESS;
+	} else {
+		result = IO_FAIL;
+	}
+
+	return result;
+}
+
+
+/* Read data from a file on the memdrv device */
+static int32_t memdrv_block_read(io_entity_t *entity, uintptr_t buffer,
+			     size_t length, size_t *length_read)
+{
+	file_state_t *fp;
+
+	assert(entity != NULL);
+	assert(buffer != (uintptr_t)NULL);
+	assert(length_read != NULL);
+
+	fp = (file_state_t *)entity->info;
+
+	NOTICE("BL2: %s dst=0x%x src=0x%x len=%d(0x%x)\n",
+		__FUNCTION__,
+		(uint32_t)buffer,
+		(uint32_t)(fp->base + fp->file_pos),
+		(uint32_t)length, (uint32_t)length);
+
+#if 1	/* DMA driver */
+	execDMA((uint32_t)buffer, (uint32_t)(fp->base + fp->file_pos),
+		(uint32_t)length);
+#else
+	(void)memcpy((void *)buffer, (void *)(fp->base + fp->file_pos),
+		length);
+#endif
+
+	*length_read = length;
+	/* advance the file 'cursor' for incremental reads */
+	fp->file_pos += (ssize_t)length;
+
+	return IO_SUCCESS;
+}
+
+
+/* Close a file on the memdrv device */
+static int32_t memdrv_block_close(io_entity_t *entity)
+{
+	assert(entity != NULL);
+
+	entity->info = 0U;
+
+	/* This would be a mem free() if we had malloc.*/
+	(void)memset((void *)&current_file, 0, sizeof(current_file));
+
+	return IO_SUCCESS;
+}
+
+
+/* Exported functions */
+
+/* Register the memdrv driver with the IO abstraction */
+int32_t register_io_dev_memdrv(const io_dev_connector_t **dev_con)
+{
+	int32_t result;
+	assert(dev_con != NULL);
+
+	result = io_register_device(&memdrv_dev_info);
+	if (result == IO_SUCCESS) {
+		*dev_con = &memdrv_dev_connector;
+	}
+
+	return result;
+}
diff --git a/plat/renesas/rcar/drivers/io/io_rcar.c b/plat/renesas/rcar/drivers/io/io_rcar.c
new file mode 100644
index 0000000..1e12f37
--- /dev/null
+++ b/plat/renesas/rcar/drivers/io/io_rcar.c
@@ -0,0 +1,596 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <bl_common.h>
+#include <debug.h>
+#include <errno.h>
+#include <firmware_image_package.h>
+#include <io_driver.h>
+#include <io_storage.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <stdint.h>
+#include <string.h>
+#include <uuid.h>
+#include "io_rcar.h"
+
+
+typedef struct {
+	const int8_t	*name;
+	const uint32_t	offset;
+	const uint32_t	attr;
+} plat_rcar_name_offset_t;
+
+typedef struct {
+	/* Put file_pos above the struct to allow {0} on static init.
+	 * It is a workaround for a known bug in GCC
+	 * http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53119
+	 */
+	uint32_t	file_pos;
+	uint32_t	is_noload;
+	uint32_t	offset_address;
+	uint32_t	size;
+	uint32_t	dest_address;
+} file_state_t;
+
+#define RCAR_GET_FLASH_ADR(a,b)		(uint32_t)((0x40000U*(a)) + (b))
+#define RCAR_ATTR_SET_CALCADDR(a)	((a) & 0xF)			/* lower 4bit use */
+#define RCAR_ATTR_SET_ISNOLOAD(a)	(((a) & 0x1) << 16U)		/* 16bit use */
+#define RCAR_ATTR_SET_CERTOFF(a)	(((a) & 0xF) << 8U)		/* 11-8bit use */
+#define RCAR_ATTR_SET_ALL(a,b,c)	(uint32_t)(RCAR_ATTR_SET_CALCADDR(a) |\
+					RCAR_ATTR_SET_ISNOLOAD(b) | RCAR_ATTR_SET_CERTOFF(c))
+
+#define RCAR_ATTR_GET_CALCADDR(a)	((a) & 0xFU)			/* lower 4bit use */
+#define RCAR_ATTR_GET_ISNOLOAD(a)	(((a) >> 16) & 0x1U)		/* 16bit use */
+#define RCAR_ATTR_GET_CERTOFF(a)	(((a) >> 8) & 0xFU)		/* 11-8bit use */
+
+#define RCAR_MAX_BL3X_IMAGE		(8U)
+#define RCAR_SECTOR6_CERT_OFFSET	(0x400U)
+#define RCAR_SDRAM_CERT_ADDRESS		(0x43F00000U)
+#define RCAR_CERT_SIZE			(0x400U)
+#define RCAR_CERT_INFO_SIZE_OFFSET	(0x264U)	/* byte address set : must 4byte alignment */
+#define RCAR_CERT_INFO_DST_OFFSET	(0x154U)	/* byte address set : must 4byte alignment */
+
+#define RCAR_CERT_LOAD			(1U)
+
+static const plat_rcar_name_offset_t name_offset[] = {		/* calc addr, no load, cert offset */
+	{(const int8_t *)BL31_IMAGE_NAME,	RCAR_GET_FLASH_ADR(7U,0x000U),	RCAR_ATTR_SET_ALL(0,0,0)},
+	/* BL3-2 is optional in the platform */
+	{(const int8_t *)BL32_IMAGE_NAME,	RCAR_GET_FLASH_ADR(8U,0x000U),	RCAR_ATTR_SET_ALL(0,0,1)},
+	{(const int8_t *)BL33_IMAGE_NAME,	0U,				RCAR_ATTR_SET_ALL(1,0,2)},
+	{(const int8_t *)BL332_IMAGE_NAME,	0U,				RCAR_ATTR_SET_ALL(2,0,3)},
+	{(const int8_t *)BL333_IMAGE_NAME,	0U,				RCAR_ATTR_SET_ALL(3,0,4)},
+	{(const int8_t *)BL334_IMAGE_NAME,	0U,				RCAR_ATTR_SET_ALL(4,0,5)},
+	{(const int8_t *)BL335_IMAGE_NAME,	0U,				RCAR_ATTR_SET_ALL(5,0,6)},
+	{(const int8_t *)BL336_IMAGE_NAME,	0U,				RCAR_ATTR_SET_ALL(6,0,7)},
+	{(const int8_t *)BL337_IMAGE_NAME,	0U,				RCAR_ATTR_SET_ALL(7,0,8)},
+	{(const int8_t *)BL338_IMAGE_NAME,	0U,				RCAR_ATTR_SET_ALL(8,0,9)},
+};
+#if TRUSTED_BOARD_BOOT
+static const plat_rcar_name_offset_t cert_offset[] = {
+	/* Certificates */
+	{(const int8_t *)TRUSTED_KEY_CERT_NAME,	0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{(const int8_t *)BL31_KEY_CERT_NAME,	0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{(const int8_t *)BL32_KEY_CERT_NAME,	0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{(const int8_t *)BL33_KEY_CERT_NAME,	0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{(const int8_t *)BL31_CERT_NAME,	0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{(const int8_t *)BL32_CERT_NAME,	0U,				RCAR_ATTR_SET_ALL(0,1,1)},
+	{(const int8_t *)BL33_CERT_NAME,	0U,				RCAR_ATTR_SET_ALL(0,1,2)},
+};
+#endif /* TRUSTED_BOARD_BOOT */
+
+
+static file_state_t current_file = {0};
+static uintptr_t backend_dev_handle;
+static uintptr_t backend_image_spec;
+static uint32_t rcar_image_header[RCAR_MAX_BL3X_IMAGE + 1U] = {0U};
+static uint32_t	rcar_cert_load = {0U};
+
+
+/* prototype */
+static io_type_t device_type_rcar(void);
+static int32_t rcar_dev_open(const uintptr_t dev_spec, io_dev_info_t **dev_info);
+static int32_t rcar_file_open(io_dev_info_t *dev_info, const uintptr_t spec,
+			  io_entity_t *entity);
+static int32_t rcar_file_len(io_entity_t *entity, size_t *length);
+static int32_t rcar_file_read(io_entity_t *entity, uintptr_t buffer, size_t length,
+			  size_t *length_read);
+static int32_t rcar_file_close(io_entity_t *entity);
+static int32_t rcar_dev_init(io_dev_info_t *dev_info, const uintptr_t init_params);
+static int32_t rcar_dev_close(io_dev_info_t *dev_info);
+static int32_t file_to_offset(const int8_t *filename, uint32_t *offset, uint32_t *cert_addr, uint32_t *is_noload);
+static int32_t load_bl33x(uintptr_t handle);
+
+
+/* Identify the device type as a virtual driver */
+static io_type_t device_type_rcar(void)
+{
+	return IO_TYPE_FIRMWARE_IMAGE_PACKAGE;
+}
+
+
+static const io_dev_connector_t rcar_dev_connector = {
+	.dev_open = &rcar_dev_open
+};
+
+
+static const io_dev_funcs_t rcar_dev_funcs = {
+	.type = &device_type_rcar,
+	.open = &rcar_file_open,
+	.seek = NULL,
+	.size = &rcar_file_len,
+	.read = &rcar_file_read,
+	.write = NULL,
+	.close = &rcar_file_close,
+	.dev_init = &rcar_dev_init,
+	.dev_close = &rcar_dev_close,
+};
+
+
+/* No state associated with this device so structure can be const */
+static const io_dev_info_t rcar_dev_info = {
+	.funcs = &rcar_dev_funcs,
+	.info = (uintptr_t)0
+};
+
+
+/* Open a connection to the FIP device */
+static int32_t rcar_dev_open(const uintptr_t dev_spec __attribute__((unused)),
+			 io_dev_info_t **dev_info)
+{
+	assert(dev_info != NULL);
+	*dev_info = (io_dev_info_t *)&rcar_dev_info; /* cast away const */
+
+	return IO_SUCCESS;
+}
+
+int32_t file_to_cert(const int8_t *filename, uint32_t *cert_addr)
+{
+	int32_t i;
+	int32_t status = -EINVAL;
+
+	for (i = 0; i < (int32_t)ARRAY_SIZE(cert_offset); i++) {
+		if (strcmp((const char *)filename, (const char *)cert_offset[i].name) == 0) {
+			*cert_addr = RCAR_CERT_SIZE;
+			*cert_addr *= (uint32_t)RCAR_ATTR_GET_CERTOFF(cert_offset[i].attr);
+			*cert_addr += RCAR_SDRAM_CERT_ADDRESS;
+			status = 0;
+			break;
+		}
+	}
+	return status;
+}
+
+static int32_t file_to_offset(const int8_t *filename, uint32_t *offset, uint32_t *cert_addr, uint32_t *is_noload)
+{
+	int32_t i;
+	int32_t status = -EINVAL;
+	uint32_t is_calc_addr;
+	
+	assert(offset != NULL);
+	assert(cert_addr != NULL);
+	assert(is_noload != NULL);
+
+	for (i = 0; i < (int32_t)ARRAY_SIZE(name_offset); i++) {
+		if (strcmp((const char *)filename, (const char *)name_offset[i].name) == 0) {
+			is_calc_addr = RCAR_ATTR_GET_CALCADDR(name_offset[i].attr);
+			if (rcar_image_header[0] >= is_calc_addr)
+			{
+				if (0U != is_calc_addr)
+				{
+					*offset = rcar_image_header[is_calc_addr];
+				} else {
+					*offset = name_offset[i].offset;
+				}
+				*cert_addr = RCAR_CERT_SIZE;
+				*cert_addr *= RCAR_ATTR_GET_CERTOFF(name_offset[i].attr);
+				*cert_addr += RCAR_SDRAM_CERT_ADDRESS;
+				*is_noload = RCAR_ATTR_GET_ISNOLOAD(name_offset[i].attr);
+				status = IO_SUCCESS;
+				break;
+			}
+		}
+	}
+
+	if (IO_SUCCESS != status) {
+		for (i = 0; i < (int32_t)ARRAY_SIZE(cert_offset); i++) {
+			if (strcmp((const char *)filename, (const char *)cert_offset[i].name) == 0) {
+				*offset = 0U;
+				*cert_addr = 0U;
+				*is_noload = RCAR_ATTR_GET_ISNOLOAD(cert_offset[i].attr);
+				status = IO_SUCCESS;
+				break;
+			}
+		}
+	}
+	return status;
+}
+
+void get_info_from_cert(uint64_t cert_addr, uint32_t *size, uint32_t *dest_addr)
+{
+	assert(size != NULL);
+	assert(dest_addr != NULL);
+	
+	cert_addr &= 0xFFFFFFFFU;		/* need? */
+
+	*size = *((uint32_t *)(cert_addr + RCAR_CERT_INFO_SIZE_OFFSET)) * 4U;
+	*dest_addr = *((uint32_t *)(cert_addr + RCAR_CERT_INFO_DST_OFFSET));
+}
+
+static int32_t load_bl33x(uintptr_t handle)
+{
+	int32_t result = IO_SUCCESS;
+	uint32_t loop = 1U;	/* start is BL332 */
+	uint32_t file_offset;
+	uint32_t noload;
+	uint32_t cert_addr;
+	uint32_t l_image_size;
+	uint32_t dest_addr;
+	size_t bytes_read;
+	const char *load_names[] = {
+		BL33_IMAGE_NAME,
+		BL332_IMAGE_NAME,
+		BL333_IMAGE_NAME,
+		BL334_IMAGE_NAME,
+		BL335_IMAGE_NAME,
+		BL336_IMAGE_NAME,
+		BL337_IMAGE_NAME,
+		BL338_IMAGE_NAME
+	};
+
+	for (; loop < rcar_image_header[0]; loop++) {
+
+		if (IO_SUCCESS != result){
+			break;
+		}
+
+		result = file_to_offset((const int8_t *)load_names[loop], &file_offset,
+			&cert_addr, &noload);
+		if (IO_SUCCESS != result) {
+			WARN("load_bl33x: failed to get offset\n");
+			result = IO_FAIL;
+		} else {
+
+			get_info_from_cert((uint64_t) cert_addr, &l_image_size,
+				&dest_addr);
+
+			result = io_seek(handle, IO_SEEK_SET,
+				(ssize_t) file_offset);
+			if (IO_SUCCESS != result) {
+				WARN("load_bl33x: failed to seek\n");
+				result = IO_FAIL;
+			}
+		}
+
+		if (IO_SUCCESS == result) {
+
+			result = io_read(handle, (uintptr_t)dest_addr, (size_t)l_image_size,
+				(size_t *)&bytes_read);
+			if (IO_SUCCESS != result) {
+				WARN("load_bl33x: failed to read\n");
+				result = IO_FAIL;
+			}
+		}
+	}
+
+	return result;
+}
+
+/* Do some basic package checks. */
+static int32_t rcar_dev_init(io_dev_info_t *dev_info, const uintptr_t init_params)
+{
+	int32_t result;
+	int8_t *image_name = (int8_t *)init_params;
+	uintptr_t backend_handle;
+	size_t bytes_read;
+
+	/* Obtain a reference to the image by querying the platform layer */
+	/* get rcar flash memory address... (certain BL2, BL31, BL32, BL33... max 64MB:RPC LBSC address) */
+	result = plat_get_image_source((const char *)image_name, &backend_dev_handle,
+				       &backend_image_spec);
+	if (result != IO_SUCCESS) {
+		WARN("Failed to obtain reference to image '%s' (%i)\n",
+			image_name, result);
+		result = IO_FAIL;
+	} else {
+
+		if (RCAR_CERT_LOAD == rcar_cert_load) {
+			/* not load certificate file after 1at initialize */
+			result = IO_SUCCESS;
+		} else {
+
+			/* Attempt to access the RCAR image */
+			/* open memory driver (certain SYS-DMAC2 initialize) */
+			result = io_open(backend_dev_handle, backend_image_spec,
+					&backend_handle);
+			if (result != IO_SUCCESS) {
+				WARN("Failed to access image '%s' (%i)\n",
+						image_name, result);
+				result = IO_FAIL;
+			}
+
+			/* get start address list */
+			/* [0] address num */
+			/* [1] BL33-1 image address */
+			/* [2] BL33-2 image address */
+			/* [3] BL33-3 image address */
+			/* [4] BL33-4 image address */
+			/* [5] BL33-5 image address */
+			/* [6] BL33-6 image address */
+			/* [7] BL33-7 image address */
+			/* [8] BL33-8 image address */
+			if (IO_SUCCESS == result) {
+				result = io_seek(backend_handle, IO_SEEK_SET,
+					(ssize_t) RCAR_GET_FLASH_ADR(6U, 0U));
+				if (result != IO_SUCCESS) {
+					WARN("Firmware Image Package header "\
+						"failed to seek\n");
+					result = IO_FAIL;
+					(void) io_close(backend_handle);
+				}
+			}
+			if (IO_SUCCESS == result) {
+				result = io_read(backend_handle,
+					(uintptr_t) &rcar_image_header,
+					sizeof(rcar_image_header), &bytes_read);
+				if (result == IO_SUCCESS) {
+					if ((rcar_image_header[0] == 0U)
+						|| (rcar_image_header[0] > 8U)) {
+						WARN("Firmware Image Package "\
+							"header check failed.\n");
+						result = IO_FAIL;
+						(void) io_close(backend_handle);
+					} else {
+						VERBOSE("header looks OK.\n");
+					}
+				}
+			}
+			/* load cert file */
+			if (IO_SUCCESS == result) {
+				result = io_seek(backend_handle, IO_SEEK_SET,
+					(ssize_t) (RCAR_GET_FLASH_ADR(6U, 0U)
+						+ RCAR_SECTOR6_CERT_OFFSET));
+				if (result != IO_SUCCESS) {
+					WARN("Firmware Image Package "\
+						"header failed to seek\n");
+					result = IO_FAIL;
+					(void) io_close(backend_handle);
+				}
+			}
+			if (IO_SUCCESS == result) {
+				result = io_read(backend_handle,
+						(uintptr_t) RCAR_SDRAM_CERT_ADDRESS,
+						(size_t) (RCAR_CERT_SIZE *
+						 (2U + (size_t) rcar_image_header[0])),
+						&bytes_read);
+				if (result != IO_SUCCESS) {
+					WARN("cert file road error.\n");
+					result = IO_FAIL;
+				} else {
+
+					rcar_cert_load = RCAR_CERT_LOAD;
+				}
+				(void) io_close(backend_handle);
+			}
+		}
+	}
+
+	return result;
+}
+
+/* Close a connection to the FIP device */
+static int32_t rcar_dev_close(io_dev_info_t *dev_info)
+{
+	/* TODO: Consider tracking open files and cleaning them up here */
+
+	/* Clear the backend. */
+	backend_dev_handle = (uintptr_t)0;
+	backend_image_spec = (uintptr_t)0;
+
+	return IO_SUCCESS;
+}
+
+
+/* Open a file for access from package. */
+static int32_t rcar_file_open(io_dev_info_t *dev_info, const uintptr_t spec,
+			 io_entity_t *entity)
+{
+	int32_t result;
+	uint32_t file_offset;
+	uint32_t noload;
+	uint32_t cert_addr;
+	uint32_t l_image_size;
+	uint32_t dest_addr;
+	const io_file_spec_t *file_spec = (io_file_spec_t *)spec;
+
+	assert(file_spec != NULL);
+	assert(entity != NULL);
+
+	/* Can only have one file open at a time for the moment. We need to
+	 * track state like file cursor position. We know the header lives at
+	 * offset zero, so this entry should never be zero for an active file.
+	 * When the system supports dynamic memory allocation we can allow more
+	 * than one open file at a time if needed.
+	 */
+	if (current_file.offset_address != 0U) {
+		WARN("rcar_file_open : Only one open file at a time.\n");
+		result = IO_RESOURCES_EXHAUSTED;
+	} else {
+
+		/* get file offset(but BL33 image id not get) */
+		result = file_to_offset((const int8_t *) file_spec->path,
+			&file_offset, &cert_addr, &noload);
+		if (result != IO_SUCCESS) {
+			WARN("Failed to open file name %s (%i)\n",
+				file_spec->path, result);
+			result = IO_FAIL;
+		} else {
+			if (0U != noload) {
+				current_file.offset_address = 1U;
+				current_file.dest_address = 0U;
+				current_file.size = 1U;
+				current_file.file_pos = 0U;
+				current_file.is_noload = noload;
+				entity->info = (uintptr_t) &current_file;
+
+			} else {
+
+				/* get image size and destination address */
+				get_info_from_cert((uint64_t) cert_addr,
+					&l_image_size, &dest_addr);
+
+				current_file.offset_address = file_offset;
+				current_file.dest_address = dest_addr;
+				current_file.size = l_image_size;
+				current_file.file_pos = 0U;
+				current_file.is_noload = noload;
+				entity->info = (uintptr_t) &current_file;
+			}
+		}
+	}
+
+	return result;
+}
+
+
+/* Return the size of a file in package */
+static int32_t rcar_file_len(io_entity_t *entity, size_t *length)
+{
+	assert(entity != NULL);
+	assert(length != NULL);
+
+	*length =  ((file_state_t *)entity->info)->size;
+
+	return IO_SUCCESS;
+}
+
+
+/* Read data from a file in package */
+static int32_t rcar_file_read(io_entity_t *entity, uintptr_t buffer, size_t length,
+			  size_t *length_read)
+{
+	int32_t result;
+	file_state_t *fp;
+	ssize_t file_offset;
+	size_t bytes_read;
+	uintptr_t backend_handle;
+
+	assert(entity != NULL);
+	assert(buffer != (uintptr_t)NULL);
+	assert(length_read != NULL);
+	assert(entity->info != (uintptr_t)NULL);
+
+	/* cert image no load */
+	if ( 0U != current_file.is_noload ) {
+		result = IO_SUCCESS;
+		*length_read = length;
+	} else {
+
+		/* Open the backend, attempt to access the blob image */
+		result = io_open(backend_dev_handle, backend_image_spec,
+			&backend_handle);
+		if (result != IO_SUCCESS) {
+			WARN("Failed to open FIP (%i)\n", result);
+			result = IO_FAIL;
+		} else {
+
+			fp = (file_state_t *) entity->info;
+
+			/* Seek to the position in the FIP where the payload lives */
+			file_offset = (ssize_t) fp->offset_address
+				+ (ssize_t) fp->file_pos;
+			result = io_seek(backend_handle, IO_SEEK_SET,
+				file_offset);
+			if (result != IO_SUCCESS) {
+				WARN("rcar_file_read: failed to seek\n");
+				result = IO_FAIL;
+			}
+
+			if (result == IO_SUCCESS) {
+				result = io_read(backend_handle, buffer, length,
+					&bytes_read);
+				if (result != IO_SUCCESS) {
+					/* We cannot read our data. Fail. */
+					WARN("Failed to read payload (%i)\n",
+						result);
+					result = IO_FAIL;
+				} else {
+					/* Set caller length and new file position. */
+					*length_read = bytes_read;
+					fp->file_pos += (uint32_t) bytes_read;
+				}
+			}
+
+			if ((result == IO_SUCCESS) && (buffer == (uintptr_t)NS_IMAGE_OFFSET)) {
+				result = load_bl33x(backend_handle);
+			}
+			/* Close the backend. */
+			(void) io_close(backend_handle);
+		}
+	}
+
+	return result;
+}
+
+
+/* Close a file in package */
+static int32_t rcar_file_close(io_entity_t *entity)
+{
+	/* Clear our current file pointer.
+	 * If we had malloc() we would free() here.
+	 */
+	assert(entity != NULL);
+	if (current_file.offset_address != 0U) {
+		(void)memset(&current_file, 0, sizeof(current_file));
+	}
+
+	/* Clear the Entity info. */
+	entity->info = 0U;
+
+	return IO_SUCCESS;
+}
+
+/* Exported functions */
+
+/* Register the Firmware Image Package driver with the IO abstraction */
+int32_t register_io_dev_rcar(const io_dev_connector_t **dev_con)
+{
+	int32_t result;
+	assert(dev_con != NULL);
+
+	result = io_register_device(&rcar_dev_info);
+	if (result == IO_SUCCESS) {
+		*dev_con = &rcar_dev_connector;
+	}
+
+	return result;
+}
diff --git a/plat/renesas/rcar/drivers/memdrv/rcar_console.S b/plat/renesas/rcar/drivers/memdrv/rcar_console.S
new file mode 100644
index 0000000..e8f5c04
--- /dev/null
+++ b/plat/renesas/rcar/drivers/memdrv/rcar_console.S
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2013-2015, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <arch.h>
+#include <asm_macros.S>
+
+/*
+ * Pull in generic functions to provide backwards compatibility for
+ * platform makefiles
+ */
+#include "../../../drivers/console/console.S"
+
+	.globl	console_core_init
+	.globl	console_core_putc
+	.globl	console_core_getc
+	.globl	readreg_cntpct_el0
+
+	.extern	rcar_log_init
+	.extern	rcar_set_log_data
+
+	/* -----------------------------------------------
+	 * int console_core_init(unsigned long base_addr,
+	 * unsigned int uart_clk, unsigned int baud_rate)
+	 * Function to initialize the log area. This
+	 * function will be accessed by console_init and
+	 * crash reporting.
+	 * Return 1 on SUCCESS, 0 on error
+	 * In: x0 - Not used
+	 *     w1 - Not used
+	 *     w2 - Not used
+	 * -----------------------------------------------
+	 */
+func console_core_init
+	b	rcar_log_init
+endfunc console_core_init
+
+	/* --------------------------------------------------------
+	 * int console_core_putc(int c, unsigned long base_addr)
+	 * Function to output a character over the log area.
+	 * Return 1 on SUCCESS, 0 on error
+	 * In : w0 - Not used
+	 *      x1 - Not used
+	 * --------------------------------------------------------
+	 */
+func console_core_putc
+	b	rcar_set_log_data
+endfunc console_core_putc
+
+	/* ---------------------------------------------
+	 * int console_core_getc(unsigned long base_addr)
+	 * Function to get a character from the console.
+	 * It returns the character grabbed on success
+	 * or -1 on error.
+	 * In : x0 - console base address
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_core_getc
+	ret
+endfunc console_core_getc
+
+
+	/* --------------------------------------------
+	 * uint64_t readreg_cntpct_el0(void)
+	 * Function to read CNTPCT_EL0 register.
+	 * --------------------------------------------
+	 */
+func readreg_cntpct_el0
+	mrs	x0, cntpct_el0
+	ret
+endfunc readreg_cntpct_el0
diff --git a/plat/renesas/rcar/drivers/memdrv/rcar_printf.c b/plat/renesas/rcar/drivers/memdrv/rcar_printf.c
new file mode 100644
index 0000000..41478b5
--- /dev/null
+++ b/plat/renesas/rcar/drivers/memdrv/rcar_printf.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <debug.h>
+#include <stdarg.h>
+#include <stdint.h>
+
+#include	<arch_helpers.h>
+#include	<platform_def.h>
+#include	"../../rcar_def.h"
+#include	"../../rcar_private.h"
+#include	"rcar_printf.h"
+
+typedef struct log_head
+{
+	uint8_t head[4];
+	uint32_t index;
+	uint32_t size;
+	uint8_t res[4];
+} loghead_t;
+
+typedef struct log_map
+{
+	loghead_t header;
+	uint8_t log_data[RCAR_BL31_LOG_MAX];
+	uint8_t res_data[RCAR_LOG_RES_SIZE];
+} logmap_t;
+
+#if USE_COHERENT_MEM
+static bakery_lock_t log_lock __attribute__((section("tzfw_coherent_mem")));
+#define	LOG_LOCK	(&log_lock)
+#else
+#define	LOG_LOCK	ERROR("not use coherent memory");	\
+			panic();
+#endif
+
+void rcar_set_log_time(void)
+{
+	uint64_t now_time;
+	uint64_t freq;
+	uint64_t second;
+	uint64_t micro_sec;
+	uint64_t t_log[2][15];
+	int32_t i;
+	int32_t start_counter;
+
+	now_time = readreg_cntpct_el0();
+	freq = read_cntfrq_el0(); /* get the frequency	*/
+	if (freq == 0U) { /* for zero division	*/
+		second = 0U;
+		micro_sec = 0U;
+	} else {
+		second = now_time / freq;
+		micro_sec = ((now_time % freq) * 1000000U) / freq;
+	}
+	i = 14; /* counter initialize	*/
+	do {
+		t_log[0][i] = second % 10U;
+		second = second / 10U;
+		i--;
+	} while (second != 0U);
+	start_counter = i + 1;
+	t_log[1][0] = micro_sec / 100000U;
+	micro_sec %= 100000U;
+	t_log[1][1] = micro_sec / 10000U;
+	micro_sec %= 10000U;
+	t_log[1][2] = micro_sec / 1000U;
+	micro_sec %= 1000U;
+	t_log[1][3] = micro_sec / 100U;
+	micro_sec %= 100U;
+	t_log[1][4] = micro_sec / 10U;
+	t_log[1][5] = micro_sec % 10U;
+
+	(void)putchar((int)'[');
+	for (i = start_counter; i < 15; i++) {
+		(void)putchar((int)((int)t_log[0][i] + (int)0x30));
+	}
+	(void)putchar((int)'.');
+	for (i = 0; i < 6; i++) {
+		(void)putchar((int)((int)t_log[1][i] + (int)0x30));
+	}
+	(void)putchar((int)']');
+}
+
+int32_t rcar_set_log_data(int32_t c)
+{
+	logmap_t *t_log;
+
+	t_log = (logmap_t *)RCAR_BL31_LOG_BASE;
+
+	rcar_lock_get(LOG_LOCK);
+
+	/*
+	 * If index is broken, then index and size initialize
+	 */
+	if (t_log->header.index	>= (uint32_t)RCAR_BL31_LOG_MAX) {
+		t_log->header.index = 0U;
+		t_log->header.size = 0U;
+	}
+	/*
+	 * data store to log area then index and size renewal
+	 */
+	t_log->log_data[t_log->header.index] = (uint8_t)c;
+	t_log->header.index++;
+	if (t_log->header.size < t_log->header.index) {
+		t_log->header.size = t_log->header.index;
+	}
+	if (t_log->header.index	>= (uint32_t)RCAR_BL31_LOG_MAX) {
+		t_log->header.index = 0U;
+	}
+
+	rcar_lock_release(LOG_LOCK);
+
+	return(1);
+}
+
+int32_t rcar_log_init(void)
+{
+
+	static const uint8_t const_header[] = "TLOG";
+	logmap_t *t_log;
+	int16_t init_flag = 0;
+
+	t_log = (logmap_t *)RCAR_BL31_LOG_BASE;
+	if (memcmp((const void *)t_log->header.head, (const void *)const_header, sizeof(t_log->header.head)) != 0) {
+		/*
+		 * Log header is not "TLOG", then log area initialize
+		 */
+		init_flag = 1;
+	}
+	if (t_log->header.index	>= (uint32_t)RCAR_BL31_LOG_MAX) {
+		/*
+		 * index is broken, then log area initialize
+		 */
+		init_flag = 1;
+	}
+	if (init_flag == 1) {
+		(void)memset((void *)t_log->log_data, 0, (size_t)RCAR_BL31_LOG_MAX);
+		(void)memcpy((void *)t_log->header.head, (const void *)const_header, sizeof(t_log->header.head));
+		t_log->header.index = 0U;
+		t_log->header.size = 0U;
+	}
+	rcar_lock_init(LOG_LOCK);
+
+	return(1);
+}
diff --git a/plat/renesas/rcar/drivers/memdrv/rcar_printf.h b/plat/renesas/rcar/drivers/memdrv/rcar_printf.h
new file mode 100644
index 0000000..f9e4e54
--- /dev/null
+++ b/plat/renesas/rcar/drivers/memdrv/rcar_printf.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	RCAR_PRINTF_H__
+#define	RCAR_PRINTF_H__
+
+#include <string.h>
+
+void		rcar_set_log_time(void);
+int32_t		rcar_set_log_data(int32_t c);
+int32_t		rcar_log_init(void);
+
+extern uint64_t	readreg_cntpct_el0(void);
+
+#endif	/* RCAR_PRINTF_H__	*/
diff --git a/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
new file mode 100644
index 0000000..0b91fd5
--- /dev/null
+++ b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
@@ -0,0 +1,268 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <bakery_lock.h>
+#include <mmio.h>
+#include <debug.h>
+#include <arch.h>
+#include "../../rcar_def.h"
+#include "../../rcar_private.h"
+#include "rcar_pwrc.h"
+
+/*
+ * TODO: Someday there will be a generic power controller api. At the moment
+ * each platform has its own pwrc so just exporting functions is fine.
+ */
+#if USE_COHERENT_MEM
+static bakery_lock_t pwrc_lock __attribute__ ((section("tzfw_coherent_mem")));
+#define PWRC_LOCK	(&pwrc_lock)
+#else
+#define PWRC_LOCK	ERROR("not use coherent memory");	\
+			panic();
+#endif
+
+#define	WUP_IRQ_SHIFT	(0U)
+#define	WUP_FIQ_SHIFT	(8U)
+#define	WUP_CSD_SHIFT	(16U)
+
+#define	BIT_CA53_SCU	((uint32_t)1U<<21)
+#define	BIT_CA57_SCU	((uint32_t)1U<<12)
+#define	REQ_RESUME	((uint32_t)1U<<1)
+#define	REQ_OFF		((uint32_t)1U<<0)
+#define	STATUS_PWRUP	((uint32_t)1U<<1)
+#define	STATUS_PWRDOWN	((uint32_t)1U<<0)
+
+#define	STATE_CA57_CPU	(27U)
+#define	STATE_CA53_CPU	(22U)
+
+static void SCU_power_up(uint64_t mpidr);
+
+#if 0
+uint32_t rcar_pwrc_get_cpu_wkr(uint64_t mpidr)
+{
+	return PSYSR_WK(rcar_pwrc_read_psysr(mpidr));
+}
+#endif
+uint32_t rcar_pwrc_status(uint64_t mpidr)
+{
+	uint32_t rc;
+	uint64_t cpu_no;
+	uint32_t prr_data;
+
+	rcar_lock_get(PWRC_LOCK);
+	prr_data = mmio_read_32((uintptr_t)RCAR_PRR);
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != 0U) {
+		/* A53 side				*/
+		if ((prr_data & ((uint32_t)1U << (STATE_CA53_CPU + cpu_no))) == 0U) {
+			rc = 0U;
+		} else {
+			rc = RCAR_INVALID;
+		}
+	} else {
+		/* A57 side				*/
+		if ((prr_data & ((uint32_t)1U << (STATE_CA57_CPU + cpu_no))) == 0U) {
+			rc = 0U;
+		} else {
+			rc = RCAR_INVALID;
+		}
+	}
+	NOTICE("BL31: - rcar_pwrc_read_psysr : rc=0x%x\n", rc);
+	rcar_lock_release(PWRC_LOCK);
+
+	return rc;
+}
+
+void rcar_pwrc_cpuon(uint64_t mpidr)
+{
+
+	uintptr_t res_reg;
+	uint32_t res_data;
+	uintptr_t on_reg;
+	uint64_t cpu_no;
+	uint32_t upper_value;
+
+	rcar_lock_get(PWRC_LOCK);
+
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != 0U) {
+		/* A53 side				*/
+		res_reg = (uintptr_t)RCAR_CA53RESCNT;
+		on_reg = (uintptr_t)RCAR_CA53WUPCR;
+		upper_value = 0x5A5A0000U;
+	} else {
+		res_reg = (uintptr_t)RCAR_CA57RESCNT;
+		on_reg = (uintptr_t)RCAR_CA57WUPCR;
+		upper_value = 0xA5A50000U;
+	}
+	SCU_power_up(mpidr);
+	mmio_write_32(RCAR_CPGWPR, ~((uint32_t)((uint32_t)1U << cpu_no)));
+	mmio_write_32(on_reg, (uint32_t)((uint32_t)1U << cpu_no));
+	res_data = mmio_read_32(res_reg) | upper_value;
+	mmio_write_32(res_reg, (res_data & (~((uint32_t)1U << (3U - cpu_no)))));
+	rcar_lock_release(PWRC_LOCK);
+}
+
+static void SCU_power_up(uint64_t mpidr)
+{
+	uint32_t reg_SYSC_bit;
+	uintptr_t reg_PWRONCR;
+	volatile uintptr_t reg_PWRER;
+	uintptr_t reg_PWRSR;
+	uintptr_t reg_SYSCIER =	(uintptr_t)RCAR_SYSCIER;
+	uintptr_t reg_SYSCIMR =	(uintptr_t)RCAR_SYSCIMR;
+	volatile uintptr_t reg_SYSCSR =	(volatile uintptr_t)RCAR_SYSCSR;
+	volatile uintptr_t reg_SYSCISR = (volatile uintptr_t)RCAR_SYSCISR;
+	volatile uintptr_t reg_SYSCISCR = (volatile uintptr_t)RCAR_SYSCISCR;
+
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) == 0U) {
+		/* CA57-SCU	*/
+		reg_SYSC_bit = (uint32_t)BIT_CA57_SCU;
+		reg_PWRONCR = (uintptr_t)RCAR_PWRONCR5;
+		reg_PWRER = (volatile uintptr_t)RCAR_PWRER5;
+		reg_PWRSR = (uintptr_t)RCAR_PWRSR5;
+	} else {
+		/* CA53-SCU	*/
+		reg_SYSC_bit = (uint32_t)BIT_CA53_SCU;
+		reg_PWRONCR = (uintptr_t)RCAR_PWRONCR3;
+		reg_PWRER = (volatile uintptr_t)RCAR_PWRER3;
+		reg_PWRSR = (uintptr_t)RCAR_PWRSR3;
+	}
+	if ((mmio_read_32(reg_PWRSR) & (uint32_t)STATUS_PWRDOWN) != 0x0000U) {
+		/* set SYSCIER and SYSCIMR		*/
+		mmio_write_32(reg_SYSCIER, (mmio_read_32(reg_SYSCIER) | reg_SYSC_bit));
+		mmio_write_32(reg_SYSCIMR, (mmio_read_32(reg_SYSCIMR) | reg_SYSC_bit));
+		do {
+			/* SYSCSR[1]=1?				*/
+			while ((mmio_read_32(reg_SYSCSR) & (uint32_t)REQ_RESUME) == 0U) {
+				;
+			}
+			/* If SYSCSR[1]=1 then set bit in PWRONCRn to 1	*/
+			mmio_write_32(reg_PWRONCR, 0x0001U);
+		} while ((mmio_read_32(reg_PWRER) & 0x0001U) != 0U);
+
+		/* bit in SYSCISR=1 ?				*/
+		while ((mmio_read_32(reg_SYSCISR) & reg_SYSC_bit) == 0U) {
+			;
+		}
+		/* clear bit in SYSCISR				*/
+		mmio_write_32(reg_SYSCISCR, reg_SYSC_bit);
+	}
+}
+
+void rcar_pwrc_cpuoff(uint64_t mpidr)
+{
+#if 0
+	uint32_t *off_reg;
+	uint64_t cpu_no;
+
+	rcar_lock_get(PWRC_LOCK);
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & (uint64_t)MPIDR_CLUSTER_MASK) != 0U) {
+		/* A53 side				*/
+		off_reg = (uintptr_t)RCAR_CA53CPU0CR;
+	} else {
+		/* A57 side				*/
+		off_reg = (uintptr_t)RCAR_CA57CPU0CR;
+	}
+	mmio_write_32(off_reg+(cpu_no*10), (uint32_t)0x03U);
+	wfi();
+	rcar_lock_release(PWRC_LOCK);
+#endif
+}
+
+void rcar_pwrc_enable_interrupt_wakeup(uint64_t mpidr)
+{
+	uintptr_t reg;
+	uint64_t cpu_no;
+	uint32_t shift_irq;
+	uint32_t shift_fiq;
+
+	rcar_lock_get(PWRC_LOCK);
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != 0U) {
+		/* A53 side				*/
+		reg = (uintptr_t)RCAR_WUPMSKCA53;
+	} else {
+		/* A57 side				*/
+		reg = (uintptr_t)RCAR_WUPMSKCA57;
+	}
+	shift_irq = WUP_IRQ_SHIFT + (uint32_t)cpu_no;
+	shift_fiq = WUP_FIQ_SHIFT + (uint32_t)cpu_no;
+	mmio_write_32(reg, (uint32_t)((~((uint32_t)1U << shift_irq)) & (~((uint32_t)1U << shift_fiq))));
+	rcar_lock_release(PWRC_LOCK);
+}
+
+void rcar_pwrc_disable_interrupt_wakeup(uint64_t mpidr)
+{
+	uintptr_t reg;
+	uint64_t cpu_no;
+	uint32_t shift_irq;
+	uint32_t shift_fiq;
+
+	rcar_lock_get(PWRC_LOCK);
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != 0U) {
+		/* A53 side				*/
+		reg = (uintptr_t)RCAR_WUPMSKCA53;
+	} else {
+		/* A57 side				*/
+		reg = (uintptr_t)RCAR_WUPMSKCA57;
+	}
+	shift_irq = WUP_IRQ_SHIFT + (uint32_t)cpu_no;
+	shift_fiq = WUP_FIQ_SHIFT + (uint32_t)cpu_no;
+	mmio_write_32(reg, (uint32_t)(((uint32_t)1U << shift_irq) | ((uint32_t)1U << shift_fiq)));
+	rcar_lock_release(PWRC_LOCK);
+}
+
+#if 0
+void rcar_pwrc_clusteroff(uint64_t mpidr)
+{
+	uintptr_t off_reg;
+
+	rcar_lock_get(PWRC_LOCK);
+	if ((mpidr & (uint64_t)MPIDR_CLUSTER_MASK) != 0U) {
+		/* A53 side				*/
+		off_reg = (uintptr_t)RCAR_CA53CPUCMCR;
+	} else {
+		/* A57 side				*/
+		off_reg = (uintptr_t)RCAR_CA57CPUCMCR;
+	}
+	mmio_write_32(off_reg, (uint32_t)0x03U);
+	rcar_lock_release(PWRC_LOCK);
+}
+#endif
+
+/* Nothing else to do here apart from initializing the lock */
+void rcar_pwrc_setup(void)
+{
+	rcar_lock_init(PWRC_LOCK);
+}
diff --git a/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h
new file mode 100644
index 0000000..7a513d9
--- /dev/null
+++ b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_PWRC_H__
+#define RCAR_PWRC_H__
+
+/* RCAR Power controller register offset etc */
+#define PPOFFR_OFF		0x0
+#define PPONR_OFF		0x4
+#define PCOFFR_OFF		0x8
+#define PWKUPR_OFF		0xc
+#define PSYSR_OFF		0x10
+
+#define PWKUPR_WEN		(1ull << 31)
+
+#define PSYSR_AFF_L2		(1 << 31)
+#define PSYSR_AFF_L1		(1 << 30)
+#define PSYSR_AFF_L0		(1 << 29)
+#define PSYSR_WEN		(1 << 28)
+#define PSYSR_PC		(1 << 27)
+#define PSYSR_PP		(1 << 26)
+
+#define PSYSR_WK_SHIFT		(24)
+#define PSYSR_WK_MASK		(0x3)
+#define PSYSR_WK(x)		(((x) >> PSYSR_WK_SHIFT) & PSYSR_WK_MASK)
+
+#define WKUP_COLD		0x0
+#define WKUP_RESET		0x1
+#define WKUP_PPONR		0x2
+#define WKUP_GICREQ		0x3
+
+#define	RCAR_INVALID		(0xffffffffU)
+#define PSYSR_INVALID		0xffffffff
+
+#ifndef __ASSEMBLY__
+
+/*******************************************************************************
+ * Function & variable prototypes
+ ******************************************************************************/
+void rcar_pwrc_setup(void);
+#if 0
+void rcar_pwrc_clusteroff(uint64_t mpidr);
+#endif
+void rcar_pwrc_cpuoff(uint64_t mpidr);
+void rcar_pwrc_cpuon(uint64_t mpidr);
+void rcar_pwrc_enable_interrupt_wakeup(uint64_t mpidr);
+void rcar_pwrc_disable_interrupt_wakeup(uint64_t mpidr);
+uint32_t rcar_pwrc_status(uint64_t mpidr);
+uint32_t rcar_pwrc_get_cpu_wkr(uint64_t mpidr);
+
+#endif /*__ASSEMBLY__*/
+
+#endif /* RCAR_PWRC_H__ */
diff --git a/plat/renesas/rcar/drivers/rpc/rpc_driver.c b/plat/renesas/rcar/drivers/rpc/rpc_driver.c
new file mode 100644
index 0000000..c6697c3
--- /dev/null
+++ b/plat/renesas/rcar/drivers/rpc/rpc_driver.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include "bl2_cpg_register.h"
+#include "bl2_cpg_write.h"
+#include "bl2_rpc_register.h"
+#include "rpc_driver.h"
+#include "debug.h"
+
+static void enableRPC(void);
+static void setupRPC(void);
+#if DEBUG
+static void disableRPC(void);
+#endif
+
+static void enableRPC(void)
+{
+	while((mmio_read_32(CPG_MSTPSR9) & 0x00020000U) != 0U) {
+		cpg_write(CPG_SMSTPCR9,
+			mmio_read_32(CPG_SMSTPCR9) & (~0x00020000U));
+	}
+}
+
+static void setupRPC(void)
+{
+	/* manual mode */
+	if ((mmio_read_32(RPC_CMNCR) & 0x80000000U) != 0U) {
+		/* external address space read mode */
+		mmio_write_32(RPC_CMNCR,
+			mmio_read_32(RPC_CMNCR) & (~0x80000000U));
+	}
+}
+
+#if DEBUG
+static void disableRPC(void)
+{
+	cpg_write(CPG_SMSTPCR9,
+		mmio_read_32(CPG_SMSTPCR9) | 0x00020000U);
+}
+#endif
+
+void initRPC(void)
+{
+	enableRPC();
+	setupRPC();
+}
+
+#if DEBUG
+void termRPC(void)
+{
+	disableRPC();
+}
+#endif
diff --git a/plat/renesas/rcar/drivers/scif/scif.S b/plat/renesas/rcar/drivers/scif/scif.S
new file mode 100644
index 0000000..29a0cf0
--- /dev/null
+++ b/plat/renesas/rcar/drivers/scif/scif.S
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <scif.h>
+
+	.globl	console_init
+	.globl	console_putc
+	.globl	console_core_init
+	.globl	console_core_putc
+	.globl	console_getc
+
+	/*
+	 *  The console base is in the data section and not in .bss
+	 *  even though it is zero-init. In particular, this allows
+	 *  the console functions to start using this variable before
+	 *  the runtime memory is initialized for images which do not
+	 *  need to copy the .data section from ROM to RAM.
+	 */
+	/* -----------------------------------------------
+	 * int console_init(unsigned long base_addr,
+	 * unsigned int uart_clk, unsigned int baud_rate)
+	 * Function to initialize the console without a
+	 * C Runtime to print debug information. It saves
+	 * the console base to the data section.
+	 * In: x0 - console base address
+	 *     w1 - Uart clock in Hz
+	 *     w2 - Baud rate
+	 * out: return 1 on success.
+	 * Clobber list : x1 - x3
+	 * -----------------------------------------------
+	 */
+func console_init
+	b	console_core_init
+endfunc console_init
+
+	/* -----------------------------------------------
+	 * int console_core_init(unsigned long base_addr,
+	 * unsigned int uart_clk, unsigned int baud_rate)
+	 * Function to initialize the console without a
+	 * C Runtime to print debug information. This
+	 * function will be accessed by console_init and
+	 * crash reporting.
+	 * In: x0 - console base address
+	 *     w1 - Uart clock in Hz
+	 *     w2 - Baud rate
+	 * Out: return 1 on success
+	 * Clobber list : x1, x2
+	 * -----------------------------------------------
+	 */
+func console_core_init
+	ldr	x0, =CPG_BASE
+	ldr	w1, [x0, #CPG_SMSTPCR3]
+	and	w1, w1, #~MSTP310		/* MSTP310=0 */
+	mvn	w2, w1
+	str	w2, [x0, #CPG_CPGWPR]
+	str	w1, [x0, #CPG_SMSTPCR3]
+
+	ldr	x0, =SCIF2_BASE
+	mov	w1, #0
+	strh	w1, [x0, #SCIF_SCSMRIR]
+	/* Clear bits TE and RE in SCSCR to 0 */
+	mov	w1, #(SCSCR_TE_DIS + SCSCR_RE_DIS)	/* TE=0,RE=0 */
+	strh	w1, [x0, #SCIF_SCSCR]
+	/* Set bits TFRST and RFRST in SCFCR to 1 */
+	ldrh	w1, [x0, #SCIF_SCFCR]
+	orr	w1, w1, #(SCFCR_TFRST_EN + SCFCR_RFRS_EN)	/* TFRESET=1,RFRESET=1 */
+	strh	w1, [x0, #SCIF_SCFCR]
+	/* Read flags of ER, DR, BRK, and RDF in SCFSR and those of TO and ORER in SCLSR, then clear them to 0 */
+	mov	w1, #SCFSR_INIT_DATA
+	strh	w1, [x0, #SCIF_SCFSR]
+	mov	w1, #0
+	strh	w1, [x0, #SCIF_SCLSR]
+	/* Set bits CKE[1:0] in SCSCR */
+	ldrh	w1, [x0, #SCIF_SCSCR]
+	and	w1, w1, #~SCSCR_CKE_MASK
+	mov	w2, #SCSCR_CKE_INT_CLK		/* CKE=00 */
+	orr	w1, w1, w2
+	strh	w1, [x0, #SCIF_SCSCR]
+	/* Set data transfer format in SCSMR */
+	mov	w1, #SCSMR_INIT_DATA
+	strh	w1, [x0, #SCIF_SCSMR]		/* CA=0,CHR=0,PE=0,STOP=0,CKS=P */
+	/* Set value in SCBRR */
+#if SCIF_CLK == SCIF_INTERNAL_CLK
+	mov	w1,	#SCBRR_INIT_DATA
+	strb	w1,	[x0, SCIF_SCBRR]
+#else
+	mov	w1, #DL_INIT_DATA
+	strh	w1, [x0, #SCIF_DL]
+	mov	w1, #CKS_INIT_DATA		/* CKS=0,XIN=0 */
+	strh	w1, [x0, #SCIF_CKS]
+#endif
+	/* 1-bit interval elapsed */
+	mov	w1, #100			/* 100 times */
+1:
+	subs	w1, w1, #1
+	cbnz	w1, 1b
+	/* Set bits RTRG[1:0], TTRG[1:0], and MCE in SCFCR, and clear bits FRST and RFRST to 0 */
+	mov	w1, #SCFCR_INIT_DATA
+	strh	w1, [x0, #SCIF_SCFCR]
+	/* Set bits TE and RE in SCSCR to 1 */
+	ldrh	w1, [x0, #SCIF_SCSCR]
+	orr	w1, w1, #(SCSCR_TE_EN + SCSCR_RE_EN)	/* TE=1,RE=1 */
+	strh	w1, [x0, #SCIF_SCSCR]
+	mov	x1, #1
+
+	ret
+endfunc console_core_init
+
+	/* ---------------------------------------------
+	 * int console_putc(int c)
+	 * Function to output a character over the
+	 * console. It returns the character printed on
+	 * success or -1 on error.
+	 * In : x0 - character to be printed
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x1, x2
+	 * ---------------------------------------------
+	 */
+func console_putc
+	b	console_core_putc
+endfunc console_putc
+
+	/* --------------------------------------------------------
+	 * int console_core_putc(int c, unsigned int base_addr)
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
+	 * In : w0 - character to be printed
+	 *      x1 - console base address
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x2
+	 * --------------------------------------------------------
+	 */
+func console_core_putc
+	ldr	x1, =SCIF2_BASE
+	cmp	w0, #0xA
+	/* Prepend '\r' to '\n' */
+	bne	2f
+1:
+	/* Check if the transmit FIFO is full */
+	ldrh	w2, [x1, #SCIF_SCFDR]
+	ubfx	w2, w2, #8, #5
+	cmp	w2, #16
+	bcs	1b
+	mov	w2, #0x0D
+	strb	w2, [x1, #SCIF_SCFTDR]
+2:
+	/* Check if the transmit FIFO is full */
+	ldrh	w2, [x1, #SCIF_SCFDR]
+	ubfx	w2, w2, #8, #5
+	cmp	w2, #16
+	bcs	2b
+	strb	w0, [x1, #SCIF_SCFTDR]
+
+	ret
+endfunc console_core_putc
+
+	/* ---------------------------------------------
+	 * int console_getc(void)
+	 * Function to get a character from the console.
+	 * It returns the character grabbed on success
+	 * or -1 on error.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_getc
+	mov	w0, #-1			/* no support */
+	ret
+endfunc console_getc
diff --git a/plat/renesas/rcar/include/bl2_axi_register.h b/plat/renesas/rcar/include/bl2_axi_register.h
new file mode 100644
index 0000000..da449c2
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_axi_register.h
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_AXI_REGISTER_H__
+#define	BL2_AXI_REGISTER_H__
+
+/* AXI registers */
+
+/* AXI base address */
+#define	AXI_BASE	(0xE6780000U)
+
+/* address split */
+
+/* AXI address split control 0 */
+#define	AXI_ADSPLCR0	(AXI_BASE + 0x4008U)
+/* AXI address split control 1 */
+#define	AXI_ADSPLCR1	(AXI_BASE + 0x400CU)
+/* AXI address split control 2 */
+#define	AXI_ADSPLCR2	(AXI_BASE + 0x4010U)
+/* AXI address split control 3 */
+#define	AXI_ADSPLCR3	(AXI_BASE + 0x4014U)
+
+/* functional safety */
+
+/* AXI functional safety control */
+#define	AXI_FUSACR	(AXI_BASE + 0x4020U)
+
+/* decompression */
+
+/* AXI decompression area configuration A0 */
+#define	AXI_DCMPAREACRA0	(AXI_BASE + 0x4100U)
+/* AXI decompression area configuration B0 */
+#define	AXI_DCMPAREACRB0	(AXI_BASE + 0x4104U)
+/* AXI decompression area configuration A1 */
+#define	AXI_DCMPAREACRA1	(AXI_BASE + 0x4108U)
+/* AXI decompression area configuration B1 */
+#define	AXI_DCMPAREACRB1	(AXI_BASE + 0x410CU)
+/* AXI decompression area configuration A2 */
+#define	AXI_DCMPAREACRA2	(AXI_BASE + 0x4110U)
+/* AXI decompression area configuration B2 */
+#define	AXI_DCMPAREACRB2	(AXI_BASE + 0x4114U)
+/* AXI decompression area configuration A3 */
+#define	AXI_DCMPAREACRA3	(AXI_BASE + 0x4118U)
+/* AXI decompression area configuration B3 */
+#define	AXI_DCMPAREACRB3	(AXI_BASE + 0x411CU)
+/* AXI decompression area configuration A4 */
+#define	AXI_DCMPAREACRA4	(AXI_BASE + 0x4120U)
+/* AXI decompression area configuration B4 */
+#define	AXI_DCMPAREACRB4	(AXI_BASE + 0x4124U)
+/* AXI decompression area configuration A5 */
+#define	AXI_DCMPAREACRA5	(AXI_BASE + 0x4128U)
+/* AXI decompression area configuration B5 */
+#define	AXI_DCMPAREACRB5	(AXI_BASE + 0x412CU)
+/* AXI decompression area configuration A6 */
+#define	AXI_DCMPAREACRA6	(AXI_BASE + 0x4130U)
+/* AXI decompression area configuration B6 */
+#define	AXI_DCMPAREACRB6	(AXI_BASE + 0x4134U)
+/* AXI decompression area configuration A7 */
+#define	AXI_DCMPAREACRA7	(AXI_BASE + 0x4138U)
+/* AXI decompression area configuration B7 */
+#define	AXI_DCMPAREACRB7	(AXI_BASE + 0x413CU)
+/* AXI decompression area configuration A8 */
+#define	AXI_DCMPAREACRA8	(AXI_BASE + 0x4140U)
+/* AXI decompression area configuration B8 */
+#define	AXI_DCMPAREACRB8	(AXI_BASE + 0x4144U)
+/* AXI decompression area configuration A9 */
+#define	AXI_DCMPAREACRA9	(AXI_BASE + 0x4148U)
+/* AXI decompression area configuration B9 */
+#define	AXI_DCMPAREACRB9	(AXI_BASE + 0x414CU)
+/* AXI decompression area configuration A10 */
+#define	AXI_DCMPAREACRA10	(AXI_BASE + 0x4150U)
+/* AXI decompression area configuration B10 */
+#define	AXI_DCMPAREACRB10	(AXI_BASE + 0x4154U)
+/* AXI decompression area configuration A11 */
+#define	AXI_DCMPAREACRA11	(AXI_BASE + 0x4158U)
+/* AXI decompression area configuration B11 */
+#define	AXI_DCMPAREACRB11	(AXI_BASE + 0x415CU)
+/* AXI decompression area configuration A12 */
+#define	AXI_DCMPAREACRA12	(AXI_BASE + 0x4160U)
+/* AXI decompression area configuration B12 */
+#define	AXI_DCMPAREACRB12	(AXI_BASE + 0x4164U)
+/* AXI decompression area configuration A13 */
+#define	AXI_DCMPAREACRA13	(AXI_BASE + 0x4168U)
+/* AXI decompression area configuration B13 */
+#define	AXI_DCMPAREACRB13	(AXI_BASE + 0x416CU)
+/* AXI decompression area configuration A14 */
+#define	AXI_DCMPAREACRA14	(AXI_BASE + 0x4170U)
+/* AXI decompression area configuration B14 */
+#define	AXI_DCMPAREACRB14	(AXI_BASE + 0x4174U)
+/* AXI decompression area configuration A15 */
+#define	AXI_DCMPAREACRA15	(AXI_BASE + 0x4178U)
+/* AXI decompression area configuration B15 */
+#define	AXI_DCMPAREACRB15	(AXI_BASE + 0x417CU)
+/* AXI decompression shadow area configuration */
+#define	AXI_DCMPSHDWCR	(AXI_BASE + 0x4280U)
+
+/* SDRAM protection */
+
+/* AXI dram protected area division 0 */
+#define	AXI_DPTDIVCR0	(AXI_BASE + 0x4400U)
+/* AXI dram protected area division 1 */
+#define	AXI_DPTDIVCR1	(AXI_BASE + 0x4404U)
+/* AXI dram protected area division 2 */
+#define	AXI_DPTDIVCR2	(AXI_BASE + 0x4408U)
+/* AXI dram protected area division 3 */
+#define	AXI_DPTDIVCR3	(AXI_BASE + 0x440CU)
+/* AXI dram protected area division 4 */
+#define	AXI_DPTDIVCR4	(AXI_BASE + 0x4410U)
+/* AXI dram protected area division 5 */
+#define	AXI_DPTDIVCR5	(AXI_BASE + 0x4414U)
+/* AXI dram protected area division 6 */
+#define	AXI_DPTDIVCR6	(AXI_BASE + 0x4418U)
+/* AXI dram protected area division 7 */
+#define	AXI_DPTDIVCR7	(AXI_BASE + 0x441CU)
+/* AXI dram protected area division 8 */
+#define	AXI_DPTDIVCR8	(AXI_BASE + 0x4420U)
+/* AXI dram protected area division 9 */
+#define	AXI_DPTDIVCR9	(AXI_BASE + 0x4424U)
+/* AXI dram protected area division 10 */
+#define	AXI_DPTDIVCR10	(AXI_BASE + 0x4428U)
+/* AXI dram protected area division 11 */
+#define	AXI_DPTDIVCR11	(AXI_BASE + 0x442CU)
+/* AXI dram protected area division 12 */
+#define	AXI_DPTDIVCR12	(AXI_BASE + 0x4430U)
+/* AXI dram protected area division 13 */
+#define	AXI_DPTDIVCR13	(AXI_BASE + 0x4434U)
+/* AXI dram protected area division 14 */
+#define	AXI_DPTDIVCR14	(AXI_BASE + 0x4438U)
+
+/* AXI dram protected area setting 0 */
+#define	AXI_DPTCR0	(AXI_BASE + 0x4440U)
+/* AXI dram protected area setting 1 */
+#define	AXI_DPTCR1	(AXI_BASE + 0x4444U)
+/* AXI dram protected area setting 2 */
+#define	AXI_DPTCR2	(AXI_BASE + 0x4448U)
+/* AXI dram protected area setting 3 */
+#define	AXI_DPTCR3	(AXI_BASE + 0x444CU)
+/* AXI dram protected area setting 4 */
+#define	AXI_DPTCR4	(AXI_BASE + 0x4450U)
+/* AXI dram protected area setting 5 */
+#define	AXI_DPTCR5	(AXI_BASE + 0x4454U)
+/* AXI dram protected area setting 6 */
+#define	AXI_DPTCR6	(AXI_BASE + 0x4458U)
+/* AXI dram protected area setting 7 */
+#define	AXI_DPTCR7	(AXI_BASE + 0x445CU)
+/* AXI dram protected area setting 8 */
+#define	AXI_DPTCR8	(AXI_BASE + 0x4460U)
+/* AXI dram protected area setting 9 */
+#define	AXI_DPTCR9	(AXI_BASE + 0x4464U)
+/* AXI dram protected area setting 10 */
+#define	AXI_DPTCR10	(AXI_BASE + 0x4468U)
+/* AXI dram protected area setting 11 */
+#define	AXI_DPTCR11	(AXI_BASE + 0x446CU)
+/* AXI dram protected area setting 12 */
+#define	AXI_DPTCR12	(AXI_BASE + 0x4470U)
+/* AXI dram protected area setting 13 */
+#define	AXI_DPTCR13	(AXI_BASE + 0x4474U)
+/* AXI dram protected area setting 14 */
+#define	AXI_DPTCR14	(AXI_BASE + 0x4478U)
+/* AXI dram protected area setting 15 */
+#define	AXI_DPTCR15	(AXI_BASE + 0x447CU)
+
+/* SRAM protection */
+
+/* AXI sram protected area division 0 */
+#define	AXI_SPTDIVCR0	(AXI_BASE + 0x4500U)
+/* AXI sram protected area division 1 */
+#define	AXI_SPTDIVCR1	(AXI_BASE + 0x4504U)
+/* AXI sram protected area division 2 */
+#define	AXI_SPTDIVCR2	(AXI_BASE + 0x4508U)
+/* AXI sram protected area division 3 */
+#define	AXI_SPTDIVCR3	(AXI_BASE + 0x450CU)
+/* AXI sram protected area division 4 */
+#define	AXI_SPTDIVCR4	(AXI_BASE + 0x4510U)
+/* AXI sram protected area division 5 */
+#define	AXI_SPTDIVCR5	(AXI_BASE + 0x4514U)
+/* AXI sram protected area division 6 */
+#define	AXI_SPTDIVCR6	(AXI_BASE + 0x4518U)
+/* AXI sram protected area division 7 */
+#define	AXI_SPTDIVCR7	(AXI_BASE + 0x451CU)
+/* AXI sram protected area division 8 */
+#define	AXI_SPTDIVCR8	(AXI_BASE + 0x4520U)
+/* AXI sram protected area division 9 */
+#define	AXI_SPTDIVCR9	(AXI_BASE + 0x4524U)
+/* AXI sram protected area division 10 */
+#define	AXI_SPTDIVCR10	(AXI_BASE + 0x4528U)
+/* AXI sram protected area division 11 */
+#define	AXI_SPTDIVCR11	(AXI_BASE + 0x452CU)
+/* AXI sram protected area division 12 */
+#define	AXI_SPTDIVCR12	(AXI_BASE + 0x4530U)
+/* AXI sram protected area division 13 */
+#define	AXI_SPTDIVCR13	(AXI_BASE + 0x4534U)
+/* AXI sram protected area division 14 */
+#define	AXI_SPTDIVCR14	(AXI_BASE + 0x4538U)
+
+/* AXI sram protected area setting 0 */
+#define	AXI_SPTCR0	(AXI_BASE + 0x4540U)
+/* AXI sram protected area setting 1 */
+#define	AXI_SPTCR1	(AXI_BASE + 0x4544U)
+/* AXI sram protected area setting 2 */
+#define	AXI_SPTCR2	(AXI_BASE + 0x4548U)
+/* AXI sram protected area setting 3 */
+#define	AXI_SPTCR3	(AXI_BASE + 0x454CU)
+/* AXI sram protected area setting 4 */
+#define	AXI_SPTCR4	(AXI_BASE + 0x4550U)
+/* AXI sram protected area setting 5 */
+#define	AXI_SPTCR5	(AXI_BASE + 0x4554U)
+/* AXI sram protected area setting 6 */
+#define	AXI_SPTCR6	(AXI_BASE + 0x4558U)
+/* AXI sram protected area setting 7 */
+#define	AXI_SPTCR7	(AXI_BASE + 0x455CU)
+/* AXI sram protected area setting 8 */
+#define	AXI_SPTCR8	(AXI_BASE + 0x4560U)
+/* AXI sram protected area setting 9 */
+#define	AXI_SPTCR9	(AXI_BASE + 0x4564U)
+/* AXI sram protected area setting 10 */
+#define	AXI_SPTCR10	(AXI_BASE + 0x4568U)
+/* AXI sram protected area setting 11 */
+#define	AXI_SPTCR11	(AXI_BASE + 0x456CU)
+/* AXI sram protected area setting 12 */
+#define	AXI_SPTCR12	(AXI_BASE + 0x4570U)
+/* AXI sram protected area setting 13 */
+#define	AXI_SPTCR13	(AXI_BASE + 0x4574U)
+/* AXI sram protected area setting 14 */
+#define	AXI_SPTCR14	(AXI_BASE + 0x4578U)
+/* AXI sram protected area setting 15 */
+#define	AXI_SPTCR15	(AXI_BASE + 0x457CU)
+
+/* EDC base address */
+#define	EDC_BASE	(0xFF840000U)
+
+/* EDC edc enable */
+#define	EDC_EDCEN	(EDC_BASE + 0x0010U)
+/* EDC edc status 0 */
+#define	EDC_EDCST0	(EDC_BASE + 0x0020U)
+/* EDC edc status 1 */
+#define	EDC_EDCST1	(EDC_BASE + 0x0024U)
+/* EDC edc interrupt enable 0 */
+#define	EDC_EDCINTEN0	(EDC_BASE + 0x0040U)
+/* EDC edc interrupt enable 1 */
+#define	EDC_EDCINTEN1	(EDC_BASE + 0x0044U)
+
+#endif	/* BL2_AXI_REGISTER_H__ */
+
diff --git a/plat/renesas/rcar/include/bl2_cpg_init.h b/plat/renesas/rcar/include/bl2_cpg_init.h
new file mode 100644
index 0000000..529bc58
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_cpg_init.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_CPG_INIT_H__
+#define	BL2_CPG_INIT_H__
+
+void bl2_cpg_init(void);
+
+#endif	/* BL2_CPG_INIT_H__ */
diff --git a/plat/renesas/rcar/include/bl2_cpg_register.h b/plat/renesas/rcar/include/bl2_cpg_register.h
new file mode 100644
index 0000000..f58f038
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_cpg_register.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_CPG_REGISTER_H__
+#define	BL2_CPG_REGISTER_H__
+
+/* CPG base address */
+#define	CPG_BASE	(0xE6150000U)
+
+/* CPG system module stop control 2 */
+#define CPG_SMSTPCR2	(CPG_BASE + 0x0138U)
+/* CPG software reset 2 */
+#define CPG_SRCR2	(CPG_BASE + 0x00B0U)
+/* CPG module stop status 2 */
+#define CPG_MSTPSR2	(CPG_BASE + 0x0040U)
+/* CPG write protect */
+#define CPG_CPGWPR	(CPG_BASE + 0x0900U)
+/* CPG write protect control */
+#define CPG_CPGWPCR	(CPG_BASE + 0x0904U)
+/* CPG system module stop control 9 */
+#define CPG_SMSTPCR9    (CPG_BASE + 0x0994U)
+/* CPG module stop status 9 */
+#define CPG_MSTPSR9     (CPG_BASE + 0x09A4U)
+
+/* CPG (SECURITY) registers */
+
+/* Secure Module Stop Control Register 0 */
+#define	SCMSTPCR0	(CPG_BASE + 0x0B20U)
+/* Secure Module Stop Control Register 1 */
+#define	SCMSTPCR1	(CPG_BASE + 0x0B24U)
+/* Secure Module Stop Control Register 2 */
+#define	SCMSTPCR2	(CPG_BASE + 0x0B28U)
+/* Secure Module Stop Control Register 3 */
+#define	SCMSTPCR3	(CPG_BASE + 0x0B2CU)
+/* Secure Module Stop Control Register 4 */
+#define	SCMSTPCR4	(CPG_BASE + 0x0B30U)
+/* Secure Module Stop Control Register 5 */
+#define	SCMSTPCR5	(CPG_BASE + 0x0B34U)
+/* Secure Module Stop Control Register 6 */
+#define	SCMSTPCR6	(CPG_BASE + 0x0B38U)
+/* Secure Module Stop Control Register 7 */
+#define	SCMSTPCR7	(CPG_BASE + 0x0B3CU)
+/* Secure Module Stop Control Register 8 */
+#define	SCMSTPCR8	(CPG_BASE + 0x0B40U)
+/* Secure Module Stop Control Register 9 */
+#define	SCMSTPCR9	(CPG_BASE + 0x0B44U)
+/* Secure Module Stop Control Register 10 */
+#define	SCMSTPCR10	(CPG_BASE + 0x0B48U)
+/* Secure Module Stop Control Register 11 */
+#define	SCMSTPCR11	(CPG_BASE + 0x0B4CU)
+
+/* CPG (SECURITY) registers */
+
+/* Secure Software Reset Access Enable Control Register 0 */
+#define	SCSRSTECR0	(CPG_BASE + 0x0B80U)
+/* Secure Software Reset Access Enable Control Register 1 */
+#define	SCSRSTECR1	(CPG_BASE + 0x0B84U)
+/* Secure Software Reset Access Enable Control Register 2 */
+#define	SCSRSTECR2	(CPG_BASE + 0x0B88U)
+/* Secure Software Reset Access Enable Control Register 3 */
+#define	SCSRSTECR3	(CPG_BASE + 0x0B8CU)
+/* Secure Software Reset Access Enable Control Register 4 */
+#define	SCSRSTECR4	(CPG_BASE + 0x0B90U)
+/* Secure Software Reset Access Enable Control Register 5 */
+#define	SCSRSTECR5	(CPG_BASE + 0x0B94U)
+/* Secure Software Reset Access Enable Control Register 6 */
+#define	SCSRSTECR6	(CPG_BASE + 0x0B98U)
+/* Secure Software Reset Access Enable Control Register 7 */
+#define	SCSRSTECR7	(CPG_BASE + 0x0B9CU)
+/* Secure Software Reset Access Enable Control Register 8 */
+#define	SCSRSTECR8	(CPG_BASE + 0x0BA0U)
+/* Secure Software Reset Access Enable Control Register 9 */
+#define	SCSRSTECR9	(CPG_BASE + 0x0BA4U)
+/* Secure Software Reset Access Enable Control Register 10 */
+#define	SCSRSTECR10	(CPG_BASE + 0x0BA8U)
+/* Secure Software Reset Access Enable Control Register 11 */
+#define	SCSRSTECR11	(CPG_BASE + 0x0BACU)
+
+/* CPG (SAFETY) registers */
+
+/* Safety Module Stop Control Register 0 */
+#define	SAMSTPCR0	(CPG_BASE + 0x0C20U)
+/* Safety Module Stop Control Register 1 */
+#define	SAMSTPCR1	(CPG_BASE + 0x0C24U)
+/* Safety Module Stop Control Register 2 */
+#define	SAMSTPCR2	(CPG_BASE + 0x0C28U)
+/* Safety Module Stop Control Register 3 */
+#define	SAMSTPCR3	(CPG_BASE + 0x0C2CU)
+/* Safety Module Stop Control Register 4 */
+#define	SAMSTPCR4	(CPG_BASE + 0x0C30U)
+/* Safety Module Stop Control Register 5 */
+#define	SAMSTPCR5	(CPG_BASE + 0x0C34U)
+/* Safety Module Stop Control Register 6 */
+#define	SAMSTPCR6	(CPG_BASE + 0x0C38U)
+/* Safety Module Stop Control Register 7 */
+#define	SAMSTPCR7	(CPG_BASE + 0x0C3CU)
+/* Safety Module Stop Control Register 8 */
+#define	SAMSTPCR8	(CPG_BASE + 0x0C40U)
+/* Safety Module Stop Control Register 9 */
+#define	SAMSTPCR9	(CPG_BASE + 0x0C44U)
+/* Safety Module Stop Control Register 10 */
+#define	SAMSTPCR10	(CPG_BASE + 0x0C48U)
+/* Safety Module Stop Control Register 11 */
+#define	SAMSTPCR11	(CPG_BASE + 0x0C4CU)
+
+/* CPG (SAFETY) registers */
+
+/* Safety Software Reset Access Enable Control Register 0 */
+#define	SASRSTECR0	(CPG_BASE + 0x0C80U)
+/* Safety Software Reset Access Enable Control Register 1 */
+#define	SASRSTECR1	(CPG_BASE + 0x0C84U)
+/* Safety Software Reset Access Enable Control Register 2 */
+#define	SASRSTECR2	(CPG_BASE + 0x0C88U)
+/* Safety Software Reset Access Enable Control Register 3 */
+#define	SASRSTECR3	(CPG_BASE + 0x0C8CU)
+/* Safety Software Reset Access Enable Control Register 4 */
+#define	SASRSTECR4	(CPG_BASE + 0x0C90U)
+/* Safety Software Reset Access Enable Control Register 5 */
+#define	SASRSTECR5	(CPG_BASE + 0x0C94U)
+/* Safety Software Reset Access Enable Control Register 6 */
+#define	SASRSTECR6	(CPG_BASE + 0x0C98U)
+/* Safety Software Reset Access Enable Control Register 7 */
+#define	SASRSTECR7	(CPG_BASE + 0x0C9CU)
+/* Safety Software Reset Access Enable Control Register 8 */
+#define	SASRSTECR8	(CPG_BASE + 0x0CA0U)
+/* Safety Software Reset Access Enable Control Register 9 */
+#define	SASRSTECR9	(CPG_BASE + 0x0CA4U)
+/* Safety Software Reset Access Enable Control Register 10 */
+#define	SASRSTECR10	(CPG_BASE + 0x0CA8U)
+/* Safety Software Reset Access Enable Control Register 11 */
+#define	SASRSTECR11	(CPG_BASE + 0x0CACU)
+
+#endif	/* BL2_CPG_REGISTER_H__ */
diff --git a/plat/renesas/rcar/include/bl2_cpg_write.h b/plat/renesas/rcar/include/bl2_cpg_write.h
new file mode 100644
index 0000000..638371e
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_cpg_write.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_CPG_WRITE_H__
+#define	BL2_CPG_WRITE_H__
+
+#include "bl2_cpg_register.h"
+#include "mmio.h"
+
+static inline void cpg_write(uintptr_t regadr, uint32_t regval)
+{
+	uint32_t val = (regval);
+	mmio_write_32((uintptr_t)CPG_CPGWPR,~val);
+	mmio_write_32(regadr,val);
+}
+
+#endif	/* BL2_CPG_WRITE_H__ */
diff --git a/plat/renesas/rcar/include/bl2_dma_register.h b/plat/renesas/rcar/include/bl2_dma_register.h
new file mode 100644
index 0000000..e168add
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_dma_register.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_DMA_REGISTER_H__
+#define BL2_DMA_REGISTER_H__
+
+#define	DMACH	0	/* DMA CH setting (0/16/32) */
+
+#if (DMACH==0)		/* SYS-DMAC0 (CH0) */
+#define SYS_DMAC2_BIT	(0x00080000U)
+#define DMA_BASE	(0xE6700000U)
+#elif (DMACH==16)	/* SYS-DMAC1 (CH16) */
+#define SYS_DMAC2_BIT	(0x00040000U)
+#define DMA_BASE	(0xE7300000U)
+#elif (DMACH==32)	/* SYS-DMAC2 (CH32) */
+#define SYS_DMAC2_BIT	(0x00020000U)
+#define DMA_BASE	(0xE7320000U)
+#else
+#define SYS_DMAC2_BIT	(0x00080000U)
+#define DMA_BASE	(0xE6700000U)
+#endif
+
+/* DMA operation 0 */
+#define DMA_DMAOR2	(DMA_BASE + 0x0060U)
+/* DMA secure control */
+#define	DMA_DMASEC2	(DMA_BASE + 0x0030U)
+/* DMA channel clear */
+#define DMA_DMACHCLR2	(DMA_BASE + 0x0080U)
+/* DMA source address */
+#define DMA_DMASAR32	(DMA_BASE + 0x8000U)
+/* DMA destination address */
+#define DMA_DMADAR32	(DMA_BASE + 0x8004U)
+/* DMA transfer count */
+#define DMA_DMATCR32	(DMA_BASE + 0x8008U)
+/* DMA channel control */
+#define DMA_DMACHCR32	(DMA_BASE + 0x800CU)
+
+#endif	/* BL2_DMA_REGISTER_H__ */
+
diff --git a/plat/renesas/rcar/include/bl2_lifec_register.h b/plat/renesas/rcar/include/bl2_lifec_register.h
new file mode 100644
index 0000000..5178c34
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_lifec_register.h
@@ -0,0 +1,305 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_LIFEC_REGISTER_H__
+#define	BL2_LIFEC_REGISTER_H__
+
+/* LIFEC0 (SECURITY) registers */
+
+/* LIFEC0 (SECURITY) base address */
+#define	LIFEC_SEC_BASE	(0xE6110000U)
+
+/* Security attribute setting for master ports */
+#define	SEC_SRC		(LIFEC_SEC_BASE + 0x0008U)
+/* Security attribute setting for slave ports 0 */
+#define	SEC_SEL0	(LIFEC_SEC_BASE + 0x0030U)
+/* Security attribute setting for slave ports 1 */
+#define	SEC_SEL1	(LIFEC_SEC_BASE + 0x0034U)
+/* Security attribute setting for slave ports 2 */
+#define	SEC_SEL2	(LIFEC_SEC_BASE + 0x0038U)
+/* Security attribute setting for slave ports 3 */
+#define	SEC_SEL3	(LIFEC_SEC_BASE + 0x003CU)
+/* Security attribute setting for slave ports 4 */
+#define	SEC_SEL4	(LIFEC_SEC_BASE + 0x0058U)
+/* Security attribute setting for slave ports 5 */
+#define	SEC_SEL5	(LIFEC_SEC_BASE + 0x005CU)
+/* Security attribute setting for slave ports 6 */
+#define SEC_SEL6	(LIFEC_SEC_BASE + 0x0060U)
+/* Security attribute setting for slave ports 7 */
+#define	SEC_SEL7	(LIFEC_SEC_BASE + 0x0064U)
+/* Security attribute setting for slave ports 8 */
+#define	SEC_SEL8	(LIFEC_SEC_BASE + 0x0068U)
+/* Security attribute setting for slave ports 9 */
+#define	SEC_SEL9	(LIFEC_SEC_BASE + 0x006CU)
+/* Security attribute setting for slave ports 10 */
+#define	SEC_SEL10	(LIFEC_SEC_BASE + 0x0070U)
+/* Security attribute setting for slave ports 11 */
+#define	SEC_SEL11	(LIFEC_SEC_BASE + 0x0074U)
+/* Security attribute setting for slave ports 12 */
+#define	SEC_SEL12	(LIFEC_SEC_BASE + 0x0078U)
+/* Security attribute setting for slave ports 13 */
+#define	SEC_SEL13	(LIFEC_SEC_BASE + 0x007CU)
+/* Security attribute setting for slave ports 14 */
+#define	SEC_SEL14	(LIFEC_SEC_BASE + 0x0080U)
+/* Security attribute setting for slave ports 15 */
+#define	SEC_SEL15	(LIFEC_SEC_BASE + 0x0084U)
+/* Security group 0 attribute setting for master ports 0 */
+#define	SEC_GRP0CR0	(LIFEC_SEC_BASE + 0x0138U)
+/* Security group 1 attribute setting for master ports 0 */
+#define	SEC_GRP1CR0	(LIFEC_SEC_BASE + 0x013CU)
+/* Security group 0 attribute setting for master ports 1 */
+#define	SEC_GRP0CR1	(LIFEC_SEC_BASE + 0x0140U)
+/* Security group 1 attribute setting for master ports 1 */
+#define	SEC_GRP1CR1	(LIFEC_SEC_BASE + 0x0144U)
+/* Security group 0 attribute setting for master ports 2 */
+#define	SEC_GRP0CR2	(LIFEC_SEC_BASE + 0x0148U)
+/* Security group 1 attribute setting for master ports 2 */
+#define	SEC_GRP1CR2	(LIFEC_SEC_BASE + 0x014CU)
+/* Security group 0 attribute setting for master ports 3 */
+#define	SEC_GRP0CR3	(LIFEC_SEC_BASE + 0x0150U)
+/* Security group 1 attribute setting for master ports 3 */
+#define	SEC_GRP1CR3	(LIFEC_SEC_BASE + 0x0154U)
+/* Security group 0 attribute setting for slave ports 0 */
+#define	SEC_GRP0COND0	(LIFEC_SEC_BASE + 0x0158U)
+/* Security group 1 attribute setting for slave ports 0 */
+#define	SEC_GRP1COND0	(LIFEC_SEC_BASE + 0x015CU)
+/* Security group 0 attribute setting for slave ports 1 */
+#define	SEC_GRP0COND1	(LIFEC_SEC_BASE + 0x0160U)
+/* Security group 1 attribute setting for slave ports 1 */
+#define	SEC_GRP1COND1	(LIFEC_SEC_BASE + 0x0164U)
+/* Security group 0 attribute setting for slave ports 2 */
+#define	SEC_GRP0COND2	(LIFEC_SEC_BASE + 0x0168U)
+/* Security group 1 attribute setting for slave ports 2 */
+#define	SEC_GRP1COND2	(LIFEC_SEC_BASE + 0x016CU)
+/* Security group 0 attribute setting for slave ports 3 */
+#define	SEC_GRP0COND3	(LIFEC_SEC_BASE + 0x0170U)
+/* Security group 1 attribute setting for slave ports 3 */
+#define	SEC_GRP1COND3	(LIFEC_SEC_BASE + 0x0174U)
+/* Security group 0 attribute setting for slave ports 4 */
+#define	SEC_GRP0COND4	(LIFEC_SEC_BASE + 0x0178U)
+/* Security group 1 attribute setting for slave ports 4 */
+#define	SEC_GRP1COND4	(LIFEC_SEC_BASE + 0x017CU)
+/* Security group 0 attribute setting for slave ports 5 */
+#define	SEC_GRP0COND5	(LIFEC_SEC_BASE + 0x0180U)
+/* Security group 1 attribute setting for slave ports 5 */
+#define	SEC_GRP1COND5	(LIFEC_SEC_BASE + 0x0184U)
+/* Security group 0 attribute setting for slave ports 6 */
+#define	SEC_GRP0COND6	(LIFEC_SEC_BASE + 0x0188U)
+/* Security group 1 attribute setting for slave ports 6 */
+#define	SEC_GRP1COND6	(LIFEC_SEC_BASE + 0x018CU)
+/* Security group 0 attribute setting for slave ports 7 */
+#define	SEC_GRP0COND7	(LIFEC_SEC_BASE + 0x0190U)
+/* Security group 1 attribute setting for slave ports 7 */
+#define	SEC_GRP1COND7	(LIFEC_SEC_BASE + 0x0194U)
+/* Security group 0 attribute setting for slave ports 8 */
+#define	SEC_GRP0COND8	(LIFEC_SEC_BASE + 0x0198U)
+/* Security group 1 attribute setting for slave ports 8 */
+#define	SEC_GRP1COND8	(LIFEC_SEC_BASE + 0x019CU)
+/* Security group 0 attribute setting for slave ports 9 */
+#define	SEC_GRP0COND9	(LIFEC_SEC_BASE + 0x01A0U)
+/* Security group 1 attribute setting for slave ports 9 */
+#define	SEC_GRP1COND9	(LIFEC_SEC_BASE + 0x01A4U)
+/* Security group 0 attribute setting for slave ports 10 */
+#define	SEC_GRP0COND10	(LIFEC_SEC_BASE + 0x01A8U)
+/* Security group 1 attribute setting for slave ports 10 */
+#define	SEC_GRP1COND10	(LIFEC_SEC_BASE + 0x01ACU)
+/* Security group 0 attribute setting for slave ports 11 */
+#define	SEC_GRP0COND11	(LIFEC_SEC_BASE + 0x01B0U)
+/* Security group 1 attribute setting for slave ports 11 */
+#define	SEC_GRP1COND11	(LIFEC_SEC_BASE + 0x01B4U)
+/* Security group 0 attribute setting for slave ports 12 */
+#define	SEC_GRP0COND12	(LIFEC_SEC_BASE + 0x01B8U)
+/* Security group 1 attribute setting for slave ports 12 */
+#define	SEC_GRP1COND12	(LIFEC_SEC_BASE + 0x01BCU)
+/* Security group 0 attribute setting for slave ports 13 */
+#define	SEC_GRP0COND13	(LIFEC_SEC_BASE + 0x01C0U)
+/* Security group 1 attribute setting for slave ports 13 */
+#define	SEC_GRP1COND13	(LIFEC_SEC_BASE + 0x01C4U)
+/* Security group 0 attribute setting for slave ports 14 */
+#define	SEC_GRP0COND14	(LIFEC_SEC_BASE + 0x01C8U)
+/* Security group 1 attribute setting for slave ports 14 */
+#define	SEC_GRP1COND14	(LIFEC_SEC_BASE + 0x01CCU)
+/* Security group 0 attribute setting for slave ports 15 */
+#define	SEC_GRP0COND15	(LIFEC_SEC_BASE + 0x01D0U)
+/* Security group 1 attribute setting for slave ports 15 */
+#define	SEC_GRP1COND15	(LIFEC_SEC_BASE + 0x01D4U)
+/* Security write protection attribute setting for slave ports 0 */
+#define	SEC_READONLY0	(LIFEC_SEC_BASE + 0x01D8U)
+/* Security write protection attribute setting for slave ports 1 */
+#define	SEC_READONLY1	(LIFEC_SEC_BASE + 0x01DCU)
+/* Security write protection attribute setting for slave ports 2 */
+#define	SEC_READONLY2	(LIFEC_SEC_BASE + 0x01E0U)
+/* Security write protection attribute setting for slave ports 3 */
+#define	SEC_READONLY3	(LIFEC_SEC_BASE + 0x01E4U)
+/* Security write protection attribute setting for slave ports 4 */
+#define	SEC_READONLY4	(LIFEC_SEC_BASE + 0x01E8U)
+/* Security write protection attribute setting for slave ports 5 */
+#define	SEC_READONLY5	(LIFEC_SEC_BASE + 0x01ECU)
+/* Security write protection attribute setting for slave ports 6 */
+#define	SEC_READONLY6	(LIFEC_SEC_BASE + 0x01F0U)
+/* Security write protection attribute setting for slave ports 7 */
+#define	SEC_READONLY7	(LIFEC_SEC_BASE + 0x01F4U)
+/* Security write protection attribute setting for slave ports 8 */
+#define	SEC_READONLY8	(LIFEC_SEC_BASE + 0x01F8U)
+/* Security write protection attribute setting for slave ports 9 */
+#define	SEC_READONLY9	(LIFEC_SEC_BASE + 0x01FCU)
+/* Security write protection attribute setting for slave ports 10 */
+#define	SEC_READONLY10	(LIFEC_SEC_BASE + 0x0200U)
+/* Security write protection attribute setting for slave ports 11 */
+#define	SEC_READONLY11	(LIFEC_SEC_BASE + 0x0204U)
+/* Security write protection attribute setting for slave ports 12 */
+#define	SEC_READONLY12	(LIFEC_SEC_BASE + 0x0208U)
+/* Security write protection attribute setting for slave ports 13 */
+#define	SEC_READONLY13	(LIFEC_SEC_BASE + 0x020CU)
+/* Security write protection attribute setting for slave ports 14 */
+#define	SEC_READONLY14	(LIFEC_SEC_BASE + 0x0210U)
+/* Security write protection attribute setting for slave ports 15 */
+#define	SEC_READONLY15	(LIFEC_SEC_BASE + 0x0214U)
+
+/* LIFEC1 (SAFETY) registers */
+
+/* LIFEC1 (SAFETY) base address */
+#define	LIFEC_SAFE_BASE	(0xE6120000U)
+
+/* Safety group 0 attribute setting for master ports 0 */
+#define	SAFE_GRP0CR0	(LIFEC_SAFE_BASE + 0x0138U)
+/* Safety group 1 attribute setting for master ports 0 */
+#define	SAFE_GRP1CR0	(LIFEC_SAFE_BASE + 0x013CU)
+/* Safety group 0 attribute setting for master ports 1 */
+#define	SAFE_GRP0CR1	(LIFEC_SAFE_BASE + 0x0140U)
+/* Safety group 1 attribute setting for master ports 1 */
+#define	SAFE_GRP1CR1	(LIFEC_SAFE_BASE + 0x0144U)
+/* Safety group 0 attribute setting for master ports 2 */
+#define	SAFE_GRP0CR2	(LIFEC_SAFE_BASE + 0x0148U)
+/* Safety group 1 attribute setting for master ports 2 */
+#define	SAFE_GRP1CR2	(LIFEC_SAFE_BASE + 0x014CU)
+/* Safety group 0 attribute setting for master ports 3 */
+#define	SAFE_GRP0CR3	(LIFEC_SAFE_BASE + 0x0150U)
+/* Safety group 1 attribute setting for master ports 3 */
+#define	SAFE_GRP1CR3	(LIFEC_SAFE_BASE + 0x0154U)
+/* Safety group 0 attribute setting for slave ports 0 */
+#define	SAFE_GRP0COND0	(LIFEC_SAFE_BASE + 0x0158U)
+/* Safety group 1 attribute setting for slave ports 0 */
+#define	SAFE_GRP1COND0	(LIFEC_SAFE_BASE + 0x015CU)
+/* Safety group 0 attribute setting for slave ports 1 */
+#define	SAFE_GRP0COND1	(LIFEC_SAFE_BASE + 0x0160U)
+/* Safety group 1 attribute setting for slave ports 1 */
+#define	SAFE_GRP1COND1	(LIFEC_SAFE_BASE + 0x0164U)
+/* Safety group 0 attribute setting for slave ports 2 */
+#define	SAFE_GRP0COND2	(LIFEC_SAFE_BASE + 0x0168U)
+/* Safety group 1 attribute setting for slave ports 2 */
+#define	SAFE_GRP1COND2	(LIFEC_SAFE_BASE + 0x016CU)
+/* Safety group 0 attribute setting for slave ports 3 */
+#define	SAFE_GRP0COND3	(LIFEC_SAFE_BASE + 0x0170U)
+/* Safety group 1 attribute setting for slave ports 3 */
+#define	SAFE_GRP1COND3	(LIFEC_SAFE_BASE + 0x0174U)
+/* Safety group 0 attribute setting for slave ports 4 */
+#define	SAFE_GRP0COND4	(LIFEC_SAFE_BASE + 0x0178U)
+/* Safety group 1 attribute setting for slave ports 4 */
+#define	SAFE_GRP1COND4	(LIFEC_SAFE_BASE + 0x017CU)
+/* Safety group 0 attribute setting for slave ports 5 */
+#define	SAFE_GRP0COND5	(LIFEC_SAFE_BASE + 0x0180U)
+/* Safety group 1 attribute setting for slave ports 5 */
+#define	SAFE_GRP1COND5	(LIFEC_SAFE_BASE + 0x0184U)
+/* Safety group 0 attribute setting for slave ports 6 */
+#define	SAFE_GRP0COND6	(LIFEC_SAFE_BASE + 0x0188U)
+/* Safety group 1 attribute setting for slave ports 6 */
+#define	SAFE_GRP1COND6	(LIFEC_SAFE_BASE + 0x018CU)
+/* Safety group 0 attribute setting for slave ports 7 */
+#define	SAFE_GRP0COND7	(LIFEC_SAFE_BASE + 0x0190U)
+/* Safety group 1 attribute setting for slave ports 7 */
+#define	SAFE_GRP1COND7	(LIFEC_SAFE_BASE + 0x0194U)
+/* Safety group 0 attribute setting for slave ports 8 */
+#define	SAFE_GRP0COND8	(LIFEC_SAFE_BASE + 0x0198U)
+/* Safety group 1 attribute setting for slave ports 8 */
+#define	SAFE_GRP1COND8	(LIFEC_SAFE_BASE + 0x019CU)
+/* Safety group 0 attribute setting for slave ports 9 */
+#define	SAFE_GRP0COND9	(LIFEC_SAFE_BASE + 0x01A0U)
+/* Safety group 1 attribute setting for slave ports 9 */
+#define	SAFE_GRP1COND9	(LIFEC_SAFE_BASE + 0x01A4U)
+/* Safety group 0 attribute setting for slave ports 10 */
+#define	SAFE_GRP0COND10	(LIFEC_SAFE_BASE + 0x01A8U)
+/* Safety group 1 attribute setting for slave ports 10 */
+#define	SAFE_GRP1COND10	(LIFEC_SAFE_BASE + 0x01ACU)
+/* Safety group 0 attribute setting for slave ports 11 */
+#define	SAFE_GRP0COND11	(LIFEC_SAFE_BASE + 0x01B0U)
+/* Safety group 1 attribute setting for slave ports 11 */
+#define	SAFE_GRP1COND11	(LIFEC_SAFE_BASE + 0x01B4U)
+/* Safety group 0 attribute setting for slave ports 12 */
+#define	SAFE_GRP0COND12	(LIFEC_SAFE_BASE + 0x01B8U)
+/* Safety group 1 attribute setting for slave ports 12 */
+#define	SAFE_GRP1COND12	(LIFEC_SAFE_BASE + 0x01BCU)
+/* Safety group 0 attribute setting for slave ports 13 */
+#define	SAFE_GRP0COND13	(LIFEC_SAFE_BASE + 0x01C0U)
+/* Safety group 1 attribute setting for slave ports 13 */
+#define	SAFE_GRP1COND13	(LIFEC_SAFE_BASE + 0x01C4U)
+/* Safety group 0 attribute setting for slave ports 14 */
+#define	SAFE_GRP0COND14	(LIFEC_SAFE_BASE + 0x01C8U)
+/* Safety group 1 attribute setting for slave ports 14 */
+#define	SAFE_GRP1COND14	(LIFEC_SAFE_BASE + 0x01CCU)
+/* Safety group 0 attribute setting for slave ports 15 */
+#define	SAFE_GRP0COND15	(LIFEC_SAFE_BASE + 0x01D0U)
+/* Safety group 1 attribute setting for slave ports 15 */
+#define	SAFE_GRP1COND15	(LIFEC_SAFE_BASE + 0x01D4U)
+/* Safety write protection attribute setting for slave ports 0 */
+#define	SAFE_READONLY0	(LIFEC_SAFE_BASE + 0x01D8U)
+/* Safety write protection attribute setting for slave ports 1 */
+#define	SAFE_READONLY1	(LIFEC_SAFE_BASE + 0x01DCU)
+/* Safety write protection attribute setting for slave ports 2 */
+#define	SAFE_READONLY2	(LIFEC_SAFE_BASE + 0x01E0U)
+/* Safety write protection attribute setting for slave ports 3 */
+#define	SAFE_READONLY3	(LIFEC_SAFE_BASE + 0x01E4U)
+/* Safety write protection attribute setting for slave ports 4 */
+#define	SAFE_READONLY4	(LIFEC_SAFE_BASE + 0x01E8U)
+/* Safety write protection attribute setting for slave ports 5 */
+#define	SAFE_READONLY5	(LIFEC_SAFE_BASE + 0x01ECU)
+/* Safety write protection attribute setting for slave ports 6 */
+#define	SAFE_READONLY6	(LIFEC_SAFE_BASE + 0x01F0U)
+/* Safety write protection attribute setting for slave ports 7 */
+#define	SAFE_READONLY7	(LIFEC_SAFE_BASE + 0x01F4U)
+/* Safety write protection attribute setting for slave ports 8 */
+#define	SAFE_READONLY8	(LIFEC_SAFE_BASE + 0x01F8U)
+/* Safety write protection attribute setting for slave ports 9 */
+#define	SAFE_READONLY9	(LIFEC_SAFE_BASE + 0x01FCU)
+/* Safety write protection attribute setting for slave ports 10 */
+#define	SAFE_READONLY10	(LIFEC_SAFE_BASE + 0x0200U)
+/* Safety write protection attribute setting for slave ports 11 */
+#define	SAFE_READONLY11	(LIFEC_SAFE_BASE + 0x0204U)
+/* Safety write protection attribute setting for slave ports 12 */
+#define	SAFE_READONLY12	(LIFEC_SAFE_BASE + 0x0208U)
+/* Safety write protection attribute setting for slave ports 13 */
+#define	SAFE_READONLY13	(LIFEC_SAFE_BASE + 0x020CU)
+/* Safety write protection attribute setting for slave ports 14 */
+#define	SAFE_READONLY14	(LIFEC_SAFE_BASE + 0x0210U)
+/* Safety write protection attribute setting for slave ports 15 */
+#define	SAFE_READONLY15	(LIFEC_SAFE_BASE + 0x0214U)
+
+#endif	/* BL2_LIFEC_REGISTER_H__ */
diff --git a/plat/renesas/rcar/include/bl2_pfc_init.h b/plat/renesas/rcar/include/bl2_pfc_init.h
new file mode 100644
index 0000000..7b68beb
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_pfc_init.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_PFC_INIT_H__
+#define BL2_PFC_INIT_H__
+
+void bl2_pfc_init(void);
+
+#endif	/* BL2_PFC_INIT_H__ */
diff --git a/plat/renesas/rcar/include/bl2_phy_init.h b/plat/renesas/rcar/include/bl2_phy_init.h
new file mode 100644
index 0000000..0b864b2
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_phy_init.h
@@ -0,0 +1,273 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_PHY_INIT_H__
+#define BL2_PHY_INIT_H__
+
+#define	INIT_DRAM_TBL_PHY_START		(0x400U)
+#define	INIT_DRAM_TBL_PI_START		(0x200U)
+
+#define	INIT_DRAM_TBL_PHY_3200_NUM	(827U)
+#define	INIT_DRAM_TBL_PI_3200_NUM	(181U)
+
+#define	INIT_DRAM_TBL_PHY_1600_NUM	(827U)
+#define	INIT_DRAM_TBL_PI_1600_NUM	(181U)
+
+#define	PHY_MAX_NUM			(4U)
+
+enum {
+	PHY_DQ_TSEL_SELECT_0 = 0,
+	PHY_DQS_TSEL_SELECT_0,
+	PHY_LP4_RDLVL_PATT8_0,
+	PHY_DQ_SWIZZLING_0,
+	PHY_WRLVL_HARD1_DELAY_OBS_0,
+	PHY_WRLVL_HARD0_DELAY_OBS_0,
+	PHY_CLK_WRDQ1_SLAVE_DELAY_0,
+	PHY_CLK_WRDQ0_SLAVE_DELAY_0,
+	PHY_CLK_WRDQ3_SLAVE_DELAY_0,
+	PHY_CLK_WRDQ2_SLAVE_DELAY_0,
+	PHY_CLK_WRDQ5_SLAVE_DELAY_0,
+	PHY_CLK_WRDQ4_SLAVE_DELAY_0,
+	PHY_CLK_WRDQ7_SLAVE_DELAY_0,
+	PHY_CLK_WRDQ6_SLAVE_DELAY_0,
+	PHY_CLK_WRDM_SLAVE_DELAY_0,
+	PHY_RDDQ1_SLAVE_DELAY_0,
+	PHY_RDDQ0_SLAVE_DELAY_0,
+	PHY_RDDQ3_SLAVE_DELAY_0,
+	PHY_RDDQ2_SLAVE_DELAY_0,
+	PHY_RDDQ5_SLAVE_DELAY_0,
+	PHY_RDDQ4_SLAVE_DELAY_0,
+	PHY_RDDQ7_SLAVE_DELAY_0,
+	PHY_RDDQ6_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_0,
+	PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_0,
+	PHY_RDDQS_DM_FALL_SLAVE_DELAY_0,
+	PHY_RDDQS_DM_RISE_SLAVE_DELAY_0,
+	PHY_WRITE_PATH_LAT_ADD_0,
+	PHY_RDDQS_LATENCY_ADJUST_0,
+	PHY_RDDQS_GATE_SLAVE_DELAY_0,
+	PHY_DQ_TSEL_SELECT_1,
+	PHY_DQS_TSEL_SELECT_1,
+	PHY_LP4_RDLVL_PATT8_1,
+	PHY_DQ_SWIZZLING_1,
+	PHY_WRLVL_HARD1_DELAY_OBS_1,
+	PHY_WRLVL_HARD0_DELAY_OBS_1,
+	PHY_CLK_WRDQ1_SLAVE_DELAY_1,
+	PHY_CLK_WRDQ0_SLAVE_DELAY_1,
+	PHY_CLK_WRDQ3_SLAVE_DELAY_1,
+	PHY_CLK_WRDQ2_SLAVE_DELAY_1,
+	PHY_CLK_WRDQ5_SLAVE_DELAY_1,
+	PHY_CLK_WRDQ4_SLAVE_DELAY_1,
+	PHY_CLK_WRDQ7_SLAVE_DELAY_1,
+	PHY_CLK_WRDQ6_SLAVE_DELAY_1,
+	PHY_CLK_WRDQS_SLAVE_DELAY_1,
+	PHY_CLK_WRDM_SLAVE_DELAY_1,
+	PHY_RDDQ1_SLAVE_DELAY_1,
+	PHY_RDDQ0_SLAVE_DELAY_1,
+	PHY_RDDQ3_SLAVE_DELAY_1,
+	PHY_RDDQ2_SLAVE_DELAY_1,
+	PHY_RDDQ5_SLAVE_DELAY_1,
+	PHY_RDDQ4_SLAVE_DELAY_1,
+	PHY_RDDQ7_SLAVE_DELAY_1,
+	PHY_RDDQ6_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_1,
+	PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_1,
+	PHY_RDDQS_DM_FALL_SLAVE_DELAY_1,
+	PHY_RDDQS_DM_RISE_SLAVE_DELAY_1,
+	PHY_WRITE_PATH_LAT_ADD_1,
+	PHY_RDDQS_LATENCY_ADJUST_1,
+	PHY_RDDQS_GATE_SLAVE_DELAY_1,
+	PHY_DQ_TSEL_SELECT_2,
+	PHY_DQS_TSEL_SELECT_2,
+	PHY_LP4_RDLVL_PATT8_2,
+	PHY_DQ_SWIZZLING_2,
+	PHY_WRLVL_HARD1_DELAY_OBS_2,
+	PHY_WRLVL_HARD0_DELAY_OBS_2,
+	PHY_CLK_WRDQ1_SLAVE_DELAY_2,
+	PHY_CLK_WRDQ0_SLAVE_DELAY_2,
+	PHY_CLK_WRDQ3_SLAVE_DELAY_2,
+	PHY_CLK_WRDQ2_SLAVE_DELAY_2,
+	PHY_CLK_WRDQ5_SLAVE_DELAY_2,
+	PHY_CLK_WRDQ4_SLAVE_DELAY_2,
+	PHY_CLK_WRDQ7_SLAVE_DELAY_2,
+	PHY_CLK_WRDQ6_SLAVE_DELAY_2,
+	PHY_CLK_WRDQS_SLAVE_DELAY_2,
+	PHY_CLK_WRDM_SLAVE_DELAY_2,
+	PHY_RDDQ1_SLAVE_DELAY_2,
+	PHY_RDDQ0_SLAVE_DELAY_2,
+	PHY_RDDQ3_SLAVE_DELAY_2,
+	PHY_RDDQ2_SLAVE_DELAY_2,
+	PHY_RDDQ5_SLAVE_DELAY_2,
+	PHY_RDDQ4_SLAVE_DELAY_2,
+	PHY_RDDQ7_SLAVE_DELAY_2,
+	PHY_RDDQ6_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_2,
+	PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_2,
+	PHY_RDDQS_DM_FALL_SLAVE_DELAY_2,
+	PHY_RDDQS_DM_RISE_SLAVE_DELAY_2,
+	PHY_WRITE_PATH_LAT_ADD_2,
+	PHY_RDDQS_LATENCY_ADJUST_2,
+	PHY_RDDQS_GATE_SLAVE_DELAY_2,
+	PHY_DQ_TSEL_SELECT_3,
+	PHY_DQS_TSEL_SELECT_3,
+	PHY_LP4_RDLVL_PATT8_3,
+	PHY_DQ_SWIZZLING_3,
+	PHY_WRLVL_HARD1_DELAY_OBS_3,
+	PHY_WRLVL_HARD0_DELAY_OBS_3,
+	PHY_RDDQ1_SLAVE_DELAY_3,
+	PHY_RDDQ0_SLAVE_DELAY_3,
+	PHY_RDDQ3_SLAVE_DELAY_3,
+	PHY_RDDQ2_SLAVE_DELAY_3,
+	PHY_RDDQ5_SLAVE_DELAY_3,
+	PHY_RDDQ4_SLAVE_DELAY_3,
+	PHY_RDDQ7_SLAVE_DELAY_3,
+	PHY_RDDQ6_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ0_FALL_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ0_RISE_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ1_FALL_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ1_RISE_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ2_FALL_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ2_RISE_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ3_FALL_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ3_RISE_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ4_FALL_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ4_RISE_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ5_FALL_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ5_RISE_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ6_FALL_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ6_RISE_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ7_FALL_SLAVE_DELAY_3,
+	PHY_RDDQS_DQ7_RISE_SLAVE_DELAY_3,
+	PHY_RDDQS_DM_FALL_SLAVE_DELAY_3,
+	PHY_RDDQS_DM_RISE_SLAVE_DELAY_3,
+	PHY_WRITE_PATH_LAT_ADD_3,
+	PHY_RDDQS_LATENCY_ADJUST_3,
+	PHY_RDDQS_GATE_SLAVE_DELAY_3,
+	PHY_ADR_CALVL_SWIZZLE0_0_0,
+	PHY_ADR_CALVL_SWIZZLE1_0_0,
+	PHY_ADR_CALVL_SWIZZLE0_1_0,
+	PHY_ADR_CALVL_DEVICE_MAP_0,
+	PHY_ADR_CALVL_SWIZZLE1_1_0,
+	PHY_ADR_ADDR_SEL_0,
+	PHY_ADR0_CLK_WR_SLAVE_DELAY_0,
+	PHY_ADR2_CLK_WR_SLAVE_DELAY_0,
+	PHY_ADR1_CLK_WR_SLAVE_DELAY_0,
+	PHY_ADR4_CLK_WR_SLAVE_DELAY_0,
+	PHY_ADR3_CLK_WR_SLAVE_DELAY_0,
+	PHY_ADR5_CLK_WR_SLAVE_DELAY_0,
+	PHY_FREQ_SEL_INDEX,
+	SC_PHY_MANUAL_UPDATE,
+	PHY_GRP_SLAVE_DELAY_0,
+	PHY_GRP_SLAVE_DELAY_2,
+	PHY_GRP_SLAVE_DELAY_1,
+	PHY_GRP_SLAVE_DELAY_3,
+	PHY_PAD_ADDR_DRIVE,
+	PHY_PAD_CLK_DRIVE,
+	PHY_PAD_FDBK_TERM,
+	PHY_PAD_DATA_TERM,
+	PHY_PAD_DQS_TERM,
+	PHY_PAD_ADDR_TERM,
+	PHY_PAD_CLK_TERM,
+	PHY_PAD_CKE_DRIVE,
+	PHY_PAD_CKE_TERM,
+	PHY_PAD_RST_DRIVE,
+	PHY_PAD_RST_TERM,
+	PHY_PAD_CS_DRIVE,
+	PHY_PAD_CS_TERM,
+	PHY_CAL_MODE_0,
+	PHY_TST_CLK_PAD_CTRL2,
+	PHY_CAL_START_0,
+	PHY_CAL_CLEAR_0,
+	PHY_CAL_CLK_SELECT_0,
+	PHY_ADRCTL_MANUAL_UPDATE,
+	PI_START,
+	PI_CS_MAP,
+	PI_SW_RST_N,
+	PI_WDT_DISABLE,
+	PI_WRLVL_EN,
+	PI_RDLVL_GATE_EN,
+	PI_RDLVL_EN,
+	PI_RDLVL_PATTERN_START,
+	PI_CALVL_EN,
+	PI_CALVL_CS_MAP,
+	PI_WDQLVL_EN,
+	PI_INT_STATUS
+};
+
+uint32_t ddr_phy_reg_read(uint32_t ch, uint32_t reg);
+void ddr_phy_reg_write(uint32_t ch, uint16_t reg, uint32_t data);
+uint32_t ddr_phy_reg_rawread(uint32_t ch, uint32_t reg);
+void ddr_phy_reg_rawwrite(uint32_t ch, uint16_t reg, uint32_t data);
+void bl2_phy_init(void);
+
+#endif	/* BL2_PHY_INIT_H__ */
diff --git a/plat/renesas/rcar/include/bl2_qos_init.h b/plat/renesas/rcar/include/bl2_qos_init.h
new file mode 100644
index 0000000..005bdc1
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_qos_init.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_QOS_INIT_H__
+#define BL2_QOS_INIT_H__
+
+void bl2_qos_init(void);
+
+#endif	/* BL2_QOS_INIT_H__ */
diff --git a/plat/renesas/rcar/include/bl2_rpc_register.h b/plat/renesas/rcar/include/bl2_rpc_register.h
new file mode 100644
index 0000000..f9d4532
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_rpc_register.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_RPC_REGISTER_H__
+#define BL2_RPC_REGISTER_H__
+
+/* RPC base address */
+#define RPC_BASE	(0xEE200000U)
+
+/* RPC common control */
+#define RPC_CMNCR	(RPC_BASE + 0x0000U)
+/* RPC ssl delay */
+#define RPC_SSLDR	(RPC_BASE + 0x0004U)
+/* RPC data read control */
+#define RPC_DRCR	(RPC_BASE + 0x000CU)
+/* RPC data read command setting */
+#define RPC_DRCMR	(RPC_BASE + 0x0010U)
+/* RPC data read enable setting */
+#define RPC_DRENR	(RPC_BASE + 0x001CU)
+
+/* RPC manual mode control */
+#define RPC_SMCR	(RPC_BASE + 0x0020U)
+/* RPC manual mode command setting */
+#define RPC_SMCMR	(RPC_BASE + 0x0024U)
+/* RPC manual mode enable setting */
+#define RPC_SMENR	(RPC_BASE + 0x0030U)
+
+/* RPC common status */
+#define RPC_CMNSR	(RPC_BASE + 0x0048U)
+/* RPC data read dummy cycle setting */
+#define RPC_DRDMCR	(RPC_BASE + 0x0058U)
+/* RPC data read ddr enable */
+#define RPC_DRDRENR	(RPC_BASE + 0x005CU)
+
+/* RPC phy control */
+#define RPC_PHYCNT	(RPC_BASE + 0x007CU)
+/* RPC phy interrupt */
+#define RPC_PHYINT	(RPC_BASE + 0x0088U)
+
+#endif	/* BL2_RPC_REGISTER_H__ */
diff --git a/plat/renesas/rcar/include/bl2_sdram_init.h b/plat/renesas/rcar/include/bl2_sdram_init.h
new file mode 100644
index 0000000..ea5d63f
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_sdram_init.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_SDRAM_INIT_H__
+#define BL2_SDRAM_INIT_H__
+
+void bl2_sdram_init(void);
+
+#endif	/*_BL2_SDRAM_INIT_H__ */
diff --git a/plat/renesas/rcar/include/bl2_secure_setting.h b/plat/renesas/rcar/include/bl2_secure_setting.h
new file mode 100644
index 0000000..f69d5b3
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_secure_setting.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_SECURE_SETTING_H__
+#define	BL2_SECURE_SETTING_H__
+
+void bl2_secure_setting(void);
+
+#endif	/* BL2_SECURE_SETTING_H__ */
diff --git a/plat/renesas/rcar/include/dma_driver.h b/plat/renesas/rcar/include/dma_driver.h
new file mode 100644
index 0000000..85c0718
--- /dev/null
+++ b/plat/renesas/rcar/include/dma_driver.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DMA_DRIVER_H__
+#define DMA_DRIVER_H__
+
+#include <stdint.h>
+
+#if 0	/* for QAC */
+#ifndef DEBUG
+#define DEBUG 0
+#endif
+#endif	/* for QAC */
+
+void initDMA(void);
+void execDMA(uint32_t dst, uint32_t src, uint32_t len);
+#if DEBUG
+void termDMA(void);
+#endif
+
+#endif	/* DMA_DRIVER_H__ */
diff --git a/plat/renesas/rcar/include/io_common.h b/plat/renesas/rcar/include/io_common.h
new file mode 100644
index 0000000..d414c1b
--- /dev/null
+++ b/plat/renesas/rcar/include/io_common.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2014 ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef IO_COMMON_H__
+#define IO_COMMON_H__
+
+extern void rcar_io_setup (void);
+extern int plat_get_image_source(const char *image_name, uintptr_t *dev_handle,
+		  uintptr_t *image_spec);
+
+#endif /* IO_COMMON_H__ */
diff --git a/plat/renesas/rcar/include/io_memdrv.h b/plat/renesas/rcar/include/io_memdrv.h
new file mode 100644
index 0000000..4eafa5e
--- /dev/null
+++ b/plat/renesas/rcar/include/io_memdrv.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef IO_MEMDRV_H__
+#define IO_MEMDRV_H__
+
+struct io_dev_connector;
+
+int32_t register_io_dev_memdrv(const io_dev_connector_t **dev_con);
+
+#endif /* IO_MEMDRV_H__ */
diff --git a/plat/renesas/rcar/include/io_rcar.h b/plat/renesas/rcar/include/io_rcar.h
new file mode 100644
index 0000000..8efe406
--- /dev/null
+++ b/plat/renesas/rcar/include/io_rcar.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2014 ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef IO_RCAR_H__
+#define IO_RCAR_H__
+
+int32_t register_io_dev_rcar(const io_dev_connector_t **dev_con);
+int32_t file_to_cert(const int8_t *filename, uint32_t *cert_addr);
+void get_info_from_cert(uint64_t cert_addr, uint32_t *size, uint32_t *dest_addr);
+
+#endif /* IO_FIP_H__ */
diff --git a/plat/renesas/rcar/include/plat_macros.S b/plat/renesas/rcar/include/plat_macros.S
new file mode 100644
index 0000000..4db1bc3
--- /dev/null
+++ b/plat/renesas/rcar/include/plat_macros.S
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <cci.h>
+#include <gic_v2.h>
+#include "../rcar_def.h"
+
+.section .rodata.gic_reg_name, "aS"
+gicc_regs:
+	.asciz "gicc_hppir", "gicc_ahppir", "gicc_ctlr", ""
+gicd_pend_reg:
+	.asciz "gicd_ispendr regs (Offsets 0x200 - 0x278)\n Offset:\t\t\tvalue\n"
+newline:
+	.asciz "\n"
+spacer:
+	.asciz ":\t\t0x"
+
+	/* ---------------------------------------------
+	 * The below macro prints out relevant GIC
+	 * registers whenever an unhandled exception is
+	 * taken in BL3-1.
+	 * Clobbers: x0 - x10, x16, x17, sp
+	 * ---------------------------------------------
+	 */
+	.macro plat_print_gic_regs
+	mov_imm	x17, RCAR_GICC_BASE_A
+	mov_imm	x16, RCAR_GICD_BASE_A
+print_gicc_regs:
+	/* gicc base address is now in x17 */
+	adr	x6, gicc_regs	/* Load the gicc reg list to x6 */
+	/* Load the gicc regs to gp regs used by str_in_crash_buf_print */
+	ldr	w8, [x17, #GICC_HPPIR]
+	ldr	w9, [x17, #GICC_AHPPIR]
+	ldr	w10, [x17, #GICC_CTLR]
+	/* Store to the crash buf and print to console */
+	bl	str_in_crash_buf_print
+
+	/* Print the GICD_ISPENDR regs */
+	add	x7, x16, #GICD_ISPENDR
+	adr	x4, gicd_pend_reg
+	bl	asm_print_str
+gicd_ispendr_loop:
+	sub	x4, x7, x16
+	cmp	x4, #0x280
+	b.eq	exit_print_gic_regs
+	bl	asm_print_hex
+	adr	x4, spacer
+	bl	asm_print_str
+	ldr	x4, [x7], #8
+	bl	asm_print_hex
+	adr	x4, newline
+	bl	asm_print_str
+	b	gicd_ispendr_loop
+exit_print_gic_regs:
+	.endm
+
+.section .rodata.cci_reg_name, "aS"
+cci_iface_regs:
+	.asciz "cci_snoop_ctrl_cluster0", "cci_snoop_ctrl_cluster1" , ""
+
+	/* ------------------------------------------------
+	 * The below macro prints out relevant interconnect
+	 * registers whenever an unhandled exception is
+	 * taken in BL3-1.
+	 * Clobbers: x0 - x9, sp
+	 * ------------------------------------------------
+	 */
+	.macro plat_print_interconnect_regs
+	adr	x6, cci_iface_regs
+	/* Store in x7 the base address of the first interface */
+	mov_imm	x7, (CCI500_BASE + SLAVE_IFACE3_OFFSET)
+	ldr	w8, [x7, #SNOOP_CTRL_REG]
+	/* Store in x7 the base address of the second interface */
+	mov_imm	x7, (CCI500_BASE + SLAVE_IFACE4_OFFSET)
+	ldr	w9, [x7, #SNOOP_CTRL_REG]
+	/* Store to the crash buf and print to console */
+	bl	str_in_crash_buf_print
+	.endm
diff --git a/plat/renesas/rcar/include/platform.h b/plat/renesas/rcar/include/platform.h
new file mode 100644
index 0000000..8ddfaad
--- /dev/null
+++ b/plat/renesas/rcar/include/platform.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_PLATFORM_H__
+#define RCAR_PLATFORM_H__
+
+#include <stdint.h>
+
+
+/*******************************************************************************
+ * Forward declarations
+ ******************************************************************************/
+struct plat_pm_ops;
+struct meminfo;
+struct image_info;
+struct entry_point_info;
+struct bl31_params;
+
+/*******************************************************************************
+ * Function declarations
+ ******************************************************************************/
+/*******************************************************************************
+ * Mandatory common functions
+ ******************************************************************************/
+uint64_t plat_get_syscnt_freq(void);
+int plat_get_image_source(const char *image_name,
+			uintptr_t *dev_handle,
+			uintptr_t *image_spec);
+unsigned long plat_get_ns_image_entrypoint(void);
+
+/*******************************************************************************
+ * Mandatory interrupt management functions
+ ******************************************************************************/
+uint32_t plat_ic_get_pending_interrupt_id(void);
+uint32_t plat_ic_get_pending_interrupt_type(void);
+uint32_t plat_ic_acknowledge_interrupt(void);
+uint32_t plat_ic_get_interrupt_type(uint32_t id);
+void plat_ic_end_of_interrupt(uint32_t id);
+uint32_t plat_interrupt_type_to_line(uint32_t type,
+				     uint32_t security_state);
+
+/*******************************************************************************
+ * Optional common functions (may be overridden)
+ ******************************************************************************/
+unsigned int platform_get_core_pos(unsigned long mpidr);
+unsigned long platform_get_stack(unsigned long mpidr);
+void plat_report_exception(unsigned long);
+int plat_crash_console_init(void);
+int plat_crash_console_putc(int c);
+
+/*******************************************************************************
+ * Mandatory BL1 functions
+ ******************************************************************************/
+void bl1_early_platform_setup(void);
+void bl1_plat_arch_setup(void);
+void bl1_platform_setup(void);
+struct meminfo *bl1_plat_sec_mem_layout(void);
+
+/*
+ * This function allows the platform to change the entrypoint information for
+ * BL2, after BL1 has loaded BL2 into memory but before BL2 is executed.
+ */
+void bl1_plat_set_bl2_ep_info(struct image_info *image,
+			      struct entry_point_info *ep);
+
+/*******************************************************************************
+ * Optional BL1 functions (may be overridden)
+ ******************************************************************************/
+void bl1_init_bl2_mem_layout(const struct meminfo *bl1_mem_layout,
+			     struct meminfo *bl2_mem_layout);
+
+/*******************************************************************************
+ * Mandatory BL2 functions
+ ******************************************************************************/
+void bl2_early_platform_setup(struct meminfo *mem_layout);
+void bl2_plat_arch_setup(void);
+void bl2_platform_setup(void);
+struct meminfo *bl2_plat_sec_mem_layout(void);
+
+/*
+ * This function returns a pointer to the shared memory that the platform has
+ * kept aside to pass trusted firmware related information that BL3-1
+ * could need
+ */
+struct bl31_params *bl2_plat_get_bl31_params(void);
+
+/*
+ * This function returns a pointer to the shared memory that the platform
+ * has kept to point to entry point information of BL31 to BL2
+ */
+struct entry_point_info *bl2_plat_get_bl31_ep_info(void);
+
+/*
+ * This function flushes to main memory all the params that are
+ * passed to BL3-1
+ */
+void bl2_plat_flush_bl31_params(void);
+
+/*
+ * The next 2 functions allow the platform to change the entrypoint information
+ * for the mandatory 3rd level BL images, BL3-1 and BL3-3. This is done after
+ * BL2 has loaded those images into memory but before BL3-1 is executed.
+ */
+void bl2_plat_set_bl31_ep_info(struct image_info *image,
+			       struct entry_point_info *ep);
+
+void bl2_plat_set_bl33_ep_info(struct image_info *image,
+			       struct entry_point_info *ep);
+
+/* Gets the memory layout for BL3-3 */
+void bl2_plat_get_bl33_meminfo(struct meminfo *mem_info);
+
+/*******************************************************************************
+ * Conditionally mandatory BL2 functions: must be implemented if BL3-0 image
+ * is supported
+ ******************************************************************************/
+/* Gets the memory layout for BL3-0 */
+void bl2_plat_get_bl30_meminfo(struct meminfo *mem_info);
+
+/*
+ * This function is called after loading BL3-0 image and it is used to perform
+ * any platform-specific actions required to handle the SCP firmware.
+ */
+int bl2_plat_handle_bl30(struct image_info *bl30_image_info);
+
+/*******************************************************************************
+ * Conditionally mandatory BL2 functions: must be implemented if BL3-2 image
+ * is supported
+ ******************************************************************************/
+void bl2_plat_set_bl32_ep_info(struct image_info *image,
+			       struct entry_point_info *ep);
+
+/* Gets the memory layout for BL3-2 */
+void bl2_plat_get_bl32_meminfo(struct meminfo *mem_info);
+
+/*******************************************************************************
+ * Optional BL2 functions (may be overridden)
+ ******************************************************************************/
+
+/*******************************************************************************
+ * Mandatory BL3-1 functions
+ ******************************************************************************/
+void bl31_early_platform_setup(struct bl31_params *from_bl2,
+				void *plat_params_from_bl2);
+void bl31_plat_arch_setup(void);
+void bl31_platform_setup(void);
+struct entry_point_info *bl31_plat_get_next_image_ep_info(uint32_t type);
+
+/*******************************************************************************
+ * Mandatory PSCI functions (BL3-1)
+ ******************************************************************************/
+int platform_setup_pm(const struct plat_pm_ops **);
+unsigned int plat_get_aff_count(unsigned int, unsigned long);
+unsigned int plat_get_aff_state(unsigned int, unsigned long);
+
+/*******************************************************************************
+ * Optional BL3-1 functions (may be overridden)
+ ******************************************************************************/
+void bl31_plat_enable_mmu(uint32_t flags);
+
+/*******************************************************************************
+ * Optional BL3-2 functions (may be overridden)
+ ******************************************************************************/
+void bl32_plat_enable_mmu(uint32_t flags);
+
+/*******************************************************************************
+ * Trusted Boot functions
+ ******************************************************************************/
+int plat_match_rotpk(const unsigned char *, unsigned int);
+
+#endif /* RCAR_PLATFORM_H__ */
diff --git a/plat/renesas/rcar/include/platform_def.h b/plat/renesas/rcar/include/platform_def.h
new file mode 100644
index 0000000..58a4fff
--- /dev/null
+++ b/plat/renesas/rcar/include/platform_def.h
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_PLATFORM_DEF_H__
+#define RCAR_PLATFORM_DEF_H__
+
+#include <arch.h>
+#ifndef __ASSEMBLY__
+#include <stdlib.h>
+#endif
+#include "../rcar_def.h"
+
+
+/*******************************************************************************
+ * Platform binary types for linking
+ ******************************************************************************/
+#define PLATFORM_LINKER_FORMAT          "elf64-littleaarch64"
+#define PLATFORM_LINKER_ARCH            aarch64
+
+/*******************************************************************************
+ * Generic platform constants
+ ******************************************************************************/
+
+/* Align the storing version code for BL2 and BL31 */
+#define	ALIGN_VERSION		(0x400)
+
+/* Size of cacheable stacks */
+#if IMAGE_BL1
+#if TRUSTED_BOARD_BOOT
+#define PLATFORM_STACK_SIZE 0x1000
+#else
+#define PLATFORM_STACK_SIZE 0x440
+#endif
+#elif IMAGE_BL2
+#if TRUSTED_BOARD_BOOT
+#define PLATFORM_STACK_SIZE 0x1000
+#else
+#define PLATFORM_STACK_SIZE 0x400
+#endif
+#elif IMAGE_BL31
+#define PLATFORM_STACK_SIZE 0x400
+#elif IMAGE_BL32
+#define PLATFORM_STACK_SIZE 0x440
+#endif
+
+#define FIRMWARE_WELCOME_STR		"Booting Trusted Firmware\n"
+
+/* Trusted Boot Firmware BL2 */
+#define BL2_IMAGE_NAME			"bl2.bin"
+
+/* EL3 Runtime Firmware BL31 */
+#define BL31_IMAGE_NAME			"bl31.bin"
+
+/* Secure Payload BL32 (Trusted OS) */
+#define BL32_IMAGE_NAME			"bl32.bin"
+
+/* Non-Trusted Firmware BL33 */
+#define BL33_IMAGE_NAME			"bl33.bin" /* e.g. UEFI */
+#define BL332_IMAGE_NAME		"bl332.bin"
+#define BL333_IMAGE_NAME		"bl333.bin"
+#define BL334_IMAGE_NAME		"bl334.bin"
+#define BL335_IMAGE_NAME		"bl335.bin"
+#define BL336_IMAGE_NAME		"bl336.bin"
+#define BL337_IMAGE_NAME		"bl337.bin"
+#define BL338_IMAGE_NAME		"bl338.bin"
+
+#if TRUSTED_BOARD_BOOT
+/* Certificates */
+# define BL2_CERT_NAME			"bl2.crt"
+# define TRUSTED_KEY_CERT_NAME		"trusted_key.crt"
+
+# define BL30_KEY_CERT_NAME		"bl30_key.crt"
+# define BL31_KEY_CERT_NAME		"bl31_key.crt"
+# define BL32_KEY_CERT_NAME		"bl32_key.crt"
+# define BL33_KEY_CERT_NAME		"bl33_key.crt"
+
+# define BL30_CERT_NAME			"bl30.crt"
+# define BL31_CERT_NAME			"bl31.crt"
+# define BL32_CERT_NAME			"bl32.crt"
+# define BL33_CERT_NAME			"bl33.crt"
+#endif /* TRUSTED_BOARD_BOOT */
+
+/*
+ * R-Car H3 Cortex-A57
+ * L1:I/48KB(16KBx3way) D/32KB(16KBx2way) L2:2MB(128KBx16way)
+ *          Cortex-A53
+ * L1:I/32KB(16KBx2way) D/32KB(8KBx4way) L2:512KB(32KBx16way)
+ */
+#define PLATFORM_CACHE_LINE_SIZE	128
+#define PLATFORM_CLUSTER_COUNT		2ull
+#define PLATFORM_CLUSTER0_CORE_COUNT	4
+#define PLATFORM_CLUSTER1_CORE_COUNT	4
+#define PLATFORM_CORE_COUNT		(PLATFORM_CLUSTER1_CORE_COUNT + \
+						PLATFORM_CLUSTER0_CORE_COUNT)
+#define PLATFORM_MAX_CPUS_PER_CLUSTER	4
+#define PLATFORM_NUM_AFFS		(PLATFORM_CLUSTER_COUNT + \
+					 PLATFORM_CORE_COUNT)
+#define PLATFORM_MAX_AFFLVL		MPIDR_AFFLVL1
+#define MAX_IO_DEVICES			3
+#define MAX_IO_HANDLES			4
+
+/*******************************************************************************
+ * BL1 specific defines.
+ * BL1 RW data is relocated from ROM to RAM at runtime so we need 2 sets of
+ * addresses.
+ ******************************************************************************/
+#define BL1_RO_BASE			RCAR_TRUSTED_ROM_BASE
+#define BL1_RO_LIMIT			(RCAR_TRUSTED_ROM_BASE \
+					+ RCAR_TRUSTED_ROM_SIZE)
+/*
+ * Put BL1 RW at the top of the Trusted SRAM. BL1_RW_BASE is calculated using
+ * the current BL1 RW debug size plus a little space for growth.
+ */
+#if TRUSTED_BOARD_BOOT
+#define BL1_RW_BASE			(RCAR_TRUSTED_SRAM_BASE \
+					+ RCAR_TRUSTED_SRAM_SIZE - 0x8000)
+#else
+#define BL1_RW_BASE			(RCAR_TRUSTED_SRAM_BASE \
+					+ RCAR_TRUSTED_SRAM_SIZE - 0x6000)
+#endif
+#define BL1_RW_LIMIT			(RCAR_TRUSTED_SRAM_BASE \
+					+ RCAR_TRUSTED_SRAM_SIZE)
+
+/*******************************************************************************
+ * BL2 specific defines.
+ ******************************************************************************/
+/*
+ * Put BL2 just below BL3-1. BL2_BASE is calculated using the current BL2 debug
+ * size plus a little space for growth.
+ */
+#define	RCAR_SECRAM_BASE		(0xE6300000)
+#if MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+#define BL2_BASE			(0xE6302000)
+#define BL2_LIMIT			(0xE632E800)
+#elif MASTER_BOOT_CPU == RCAR_BOOT_CR7
+#define BL2_BASE			(0x43F20000)
+#define BL2_LIMIT			(0x43F4C800)
+#endif
+
+/*******************************************************************************
+ * BL31 specific defines.
+ ******************************************************************************/
+/*
+ * Put BL3-1 at the top of the Trusted SRAM. BL31_BASE is calculated using the
+ * current BL3-1 debug size plus a little space for growth.
+ */
+#define BL31_BASE			(RCAR_TRUSTED_SRAM_BASE)
+#define BL31_LIMIT			(RCAR_TRUSTED_SRAM_BASE \
+					+ RCAR_TRUSTED_SRAM_SIZE)
+#define	RCAR_BL31_LOG_BASE		(0x44040000)
+#define	RCAR_BL31_SDRAM_BTM		(RCAR_BL31_LOG_BASE + 0x14000)
+#define	RCAR_BL31_LOG_SIZE		(RCAR_BL31_SDRAM_BTM \
+					- RCAR_BL31_LOG_BASE)
+
+/*******************************************************************************
+ * BL32 specific defines.
+ ******************************************************************************/
+
+# define BL32_BASE			(0x44100000)
+# define BL32_LIMIT			(BL32_BASE + 0x100000)
+/*
+ * ID of the secure physical generic timer interrupt used by the TSP.
+ */
+
+
+/*******************************************************************************
+ * Platform specific page table and MMU setup constants
+ ******************************************************************************/
+#define ADDR_SPACE_SIZE			(1ull << 32)
+
+#if IMAGE_BL1
+# define MAX_XLAT_TABLES		2
+#elif IMAGE_BL2
+# define MAX_XLAT_TABLES		3
+#elif IMAGE_BL31
+# define MAX_XLAT_TABLES		4
+#elif IMAGE_BL32
+#  define MAX_XLAT_TABLES		3
+#endif
+
+#define MAX_MMAP_REGIONS		(RCAR_MMAP_ENTRIES + RCAR_BL_REGIONS)
+
+/*******************************************************************************
+ * Declarations and constants to access the mailboxes safely. Each mailbox is
+ * aligned on the biggest cache line size in the platform. This is known only
+ * to the platform as it might have a combination of integrated and external
+ * caches. Such alignment ensures that two maiboxes do not sit on the same cache
+ * line at any cache level. They could belong to different cpus/clusters &
+ * get written while being protected by different locks causing corruption of
+ * a valid mailbox address.
+ ******************************************************************************/
+#define CACHE_WRITEBACK_SHIFT   6
+#define CACHE_WRITEBACK_GRANULE (1 << CACHE_WRITEBACK_SHIFT)
+
+#if !USE_COHERENT_MEM
+/*******************************************************************************
+ * Size of the per-cpu data in bytes that should be reserved in the generic
+ * per-cpu data structure for the RCAR port.
+ ******************************************************************************/
+#define PLAT_PCPU_DATA_SIZE	2
+#endif
+
+#endif /* RCAR_PLATFORM_DEF_H__ */
diff --git a/plat/renesas/rcar/include/rpc_driver.h b/plat/renesas/rcar/include/rpc_driver.h
new file mode 100644
index 0000000..0089504
--- /dev/null
+++ b/plat/renesas/rcar/include/rpc_driver.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RPC_DRIVER_H__
+#define RPC_DRIVER_H__
+
+#if 0	/* for QAC */
+#ifndef DEBUG
+#define DEBUG 0
+#endif
+#endif	/* for QAC */
+
+void initRPC(void);
+#if DEBUG
+void termRPC(void);
+#endif
+
+#endif	/* RPC_DRIVER_H__ */
diff --git a/plat/renesas/rcar/include/scif.h b/plat/renesas/rcar/include/scif.h
new file mode 100644
index 0000000..20265b4
--- /dev/null
+++ b/plat/renesas/rcar/include/scif.h
@@ -0,0 +1,145 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SCIF_H__
+#define __SCIF_H__
+
+
+#define	SCIF_INTERNAL_CLK	0	/* Internal clock(S3D4:66.66MHz) */
+#define	SCIF_EXTARNAL_CLK	1	/* External clock(SCK2:14.7456MHz) */
+#define	SCIF_CLK		SCIF_EXTARNAL_CLK
+
+/* Pin functon */
+#define	PFC_BASE		(0xE6060000)
+#define	PMMR			(0x0000)
+#define	GPSR5			(0x0114)
+#define	IPSR12			(0x0230)
+#define	MOD_SEL1		(0x0504)
+
+/* module stop */
+#define	CPG_BASE		(0xE6150000)
+#define	CPG_SMSTPCR3		(0x013C)
+#define	MSTP310			(1 << 10)
+#define	CPG_CPGWPR		(0x0900)
+
+/* SCIF2 */
+#define	SCIF2_BASE		(0xE6E88000)	/* SCIF-2 base address */
+#define	SCIF_BASE		(SCIF2_BASE)
+
+#define	SCIF_SCSMR		(0x00)		/* Serial mode register */
+#define	SCIF_SCBRR		(0x04)		/* Bit rate register */
+#define	SCIF_SCSCR		(0x08)		/* Serial control register */
+#define	SCIF_SCFTDR		(0x0C)		/* Transmit FIFO data register */
+#define	SCIF_SCFSR		(0x10)		/* Serial status register */
+#define SCIF_SCFRDR		(0x14)		/* Receive FIFO data register */
+#define	SCIF_SCFCR		(0x18)		/* FIFO control register */
+#define	SCIF_SCFDR		(0x1C)		/* FIFO data count register */
+#define SCIF_SCSPTR		(0x20)		/* Serial port register */
+#define	SCIF_SCLSR		(0x24)		/* Line status register */
+#define	SCIF_DL			(0x30)		/* Frequency division register */
+#define	SCIF_CKS		(0x34)		/* Clock Select register */
+#define	SCIF_SCSMRIR		(0x40)		/* Serial mode register */
+
+
+#define	SCSMR_CA_MASK		(1 << 7)
+#define	SCSMR_CA_ASYNC		(0x0000)
+#define	SCSMR_CHR_MASK		(1 << 6)
+#define	SCSMR_CHR_8		(0x0000)
+#define	SCSMR_PE_MASK		(1 << 5)
+#define	SCSMR_PE_DIS		(0x0000)
+#define	SCSMR_STOP_MASK		(1 << 3)
+#define	SCSMR_STOP_1		(0x0000)
+#define	SCSMR_CKS_MASK		(3 << 0)
+#define	SCSMR_CKS_DIV1		(0x0000)
+#define	SCSMR_INIT_DATA		(SCSMR_CA_ASYNC + SCSMR_CHR_8 + \
+				SCSMR_PE_DIS + SCSMR_STOP_1 + \
+				SCSMR_CKS_DIV1)
+
+#define	SCBRR_115200BPS		(17)		/* 115200bps@66MHz */
+#define	SCBRR_INIT_DATA		(SCBRR_115200BPS)
+
+#define	SCSCR_TE_MASK		(1 << 5)
+#define	SCSCR_TE_DIS		(0x0000)
+#define	SCSCR_TE_EN		(0x0020)
+#define	SCSCR_RE_MASK		(1 << 4)
+#define	SCSCR_RE_DIS		(0x0000)
+#define	SCSCR_RE_EN		(0x0010)
+#define	SCSCR_CKE_MASK		(3 << 0)
+#define SCSCR_CKE_INT		(0x0000)
+#define SCSCR_CKE_BRG		(0x0002)
+#if SCIF_CLK == SCIF_EXTARNAL_CLK
+#define	SCSCR_CKE_INT_CLK	(SCSCR_CKE_BRG)
+#else
+#define	SCSCR_CKE_INT_CLK	(SCSCR_CKE_INT)
+#endif
+
+#define	SCFSR_INIT_DATA		(0x0000)
+
+#define	SCFCR_TTRG_MASK		(3 << 4)
+#define	SCFCR_TTRG_8		(0x0000)
+#define	SCFCR_TTRG_0		(0x0030)
+#define	SCFCR_TFRST_MASK	(1 << 2)
+#define	SCFCR_TFRST_DIS		(0x0000)
+#define	SCFCR_TFRST_EN		(0x0004)
+#define	SCFCR_RFRS_MASK		(1 << 1)
+#define	SCFCR_RFRS_DIS		(0x0000)
+#define	SCFCR_RFRS_EN		(0x0002)
+#define	SCFCR_INIT_DATA		(SCFCR_TTRG_8)
+
+#define SCFDR_T_MASK		(0x1f << 8)
+
+#define	DL_INIT_DATA		(8)		/* 14.7456MHz/(115200bps*16)*/
+			
+#define	CKS_CKS_DIV_MASK		(1 << 15)
+#define	CKS_CKS_DIV_CLK		(0x0000)
+#define	CKS_XIN_MASK		(1 << 14)
+#define	CKS_XIN_SCIF_CLK		(0x0000)
+#define	CKS_INIT_DATA		(CKS_CKS_DIV_CLK + CKS_XIN_SCIF_CLK)
+
+#define	GPSR5_MASK		(3 << 10)
+#define	GPSR5_RX2_A	(1 << 11)
+#define	GPSR5_TX2_A	(1 << 10)
+#define	GPSR5_SCK2	(1 << 9)
+#if SCIF_CLK == SCIF_EXTARNAL_CLK
+#define	GPSR5_INIT_DATA		(GPSR5_RX2_A + GPSR5_TX2_A + GPSR5_SCK2)
+#else
+#define	GPSR5_INIT_DATA		(GPSR5_RX2_A + GPSR5_TX2_A)
+#endif
+
+#define	IPSR12_MASK		(255 << 0)
+#define	IPSR12_RX2_A		(0 << 4)
+#define	IPSR12_TX2_A		(0 << 0)
+#define	IPSR12_INIT_DATA	(IPSR12_RX2_A + IPSR12_TX2_A)
+
+#define	MOD_SEL1_SCIF2_MASK	(1 << 12)
+#define	MOD_SEL1_SCIF2		(0 << 12)
+
+#endif	/* __SCIF_H__ */
diff --git a/plat/renesas/rcar/platform.mk b/plat/renesas/rcar/platform.mk
new file mode 100644
index 0000000..5bc3489
--- /dev/null
+++ b/plat/renesas/rcar/platform.mk
@@ -0,0 +1,113 @@
+#
+# Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+# Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# Redistributions of source code must retain the above copyright notice, this
+# list of conditions and the following disclaimer.
+#
+# Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation
+# and/or other materials provided with the distribution.
+#
+# Neither the name of ARM nor the names of its contributors may be used
+# to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+
+# Process flags
+
+PLAT_INCLUDES		:=	-Iplat/renesas/rcar/include/
+
+PLAT_BL_COMMON_SOURCES	:=	lib/aarch64/xlat_tables.c			\
+				plat/common/aarch64/plat_common.c
+
+BL2_SOURCES		+=	plat/common/aarch64/platform_up_stack.S		\
+				plat/renesas/rcar/bl2_rcar_setup.c		\
+				plat/renesas/rcar/aarch64/rcar_common.c	\
+				plat/renesas/rcar/drivers/io/io_rcar.c	\
+				plat/renesas/rcar/drivers/io/io_memdrv.c	\
+				plat/renesas/rcar/drivers/scif/scif.S		\
+				plat/renesas/rcar/rcar_io_storage.c		\
+				drivers/io/io_storage.c				\
+				plat/renesas/rcar/bl2_pfc_init.c		\
+				plat/renesas/rcar/ddr/boot_init_dram.c		\
+				plat/renesas/rcar/bl2_phy_init.c		\
+				plat/renesas/rcar/drivers/rpc/rpc_driver.c	\
+				plat/renesas/rcar/drivers/dma/dma_driver.c	\
+				plat/renesas/rcar/bl2_secure_setting.c		\
+				plat/renesas/rcar/bl2_cpg_init.c		\
+				plat/renesas/rcar/bl2_qos_init.c		\
+				plat/renesas/rcar/aarch64/bl2_reset.S
+#				plat/renesas/rcar/ddr/boot_init_dram.c		\
+#				plat/renesas/rcar/bl2_sdram_init.c		\
+#				plat/renesas/rcar/bl2_ddr3_init.S		\
+
+BL31_SOURCES		+=	drivers/arm/cci/cci.c				\
+				drivers/arm/gic/arm_gic.c			\
+				drivers/arm/gic/gic_v2.c			\
+				drivers/arm/gic/gic_v3.c			\
+				lib/cpus/aarch64/aem_generic.S			\
+				lib/cpus/aarch64/cortex_a53.S			\
+				lib/cpus/aarch64/cortex_a57.S			\
+				plat/common/plat_gic.c				\
+				plat/common/aarch64/platform_mp_stack.S		\
+				plat/renesas/rcar/bl31_rcar_setup.c		\
+				plat/renesas/rcar/rcar_pm.c			\
+				plat/renesas/rcar/drivers/memdrv/rcar_console.S	\
+				plat/renesas/rcar/drivers/memdrv/rcar_printf.c	\
+				plat/renesas/rcar/rcar_topology.c		\
+				plat/renesas/rcar/aarch64/rcar_helpers.S	\
+				plat/renesas/rcar/aarch64/rcar_common.c		\
+				plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
+
+# compile option setting
+SPD			:= opteed
+ARM_CCI_PRODUCT_ID	:= 500
+TRUSTED_BOARD_BOOT	:= 1
+AUTH_MOD		:= rcar
+
+# Process RCAR_SECURE_BOOT flag
+ifndef RCAR_SECURE_BOOT
+RCAR_SECURE_BOOT := 0
+endif
+$(eval $(call add_define,RCAR_SECURE_BOOT))
+
+# Process RCAR_QOS_TYPE flag
+ifndef RCAR_QOS_TYPE
+RCAR_QOS_TYPE := 0
+endif
+$(eval $(call add_define,RCAR_QOS_TYPE))
+
+# Process RCAR_DRAM_SPLIT flag
+ifndef RCAR_DRAM_SPLIT
+RCAR_DRAM_SPLIT := 0
+endif
+$(eval $(call add_define,RCAR_DRAM_SPLIT))
+
+# Process MASTER_BOOT_CPU flag
+ifndef MASTER_BOOT_CPU
+MASTER_BOOT_CPU := 0
+endif
+$(eval $(call add_define,MASTER_BOOT_CPU))
+
+# Process RCAR_BL33_EXECUTION_EL flag
+ifndef RCAR_BL33_EXECUTION_EL
+RCAR_BL33_EXECUTION_EL := 0
+endif
+$(eval $(call add_define,RCAR_BL33_EXECUTION_EL))
diff --git a/plat/renesas/rcar/rcar_def.h b/plat/renesas/rcar/rcar_def.h
new file mode 100644
index 0000000..26892e1
--- /dev/null
+++ b/plat/renesas/rcar/rcar_def.h
@@ -0,0 +1,257 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_DEF_H__
+#define RCAR_DEF_H__
+
+/* Firmware Image Package */
+#define RCAR_PRIMARY_CPU			0x0
+
+#define RCAR_IMAGE_NAME			"rcar.bin"
+
+/*
+ * Some of the definitions in this file use the 'ull' suffix in order to avoid
+ * subtle integer overflow errors due to implicit integer type promotion when
+ * working with 32-bit values.
+ *
+ * The TSP linker script includes some of these definitions to define the BL3-2
+ * memory map, but the GNU LD does not support the 'ull' suffix, causing the
+ * build process to fail. To solve this problem, the auxiliary macro MAKE_ULL(x)
+ * will add the 'ull' suffix only when the macro __LINKER__  is not defined
+ * (__LINKER__ is defined in the command line to preprocess the linker script).
+ * Constants in the linker script will not have the 'ull' suffix, but this is
+ * not a problem since the linker evaluates all constant expressions to 64 bit
+ * (assuming the target architecture is 64 bit).
+ */
+#ifndef __LINKER__
+  #define MAKE_ULL(x)			x##ull
+#else
+  #define MAKE_ULL(x)			x
+#endif
+
+/*******************************************************************************
+ * RCAR memory map related constants
+ ******************************************************************************/
+
+/* The first 4KB of Trusted SRAM are used as shared memory */
+#define RCAR_SHARED_MEM_BASE	(RCAR_TRUSTED_SRAM_BASE + RCAR_TRUSTED_SRAM_SIZE)
+#define RCAR_SHARED_MEM_SIZE	0x00001000U	/* 4 KB */
+
+/* The remaining Trusted SRAM is used to load the BL images */
+#define RCAR_TRUSTED_SRAM_BASE	0x44000000	/* Trusted Firmware Image */
+#define RCAR_TRUSTED_SRAM_SIZE	0x00054000	/* 336 KB */
+
+#define FLASH0_BASE		0x08000000U		/* LBSC RPC address */
+#define FLASH0_SIZE		0x04000000U		/* 64MB */
+
+/* Aggregate of all devices in the first GB */
+#define DEVICE_RCAR_BASE	0xE6000000U
+#define DEVICE_RCAR_SIZE	0x1A000000U
+
+#define DRAM1_BASE		MAKE_ULL(0x40000000)
+#define DRAM1_SIZE		MAKE_ULL(0x80000000)
+
+#define DRAM1_NS_BASE		(DRAM1_BASE + 0x8000000U)
+#define DRAM1_NS_SIZE		(DRAM1_SIZE - DRAM1_NS_BASE)
+#define DRAM1_NS_END		(DRAM1_NS_BASE + DRAM1_NS_SIZE - 1)
+
+
+#define SYS_CNTCTL_BASE		0xE6080000U
+
+
+
+/*
+ * The number of regions like RO(code), coherent and data required by
+ * different BL stages which need to be mapped in the MMU.
+ */
+#if USE_COHERENT_MEM
+#define RCAR_BL_REGIONS		3
+#else
+#define RCAR_BL_REGIONS		2
+#endif
+
+/*
+ * The RCAR_MAX_MMAP_REGIONS depend on the number of entries in rcar_mmap[]
+ * defined for each BL stage in rcar_common.c.
+ */
+#if IMAGE_BL2
+#define RCAR_MMAP_ENTRIES		7
+#endif
+#if IMAGE_BL31
+#define RCAR_MMAP_ENTRIES		5
+#endif
+
+/* Load address of BL33 in the RCAR port */
+#define NS_IMAGE_OFFSET		(DRAM1_BASE + 0x09000000U) /* DRAM */
+
+/* Special value used to verify platform parameters from BL2 to BL3-1 */
+#define RCAR_BL31_PLAT_PARAM_VAL	0x0f1e2d3c4b5a6978ULL
+
+
+/*******************************************************************************
+ * CCI-400 related constants
+ ******************************************************************************/
+#define CCI500_BASE			0xF1200000
+#define CCI500_CLUSTER0_SL_IFACE_IX	2
+#define CCI500_CLUSTER1_SL_IFACE_IX	3
+
+/* CCI-500	*/
+#define	RCAR_CCI_BASE			(0xF1200000U)					/* The base address of CCI-500						*/
+
+/*******************************************************************************
+ * GIC-400 & interrupt handling related constants
+ ******************************************************************************/
+#define RCAR_GICD_BASE			(0xF1010000U)
+#define RCAR_GICD_BASE_A		(0xF1010000)
+#define RCAR_GICR_BASE			(0xF1010000U)	/* not use */
+#define RCAR_GICC_BASE			(0xF1020000U)
+#define RCAR_GICC_BASE_A		(0xF1020000)
+#define RCAR_GICH_BASE			(0xF1040000U)	/* not use */
+#define RCAR_GICV_BASE			(0xF1060000U)	/* not use */
+
+#define ARM_IRQ_SEC_PHY_TIMER		29U
+
+#define ARM_IRQ_SEC_SGI_0		8U
+#define ARM_IRQ_SEC_SGI_1		9U
+#define ARM_IRQ_SEC_SGI_2		10U
+#define ARM_IRQ_SEC_SGI_3		11U
+#define ARM_IRQ_SEC_SGI_4		12U
+#define ARM_IRQ_SEC_SGI_5		13U
+#define ARM_IRQ_SEC_SGI_6		14U
+#define ARM_IRQ_SEC_SGI_7		15U
+
+/****************************************************************************************************************************************************************/
+/*																				*/
+/*	Interrupt ID for Secure world																*/
+/*																				*/
+/****************************************************************************************************************************************************************/
+#define	ARM_IRQ_SEC_RPC			( 70U)						/* RPC									*/
+#define	ARM_IRQ_SEC_TIMER		(166U)						/* Secure timer								*/
+#define	ARM_IRQ_SEC_TIMER_UP		(171U)						/* Secure timer UP							*/
+#define	ARM_IRQ_SEC_WDT			(173U)						/* Secure watch dog timer						*/
+#define	ARM_IRQ_SEC_CRYPT		(102U)						/* Crypt Engine sec							*/
+#define	ARM_IRQ_SEC_CRYPT_SecPKA	( 97U)						/* Crypt Engine PKA sec							*/
+#define	ARM_IRQ_SEC_CRYPT_PubPKA	( 98U)						/* Crypt Engine PKA pub							*/
+#define	ARM_IRQ_SEC_DMAC2_ERR		(448U)						/* SYS-DMAC2 err							*/
+#define	ARM_IRQ_SEC_DMAC2_0		(449U)						/* SYS-DMAC2.ch0							*/
+#define	ARM_IRQ_SEC_DMAC2_1		(450U)						/* SYS-DMAC2.ch1							*/
+#define	ARM_IRQ_SEC_DMAC2_2		(451U)						/* SYS-DMAC2.ch2							*/
+#define	ARM_IRQ_SEC_DMAC2_3		(452U)						/* SYS-DMAC2.ch3							*/
+#define	ARM_IRQ_SEC_DMAC2_4		(453U)						/* SYS-DMAC2.ch4							*/
+#define	ARM_IRQ_SEC_DMAC2_5		(454U)						/* SYS-DMAC2.ch5							*/
+#define	ARM_IRQ_SEC_DMAC2_6		(455U)						/* SYS-DMAC2.ch6							*/
+#define	ARM_IRQ_SEC_DMAC2_7		(456U)						/* SYS-DMAC2.ch7							*/
+#define	ARM_IRQ_SEC_DMAC2_8		(457U)						/* SYS-DMAC2.ch8							*/
+#define	ARM_IRQ_SEC_DMAC2_9		(458U)						/* SYS-DMAC2.ch9							*/
+#define	ARM_IRQ_SEC_DMAC2_10		(459U)						/* SYS-DMAC2.ch10							*/
+#define	ARM_IRQ_SEC_DMAC2_11		(460U)						/* SYS-DMAC2.ch11							*/
+#define	ARM_IRQ_SEC_DMAC2_12		(461U)						/* SYS-DMAC2.ch12							*/
+#define	ARM_IRQ_SEC_DMAC2_13		(462U)						/* SYS-DMAC2.ch13							*/
+#define	ARM_IRQ_SEC_DMAC2_14		(463U)						/* SYS-DMAC2.ch14							*/
+#define	ARM_IRQ_SEC_DMAC2_15		(429U)						/* SYS-DMAC2.ch15							*/
+
+/****************************************************************************************************************************************************************/
+/*																				*/
+/*	New definition for R-CarGen3																*/
+/*																				*/
+/****************************************************************************************************************************************************************/
+#define	RCAR_DEVICE_BASE		(0xE6000000)					/* Start address of BL31 register area					*/
+#define	RCAR_DEVICE_SIZE		(0x1A000000)					/* Size of BL31 register area						*/
+#define	RCAR_LOG_RES_SIZE		(512/8)						/* Size of reservation in log area					*/
+#define	RCAR_LOG_HEADER_SIZE		(16)						/* Size of LOG header							*/
+#define	RCAR_LOG_OTHER_SIZE		(RCAR_LOG_HEADER_SIZE+RCAR_LOG_RES_SIZE)	/* Size of write pointer, log header, reservation			*/
+#define	RCAR_BL31_LOG_MAX		(RCAR_BL31_LOG_SIZE - RCAR_LOG_OTHER_SIZE)	/* MAX log size								*/
+
+#define	RCAR_CRASH_STACK		(0x4403F800)					/* Temporary stack for crash						*/
+
+/****************************************************************************************************************************************************************/
+/*																				*/
+/*	Definition of R-CarGen3 register address														*/
+/*																				*/
+/****************************************************************************************************************************************************************/
+/* Timer	*/
+#define	RCAR_CNTC_BASE			(0xE6080000U)					/* The base addess of generic timer control register			*/
+/* Reset	*/
+#define	RCAR_CPGWPR			(0xE6150900U)					/* CPG write protect register						*/
+#define	RCAR_MODEMR			(0xE6160060U)					/* Mode pin register							*/
+#define	RCAR_MODEMR_A			(0xE6160060)					/* Mode pin register for Assembly language				*/
+#define	RCAR_CA57RESCNT			(0xE6160040U)					/* Reset control register for A57					*/
+#define	RCAR_CA53RESCNT			(0xE6160044U)					/* Reset control register for A53					*/
+#define	RCAR_CA53WUPCR			(0xE6151010U)					/* Wake-up control register for A53					*/
+#define	RCAR_CA57WUPCR			(0xE6152010U)					/* Wake-up control register for A57					*/
+#define	RCAR_CA53PSTR			(0xE6151040U)					/* Power status register for A53					*/
+#define	RCAR_CA57PSTR			(0xE6152040U)					/* Power status register for A57					*/
+#define	RCAR_CA53CPU0CR			(0xE6151100U)					/* The base address of CPU power status control register for A53	*/
+#define	RCAR_CA57CPU0CR			(0xE6152100U)					/* The base address of CPU power status control register for A57	*/
+#define	RCAR_CA53CPUCMCR		(0xE6151184U)					/* Common power control register for A53				*/
+#define	RCAR_CA57CPUCMCR		(0xE6152184U)					/* Common power control register for A57				*/
+#define	RCAR_WUPMSKCA57			(0xE6180014U)					/* Wake-up mask register for A57					*/
+#define	RCAR_WUPMSKCA53			(0xE6180018U)					/* Wake-up mask register for A53					*/
+/* SYSC		*/
+#define	RCAR_PWRSR3			(0xE6180140U)					/* Power status register CA53-SCU					*/
+#define	RCAR_PWRSR5			(0xE61801C0U)					/* Power status register CA57-SCU					*/
+#define	RCAR_SYSCIER			(0xE618000CU)					/* Interrupt enable register						*/
+#define	RCAR_SYSCIMR			(0xE6180010U)					/* Interrupt mask register						*/
+#define	RCAR_SYSCSR			(0xE6180000U)					/* SYSC status register							*/
+#define	RCAR_PWRONCR3			(0xE618014CU)					/* Power resume control register CA53-SCU				*/
+#define	RCAR_PWRONCR5			(0xE61801CCU)					/* Power resume control register CA57-SCU				*/
+#define	RCAR_PWRER3			(0xE6180154U)					/* Power shutoff/resume error register CA53-SCU				*/
+#define	RCAR_PWRER5			(0xE61801D4U)					/* Power shutoff/resume error register CA57-SCU				*/
+#define	RCAR_SYSCISR			(0xE6180004U)					/* Interrupt status register						*/
+#define	RCAR_SYSCISCR			(0xE6180008U)					/* Interrupt status clear register					*/
+/* Product register	*/
+#define	RCAR_PRR			(0xFFF00044U)					/* Product register							*/
+/****************************************************************************************************************************************************************/
+/* Memory mapped Generic timer interfaces  */
+/****************************************************************************************************************************************************************/
+#define ARM_SYS_CNTCTL_BASE		RCAR_CNTC_BASE
+
+/*******************************************************************************
+ *  Boot CPU
+ ******************************************************************************/
+#define	RCAR_BOOT_CA5X			(0U)	/* Master boot CPU is CA57/53 */
+#define	RCAR_BOOT_CR7			(1U)	/* Master boot CPU is CR7 */
+
+/*******************************************************************************
+ *  Shared Data
+ ******************************************************************************/
+
+#define	RCAR_BL31_MAIL_BASE	(0x4403E000)
+#define	RCAR_BL31_MAIL_SIZE	(0x00002000)
+
+/* Entrypoint mailboxes */
+#define MBOX_BASE		RCAR_BL31_MAIL_BASE
+#define MBOX_SIZE		0x200
+
+/* Base address where parameters to BL31 are stored */
+#define PARAMS_BASE		(MBOX_BASE + MBOX_SIZE)
+
+#endif /* RCAR_DEF_H__ */
diff --git a/plat/renesas/rcar/rcar_io_storage.c b/plat/renesas/rcar/rcar_io_storage.c
new file mode 100644
index 0000000..3b566f4
--- /dev/null
+++ b/plat/renesas/rcar/rcar_io_storage.c
@@ -0,0 +1,327 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <debug.h>
+#include <io_driver.h>
+#include <io_storage.h>
+#include <io_semihosting.h>
+#include <platform_def.h>
+#include <semihosting.h>	/* For FOPEN_MODE_... */
+#include <string.h>
+#include "io_common.h"
+#include "io_rcar.h"
+#include "io_memdrv.h"
+
+/* IO devices */
+static uintptr_t rcar_dev_handle;
+static uintptr_t memdrv_dev_handle;
+
+static const io_block_spec_t rcar_block_spec = {
+	.offset = FLASH0_BASE,
+	.length = FLASH0_SIZE
+};
+
+static const io_file_spec_t bl2_file_spec = {
+	.path = BL2_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl31_file_spec = {
+	.path = BL31_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl32_file_spec = {
+	.path = BL32_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl33_file_spec = {
+	.path = BL33_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl332_file_spec = {
+	.path = BL332_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl333_file_spec = {
+	.path = BL333_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl334_file_spec = {
+	.path = BL334_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl335_file_spec = {
+	.path = BL335_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl336_file_spec = {
+	.path = BL336_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl337_file_spec = {
+	.path = BL337_IMAGE_NAME,
+};
+
+static const io_file_spec_t bl338_file_spec = {
+	.path = BL338_IMAGE_NAME,
+};
+
+
+#if TRUSTED_BOARD_BOOT
+static const io_file_spec_t trusted_key_cert_file_spec = {
+	.path = TRUSTED_KEY_CERT_NAME,
+};
+
+static const io_file_spec_t bl31_key_cert_file_spec = {
+	.path = BL31_KEY_CERT_NAME,
+};
+
+static const io_file_spec_t bl32_key_cert_file_spec = {
+	.path = BL32_KEY_CERT_NAME,
+};
+
+static const io_file_spec_t bl33_key_cert_file_spec = {
+	.path = BL33_KEY_CERT_NAME,
+};
+
+static const io_file_spec_t bl31_cert_file_spec = {
+	.path = BL31_CERT_NAME,
+};
+
+static const io_file_spec_t bl32_cert_file_spec = {
+	.path = BL32_CERT_NAME,
+};
+
+static const io_file_spec_t bl33_cert_file_spec = {
+	.path = BL33_CERT_NAME,
+};
+#endif /* TRUSTED_BOARD_BOOT */
+
+static int32_t open_rcar(const uintptr_t spec);
+static int32_t open_memmap(const uintptr_t spec);
+
+struct plat_io_policy {
+	int8_t *image_name;
+	uintptr_t *dev_handle;
+	uintptr_t image_spec;
+	int32_t (*check)(const uintptr_t spec);
+};
+
+static const struct plat_io_policy policies[] = {
+	{
+		(int8_t *)RCAR_IMAGE_NAME,
+		&memdrv_dev_handle,
+		(uintptr_t)&rcar_block_spec,
+		&open_memmap
+	}, {
+		(int8_t *)BL2_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl2_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL31_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl31_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL32_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl32_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL33_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl33_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL332_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl332_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL333_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl333_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL334_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl334_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL335_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl335_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL336_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl336_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL337_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl337_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL338_IMAGE_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl338_file_spec,
+		&open_rcar
+	}, {
+#if TRUSTED_BOARD_BOOT
+		(int8_t *)TRUSTED_KEY_CERT_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&trusted_key_cert_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL31_KEY_CERT_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl31_key_cert_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL32_KEY_CERT_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl32_key_cert_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL33_KEY_CERT_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl33_key_cert_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL31_CERT_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl31_cert_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL32_CERT_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl32_cert_file_spec,
+		&open_rcar
+	}, {
+		(int8_t *)BL33_CERT_NAME,
+		&rcar_dev_handle,
+		(uintptr_t)&bl33_cert_file_spec,
+		&open_rcar
+	}, {
+#endif /* TRUSTED_BOARD_BOOT */
+		0, 0, 0
+	}
+};
+
+
+static int32_t open_rcar(const uintptr_t spec)
+{
+	int32_t result;
+
+	/* See if a Firmware Image Package is available */
+	result = io_dev_init(rcar_dev_handle, (uintptr_t)RCAR_IMAGE_NAME);
+	if (result == IO_SUCCESS) {
+		VERBOSE("Using RCar File Manager\n");
+	}
+	return result;
+}
+
+
+static int32_t open_memmap(const uintptr_t spec)
+{
+	int32_t result;
+	uintptr_t local_image_handle;
+
+	result = io_dev_init(memdrv_dev_handle, 0U);
+	if (result == IO_SUCCESS) {
+		result = io_open(memdrv_dev_handle, spec, &local_image_handle);
+		if (result == IO_SUCCESS) {
+			VERBOSE("Using Memdrv IO\n");
+			(void)io_close(local_image_handle);
+		}
+	}
+	return result;
+}
+
+
+
+void rcar_io_setup (void)
+{
+	int32_t io_result;
+	const io_dev_connector_t *rcar_dev_con;
+	const io_dev_connector_t *memmap_dev_con;
+
+	/* Register the IO devices on this platform */
+	io_result = register_io_dev_rcar(&rcar_dev_con);
+	assert(io_result == IO_SUCCESS);
+
+	io_result = register_io_dev_memdrv(&memmap_dev_con);
+	assert(io_result == IO_SUCCESS);
+
+	/* Open connections to devices and cache the handles */
+	io_result = io_dev_open(rcar_dev_con, 0U, &rcar_dev_handle);
+	assert(io_result == IO_SUCCESS);
+
+	io_result = io_dev_open(memmap_dev_con, 0U,
+				&memdrv_dev_handle);
+	assert(io_result == IO_SUCCESS);
+
+	/* Ignore improbable errors in release builds */
+	(void)io_result;
+}
+
+
+/* Return an IO device handle and specification which can be used to access
+ * an image. Use this to enforce platform load policy */
+int plat_get_image_source(const char *image_name, uintptr_t *dev_handle,
+			  uintptr_t *image_spec)
+{
+	int32_t result = IO_FAIL;
+	const struct plat_io_policy *policy;
+	int32_t loop = 0;
+
+	if ((image_name != NULL) && (dev_handle != NULL) &&
+	    (image_spec != NULL)) {
+		policy = &policies[0];
+		while (policy->image_name != NULL) {
+			if (strcmp((const char *)policy->image_name, image_name) == 0) {
+				result = policy->check(policy->image_spec);
+				if (result == IO_SUCCESS) {
+					*image_spec = policy->image_spec;
+					*dev_handle = *(policy->dev_handle);
+					break;
+				}
+			}
+			loop++;
+			policy = &policies[loop];
+		}
+	} else {
+		result = IO_FAIL;
+	}
+	return result;
+}
diff --git a/plat/renesas/rcar/rcar_pm.c b/plat/renesas/rcar/rcar_pm.c
new file mode 100644
index 0000000..abe739e
--- /dev/null
+++ b/plat/renesas/rcar/rcar_pm.c
@@ -0,0 +1,376 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch_helpers.h>
+#include <arm_gic.h>
+#include <assert.h>
+#include <bakery_lock.h>
+#include <cci.h>
+#include <debug.h>
+#include <mmio.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <psci.h>
+#include <errno.h>
+#include "drivers/pwrc/rcar_pwrc.h"
+#include "rcar_def.h"
+#include "rcar_private.h"
+
+static void rcar_program_mailbox(uint64_t mpidr, uint64_t address);
+static int32_t rcar_do_plat_actions(unsigned int afflvl, unsigned int state);
+static void __dead2 rcar_system_off(void);
+static void __dead2 rcar_system_reset(void);
+
+/*******************************************************************************
+ * Private RCAR function to program the mailbox for a cpu before it is released
+ * from reset.
+ ******************************************************************************/
+static void rcar_program_mailbox(uint64_t mpidr, uint64_t address)
+{
+	uint64_t linear_id;
+	mailbox_t *rcar_mboxes;
+
+	linear_id = platform_get_core_pos(mpidr);
+	rcar_mboxes = (mailbox_t *)MBOX_BASE;
+	rcar_mboxes[linear_id].value = address;
+	flush_dcache_range((unsigned long)&rcar_mboxes[linear_id],
+			sizeof(unsigned long));
+}
+#if 0
+/*******************************************************************************
+ * Function which implements the common RCAR specific operations to power down a
+ * cpu in response to a CPU_OFF or CPU_SUSPEND request.
+ ******************************************************************************/
+static void rcar_cpu_pwrdwn_common(void)
+{
+	/* Prevent interrupts from spuriously waking up this cpu */
+	arm_gic_cpuif_deactivate();
+
+	/* Program the power controller to power off this cpu. */
+	rcar_pwrc_cpuoff(read_mpidr_el1());
+}
+
+/*******************************************************************************
+ * Function which implements the common RCAR specific operations to power down a
+ * cluster in response to a CPU_OFF or CPU_SUSPEND request.
+ ******************************************************************************/
+static void rcar_cluster_pwrdwn_common(void)
+{
+	uint64_t mpidr = read_mpidr_el1();
+
+	/* Disable coherency if this cluster is to be turned off */
+	rcar_cci_disable();
+
+	/* Program the power controller to turn the cluster off */
+	rcar_pwrc_clusteroff(mpidr);
+}
+#endif
+
+/*******************************************************************************
+ * Private RCAR function which is used to determine if any platform actions
+ * should be performed for the specified affinity instance given its
+ * state. Nothing needs to be done if the 'state' is not off or if this is not
+ * the highest affinity level which will enter the 'state'.
+ ******************************************************************************/
+static int32_t rcar_do_plat_actions(unsigned int afflvl, unsigned int state)
+{
+	unsigned int max_phys_off_afflvl;
+
+	assert(afflvl <= MPIDR_AFFLVL1);
+
+	if (state != PSCI_STATE_OFF) {
+		return -EAGAIN;
+	}
+
+	/*
+	 * Find the highest affinity level which will be suspended and postpone
+	 * all the platform specific actions until that level is hit.
+	 */
+	max_phys_off_afflvl = psci_get_max_phys_off_afflvl();
+	assert(max_phys_off_afflvl != PSCI_INVALID_DATA);
+	if (afflvl != max_phys_off_afflvl) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance is about to enter standby.
+ ******************************************************************************/
+void rcar_affinst_standby(unsigned int power_state)
+{
+	/*
+	 * Enter standby state
+	 * dsb is good practice before using wfi to enter low power states
+	 */
+#if 0
+	dsb();
+	wfi();
+#endif
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance is about to be turned on. The
+ * level and mpidr determine the affinity instance.
+ ******************************************************************************/
+int rcar_affinst_on(unsigned long mpidr, unsigned long sec_entrypoint,
+		unsigned int afflvl, unsigned int state)
+{
+	int rc = PSCI_E_SUCCESS;
+
+	/*
+	 * It's possible to turn on only affinity level 0 i.e. a cpu
+	 * on the RCAR. Ignore any other affinity level.
+	 */
+	if (afflvl != MPIDR_AFFLVL0) {
+		return rc;
+	}
+
+	/*
+	 * Ensure that we do not cancel an inflight power off request
+	 * for the target cpu. That would leave it in a zombie wfi.
+	 * Wait for it to power off, program the jump address for the
+	 * target cpu and then program the power controller to turn
+	 * that cpu on
+	 */
+
+	rcar_program_mailbox(mpidr, sec_entrypoint);
+	rcar_pwrc_cpuon(mpidr);
+
+	return rc;
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance is about to be turned off. The
+ * level and mpidr determine the affinity instance. The 'state' arg. allows the
+ * platform to decide whether the cluster is being turned off and take apt
+ * actions.
+ *
+ * CAUTION: There is no guarantee that caches will remain turned on across calls
+ * to this function as each affinity level is dealt with. So do not write & read
+ * global variables across calls. It will be wise to do flush a write to the
+ * global to prevent unpredictable results.
+ ******************************************************************************/
+void rcar_affinst_off(unsigned int afflvl, unsigned int state)
+{
+#if 0
+	/* Determine if any platform actions need to be executed */
+	if (rcar_do_plat_actions(afflvl, state) == -EAGAIN) {
+		return;
+	}
+
+	/*
+	 * If execution reaches this stage then this affinity level will be
+	 * suspended. Perform at least the cpu specific actions followed the
+	 * cluster specific operations if applicable.
+	 */
+	rcar_cpu_pwrdwn_common();
+
+	if (afflvl != MPIDR_AFFLVL0) {
+		rcar_cluster_pwrdwn_common();
+	}
+#endif
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance is about to be suspended. The
+ * level and mpidr determine the affinity instance. The 'state' arg. allows the
+ * platform to decide whether the cluster is being turned off and take apt
+ * actions.
+ *
+ * CAUTION: There is no guarantee that caches will remain turned on across calls
+ * to this function as each affinity level is dealt with. So do not write & read
+ * global variables across calls. It will be wise to do flush a write to the
+ * global to prevent unpredictable results.
+ ******************************************************************************/
+void rcar_affinst_suspend(unsigned long sec_entrypoint, unsigned int afflvl,
+		unsigned int state)
+{
+#if 0
+	unsigned long mpidr;
+
+	/* Determine if any platform actions need to be executed. */
+	if (rcar_do_plat_actions(afflvl, state) == -EAGAIN) {
+		return;
+	}
+
+	/* Get the mpidr for this cpu */
+	mpidr = read_mpidr_el1();
+
+	/* Program the jump address for the this cpu */
+	rcar_program_mailbox(mpidr, sec_entrypoint);
+
+	/* Program the power controller to enable wakeup interrupts. */
+	rcar_pwrc_set_wen(mpidr);
+
+	/* Perform the common cpu specific operations */
+	rcar_cpu_pwrdwn_common();
+
+	/* Perform the common cluster specific operations */
+	if (afflvl != MPIDR_AFFLVL0) {
+		rcar_cluster_pwrdwn_common();
+	}
+#endif
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance has just been powered on after
+ * being turned off earlier. The level and mpidr determine the affinity
+ * instance. The 'state' arg. allows the platform to decide whether the cluster
+ * was turned off prior to wakeup and do what's necessary to setup it up
+ * correctly.
+ ******************************************************************************/
+void rcar_affinst_on_finish(unsigned int afflvl, unsigned int state)
+{
+	unsigned long mpidr;
+
+	/* Determine if any platform actions need to be executed. */
+	if (rcar_do_plat_actions(afflvl, state) == -EAGAIN) {
+		return;
+	}
+
+	/* Get the mpidr for this cpu */
+	mpidr = read_mpidr_el1();
+
+	/* Perform the common cluster specific operations */
+	if (afflvl != MPIDR_AFFLVL0) {
+		/* Enable coherency if this cluster was off */
+		rcar_cci_enable();
+	}
+
+	/*
+	 * Prohibit cpu wake up by interrupt
+	 */
+	rcar_pwrc_disable_interrupt_wakeup(mpidr);
+
+	/* Zero the jump address in the mailbox for this cpu */
+	rcar_program_mailbox(mpidr, 0U);
+
+	/* Enable the gic cpu interface */
+	arm_gic_cpuif_setup();
+
+	/* TODO: This setup is needed only after a cold boot */
+	arm_gic_pcpu_distif_setup();
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance has just been powered on after
+ * having been suspended earlier. The level and mpidr determine the affinity
+ * instance.
+ * TODO: At the moment we reuse the on finisher and reinitialize the secure
+ * context. Need to implement a separate suspend finisher.
+ ******************************************************************************/
+void rcar_affinst_suspend_finish(unsigned int afflvl, unsigned int state)
+{
+#if 0
+	rcar_affinst_on_finish(afflvl, state);
+#endif
+}
+
+/*******************************************************************************
+ * RCAR handlers to shutdown/reboot the system
+ ******************************************************************************/
+static void __dead2 rcar_system_off(void)
+{
+#if 0
+	/* Write the System Configuration Control Register */
+	mmio_write_32(VE_SYSREGS_BASE + V2M_SYS_CFGCTRL,
+		CFGCTRL_START | CFGCTRL_RW | CFGCTRL_FUNC(FUNC_SHUTDOWN));
+	wfi();
+#endif
+	ERROR("RCAR System Off: operation not handled.\n");
+	panic();
+}
+
+static void __dead2 rcar_system_reset(void)
+{
+#if 0
+	/* Write the System Configuration Control Register */
+
+	mmio_write_32(VE_SYSREGS_BASE + V2M_SYS_CFGCTRL,
+		CFGCTRL_START | CFGCTRL_RW | CFGCTRL_FUNC(FUNC_REBOOT));
+
+	wfi();
+#endif
+	ERROR("RCAR System Reset: operation not handled.\n");
+	panic();
+}
+
+/*******************************************************************************
+ * RCAR handler called to check the validity of the power state parameter.
+ ******************************************************************************/
+int rcar_validate_power_state(unsigned int power_state)
+{
+	/* Sanity check the requested state */
+	if (psci_get_pstate_type(power_state) == PSTATE_TYPE_STANDBY) {
+		/*
+		 * It's possible to enter standby only on affinity level 0
+		 * i.e. a cpu on the rcar. Ignore any other affinity level.
+		 */
+		if (psci_get_pstate_afflvl(power_state) != MPIDR_AFFLVL0) {
+			return PSCI_E_INVALID_PARAMS;
+		}
+	}
+
+	/*
+	 * We expect the 'state id' to be zero.
+	 */
+	if (psci_get_pstate_id(power_state) != 0U) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	return PSCI_E_SUCCESS;
+}
+
+/*******************************************************************************
+ * Export the platform handlers to enable psci to invoke them
+ ******************************************************************************/
+static const plat_pm_ops_t rcar_plat_pm_ops = {
+	.affinst_standby = rcar_affinst_standby,
+	.affinst_on = rcar_affinst_on,
+	.affinst_off = rcar_affinst_off,
+	.affinst_suspend = rcar_affinst_suspend,
+	.affinst_on_finish = rcar_affinst_on_finish,
+	.affinst_suspend_finish = rcar_affinst_suspend_finish,
+	.system_off = rcar_system_off,
+	.system_reset = rcar_system_reset,
+	.validate_power_state = rcar_validate_power_state
+};
+
+/*******************************************************************************
+ * Export the platform specific power ops & initialize the rcar power controller
+ ******************************************************************************/
+int platform_setup_pm(const plat_pm_ops_t **plat_ops)
+{
+	*plat_ops = &rcar_plat_pm_ops;
+	return 0;
+}
diff --git a/plat/renesas/rcar/rcar_private.h b/plat/renesas/rcar/rcar_private.h
new file mode 100644
index 0000000..42807d5
--- /dev/null
+++ b/plat/renesas/rcar/rcar_private.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_PRIVATE_H__
+#define RCAR_PRIVATE_H__
+
+#include <bakery_lock.h>
+#include <bl_common.h>
+#include <cpu_data.h>
+#include <platform_def.h>
+
+
+typedef volatile struct mailbox {
+	unsigned long value
+	__attribute__((__aligned__(CACHE_WRITEBACK_GRANULE)));
+} mailbox_t;
+
+/*******************************************************************************
+ * This structure represents the superset of information that is passed to
+ * BL31 e.g. while passing control to it from BL2 which is bl31_params
+ * and bl31_plat_params and its elements
+ ******************************************************************************/
+typedef struct bl2_to_bl31_params_mem {
+	bl31_params_t bl31_params;
+	image_info_t bl31_image_info;
+	image_info_t bl32_image_info;
+	image_info_t bl33_image_info;
+	entry_point_info_t bl33_ep_info;
+	entry_point_info_t bl32_ep_info;
+	entry_point_info_t bl31_ep_info;
+} bl2_to_bl31_params_mem_t;
+
+#if USE_COHERENT_MEM
+/*
+ * These are wrapper macros to the Coherent Memory Bakery Lock API.
+ */
+#define rcar_lock_init(_lock_arg)	bakery_lock_init(_lock_arg)
+#define rcar_lock_get(_lock_arg)	bakery_lock_get(_lock_arg)
+#define rcar_lock_release(_lock_arg)	bakery_lock_release(_lock_arg)
+
+#else
+
+/*******************************************************************************
+ * Constants to specify how many bakery locks this platform implements. These
+ * are used if the platform chooses not to use coherent memory for bakery lock
+ * data structures.
+ ******************************************************************************/
+#define RCAR_MAX_BAKERIES	2
+#define RCAR_PWRC_BAKERY_ID	0
+
+/*******************************************************************************
+ * Definition of structure which holds platform specific per-cpu data. Currently
+ * it holds only the bakery lock information for each cpu. Constants to
+ * specify how many bakeries this platform implements and bakery ids are
+ * specified in rcar_def.h
+ ******************************************************************************/
+typedef struct rcar_cpu_data {
+	bakery_info_t pcpu_bakery_info[RCAR_MAX_BAKERIES];
+} rcar_cpu_data_t;
+
+/* Macro to define the offset of bakery_info_t in rcar_cpu_data_t */
+#define RCAR_CPU_DATA_LOCK_OFFSET	__builtin_offsetof\
+					    (rcar_cpu_data_t, pcpu_bakery_info)
+
+
+/*******************************************************************************
+ * Helper macros for bakery lock api when using the above rcar_cpu_data_t for
+ * bakery lock data structures. It assumes that the bakery_info is at the
+ * beginning of the platform specific per-cpu data.
+ ******************************************************************************/
+#define rcar_lock_init(_lock_arg)	/* No init required */
+#define rcar_lock_get(_lock_arg)		bakery_lock_get(_lock_arg,  \
+						CPU_DATA_PLAT_PCPU_OFFSET + \
+						RCAR_CPU_DATA_LOCK_OFFSET)
+#define rcar_lock_release(_lock_arg)	bakery_lock_release(_lock_arg,	    \
+						CPU_DATA_PLAT_PCPU_OFFSET + \
+						RCAR_CPU_DATA_LOCK_OFFSET)
+
+/*
+ * Ensure that the size of the RCAR specific per-cpu data structure and the size
+ * of the memory allocated in generic per-cpu data for the platform are the same.
+ */
+CASSERT(PLAT_PCPU_DATA_SIZE == sizeof(rcar_cpu_data_t),	\
+	rcar_pcpu_data_size_mismatch);
+
+#endif /* __USE_COHERENT_MEM__ */
+
+/*******************************************************************************
+ * Function and variable prototypes
+ ******************************************************************************/
+void rcar_configure_mmu_el1(unsigned long total_base,
+			   unsigned long total_size,
+			   unsigned long,
+			   unsigned long
+#if USE_COHERENT_MEM
+			   , unsigned long,
+			   unsigned long
+#endif
+			   );
+void rcar_configure_mmu_el3(unsigned long total_base,
+			   unsigned long total_size,
+			   unsigned long,
+			   unsigned long
+#if USE_COHERENT_MEM
+			   , unsigned long,
+			   unsigned long
+#endif
+			   );
+
+void rcar_cci_init(void);
+void rcar_cci_enable(void);
+void rcar_cci_disable(void);
+
+/* Declarations for rcar_topology.c */
+void rcar_setup_topology(void);
+
+/* Gets the SPR for BL32 entry */
+uint32_t rcar_get_spsr_for_bl32_entry(void);
+
+/* Gets the SPSR for BL33 entry */
+uint32_t rcar_get_spsr_for_bl33_entry(void);
+
+/* Prototype function for power management	*/
+void rcar_affinst_standby(unsigned int power_state);
+int rcar_affinst_on(unsigned long mpidr, unsigned long sec_entrypoint,
+		unsigned int afflvl, unsigned int state);
+void rcar_affinst_off(unsigned int afflvl, unsigned int state);
+void rcar_affinst_suspend(unsigned long sec_entrypoint, unsigned int afflvl,
+		unsigned int state);
+void rcar_affinst_on_finish(unsigned int afflvl, unsigned int state);
+void rcar_affinst_suspend_finish(unsigned int afflvl, unsigned int state);
+int rcar_validate_power_state(unsigned int power_state);
+
+#endif /* RCAR_PRIVATE_H__ */
diff --git a/plat/renesas/rcar/rcar_topology.c b/plat/renesas/rcar/rcar_topology.c
new file mode 100644
index 0000000..78dcdd9
--- /dev/null
+++ b/plat/renesas/rcar/rcar_topology.c
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <platform_def.h>
+/* TODO: Reusing psci error codes & state information. Get our own! */
+#include <psci.h>
+#include "drivers/pwrc/rcar_pwrc.h"
+
+/* We treat '255' as an invalid affinity instance */
+#define AFFINST_INVAL	0xff
+
+typedef struct affinity_info {
+	unsigned char sibling;
+	unsigned char child;
+	unsigned char state;
+	unsigned int data;
+} affinity_info_t;
+
+/*******************************************************************************
+ * The following two data structures store the topology tree for the rcar. There
+ * is a separate array for each affinity level i.e. cpus and clusters. The child
+ * and sibling references allow traversal inside and in between the two arrays.
+ ******************************************************************************/
+static affinity_info_t rcar_aff1_topology_map[PLATFORM_CLUSTER_COUNT];
+static affinity_info_t rcar_aff0_topology_map[PLATFORM_CORE_COUNT];
+
+/* Simple global variable to safeguard us from stupidity */
+static unsigned int topology_setup_done;
+
+/*******************************************************************************
+ * This function implements a part of the critical interface between the psci
+ * generic layer and the platform to allow the former to detect the platform
+ * topology. psci queries the platform to determine how many affinity instances
+ * are present at a particular level for a given mpidr e.g. consider a dual
+ * cluster platform where each cluster has 4 cpus. A call to this function with
+ * (0, 0x100) will return the number of cpus implemented under cluster 1 i.e. 4.
+ * Similarly a call with (1, 0x100) will return 2 i.e. the number of clusters.
+ * This is 'cause we are effectively asking how many affinity level 1 instances
+ * are implemented under affinity level 2 instance 0.
+ ******************************************************************************/
+unsigned int plat_get_aff_count(unsigned int aff_lvl,
+				unsigned long mpidr)
+{
+	unsigned int aff_count = 1, ctr;
+	unsigned char parent_aff_id;
+
+	assert(topology_setup_done == 1);
+
+	switch (aff_lvl) {
+	case 3:
+	case 2:
+		/*
+		 * Assert if the parent affinity instance is not 0.
+		 * This also takes care of level 3 in an obfuscated way
+		 */
+		parent_aff_id = (mpidr >> MPIDR_AFF3_SHIFT) & MPIDR_AFFLVL_MASK;
+		assert(parent_aff_id == 0);
+
+		/*
+		 * Report that we implement a single instance of
+		 * affinity levels 2 & 3 which are AFF_ABSENT
+		 */
+		break;
+	case 1:
+		/* Assert if the parent affinity instance is not 0. */
+		parent_aff_id = (mpidr >> MPIDR_AFF2_SHIFT) & MPIDR_AFFLVL_MASK;
+		assert(parent_aff_id == 0);
+
+		/* Fetch the starting index in the aff1 array */
+		for (ctr = 0;
+		     rcar_aff1_topology_map[ctr].sibling != AFFINST_INVAL;
+		     ctr = rcar_aff1_topology_map[ctr].sibling) {
+			aff_count++;
+		}
+
+		break;
+	case 0:
+		/* Assert if the cluster id is anything apart from 0 or 1 */
+		parent_aff_id = (mpidr >> MPIDR_AFF1_SHIFT) & MPIDR_AFFLVL_MASK;
+		assert(parent_aff_id < PLATFORM_CLUSTER_COUNT);
+
+		/* Fetch the starting index in the aff0 array */
+		for (ctr = rcar_aff1_topology_map[parent_aff_id].child;
+		     rcar_aff0_topology_map[ctr].sibling != AFFINST_INVAL;
+		     ctr = rcar_aff0_topology_map[ctr].sibling) {
+			aff_count++;
+		}
+
+		break;
+	default:
+		assert(0);
+	}
+
+	return aff_count;
+}
+
+/*******************************************************************************
+ * This function implements a part of the critical interface between the psci
+ * generic layer and the platform to allow the former to detect the state of a
+ * affinity instance in the platform topology. psci queries the platform to
+ * determine whether an affinity instance is present or absent. This caters for
+ * topologies where an intermediate affinity level instance is missing e.g.
+ * consider a platform which implements a single cluster with 4 cpus and there
+ * is another cpu sitting directly on the interconnect along with the cluster.
+ * The mpidrs of the cluster would range from 0x0-0x3. The mpidr of the single
+ * cpu would be 0x100 to highlight that it does not belong to cluster 0. Cluster
+ * 1 is however missing but needs to be accounted to reach this single cpu in
+ * the topology tree. Hence it will be marked as PSCI_AFF_ABSENT. This is not
+ * applicable to the RCAR but depicted as an example.
+ ******************************************************************************/
+unsigned int plat_get_aff_state(unsigned int aff_lvl,
+				unsigned long mpidr)
+{
+	unsigned int aff_state = PSCI_AFF_ABSENT, idx;
+	idx = (mpidr >> MPIDR_AFF1_SHIFT) & MPIDR_AFFLVL_MASK;
+
+	assert(topology_setup_done == 1);
+
+	switch (aff_lvl) {
+	case 3:
+	case 2:
+		/* Report affinity levels 2 & 3 as absent */
+		break;
+	case 1:
+		aff_state = rcar_aff1_topology_map[idx].state;
+		break;
+	case 0:
+		/*
+		 * First get start index of the aff0 in its array & then add
+		 * to it the affinity id that we want the state of
+		 */
+		idx = rcar_aff1_topology_map[idx].child;
+		idx += (mpidr >> MPIDR_AFF0_SHIFT) & MPIDR_AFFLVL_MASK;
+		aff_state = rcar_aff0_topology_map[idx].state;
+		break;
+	default:
+		assert(0);
+	}
+
+	return aff_state;
+}
+
+/*******************************************************************************
+ * This function populates the RCAR specific topology information depending upon
+ * the RCAR flavour its running on. We construct all the mpidrs we can handle
+ * and rely on the PRR to flag absent cpus when their status is queried.
+ ******************************************************************************/
+void rcar_setup_topology(void)
+{
+	unsigned char aff0, aff1, aff_state, aff0_offset = 0;
+	unsigned long mpidr;
+
+	topology_setup_done = 0;
+
+	for (aff1 = 0; aff1 < PLATFORM_CLUSTER_COUNT; aff1++) {
+
+		rcar_aff1_topology_map[aff1].child = aff0_offset;
+		rcar_aff1_topology_map[aff1].sibling = aff1 + 1;
+
+		for (aff0 = 0; aff0 < PLATFORM_MAX_CPUS_PER_CLUSTER; aff0++) {
+
+			mpidr = aff1 << MPIDR_AFF1_SHIFT;
+			mpidr |= aff0 << MPIDR_AFF0_SHIFT;
+
+			if (rcar_pwrc_status(mpidr) != RCAR_INVALID) {
+				/*
+				 * Presence of even a single aff0 indicates
+				 * presence of parent aff1 on the RCAR.
+				 */
+				aff_state = PSCI_AFF_PRESENT;
+				rcar_aff1_topology_map[aff1].state =
+					PSCI_AFF_PRESENT;
+			} else {
+				aff_state = PSCI_AFF_ABSENT;
+			}
+
+			rcar_aff0_topology_map[aff0_offset].child = AFFINST_INVAL;
+			rcar_aff0_topology_map[aff0_offset].state = aff_state;
+			rcar_aff0_topology_map[aff0_offset].sibling =
+				aff0_offset + 1;
+
+			/* Increment the absolute number of aff0s traversed */
+			aff0_offset++;
+		}
+
+		/* Tie-off the last aff0 sibling to -1 to avoid overflow */
+		rcar_aff0_topology_map[aff0_offset - 1].sibling = AFFINST_INVAL;
+	}
+
+	/* Tie-off the last aff1 sibling to AFFINST_INVAL to avoid overflow */
+	rcar_aff1_topology_map[aff1 - 1].sibling = AFFINST_INVAL;
+
+	topology_setup_done = 1;
+}
diff --git a/plat/renesas/rcar/rcar_version.h b/plat/renesas/rcar/rcar_version.h
new file mode 100644
index 0000000..cc834bb
--- /dev/null
+++ b/plat/renesas/rcar/rcar_version.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	RCAR_VERSION_H__
+#define	RCAR_VERSION_H__
+
+#include	<arch_helpers.h>
+
+#define		VER_SIZE		4
+#define		VERSION_OF_RENESAS	"1.00"
+
+extern const uint8_t	version_of_renesas[VER_SIZE];
+
+#endif	/* RCAR_VERSION_H__	*/
diff --git a/tools/dummy_create/makefile b/tools/dummy_create/makefile
new file mode 100644
index 0000000..4f40932
--- /dev/null
+++ b/tools/dummy_create/makefile
@@ -0,0 +1,103 @@
+#
+# Copyright (c) 2015-2016, Renesas Electronics Corporation
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+#   - Redistributions of source code must retain the above copyright notice,
+#     this list of conditions and the following disclaimer.
+#
+#   - Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#
+#   - Neither the name of Renesas nor the names of its contributors may be
+#     used to endorse or promote products derived from this software without
+#     specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+###################################################
+# makefile
+###################################################
+
+#output file name
+FILE_NAME_SA0   = bootparam_sa0
+FILE_NAME_SA6   = cert_header_sa6
+
+OUTPUT_FILE_SA0 = $(FILE_NAME_SA0).elf
+OUTPUT_FILE_SA6 = $(FILE_NAME_SA6).elf
+
+#object file name
+OBJ_FILE_SA0 =	sa0.o
+OBJ_FILE_SA6 =	sa6.o
+
+#linker script name 
+MEMORY_DEF_SA0 = sa0.ld.S
+MEMORY_DEF_SA6 = sa6.ld.S
+
+###################################################
+
+#c compiler
+CC = $(CROSS_COMPILE)gcc
+
+#Linker
+LD = $(CROSS_COMPILE)ld
+
+#objcopy
+objcopy = $(CROSS_COMPILE)objcopy
+
+#clean
+CL = rm -f
+
+###################################################
+.SUFFIXES : .s .c .o
+
+###################################################
+# command
+
+.PHONY: all
+all: $(OUTPUT_FILE_SA0) $(OUTPUT_FILE_SA6)
+###################################################
+# Linker
+###################################################
+$(OUTPUT_FILE_SA0) : $(MEMORY_DEF_SA0) $(OBJ_FILE_SA0)
+	$(LD) $(OBJ_FILE_SA0)		 	\
+	-T $(MEMORY_DEF_SA0)			\
+	-o $(OUTPUT_FILE_SA0)			\
+	-Map $(FILE_NAME_SA0).map 		\
+
+	$(objcopy) -O srec --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA0) $(FILE_NAME_SA0).srec
+	$(objcopy) -O binary --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA0) $(FILE_NAME_SA0).bin
+
+$(OUTPUT_FILE_SA6) : $(MEMORY_DEF_SA6) $(OBJ_FILE_SA6)
+	$(LD) $(OBJ_FILE_SA6)		 	\
+	-T $(MEMORY_DEF_SA6)			\
+	-o $(OUTPUT_FILE_SA6)			\
+	-Map $(FILE_NAME_SA6).map 		\
+
+	$(objcopy) -O srec --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA6) $(FILE_NAME_SA6).srec
+	$(objcopy) -O binary --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA6) $(FILE_NAME_SA6).bin
+
+###################################################
+# Compile
+###################################################
+
+%.o:../%.c
+	$(CC) -c -I $< -o $@
+
+.PHONY: clean
+clean:
+	$(CL)  *.bin *.map *.srec *.elf *.o
diff --git a/tools/dummy_create/sa0.c b/tools/dummy_create/sa0.c
new file mode 100644
index 0000000..c858d2d
--- /dev/null
+++ b/tools/dummy_create/sa0.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/* SA0 */
+/* 0x00000000 */
+const unsigned int __attribute__ ((section (".sa0_bootrom"))) bootrom_paramA = 0x00000100;
+/* 0x00000C00 */
+/* 0x00000D54 */
+const unsigned int __attribute__ ((section (".sa0_bl2cert_addr"))) bl2cert_addr = 0xE6302000;
+/* 0x00000E64 */
+const unsigned int __attribute__ ((section (".sa0_bl2cert_size"))) bl2cert_size = 0x00004000;
+
diff --git a/tools/dummy_create/sa0.ld.S b/tools/dummy_create/sa0.ld.S
new file mode 100644
index 0000000..55a0eee
--- /dev/null
+++ b/tools/dummy_create/sa0.ld.S
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+SECTIONS
+{
+	. = 0x00000000;
+	.rodata : {
+		KEEP(*(.sa0_bootrom))
+		. = 0x00000D54;
+		KEEP(*(.sa0_bl2cert_addr))
+		. = 0x00000E64;
+		KEEP(*(.sa0_bl2cert_size))
+	}
+
+}
diff --git a/tools/dummy_create/sa6.c b/tools/dummy_create/sa6.c
new file mode 100644
index 0000000..8b864ec
--- /dev/null
+++ b/tools/dummy_create/sa6.c
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/* SA6 */
+/* 0x00180000 */
+const unsigned int __attribute__ ((section (".sa6_image_num"))) image_num = 0x00000001;
+/* 0x00180004 */
+const unsigned int __attribute__ ((section (".sa6_start_addr_1"))) start_addr_1 = 0x00640000;
+/* 0x00180400 */
+/* 0x00180554 */
+const unsigned int __attribute__ ((section (".sa6_bl31cert_addr"))) bl31cert_addr = 0x44000000;
+/* 0x00180664 */
+const unsigned int __attribute__ ((section (".sa6_bl31cert_size"))) bl31cert_size = 0x00004000;
+/* 0x00180800 */
+/* 0x00180954 */
+const unsigned int __attribute__ ((section (".sa6_bl32cert_addr"))) bl32cert_addr = 0x44100000;
+/* 0x00180A64 */
+const unsigned int __attribute__ ((section (".sa6_bl32cert_size"))) bl32cert_size = 0x00020000;
+/* 0x00180C00 */
+/* 0x00180D54 */
+const unsigned int __attribute__ ((section (".sa6_bl33cert_addr"))) bl33cert_addr = 0x49000000;
+/* 0x00180E64 */
+const unsigned int __attribute__ ((section (".sa6_bl33cert_size"))) bl33cert_size = 0x00040000;
+
diff --git a/tools/dummy_create/sa6.ld.S b/tools/dummy_create/sa6.ld.S
new file mode 100644
index 0000000..98569cb
--- /dev/null
+++ b/tools/dummy_create/sa6.ld.S
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+SECTIONS
+{
+	. = 0x00000000;
+	.rodata : {
+		KEEP(*(.sa6_image_num))
+		. = 0x00000004;
+		KEEP(*(.sa6_start_addr_1))
+		. = 0x00000554;
+		KEEP(*(.sa6_bl31cert_addr))
+		. = 0x00000664;
+		KEEP(*(.sa6_bl31cert_size))
+		. = 0x00000954;
+		KEEP(*(.sa6_bl32cert_addr))
+		. = 0x00000A64;
+		KEEP(*(.sa6_bl32cert_size))
+		. = 0x00000D54;
+		KEEP(*(.sa6_bl33cert_addr))
+		. = 0x00000E64;
+		KEEP(*(.sa6_bl33cert_size))
+	}
+
+}
-- 
1.9.1

