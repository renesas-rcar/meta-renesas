From 6cf9df9de73f08ef193a23e058aab993490a5fcd Mon Sep 17 00:00:00 2001
From: Kazunori Kobayashi <kkobayas@igel.co.jp>
Date: Thu, 28 Jun 2012 17:50:32 +0900
Subject: [PATCH] headers: update OMX headers version 1.1.1 to 1.1.2

---
 omx/headers/OMX_Audio.h       | 2574 +++++++++++++++++++------------------
 omx/headers/OMX_Component.h   |   22 +-
 omx/headers/OMX_ContentPipe.h |  397 +++---
 omx/headers/OMX_Core.h        | 2821 +++++++++++++++++++++--------------------
 omx/headers/OMX_IVCommon.h    | 1816 +++++++++++++-------------
 omx/headers/OMX_Image.h       |  646 +++++-----
 omx/headers/OMX_Index.h       |  514 ++++----
 omx/headers/OMX_Other.h       |  662 +++++-----
 omx/headers/OMX_Types.h       |  702 +++++-----
 omx/headers/OMX_Video.h       | 2085 +++++++++++++++---------------
 10 files changed, 6204 insertions(+), 6035 deletions(-)

diff --git a/omx/headers/OMX_Audio.h b/omx/headers/OMX_Audio.h
index 0f5d30d..04f1a99 100644
--- a/omx/headers/OMX_Audio.h
+++ b/omx/headers/OMX_Audio.h
@@ -1,1263 +1,1311 @@
-/*
- * Copyright (c) 2007 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** @file OMX_Audio.h - OpenMax IL version 1.1.1
- *  The structures needed by Audio components to exchange
- *  parameters and configuration data with the componenmilts.
- */
-
-#ifndef OMX_Audio_h
-#define OMX_Audio_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/* Each OMX header must include all required header files to allow the
- *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully 
- */
-
-#include <OMX_Core.h>
-
-/** @defgroup midi MIDI
- * @ingroup audio
- */
- 
-/** @defgroup effects Audio effects
- * @ingroup audio
- */
-
-/** @defgroup audio OpenMAX IL Audio Domain
- * Structures for OpenMAX IL Audio domain
- * @{
- */
-
-/** Enumeration used to define the possible audio codings.  
- *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must 
- *  be done in a vendor specific way.  Since this is for an audio 
- *  processing element this enum is relevant.  However, for another 
- *  type of component other enums would be in this area.
- */
-typedef enum OMX_AUDIO_CODINGTYPE {
-    OMX_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
-    OMX_AUDIO_CodingAutoDetect,  /**< auto detection of audio format */
-    OMX_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
-    OMX_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
-    OMX_AUDIO_CodingAMR,         /**< Any variant of AMR encoded data */
-    OMX_AUDIO_CodingGSMFR,       /**< Any variant of GSM fullrate (i.e. GSM610) */
-    OMX_AUDIO_CodingGSMEFR,      /**< Any variant of GSM Enhanced Fullrate encoded data*/
-    OMX_AUDIO_CodingGSMHR,       /**< Any variant of GSM Halfrate encoded data */
-    OMX_AUDIO_CodingPDCFR,       /**< Any variant of PDC Fullrate encoded data */
-    OMX_AUDIO_CodingPDCEFR,      /**< Any variant of PDC Enhanced Fullrate encoded data */
-    OMX_AUDIO_CodingPDCHR,       /**< Any variant of PDC Halfrate encoded data */
-    OMX_AUDIO_CodingTDMAFR,      /**< Any variant of TDMA Fullrate encoded data (TIA/EIA-136-420) */
-    OMX_AUDIO_CodingTDMAEFR,     /**< Any variant of TDMA Enhanced Fullrate encoded data (TIA/EIA-136-410) */
-    OMX_AUDIO_CodingQCELP8,      /**< Any variant of QCELP 8kbps encoded data */
-    OMX_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
-    OMX_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
-    OMX_AUDIO_CodingSMV,         /**< Any variant of SMV encoded data */
-    OMX_AUDIO_CodingG711,        /**< Any variant of G.711 encoded data */
-    OMX_AUDIO_CodingG723,        /**< Any variant of G.723 dot 1 encoded data */
-    OMX_AUDIO_CodingG726,        /**< Any variant of G.726 encoded data */
-    OMX_AUDIO_CodingG729,        /**< Any variant of G.729 encoded data */
-    OMX_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data */
-    OMX_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
-    OMX_AUDIO_CodingSBC,         /**< Any variant of SBC encoded data */
-    OMX_AUDIO_CodingVORBIS,      /**< Any variant of VORBIS encoded data */
-    OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
-    OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
-    OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
-    OMX_AUDIO_CodingMax = 0x7FFFFFFF
-} OMX_AUDIO_CODINGTYPE;
-
-
-/** The PortDefinition structure is used to define all of the parameters 
- *  necessary for the compliant component to setup an input or an output audio 
- *  path.  If additional information is needed to define the parameters of the
- *  port (such as frequency), additional structures must be sent such as the
- *  OMX_AUDIO_PCMTYPE structure to supply the extra parameters for the port.
- */
-typedef struct OMX_AUDIO_PORTDEFINITIONTYPE {
-    OMX_STRING cMIMEType;            /**< MIME type of data for the port */
-    OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
-                                               for an output device, 
-                                               otherwise this field is 0 */
-    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is 
-                                          supported by the OMX component */
-    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this 
-                                          port (e.g. PCM, AMR, MP3, etc) */
-} OMX_AUDIO_PORTDEFINITIONTYPE;
-
-
-/**  Port format parameter.  This structure is used to enumerate
-  *  the various data input/output format supported by the port.
-  */
-typedef struct OMX_AUDIO_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_U32 nPortIndex;             /**< Indicates which port to set */
-    OMX_U32 nIndex;                 /**< Indicates the enumeration index for the format from 0x0 to N-1 */
-    OMX_AUDIO_CODINGTYPE eEncoding; /**< Type of data expected for this port (e.g. PCM, AMR, MP3, etc) */
-} OMX_AUDIO_PARAM_PORTFORMATTYPE;
-
-
-/** PCM mode type  */ 
-typedef enum OMX_AUDIO_PCMMODETYPE { 
-    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */ 
-    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */ 
-    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */ 
-    OMX_AUDIO_PCMModeMax = 0x7FFFFFFF 
-} OMX_AUDIO_PCMMODETYPE; 
-
-
-typedef enum OMX_AUDIO_CHANNELTYPE {
-    OMX_AUDIO_ChannelNone = 0x0,    /**< Unused or empty */
-    OMX_AUDIO_ChannelLF   = 0x1,    /**< Left front */
-    OMX_AUDIO_ChannelRF   = 0x2,    /**< Right front */
-    OMX_AUDIO_ChannelCF   = 0x3,    /**< Center front */
-    OMX_AUDIO_ChannelLS   = 0x4,    /**< Left surround */
-    OMX_AUDIO_ChannelRS   = 0x5,    /**< Right surround */
-    OMX_AUDIO_ChannelLFE  = 0x6,    /**< Low frequency effects */
-    OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
-    OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
-    OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
-    OMX_AUDIO_ChannelMax  = 0x7FFFFFFF 
-} OMX_AUDIO_CHANNELTYPE;
-
-#define OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
-#define OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */
-
-/** PCM format description */ 
-typedef struct OMX_AUDIO_PARAM_PCMMODETYPE { 
-    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
-    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
-    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */ 
-    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */ 
-    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */ 
-    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for 
-                                           non-interleaved data (e.g. block data) */ 
-    OMX_U32 nBitPerSample;            /**< Bit per sample */ 
-    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for 
-                                           variable or unknown sampling rate. */ 
-    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */ 
-    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */
-
-} OMX_AUDIO_PARAM_PCMMODETYPE; 
-
-
-/** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
- * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC. 
- */
-typedef enum OMX_AUDIO_CHANNELMODETYPE {
-    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those 
-                                          two channels changes accordingly to each channel information */
-    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between 
-                                           2 channels for higher compression gain */
-    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half 
-                                           the bitrate of the overall bitrate */
-    OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
-    OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
-} OMX_AUDIO_CHANNELMODETYPE;
-
-
-typedef enum OMX_AUDIO_MP3STREAMFORMATTYPE {
-    OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
-    OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
-    OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
-    OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_MP3STREAMFORMATTYPE;
-
-/** MP3 params */
-typedef struct OMX_AUDIO_PARAM_MP3TYPE {
-    OMX_U32 nSize;                 /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< port that this structure applies to */
-    OMX_U32 nChannels;             /**< Number of channels */
-    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
-                                        rate or unknown bit rates */
-    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
-                                        variable or unknown sampling rate. */
-    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
-                                        limit the audio signal. Use 0 to let encoder decide */
-    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
-    OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;  /**< MP3 stream format */
-} OMX_AUDIO_PARAM_MP3TYPE;
-
-
-typedef enum OMX_AUDIO_AACSTREAMFORMATTYPE {
-    OMX_AUDIO_AACStreamFormatMP2ADTS = 0, /**< AAC Audio Data Transport Stream 2 format */
-    OMX_AUDIO_AACStreamFormatMP4ADTS,     /**< AAC Audio Data Transport Stream 4 format */
-    OMX_AUDIO_AACStreamFormatMP4LOAS,     /**< AAC Low Overhead Audio Stream format */
-    OMX_AUDIO_AACStreamFormatMP4LATM,     /**< AAC Low overhead Audio Transport Multiplex */
-    OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
-    OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
-    OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
-    OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_AACSTREAMFORMATTYPE;
-
-
-/** AAC mode type.  Note that the term profile is used with the MPEG-2
- * standard and the term object type and profile is used with MPEG-4 */
-typedef enum OMX_AUDIO_AACPROFILETYPE{
-  OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
-  OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
-  OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
-  OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
-  OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
-  OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
-  OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
-  OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
-  OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
-  OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
-  OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
-} OMX_AUDIO_AACPROFILETYPE;
-
-
-/** AAC tool usage (for nAACtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
- * Required for encoder configuration and optional as decoder info output.
- * For MP3, OMX_AUDIO_CHANNELMODETYPE is sufficient. */
-#define OMX_AUDIO_AACToolNone 0x00000000 /**< no AAC tools allowed (encoder config) or active (decoder info output) */
-#define OMX_AUDIO_AACToolMS   0x00000001 /**< MS: Mid/side joint coding tool allowed or active */
-#define OMX_AUDIO_AACToolIS   0x00000002 /**< IS: Intensity stereo tool allowed or active */
-#define OMX_AUDIO_AACToolTNS  0x00000004 /**< TNS: Temporal Noise Shaping tool allowed or active */
-#define OMX_AUDIO_AACToolPNS  0x00000008 /**< PNS: MPEG-4 Perceptual Noise substitution tool allowed or active */
-#define OMX_AUDIO_AACToolLTP  0x00000010 /**< LTP: MPEG-4 Long Term Prediction tool allowed or active */
-#define OMX_AUDIO_AACToolAll  0x7FFFFFFF /**< all AAC tools allowed or active (*/
-
-/** MPEG-4 AAC error resilience (ER) tool usage (for nAACERtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
- * Required for ER encoder configuration and optional as decoder info output */
-#define OMX_AUDIO_AACERNone  0x00000000  /**< no AAC ER tools allowed/used */
-#define OMX_AUDIO_AACERVCB11 0x00000001  /**< VCB11: Virtual Code Books for AAC section data */
-#define OMX_AUDIO_AACERRVLC  0x00000002  /**< RVLC: Reversible Variable Length Coding */
-#define OMX_AUDIO_AACERHCR   0x00000004  /**< HCR: Huffman Codeword Reordering */
-#define OMX_AUDIO_AACERAll   0x7FFFFFFF  /**< all AAC ER tools allowed/used */
-
-
-/** AAC params */
-typedef struct OMX_AUDIO_PARAM_AACPROFILETYPE {
-    OMX_U32 nSize;                 /**< Size of this structure, in Bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< Port that this structure applies to */
-    OMX_U32 nChannels;             /**< Number of channels */
-    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
-                                        variable or unknown sampling rate. */
-    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
-                                        rate or unknown bit rates */
-    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
-                                        limit the audio signal. Use 0 to let encoder decide */
-    OMX_U32 nFrameLength;          /**< Frame length (in audio samples per channel) of the codec.
-                                        Can be 1024 or 960 (AAC-LC), 2048 (HE-AAC), 480 or 512 (AAC-LD).
-                                        Use 0 to let encoder decide */
-    OMX_U32 nAACtools;             /**< AAC tool usage */
-    OMX_U32 nAACERtools;           /**< MPEG-4 AAC error resilience tool usage */
-    OMX_AUDIO_AACPROFILETYPE eAACProfile;   /**< AAC profile enumeration */
-    OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat; /**< AAC stream format enumeration */
-    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
-} OMX_AUDIO_PARAM_AACPROFILETYPE;
-
-
-/** VORBIS params */
-typedef struct OMX_AUDIO_PARAM_VORBISTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nChannels;        /**< Number of channels */
-    OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
-                                   rate or unknown bit rates. Encoding is set to the
-                                   bitrate closest to specified  value (in bps) */
-    OMX_U32 nMinBitRate;      /**< Sets minimum bitrate (in bps). */
-    OMX_U32 nMaxBitRate;      /**< Sets maximum bitrate (in bps). */
-
-    OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
-                                   variable or unknown sampling rate. */
-    OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
-                                   limit the audio signal. Use 0 to let encoder decide */
-    OMX_S32 nQuality;		  /**< Sets encoding quality to n, between -1 (low) and 10 (high).
-                                   In the default mode of operation, teh quality level is 3.
-                                   Normal quality range is 0 - 10. */
-    OMX_BOOL bManaged;		  /**< Set  bitrate  management  mode. This turns off the
-                                   normal VBR encoding, but allows hard or soft bitrate
-                                   constraints to be enforced by the encoder. This mode can
-                                   be slower, and may also be lower quality. It is
-                                   primarily useful for streaming. */
-    OMX_BOOL bDownmix;		  /**< Downmix input from stereo to mono (has no effect on 
-                                   non-stereo streams). Useful for lower-bitrate encoding. */     
-} OMX_AUDIO_PARAM_VORBISTYPE;
-
-
-/** WMA Version */
-typedef enum OMX_AUDIO_WMAFORMATTYPE {
-  OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
-  OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
-  OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
-  OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
-  OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_WMAFORMATTYPE;
-
-
-/** WMA Profile */
-typedef enum OMX_AUDIO_WMAPROFILETYPE {
-  OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
-  OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
-  OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
-  OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
-  OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
-} OMX_AUDIO_WMAPROFILETYPE;
-
-
-/** WMA params */
-typedef struct OMX_AUDIO_PARAM_WMATYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U16 nChannels;        /**< Number of channels */
-    OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
-                                   rate or unknown bit rates */
-    OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
-	OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
-    OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
-    OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
-    OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
-    OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
-} OMX_AUDIO_PARAM_WMATYPE;
-
-/** 
- * RealAudio format
- */
-typedef enum OMX_AUDIO_RAFORMATTYPE {
-    OMX_AUDIO_RAFormatUnused = 0, /**< Format unused or unknown */
-    OMX_AUDIO_RA8,                /**< RealAudio 8 codec */
-    OMX_AUDIO_RA9,                /**< RealAudio 9 codec */
-    OMX_AUDIO_RA10_AAC,           /**< MPEG-4 AAC codec for bitrates of more than 128kbps */
-    OMX_AUDIO_RA10_CODEC,         /**< RealAudio codec for bitrates less than 128 kbps */
-    OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
-    OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
-    OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
-    OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_RAFORMATTYPE;
-
-/** RA (Real Audio) params */ 
-typedef struct OMX_AUDIO_PARAM_RATYPE { 
-    OMX_U32 nSize;              /**< Size of this structure, in Bytes */ 
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;         /**< Port that this structure applies to */ 
-    OMX_U32 nChannels;          /**< Number of channels */ 
-    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */ 
-    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */ 
-    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */ 
-    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */ 
-    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */ 
-    OMX_U32 nNumRegions;        /**< is the number of regions value */ 
-    OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
-} OMX_AUDIO_PARAM_RATYPE; 
-
-
-/** SBC Allocation Method Type */
-typedef enum OMX_AUDIO_SBCALLOCMETHODTYPE {
-  OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
-  OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
-  OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
-} OMX_AUDIO_SBCALLOCMETHODTYPE;
-
-
-/** SBC params */
-typedef struct OMX_AUDIO_PARAM_SBCTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_U32 nChannels;         /**< Number of channels */
-    OMX_U32 nBitRate;          /**< Bit rate of the input data.  Use 0 for variable
-                                    rate or unknown bit rates */
-    OMX_U32 nSampleRate;       /**< Sampling rate of the source data.  Use 0 for
-                                    variable or unknown sampling rate. */
-    OMX_U32 nBlocks;           /**< Number of blocks */
-    OMX_U32 nSubbands;         /**< Number of subbands */
-    OMX_U32 nBitPool;          /**< Bitpool value */
-    OMX_BOOL bEnableBitrate;   /**< Use bitrate value instead of bitpool */
-    OMX_AUDIO_CHANNELMODETYPE eChannelMode; /**< Channel mode enumeration */
-    OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;   /**< SBC Allocation method type */
-} OMX_AUDIO_PARAM_SBCTYPE;
-
-
-/** ADPCM stream format parameters */ 
-typedef struct OMX_AUDIO_PARAM_ADPCMTYPE { 
-    OMX_U32 nSize;              /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
-    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
-                                     necessarily the same as the number of channels 
-                                     to be rendered. */ 
-    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */ 
-    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for 
-                                    variable or unknown sampling rate. */ 
-} OMX_AUDIO_PARAM_ADPCMTYPE; 
-
-
-/** G723 rate */
-typedef enum OMX_AUDIO_G723RATE {
-    OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
-    OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
-    OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
-    OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
-} OMX_AUDIO_G723RATE;
-
-
-/** G723 - Sample rate must be 8 KHz */
-typedef struct OMX_AUDIO_PARAM_G723TYPE { 
-    OMX_U32 nSize;                /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */ 
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not 
-                                       necessarily the same as the number of channels 
-                                       to be rendered. */ 
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */ 
-    OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */ 
-    OMX_BOOL bPostFilter;         /**< Enable Post Filter */ 
-} OMX_AUDIO_PARAM_G723TYPE; 
-
-
-/** ITU G726 (ADPCM) rate */
-typedef enum OMX_AUDIO_G726MODE {
-    OMX_AUDIO_G726ModeUnused = 0,  /**< G726 Mode unused / unknown */
-    OMX_AUDIO_G726Mode16,          /**< 16 kbps */
-    OMX_AUDIO_G726Mode24,          /**< 24 kbps */
-    OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
-    OMX_AUDIO_G726Mode40,          /**< 40 kbps */
-    OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
-} OMX_AUDIO_G726MODE;
-
-
-/** G.726 stream format parameters - must be at 8KHz */ 
-typedef struct OMX_AUDIO_PARAM_G726TYPE { 
-    OMX_U32 nSize;              /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
-    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
-                                     necessarily the same as the number of channels 
-                                     to be rendered. */ 
-     OMX_AUDIO_G726MODE eG726Mode;
-} OMX_AUDIO_PARAM_G726TYPE; 
-
-
-/** G729 coder type */
-typedef enum OMX_AUDIO_G729TYPE {
-    OMX_AUDIO_G729 = 0,           /**< ITU G.729  encoded data */
-    OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
-    OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
-    OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
-    OMX_AUDIO_G729Max = 0x7FFFFFFF
-} OMX_AUDIO_G729TYPE;
-
-
-/** G729 stream format parameters - fixed 6KHz sample rate */
-typedef struct OMX_AUDIO_PARAM_G729TYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nChannels;        /**< Number of channels in the data stream (not
-                                   necessarily the same as the number of channels
-                                   to be rendered. */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_AUDIO_G729TYPE eBitType;
-} OMX_AUDIO_PARAM_G729TYPE;
-
-
-/** AMR Frame format */ 
-typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE { 
-    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance 
-                                                   (Standard) Format */ 
-    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface 
-                                                   Format 1 */ 
-    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface 
-                                                   Format 2*/ 
-    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage 
-                                                   Format */ 
-    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time 
-                                                   Transport Protocol Payload Format */ 
-    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */ 
-    OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF 
-} OMX_AUDIO_AMRFRAMEFORMATTYPE; 
-
-
-/** AMR band mode */
-typedef enum OMX_AUDIO_AMRBANDMODETYPE {
-    OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
-    OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
-    OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
-    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */ 
-    OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
-    OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
-    OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
-    OMX_AUDIO_AMRBandModeNB6,                 /**< AMRNB Mode 6 = 10200 bps */
-    OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
-    OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
-    OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
-    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */ 
-    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */ 
-    OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
-    OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
-    OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
-    OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
-    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */      
-    OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
-} OMX_AUDIO_AMRBANDMODETYPE;
-     
-
-/** AMR Discontinuous Transmission mode */ 
-typedef enum OMX_AUDIO_AMRDTXMODETYPE { 
-    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */ 
-    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using 
-                                             Voice Activity Detector 1 (VAD1) is enabled */ 
-    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using 
-                                             Voice Activity Detector 2 (VAD2) is enabled */       
-    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between 
-                                             Off, VAD1 or VAD2 modes */ 
-
-    OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */
-
-    OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF 
-} OMX_AUDIO_AMRDTXMODETYPE; 
- 
-
-/** AMR params */
-typedef struct OMX_AUDIO_PARAM_AMRTYPE {
-    OMX_U32 nSize;                          /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;               /**< OMX specification version information */
-    OMX_U32 nPortIndex;                     /**< port that this structure applies to */
-    OMX_U32 nChannels;                      /**< Number of channels */
-    OMX_U32 nBitRate;                       /**< Bit rate read only field */
-    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */ 
-    OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
-    OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
-} OMX_AUDIO_PARAM_AMRTYPE;
-
-
-/** GSM_FR (ETSI 06.10, 3GPP 46.010) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_GSMFRTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_GSMFRTYPE;
-
-
-/** GSM-HR (ETSI 06.20, 3GPP 46.020) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_GSMHRTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_GSMHRTYPE;
-
-
-/** GSM-EFR (ETSI 06.60, 3GPP 46.060) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_GSMEFRTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_GSMEFRTYPE;
-
-
-/** TDMA FR (TIA/EIA-136-420, VSELP 7.95kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_TDMAFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_TDMAFRTYPE;
-
-
-/** TDMA EFR (TIA/EIA-136-410, ACELP 7.4kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_TDMAEFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_TDMAEFRTYPE;
-
-
-/** PDC FR ( RCR-27, VSELP 6.7kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_PDCFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_PDCFRTYPE;
-
-
-/** PDC EFR ( RCR-27, ACELP 6.7kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_PDCEFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_PDCEFRTYPE;
-
-/** PDC HR ( RCR-27, PSI-CELP 3.45kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_PDCHRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_PDCHRTYPE;
-
-
-/** CDMA Rate types */
-typedef enum OMX_AUDIO_CDMARATETYPE {
-    OMX_AUDIO_CDMARateBlank = 0,          /**< CDMA encoded frame is blank */
-    OMX_AUDIO_CDMARateFull,               /**< CDMA encoded frame in full rate */
-    OMX_AUDIO_CDMARateHalf,               /**< CDMA encoded frame in half rate */
-    OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
-    OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
-    OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
-    OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
-} OMX_AUDIO_CDMARATETYPE;
-
-
-/** QCELP8 (TIA/EIA-96, up to 8kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_QCELP8TYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_U32 nBitRate;             /**< Bit rate of the input data.  Use 0 for variable
-                                       rate or unknown bit rates */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
-} OMX_AUDIO_PARAM_QCELP8TYPE;
-
-
-/** QCELP13 ( CDMA, EIA/TIA-733, 13.3kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_QCELP13TYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
-} OMX_AUDIO_PARAM_QCELP13TYPE;
-
-
-/** EVRC ( CDMA, EIA/TIA-127, RCELP up to 8.55kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_EVRCTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< actual Frame rate */
-    OMX_BOOL bRATE_REDUCon;       /**< RATE_REDUCtion is requested for this frame */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
-    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter */
-    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
-    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter */
-} OMX_AUDIO_PARAM_EVRCTYPE;
-
-
-/** SMV ( up to 8.55kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_SMVTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
-    OMX_BOOL bRATE_REDUCon;           /**< RATE_REDUCtion is requested for this frame */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 ??*/
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 ??*/
-    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter ??*/
-    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
-    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter ??*/
-} OMX_AUDIO_PARAM_SMVTYPE;
-
-
-/** MIDI Format 
- * @ingroup midi
- */
-typedef enum OMX_AUDIO_MIDIFORMATTYPE
-{
-    OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
-    OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
-    OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
-    OMX_AUDIO_MIDIFormatSMF2,        /**< Standard MIDI File Type 2 */
-    OMX_AUDIO_MIDIFormatSPMIDI,      /**< SP-MIDI */
-    OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
-    OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
-    OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
-    OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_MIDIFORMATTYPE;
-
-
-/** MIDI params 
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_PARAM_MIDITYPE {
-    OMX_U32 nSize;                 /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< port that this structure applies to */
-    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire 
-                                        MIDI file passed in, otherwise if 0x0, the MIDI data 
-                                        is merged and streamed (instead of passed as an 
-                                        entire MIDI file) */
-    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
-                                        voices. A value of zero indicates that the default 
-                                        polyphony of the device is used  */                                    
-    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound 
-                                        bank at initialization */
-    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */                                                                           
-} OMX_AUDIO_PARAM_MIDITYPE;
-
-
-/** Type of the MIDI sound bank 
- * @ingroup midi
- */
-typedef enum OMX_AUDIO_MIDISOUNDBANKTYPE {
-    OMX_AUDIO_MIDISoundBankUnused = 0,           /**< unused/unknown soundbank type */
-    OMX_AUDIO_MIDISoundBankDLS1,                 /**< DLS version 1 */
-    OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
-    OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
-    OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
-    OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
-} OMX_AUDIO_MIDISOUNDBANKTYPE;
-
-
-/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank 
- * @ingroup midi
- */
-typedef enum OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
-   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
-   OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
-   OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
-   OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
-   OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
-} OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;
-
-
-/** MIDI params to load/unload user soundbank 
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nDLSIndex;        /**< DLS file index to be loaded */
-    OMX_U32 nDLSSize;         /**< Size in bytes */
-    OMX_PTR pDLSData;         /**< Pointer to DLS file data */
-    OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;   /**< Midi sound bank type enumeration */
-    OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout; /**< Midi sound bank layout enumeration */
-} OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;
-
-
-/** Structure for Live MIDI events and MIP messages. 
- * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.) 
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
-    OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
-    OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
-                                   array for the MIP message buffer, where the size is 
-                                   indicated by nMidiEventSize */
-} OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;
-
-
-/** MIDI sound bank/ program pair in a given channel 
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
-    OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
-    OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
-    OMX_U16 nIDSoundBank;       /**< Sound bank ID */
-    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks 
-                                     by index if multiple banks are present */
-} OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;
-
-
-/** MIDI control 
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10 
-                                       format based on JAVA MMAPI (JSR-135) requirement */
-    OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
-                                       number based on JSR-135 requirement */
-    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10 
-                                       fixed-point number based on JSR-135 requirement */
-    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
-                                       voices. A value of zero indicates that the default 
-                                       polyphony of the device is used  */
-    OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
-    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback 
-                                       will stop automatically.  Set to zero if not used */
-    OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
-    OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
-    OMX_U32 nTrack0031MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 0-31 */
-    OMX_U32 nTrack3263MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 32-63 */
-    OMX_U32 nTrack0031SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 0-31 */
-    OMX_U32 nTrack3263SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 32-63 */
-
-} OMX_AUDIO_CONFIG_MIDICONTROLTYPE;
-
-
-/** MIDI Playback States 
- * @ingroup midi
- */
-typedef enum OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
-  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to 
-  													other defined states */
-  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open. 
-                                                    The MIDI engine is currently processing 
-                                                    MIDI events. */
-  OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being 
-                                                    primed. The MIDI engine is currently 
-                                                    processing MIDI events. */
-  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but 
-                                                    not playing. The MIDI engine is currently
-                                                    processing MIDI events. The transition to
-                                                    this state is only possible from the 
-                                                    OMX_AUDIO_MIDIPlayBackStatePlaying state,
-                                                    when the 'playback head' reaches the end
-                                                    of media data or the playback stops due
-                                                    to stop time set.*/
-  OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
-                                                    playing. The MIDI engine is currently
-                                                    processing MIDI events.*/
-  OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
-                                                    resource constraints */
-  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
-                                                    SP-MIDI content constraints, there is
-                                                    no audible MIDI content during playback
-                                                    currently. The situation may change if
-                                                    resources are freed later.*/
-  OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
-} OMX_AUDIO_MIDIPLAYBACKSTATETYPE;
-
-
-/** MIDI status 
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field. 
-                                     NOTE: May not return a meaningful value until the entire 
-                                     file is parsed and buffered.  */
-    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource 
-                                     in milliseconds. NOTE: May not return a meaningful value 
-                                     until the entire file is parsed and buffered.  */  
-    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played 
-                                     in milliseconds */
-    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful 
-                                     value until the entire file is parsed and buffered. */
-    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently 
-                                     open MIDI resource. NOTE: May not return a meaningful value 
-                                     until the entire file is parsed and buffered.  */
-    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing 
-                                     MIDI resource. NOTE: May not return a meaningful value until 
-                                     the entire file is parsed and buffered. */
-    OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
-} OMX_AUDIO_CONFIG_MIDISTATUSTYPE;
-
-
-/** MIDI Meta Event structure one per Meta Event.
- *  MIDI Meta Events are like audio metadata, except that they are interspersed 
- *  with the MIDI content throughout the file and are not localized in the header. 
- *  As such, it is necessary to retrieve information about these Meta Events from 
- *  the engine, as it encounters these Meta Events within the MIDI content. 
- *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright, 
- *  author, default tempo, etc.) scattered throughout the file. 
- *  @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{ 
-    OMX_U32 nSize;            /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
-    OMX_U32 nIndex;           /**< Index of Meta Event */ 
-    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */ 
-    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
-    OMX_U32 nTrack;           /**< track number for the meta event */
-    OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
-} OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE; 
-
-
-/** MIDI Meta Event Data structure - one per Meta Event. 
- * @ingroup midi
- */ 
-typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{ 
-    OMX_U32 nSize;            /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
-    OMX_U32 nIndex;           /**< Index of Meta Event */ 
-    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
-    OMX_U8 nData[1];          /**< array of one or more bytes of meta data 
-                                   as indicated by the nMetaEventSize field */ 
-} OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE; 
-
-
-/** Audio Volume adjustment for a port */
-typedef struct OMX_AUDIO_CONFIG_VOLUMETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's volume.  Select the 
-                                     output port to adjust the master 
-                                     volume. */
-    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) 
-                                     or logarithmic scale (mB) */
-    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
-                                     Volume logarithmic setting for this port.  The values
-                                     for volume are in mB (millibels = 1/100 dB) relative
-                                     to a gain of 1 (e.g. the output is the same as the 
-                                     input level).  Values are in mB from nMax 
-                                     (maximum volume) to nMin mB (typically negative).
-                                     Since the volume is "voltage"
-                                     and not a "power", it takes a setting of
-                                     -600 mB to decrease the volume by 1/2.  If
-                                     a component cannot accurately set the 
-                                     volume to the requested value, it must
-                                     set the volume to the closest value BELOW
-                                     the requested value.  When getting the
-                                     volume setting, the current actual volume
-                                     must be returned. */
-} OMX_AUDIO_CONFIG_VOLUMETYPE;
-
-
-/** Audio Volume adjustment for a channel */
-typedef struct OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's volume.  Select the 
-                                     output port to adjust the master 
-                                     volume. */
-    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
-                                     using OMX_ALL to apply volume settings
-                                     to all channels */
-    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or 
-                                     logarithmic scale (mB) */
-    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
-                                     Volume logarithmic setting for this port.  
-                                     The values for volume are in mB 
-                                     (millibels = 1/100 dB) relative to a gain
-                                     of 1 (e.g. the output is the same as the 
-                                     input level).  Values are in mB from nMax 
-                                     (maximum volume) to nMin mB (typically negative).  
-                                     Since the volume is "voltage"
-                                     and not a "power", it takes a setting of
-                                     -600 mB to decrease the volume by 1/2.  If
-                                     a component cannot accurately set the 
-                                     volume to the requested value, it must
-                                     set the volume to the closest value BELOW
-                                     the requested value.  When getting the
-                                     volume setting, the current actual volume
-                                     must be returned. */
-    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
-                                     FALSE otherwise */
-} OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE;
-
-
-/** Audio balance setting */
-typedef struct OMX_AUDIO_CONFIG_BALANCETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's balance.  Select the 
-                                     output port to adjust the master 
-                                     balance. */
-    OMX_S32 nBalance;           /**< balance setting for this port 
-                                     (-100 to 100, where -100 indicates
-                                     all left, and no right */
-} OMX_AUDIO_CONFIG_BALANCETYPE;
-
-
-/** Audio Port mute */
-typedef struct OMX_AUDIO_CONFIG_MUTETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's mute.  Select the 
-                                     output port to adjust the master 
-                                     mute. */
-    OMX_BOOL bMute;             /**< Mute setting for this port */
-} OMX_AUDIO_CONFIG_MUTETYPE;
-
-
-/** Audio Channel mute */
-typedef struct OMX_AUDIO_CONFIG_CHANNELMUTETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
-                                     using OMX_ALL to apply mute settings
-                                     to all channels */
-    OMX_BOOL bMute;             /**< Mute setting for this channel */
-    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
-                                     FALSE otherwise */ 
-} OMX_AUDIO_CONFIG_CHANNELMUTETYPE;
-
-
-
-/** Enable / Disable for loudness control, which boosts bass and to a 
- *  smaller extent high end frequencies to compensate for hearing
- *  ability at the extreme ends of the audio spectrum
- */ 
-typedef struct OMX_AUDIO_CONFIG_LOUDNESSTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bLoudness;        /**< Enable/disable for loudness */
-} OMX_AUDIO_CONFIG_LOUDNESSTYPE;
-
-
-/** Enable / Disable for bass, which controls low frequencies
- */ 
-typedef struct OMX_AUDIO_CONFIG_BASSTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for bass control */
-    OMX_S32 nBass;             /**< bass setting for the port, as a 
-                                    continuous value from -100 to 100  
-                                    (0 means no change in bass level)*/
-} OMX_AUDIO_CONFIG_BASSTYPE;
-
-
-/** Enable / Disable for treble, which controls high frequencies tones
- */ 
-typedef struct OMX_AUDIO_CONFIG_TREBLETYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for treble control */
-    OMX_S32  nTreble;          /**< treble setting for the port, as a
-                                    continuous value from -100 to 100  
-                                    (0 means no change in treble level) */
-} OMX_AUDIO_CONFIG_TREBLETYPE;
-
-
-/** An equalizer is typically used for two reasons: to compensate for an 
- *  sub-optimal frequency response of a system to make it sound more natural 
- *  or to create intentionally some unnatural coloring to the sound to create
- *  an effect.
- *  @ingroup effects
- */
-typedef struct OMX_AUDIO_CONFIG_EQUALIZERTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
-    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is 
-                                    N-1, where N is the number of bands, lower limit is 0 */
-    OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
-                                    read only element and is used to determine 
-                                    the lower, center and upper frequency of 
-                                    this band.  */
-    OMX_BS32 sBandLevel;       /**< band level in millibels */
-} OMX_AUDIO_CONFIG_EQUALIZERTYPE;
-
-
-/** Stereo widening mode type 
- * @ingroup effects
- */ 
-typedef enum OMX_AUDIO_STEREOWIDENINGTYPE {
-    OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
-    OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
-    OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
-} OMX_AUDIO_STEREOWIDENINGTYPE;
-
-
-/** Control for stereo widening, which is a special 2-channel
- *  case of the audio virtualizer effect. For example, for 5.1-channel 
- *  output, it translates to virtual surround sound. 
- * @ingroup effects
- */ 
-typedef struct OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for stereo widening control */
-    OMX_AUDIO_STEREOWIDENINGTYPE eWideningType; /**< Stereo widening algorithm type */
-    OMX_U32  nStereoWidening;  /**< stereo widening setting for the port,
-                                    as a continuous value from 0 to 100  */
-} OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE;
-
-
-/** The chorus effect (or ``choralizer'') is any signal processor which makes
- *  one sound source (such as a voice) sound like many such sources singing 
- *  (or playing) in unison. Since performance in unison is never exact, chorus 
- *  effects simulate this by making independently modified copies of the input 
- *  signal. Modifications may include (1) delay, (2) frequency shift, and 
- *  (3) amplitude modulation.
- * @ingroup effects
- */
-typedef struct OMX_AUDIO_CONFIG_CHORUSTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for chorus */
-    OMX_BU32 sDelay;           /**< average delay in milliseconds */
-    OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
-    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of 
-                                    delay (i.e. 0 to 100) */
-    OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
-} OMX_AUDIO_CONFIG_CHORUSTYPE;
-
-
-/** Reverberation is part of the reflected sound that follows the early 
- *  reflections. In a typical room, this consists of a dense succession of 
- *  echoes whose energy decays exponentially. The reverberation effect structure 
- *  as defined here includes both (early) reflections as well as (late) reverberations. 
- * @ingroup effects
- */
-typedef struct OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
-    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect 
-                                       (i.e. both early reflections and late 
-                                       reverberation) in millibels */
-    OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
-                                       relative to the intensity at low
-                                       frequencies in millibels */
-    OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
-                                       (relative to room value), in millibels */
-    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative 
-                                       to the direct path, in milliseconds */
-    OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
-                                       relative to room level, in millibels */
-    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection 
-                                       to the beginning of the late reverberation 
-                                       section, in milliseconds */
-    OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
-                                       frequencies, in milliseconds */
-    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative 
-                                       to low frequency decay time in percent  */
-    OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
-                                       in percent (i.e. 0 - 100) */
-    OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
-                                       in percent (i.e. 0 - 100) */
-    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is 
-                                       the frequency used as the reference for all 
-                                       the high-frequency settings above */
-
-} OMX_AUDIO_CONFIG_REVERBERATIONTYPE;
-
-
-/** Possible settings for the Echo Cancelation structure to use 
- * @ingroup effects
- */
-typedef enum OMX_AUDIO_ECHOCANTYPE {
-   OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
-   OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation - 
-                                     echo from plastics and face */
-   OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for 
-                                     Hands Free operation */
-   OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for 
-                                     Car Kit (longer echo) */
-   OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
-} OMX_AUDIO_ECHOCANTYPE;
-
-
-/** Enable / Disable for echo cancelation, which removes undesired echo's
- *  from the audio
- * @ingroup effects
- */ 
-typedef struct OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_AUDIO_ECHOCANTYPE eEchoCancelation; /**< Echo cancelation settings */
-} OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE;
-
-
-/** Enable / Disable for noise reduction, which undesired noise from
- * the audio
- * @ingroup effects
- */ 
-typedef struct OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bNoiseReduction;  /**< Enable/disable for noise reduction */
-} OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE;
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
-
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_Audio.h - OpenMax IL version 1.1.2
+ *  The structures needed by Audio components to exchange
+ *  parameters and configuration data with the componenmilts.
+ */
+
+#ifndef OMX_Audio_h
+#define OMX_Audio_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Core.h>
+
+/** @defgroup midi MIDI
+ * @ingroup audio
+ */
+ 
+/** @defgroup effects Audio effects
+ * @ingroup audio
+ */
+
+/** @defgroup audio OpenMAX IL Audio Domain
+ * Structures for OpenMAX IL Audio domain
+ * @{
+ */
+
+/** Enumeration used to define the possible audio codings.  
+ *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must 
+ *  be done in a vendor specific way.  Since this is for an audio 
+ *  processing element this enum is relevant.  However, for another 
+ *  type of component other enums would be in this area.
+ */
+typedef enum OMX_AUDIO_CODINGTYPE {
+    OMX_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
+    OMX_AUDIO_CodingAutoDetect,  /**< auto detection of audio format */
+    OMX_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
+    OMX_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
+    OMX_AUDIO_CodingAMR,         /**< Any variant of AMR encoded data */
+    OMX_AUDIO_CodingGSMFR,       /**< Any variant of GSM fullrate (i.e. GSM610) */
+    OMX_AUDIO_CodingGSMEFR,      /**< Any variant of GSM Enhanced Fullrate encoded data*/
+    OMX_AUDIO_CodingGSMHR,       /**< Any variant of GSM Halfrate encoded data */
+    OMX_AUDIO_CodingPDCFR,       /**< Any variant of PDC Fullrate encoded data */
+    OMX_AUDIO_CodingPDCEFR,      /**< Any variant of PDC Enhanced Fullrate encoded data */
+    OMX_AUDIO_CodingPDCHR,       /**< Any variant of PDC Halfrate encoded data */
+    OMX_AUDIO_CodingTDMAFR,      /**< Any variant of TDMA Fullrate encoded data (TIA/EIA-136-420) */
+    OMX_AUDIO_CodingTDMAEFR,     /**< Any variant of TDMA Enhanced Fullrate encoded data (TIA/EIA-136-410) */
+    OMX_AUDIO_CodingQCELP8,      /**< Any variant of QCELP 8kbps encoded data */
+    OMX_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
+    OMX_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
+    OMX_AUDIO_CodingSMV,         /**< Any variant of SMV encoded data */
+    OMX_AUDIO_CodingG711,        /**< Any variant of G.711 encoded data */
+    OMX_AUDIO_CodingG723,        /**< Any variant of G.723 dot 1 encoded data */
+    OMX_AUDIO_CodingG726,        /**< Any variant of G.726 encoded data */
+    OMX_AUDIO_CodingG729,        /**< Any variant of G.729 encoded data */
+    OMX_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data */
+    OMX_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
+    OMX_AUDIO_CodingSBC,         /**< Any variant of SBC encoded data */
+    OMX_AUDIO_CodingVORBIS,      /**< Any variant of VORBIS encoded data */
+    OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
+    OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
+    OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
+    OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CodingMax = 0x7FFFFFFF
+} OMX_AUDIO_CODINGTYPE;
+
+
+/** The PortDefinition structure is used to define all of the parameters 
+ *  necessary for the compliant component to setup an input or an output audio 
+ *  path.  If additional information is needed to define the parameters of the
+ *  port (such as frequency), additional structures must be sent such as the
+ *  OMX_AUDIO_PARAM_PCMMODETYPE structure to supply the extra parameters for the port.
+ */
+typedef struct OMX_AUDIO_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;            /**< MIME type of data for the port */
+    OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
+                                               for an output device, 
+                                               otherwise this field is 0 */
+    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is 
+                                          supported by the OMX component */
+    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this 
+                                          port (e.g. PCM, AMR, MP3, etc) */
+} OMX_AUDIO_PORTDEFINITIONTYPE;
+
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct OMX_AUDIO_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_U32 nPortIndex;             /**< Indicates which port to set */
+    OMX_U32 nIndex;                 /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    OMX_AUDIO_CODINGTYPE eEncoding; /**< Type of data expected for this port (e.g. PCM, AMR, MP3, etc) */
+} OMX_AUDIO_PARAM_PORTFORMATTYPE;
+
+
+/** PCM mode type  */ 
+typedef enum OMX_AUDIO_PCMMODETYPE { 
+    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */ 
+    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */ 
+    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */ 
+    OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_PCMModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_PCMModeMax = 0x7FFFFFFF 
+} OMX_AUDIO_PCMMODETYPE; 
+
+
+typedef enum OMX_AUDIO_CHANNELTYPE {
+    OMX_AUDIO_ChannelNone = 0x0,    /**< Unused or empty */
+    OMX_AUDIO_ChannelLF   = 0x1,    /**< Left front */
+    OMX_AUDIO_ChannelRF   = 0x2,    /**< Right front */
+    OMX_AUDIO_ChannelCF   = 0x3,    /**< Center front */
+    OMX_AUDIO_ChannelLS   = 0x4,    /**< Left surround */
+    OMX_AUDIO_ChannelRS   = 0x5,    /**< Right surround */
+    OMX_AUDIO_ChannelLFE  = 0x6,    /**< Low frequency effects */
+    OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
+    OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
+    OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
+    OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_ChannelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_ChannelMax  = 0x7FFFFFFF 
+} OMX_AUDIO_CHANNELTYPE;
+
+#define OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
+#define OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */
+
+/** PCM format description */ 
+typedef struct OMX_AUDIO_PARAM_PCMMODETYPE { 
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
+    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */ 
+    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */ 
+    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */ 
+    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for 
+                                           non-interleaved data (e.g. block data) */ 
+    OMX_U32 nBitPerSample;            /**< Bit per sample */ 
+    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for 
+                                           variable or unknown sampling rate. */ 
+    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */ 
+    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */
+
+} OMX_AUDIO_PARAM_PCMMODETYPE; 
+
+
+/** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
+ * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC. 
+ */
+typedef enum OMX_AUDIO_CHANNELMODETYPE {
+    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those 
+                                          two channels changes accordingly to each channel information */
+    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between 
+                                           2 channels for higher compression gain */
+    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half 
+                                           the bitrate of the overall bitrate */
+    OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
+    OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_ChannelModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
+} OMX_AUDIO_CHANNELMODETYPE;
+
+
+typedef enum OMX_AUDIO_MP3STREAMFORMATTYPE {
+    OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MP3StreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_MP3STREAMFORMATTYPE;
+
+/** MP3 params */
+typedef struct OMX_AUDIO_PARAM_MP3TYPE {
+    OMX_U32 nSize;                 /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    OMX_U32 nChannels;             /**< Number of channels */
+    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+    OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;  /**< MP3 stream format */
+} OMX_AUDIO_PARAM_MP3TYPE;
+
+
+typedef enum OMX_AUDIO_AACSTREAMFORMATTYPE {
+    OMX_AUDIO_AACStreamFormatMP2ADTS = 0, /**< AAC Audio Data Transport Stream 2 format */
+    OMX_AUDIO_AACStreamFormatMP4ADTS,     /**< AAC Audio Data Transport Stream 4 format */
+    OMX_AUDIO_AACStreamFormatMP4LOAS,     /**< AAC Low Overhead Audio Stream format */
+    OMX_AUDIO_AACStreamFormatMP4LATM,     /**< AAC Low overhead Audio Transport Multiplex */
+    OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
+    OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
+    OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
+    OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AACStreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_AACSTREAMFORMATTYPE;
+
+
+/** AAC mode type.  Note that the term profile is used with the MPEG-2
+ * standard and the term object type and profile is used with MPEG-4 */
+typedef enum OMX_AUDIO_AACPROFILETYPE{
+  OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
+  OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
+  OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
+  OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
+  OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
+  OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
+  OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
+  OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
+  OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
+  OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
+  OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
+} OMX_AUDIO_AACPROFILETYPE;
+
+
+/** AAC tool usage (for nAACtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for encoder configuration and optional as decoder info output.
+ * For MP3, OMX_AUDIO_CHANNELMODETYPE is sufficient. */
+#define OMX_AUDIO_AACToolNone 0x00000000 /**< no AAC tools allowed (encoder config) or active (decoder info output) */
+#define OMX_AUDIO_AACToolMS   0x00000001 /**< MS: Mid/side joint coding tool allowed or active */
+#define OMX_AUDIO_AACToolIS   0x00000002 /**< IS: Intensity stereo tool allowed or active */
+#define OMX_AUDIO_AACToolTNS  0x00000004 /**< TNS: Temporal Noise Shaping tool allowed or active */
+#define OMX_AUDIO_AACToolPNS  0x00000008 /**< PNS: MPEG-4 Perceptual Noise substitution tool allowed or active */
+#define OMX_AUDIO_AACToolLTP  0x00000010 /**< LTP: MPEG-4 Long Term Prediction tool allowed or active */
+#define OMX_AUDIO_AACToolAll  0x7FFFFFFF /**< all AAC tools allowed or active (*/
+
+/** MPEG-4 AAC error resilience (ER) tool usage (for nAACERtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for ER encoder configuration and optional as decoder info output */
+#define OMX_AUDIO_AACERNone  0x00000000  /**< no AAC ER tools allowed/used */
+#define OMX_AUDIO_AACERVCB11 0x00000001  /**< VCB11: Virtual Code Books for AAC section data */
+#define OMX_AUDIO_AACERRVLC  0x00000002  /**< RVLC: Reversible Variable Length Coding */
+#define OMX_AUDIO_AACERHCR   0x00000004  /**< HCR: Huffman Codeword Reordering */
+#define OMX_AUDIO_AACERAll   0x7FFFFFFF  /**< all AAC ER tools allowed/used */
+
+
+/** AAC params */
+typedef struct OMX_AUDIO_PARAM_AACPROFILETYPE {
+    OMX_U32 nSize;                 /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< Port that this structure applies to */
+    OMX_U32 nChannels;             /**< Number of channels */
+    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    OMX_U32 nFrameLength;          /**< Frame length (in audio samples per channel) of the codec.
+                                        Can be 1024 or 960 (AAC-LC), 2048 (HE-AAC), 480 or 512 (AAC-LD).
+                                        Use 0 to let encoder decide */
+    OMX_U32 nAACtools;             /**< AAC tool usage */
+    OMX_U32 nAACERtools;           /**< MPEG-4 AAC error resilience tool usage */
+    OMX_AUDIO_AACPROFILETYPE eAACProfile;   /**< AAC profile enumeration */
+    OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat; /**< AAC stream format enumeration */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+} OMX_AUDIO_PARAM_AACPROFILETYPE;
+
+
+/** VORBIS params */
+typedef struct OMX_AUDIO_PARAM_VORBISTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nChannels;        /**< Number of channels */
+    OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
+                                   rate or unknown bit rates. Encoding is set to the
+                                   bitrate closest to specified  value (in bps) */
+    OMX_U32 nMinBitRate;      /**< Sets minimum bitrate (in bps). */
+    OMX_U32 nMaxBitRate;      /**< Sets maximum bitrate (in bps). */
+
+    OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
+                                   variable or unknown sampling rate. */
+    OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
+                                   limit the audio signal. Use 0 to let encoder decide */
+    OMX_S32 nQuality;		  /**< Sets encoding quality to n, between -1 (low) and 10 (high).
+                                   In the default mode of operation, teh quality level is 3.
+                                   Normal quality range is 0 - 10. */
+    OMX_BOOL bManaged;		  /**< Set  bitrate  management  mode. This turns off the
+                                   normal VBR encoding, but allows hard or soft bitrate
+                                   constraints to be enforced by the encoder. This mode can
+                                   be slower, and may also be lower quality. It is
+                                   primarily useful for streaming. */
+    OMX_BOOL bDownmix;		  /**< Downmix input from stereo to mono (has no effect on 
+                                   non-stereo streams). Useful for lower-bitrate encoding. */     
+} OMX_AUDIO_PARAM_VORBISTYPE;
+
+
+/** WMA Version */
+typedef enum OMX_AUDIO_WMAFORMATTYPE {
+  OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
+  OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
+  OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
+  OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
+  OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAFORMATTYPE;
+
+
+/** WMA Profile */
+typedef enum OMX_AUDIO_WMAPROFILETYPE {
+  OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
+  OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
+  OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
+  OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
+  OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAPROFILETYPE;
+
+
+/** WMA params */
+typedef struct OMX_AUDIO_PARAM_WMATYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U16 nChannels;        /**< Number of channels */
+    OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
+                                   rate or unknown bit rates */
+    OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
+	OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
+    OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
+    OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
+    OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
+    OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
+} OMX_AUDIO_PARAM_WMATYPE;
+
+/** 
+ * RealAudio format
+ */
+typedef enum OMX_AUDIO_RAFORMATTYPE {
+    OMX_AUDIO_RAFormatUnused = 0, /**< Format unused or unknown */
+    OMX_AUDIO_RA8,                /**< RealAudio 8 codec */
+    OMX_AUDIO_RA9,                /**< RealAudio 9 codec */
+    OMX_AUDIO_RA10_AAC,           /**< MPEG-4 AAC codec for bitrates of more than 128kbps */
+    OMX_AUDIO_RA10_CODEC,         /**< RealAudio codec for bitrates less than 128 kbps */
+    OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
+    OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
+    OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
+    OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_RAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_RAFORMATTYPE;
+
+/** RA (Real Audio) params */ 
+typedef struct OMX_AUDIO_PARAM_RATYPE { 
+    OMX_U32 nSize;              /**< Size of this structure, in Bytes */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;         /**< Port that this structure applies to */ 
+    OMX_U32 nChannels;          /**< Number of channels */ 
+    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */ 
+    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */ 
+    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */ 
+    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */ 
+    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */ 
+    OMX_U32 nNumRegions;        /**< is the number of regions value */ 
+    OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
+} OMX_AUDIO_PARAM_RATYPE; 
+
+
+/** SBC Allocation Method Type */
+typedef enum OMX_AUDIO_SBCALLOCMETHODTYPE {
+  OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
+  OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
+  OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
+} OMX_AUDIO_SBCALLOCMETHODTYPE;
+
+
+/** SBC params */
+typedef struct OMX_AUDIO_PARAM_SBCTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_U32 nChannels;         /**< Number of channels */
+    OMX_U32 nBitRate;          /**< Bit rate of the input data.  Use 0 for variable
+                                    rate or unknown bit rates */
+    OMX_U32 nSampleRate;       /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+    OMX_U32 nBlocks;           /**< Number of blocks */
+    OMX_U32 nSubbands;         /**< Number of subbands */
+    OMX_U32 nBitPool;          /**< Bitpool value */
+    OMX_BOOL bEnableBitrate;   /**< Use bitrate value instead of bitpool */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode; /**< Channel mode enumeration */
+    OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;   /**< SBC Allocation method type */
+} OMX_AUDIO_PARAM_SBCTYPE;
+
+
+/** ADPCM stream format parameters */ 
+typedef struct OMX_AUDIO_PARAM_ADPCMTYPE { 
+    OMX_U32 nSize;              /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
+                                     necessarily the same as the number of channels 
+                                     to be rendered. */ 
+    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */ 
+    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for 
+                                    variable or unknown sampling rate. */ 
+} OMX_AUDIO_PARAM_ADPCMTYPE; 
+
+
+/** G723 rate */
+typedef enum OMX_AUDIO_G723RATE {
+    OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
+    OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
+    OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
+    OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G723ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
+} OMX_AUDIO_G723RATE;
+
+
+/** G723 - Sample rate must be 8 KHz */
+typedef struct OMX_AUDIO_PARAM_G723TYPE { 
+    OMX_U32 nSize;                /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */ 
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not 
+                                       necessarily the same as the number of channels 
+                                       to be rendered. */ 
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */ 
+    OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */ 
+    OMX_BOOL bPostFilter;         /**< Enable Post Filter */ 
+} OMX_AUDIO_PARAM_G723TYPE; 
+
+
+/** ITU G726 (ADPCM) rate */
+typedef enum OMX_AUDIO_G726MODE {
+    OMX_AUDIO_G726ModeUnused = 0,  /**< G726 Mode unused / unknown */
+    OMX_AUDIO_G726Mode16,          /**< 16 kbps */
+    OMX_AUDIO_G726Mode24,          /**< 24 kbps */
+    OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
+    OMX_AUDIO_G726Mode40,          /**< 40 kbps */
+    OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G726ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
+} OMX_AUDIO_G726MODE;
+
+
+/** G.726 stream format parameters - must be at 8KHz */ 
+typedef struct OMX_AUDIO_PARAM_G726TYPE { 
+    OMX_U32 nSize;              /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
+                                     necessarily the same as the number of channels 
+                                     to be rendered. */ 
+     OMX_AUDIO_G726MODE eG726Mode;
+} OMX_AUDIO_PARAM_G726TYPE; 
+
+
+/** G729 coder type */
+typedef enum OMX_AUDIO_G729TYPE {
+    OMX_AUDIO_G729 = 0,           /**< ITU G.729  encoded data */
+    OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
+    OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
+    OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
+    OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G729VendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G729Max = 0x7FFFFFFF
+} OMX_AUDIO_G729TYPE;
+
+
+/** G729 stream format parameters - fixed 6KHz sample rate */
+typedef struct OMX_AUDIO_PARAM_G729TYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nChannels;        /**< Number of channels in the data stream (not
+                                   necessarily the same as the number of channels
+                                   to be rendered. */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_AUDIO_G729TYPE eBitType;
+} OMX_AUDIO_PARAM_G729TYPE;
+
+
+/** AMR Frame format */ 
+typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE { 
+    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance 
+                                                   (Standard) Format */ 
+    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface 
+                                                   Format 1 */ 
+    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface 
+                                                   Format 2*/ 
+    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage 
+                                                   Format */ 
+    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time 
+                                                   Transport Protocol Payload Format */ 
+    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */ 
+    OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRFrameFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF 
+} OMX_AUDIO_AMRFRAMEFORMATTYPE; 
+
+
+/** AMR band mode */
+typedef enum OMX_AUDIO_AMRBANDMODETYPE {
+    OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
+    OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
+    OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
+    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */ 
+    OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
+    OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
+    OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
+    OMX_AUDIO_AMRBandModeNB6,                 /**< AMRNB Mode 6 = 10200 bps */
+    OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
+    OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
+    OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
+    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */ 
+    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */ 
+    OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
+    OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
+    OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
+    OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
+    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */      
+    OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRBandModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
+} OMX_AUDIO_AMRBANDMODETYPE;
+     
+
+/** AMR Discontinuous Transmission mode */ 
+typedef enum OMX_AUDIO_AMRDTXMODETYPE { 
+    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */ 
+    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using 
+                                             Voice Activity Detector 1 (VAD1) is enabled */ 
+    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using 
+                                             Voice Activity Detector 2 (VAD2) is enabled */       
+    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between 
+                                             Off, VAD1 or VAD2 modes */ 
+
+    OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */
+
+    OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRDTXModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF 
+} OMX_AUDIO_AMRDTXMODETYPE; 
+ 
+
+/** AMR params */
+typedef struct OMX_AUDIO_PARAM_AMRTYPE {
+    OMX_U32 nSize;                          /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;               /**< OMX specification version information */
+    OMX_U32 nPortIndex;                     /**< port that this structure applies to */
+    OMX_U32 nChannels;                      /**< Number of channels */
+    OMX_U32 nBitRate;                       /**< Bit rate read only field */
+    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */ 
+    OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
+    OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
+} OMX_AUDIO_PARAM_AMRTYPE;
+
+
+/** GSM_FR (ETSI 06.10, 3GPP 46.010) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMFRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMFRTYPE;
+
+
+/** GSM-HR (ETSI 06.20, 3GPP 46.020) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMHRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMHRTYPE;
+
+
+/** GSM-EFR (ETSI 06.60, 3GPP 46.060) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMEFRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMEFRTYPE;
+
+
+/** TDMA FR (TIA/EIA-136-420, VSELP 7.95kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_TDMAFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_TDMAFRTYPE;
+
+
+/** TDMA EFR (TIA/EIA-136-410, ACELP 7.4kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_TDMAEFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_TDMAEFRTYPE;
+
+
+/** PDC FR ( RCR-27, VSELP 6.7kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCFRTYPE;
+
+
+/** PDC EFR ( RCR-27, ACELP 6.7kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCEFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCEFRTYPE;
+
+/** PDC HR ( RCR-27, PSI-CELP 3.45kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCHRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCHRTYPE;
+
+
+/** CDMA Rate types */
+typedef enum OMX_AUDIO_CDMARATETYPE {
+    OMX_AUDIO_CDMARateBlank = 0,          /**< CDMA encoded frame is blank */
+    OMX_AUDIO_CDMARateFull,               /**< CDMA encoded frame in full rate */
+    OMX_AUDIO_CDMARateHalf,               /**< CDMA encoded frame in half rate */
+    OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
+    OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
+    OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
+    OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_CDMARateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
+} OMX_AUDIO_CDMARATETYPE;
+
+
+/** QCELP8 (TIA/EIA-96, up to 8kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_QCELP8TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_U32 nBitRate;             /**< Bit rate of the input data.  Use 0 for variable
+                                       rate or unknown bit rates */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} OMX_AUDIO_PARAM_QCELP8TYPE;
+
+
+/** QCELP13 ( CDMA, EIA/TIA-733, 13.3kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_QCELP13TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} OMX_AUDIO_PARAM_QCELP13TYPE;
+
+
+/** EVRC ( CDMA, EIA/TIA-127, RCELP up to 8.55kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_EVRCTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< actual Frame rate */
+    OMX_BOOL bRATE_REDUCon;       /**< RATE_REDUCtion is requested for this frame */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter */
+    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter */
+} OMX_AUDIO_PARAM_EVRCTYPE;
+
+
+/** SMV ( up to 8.55kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_SMVTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_BOOL bRATE_REDUCon;           /**< RATE_REDUCtion is requested for this frame */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 ??*/
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 ??*/
+    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter ??*/
+    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter ??*/
+} OMX_AUDIO_PARAM_SMVTYPE;
+
+
+/** MIDI Format 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDIFORMATTYPE
+{
+    OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
+    OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
+    OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
+    OMX_AUDIO_MIDIFormatSMF2,        /**< Standard MIDI File Type 2 */
+    OMX_AUDIO_MIDIFormatSPMIDI,      /**< SP-MIDI */
+    OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
+    OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
+    OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
+    OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MIDIFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDIFORMATTYPE;
+
+
+/** MIDI params 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_PARAM_MIDITYPE {
+    OMX_U32 nSize;                 /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire 
+                                        MIDI file passed in, otherwise if 0x0, the MIDI data 
+                                        is merged and streamed (instead of passed as an 
+                                        entire MIDI file) */
+    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
+                                        voices. A value of zero indicates that the default 
+                                        polyphony of the device is used  */                                    
+    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound 
+                                        bank at initialization */
+    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */                                                                           
+} OMX_AUDIO_PARAM_MIDITYPE;
+
+
+/** Type of the MIDI sound bank 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDISOUNDBANKTYPE {
+    OMX_AUDIO_MIDISoundBankUnused = 0,           /**< unused/unknown soundbank type */
+    OMX_AUDIO_MIDISoundBankDLS1,                 /**< DLS version 1 */
+    OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
+    OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
+    OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
+    OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MIDISoundBankVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDISOUNDBANKTYPE;
+
+
+/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
+   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
+   OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
+   OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
+   OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
+   OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;
+
+
+/** MIDI params to load/unload user soundbank 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nDLSIndex;        /**< DLS file index to be loaded */
+    OMX_U32 nDLSSize;         /**< Size in bytes */
+    OMX_PTR pDLSData;         /**< Pointer to DLS file data */
+    OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;   /**< Midi sound bank type enumeration */
+    OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout; /**< Midi sound bank layout enumeration */
+} OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;
+
+
+/** Structure for Live MIDI events and MIP messages. 
+ * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.) 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
+    OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
+                                   array for the MIP message buffer, where the size is 
+                                   indicated by nMidiEventSize */
+} OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;
+
+
+/** MIDI sound bank/ program pair in a given channel 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
+    OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
+    OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
+    OMX_U16 nIDSoundBank;       /**< Sound bank ID */
+    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks 
+                                     by index if multiple banks are present */
+} OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;
+
+
+/** MIDI control 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10 
+                                       format based on JAVA MMAPI (JSR-135) requirement */
+    OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
+                                       number based on JSR-135 requirement */
+    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10 
+                                       fixed-point number based on JSR-135 requirement */
+    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
+                                       voices. A value of zero indicates that the default 
+                                       polyphony of the device is used  */
+    OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
+    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback 
+                                       will stop automatically.  Set to zero if not used */
+    OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
+    OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
+    OMX_U32 nTrack0031MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 0-31 */
+    OMX_U32 nTrack3263MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 32-63 */
+    OMX_U32 nTrack0031SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 0-31 */
+    OMX_U32 nTrack3263SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 32-63 */
+
+} OMX_AUDIO_CONFIG_MIDICONTROLTYPE;
+
+
+/** MIDI Playback States 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
+  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to 
+  													other defined states */
+  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open. 
+                                                    The MIDI engine is currently processing 
+                                                    MIDI events. */
+  OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being 
+                                                    primed. The MIDI engine is currently 
+                                                    processing MIDI events. */
+  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but 
+                                                    not playing. The MIDI engine is currently
+                                                    processing MIDI events. The transition to
+                                                    this state is only possible from the 
+                                                    OMX_AUDIO_MIDIPlayBackStatePlaying state,
+                                                    when the 'playback head' reaches the end
+                                                    of media data or the playback stops due
+                                                    to stop time set.*/
+  OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
+                                                    playing. The MIDI engine is currently
+                                                    processing MIDI events.*/
+  OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
+                                                    resource constraints */
+  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
+                                                    SP-MIDI content constraints, there is
+                                                    no audible MIDI content during playback
+                                                    currently. The situation may change if
+                                                    resources are freed later.*/
+  OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDIPLAYBACKSTATETYPE;
+
+
+/** MIDI status 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field. 
+                                     NOTE: May not return a meaningful value until the entire 
+                                     file is parsed and buffered.  */
+    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource 
+                                     in milliseconds. NOTE: May not return a meaningful value 
+                                     until the entire file is parsed and buffered.  */  
+    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played 
+                                     in milliseconds */
+    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful 
+                                     value until the entire file is parsed and buffered. */
+    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently 
+                                     open MIDI resource. NOTE: May not return a meaningful value 
+                                     until the entire file is parsed and buffered.  */
+    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing 
+                                     MIDI resource. NOTE: May not return a meaningful value until 
+                                     the entire file is parsed and buffered. */
+    OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
+} OMX_AUDIO_CONFIG_MIDISTATUSTYPE;
+
+
+/** MIDI Meta Event structure one per Meta Event.
+ *  MIDI Meta Events are like audio metadata, except that they are interspersed 
+ *  with the MIDI content throughout the file and are not localized in the header. 
+ *  As such, it is necessary to retrieve information about these Meta Events from 
+ *  the engine, as it encounters these Meta Events within the MIDI content. 
+ *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright, 
+ *  author, default tempo, etc.) scattered throughout the file. 
+ *  @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{ 
+    OMX_U32 nSize;            /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
+    OMX_U32 nIndex;           /**< Index of Meta Event */ 
+    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */ 
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
+    OMX_U32 nTrack;           /**< track number for the meta event */
+    OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
+} OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE; 
+
+
+/** MIDI Meta Event Data structure - one per Meta Event. 
+ * @ingroup midi
+ */ 
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{ 
+    OMX_U32 nSize;            /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
+    OMX_U32 nIndex;           /**< Index of Meta Event */ 
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
+    OMX_U8 nData[1];          /**< array of one or more bytes of meta data 
+                                   as indicated by the nMetaEventSize field */ 
+} OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE; 
+
+
+/** Audio Volume adjustment for a port */
+typedef struct OMX_AUDIO_CONFIG_VOLUMETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's volume.  Select the 
+                                     output port to adjust the master 
+                                     volume. */
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) 
+                                     or logarithmic scale (mB) */
+    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.  The values
+                                     for volume are in mB (millibels = 1/100 dB) relative
+                                     to a gain of 1 (e.g. the output is the same as the 
+                                     input level).  Values are in mB from nMax 
+                                     (maximum volume) to nMin mB (typically negative).
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the 
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+} OMX_AUDIO_CONFIG_VOLUMETYPE;
+
+
+/** Audio Volume adjustment for a channel */
+typedef struct OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's volume.  Select the 
+                                     output port to adjust the master 
+                                     volume. */
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
+                                     using OMX_ALL to apply volume settings
+                                     to all channels */
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or 
+                                     logarithmic scale (mB) */
+    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.  
+                                     The values for volume are in mB 
+                                     (millibels = 1/100 dB) relative to a gain
+                                     of 1 (e.g. the output is the same as the 
+                                     input level).  Values are in mB from nMax 
+                                     (maximum volume) to nMin mB (typically negative).  
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the 
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */
+} OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE;
+
+
+/** Audio balance setting */
+typedef struct OMX_AUDIO_CONFIG_BALANCETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's balance.  Select the 
+                                     output port to adjust the master 
+                                     balance. */
+    OMX_S32 nBalance;           /**< balance setting for this port 
+                                     (-100 to 100, where -100 indicates
+                                     all left, and no right */
+} OMX_AUDIO_CONFIG_BALANCETYPE;
+
+
+/** Audio Port mute */
+typedef struct OMX_AUDIO_CONFIG_MUTETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's mute.  Select the 
+                                     output port to adjust the master 
+                                     mute. */
+    OMX_BOOL bMute;             /**< Mute setting for this port */
+} OMX_AUDIO_CONFIG_MUTETYPE;
+
+
+/** Audio Channel mute */
+typedef struct OMX_AUDIO_CONFIG_CHANNELMUTETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
+                                     using OMX_ALL to apply mute settings
+                                     to all channels */
+    OMX_BOOL bMute;             /**< Mute setting for this channel */
+    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */ 
+} OMX_AUDIO_CONFIG_CHANNELMUTETYPE;
+
+
+
+/** Enable / Disable for loudness control, which boosts bass and to a 
+ *  smaller extent high end frequencies to compensate for hearing
+ *  ability at the extreme ends of the audio spectrum
+ */ 
+typedef struct OMX_AUDIO_CONFIG_LOUDNESSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bLoudness;        /**< Enable/disable for loudness */
+} OMX_AUDIO_CONFIG_LOUDNESSTYPE;
+
+
+/** Enable / Disable for bass, which controls low frequencies
+ */ 
+typedef struct OMX_AUDIO_CONFIG_BASSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for bass control */
+    OMX_S32 nBass;             /**< bass setting for the port, as a 
+                                    continuous value from -100 to 100  
+                                    (0 means no change in bass level)*/
+} OMX_AUDIO_CONFIG_BASSTYPE;
+
+
+/** Enable / Disable for treble, which controls high frequencies tones
+ */ 
+typedef struct OMX_AUDIO_CONFIG_TREBLETYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for treble control */
+    OMX_S32  nTreble;          /**< treble setting for the port, as a
+                                    continuous value from -100 to 100  
+                                    (0 means no change in treble level) */
+} OMX_AUDIO_CONFIG_TREBLETYPE;
+
+
+/** An equalizer is typically used for two reasons: to compensate for an 
+ *  sub-optimal frequency response of a system to make it sound more natural 
+ *  or to create intentionally some unnatural coloring to the sound to create
+ *  an effect.
+ *  @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_EQUALIZERTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
+    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is 
+                                    N-1, where N is the number of bands, lower limit is 0 */
+    OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
+                                    read only element and is used to determine 
+                                    the lower, center and upper frequency of 
+                                    this band.  */
+    OMX_BS32 sBandLevel;       /**< band level in millibels */
+} OMX_AUDIO_CONFIG_EQUALIZERTYPE;
+
+
+/** Stereo widening mode type 
+ * @ingroup effects
+ */ 
+typedef enum OMX_AUDIO_STEREOWIDENINGTYPE {
+    OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
+    OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
+    OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_StereoWideningVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
+} OMX_AUDIO_STEREOWIDENINGTYPE;
+
+
+/** Control for stereo widening, which is a special 2-channel
+ *  case of the audio virtualizer effect. For example, for 5.1-channel 
+ *  output, it translates to virtual surround sound. 
+ * @ingroup effects
+ */ 
+typedef struct OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for stereo widening control */
+    OMX_AUDIO_STEREOWIDENINGTYPE eWideningType; /**< Stereo widening algorithm type */
+    OMX_U32  nStereoWidening;  /**< stereo widening setting for the port,
+                                    as a continuous value from 0 to 100  */
+} OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE;
+
+
+/** The chorus effect (or ``choralizer'') is any signal processor which makes
+ *  one sound source (such as a voice) sound like many such sources singing 
+ *  (or playing) in unison. Since performance in unison is never exact, chorus 
+ *  effects simulate this by making independently modified copies of the input 
+ *  signal. Modifications may include (1) delay, (2) frequency shift, and 
+ *  (3) amplitude modulation.
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_CHORUSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for chorus */
+    OMX_BU32 sDelay;           /**< average delay in milliseconds */
+    OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
+    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of 
+                                    delay (i.e. 0 to 100) */
+    OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
+} OMX_AUDIO_CONFIG_CHORUSTYPE;
+
+
+/** Reverberation is part of the reflected sound that follows the early 
+ *  reflections. In a typical room, this consists of a dense succession of 
+ *  echoes whose energy decays exponentially. The reverberation effect structure 
+ *  as defined here includes both (early) reflections as well as (late) reverberations. 
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
+    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect 
+                                       (i.e. both early reflections and late 
+                                       reverberation) in millibels */
+    OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
+                                       relative to the intensity at low
+                                       frequencies in millibels */
+    OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
+                                       (relative to room value), in millibels */
+    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative 
+                                       to the direct path, in milliseconds */
+    OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
+                                       relative to room level, in millibels */
+    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection 
+                                       to the beginning of the late reverberation 
+                                       section, in milliseconds */
+    OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
+                                       frequencies, in milliseconds */
+    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative 
+                                       to low frequency decay time in percent  */
+    OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is 
+                                       the frequency used as the reference for all 
+                                       the high-frequency settings above */
+
+} OMX_AUDIO_CONFIG_REVERBERATIONTYPE;
+
+
+/** Possible settings for the Echo Cancelation structure to use 
+ * @ingroup effects
+ */
+typedef enum OMX_AUDIO_ECHOCANTYPE {
+   OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
+   OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation - 
+                                     echo from plastics and face */
+   OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for 
+                                     Hands Free operation */
+   OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for 
+                                     Car Kit (longer echo) */
+   OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
+} OMX_AUDIO_ECHOCANTYPE;
+
+
+/** Enable / Disable for echo cancelation, which removes undesired echo's
+ *  from the audio
+ * @ingroup effects
+ */ 
+typedef struct OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_AUDIO_ECHOCANTYPE eEchoCancelation; /**< Echo cancelation settings */
+} OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE;
+
+
+/** Enable / Disable for noise reduction, which undesired noise from
+ * the audio
+ * @ingroup effects
+ */ 
+typedef struct OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bNoiseReduction;  /**< Enable/disable for noise reduction */
+} OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/omx/headers/OMX_Component.h b/omx/headers/OMX_Component.h
index 7f3ea77..d595640 100644
--- a/omx/headers/OMX_Component.h
+++ b/omx/headers/OMX_Component.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007 The Khronos Group Inc. 
+ * Copyright (c) 2008 The Khronos Group Inc. 
  * 
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
@@ -21,7 +21,7 @@
  *
  */
 
-/** OMX_Component.h - OpenMax IL version 1.1.1
+/** OMX_Component.h - OpenMax IL version 1.1.2
  *  The OMX_Component header file contains the definitions used to define
  *  the public interface of a component.  This header file is intended to
  *  be used by both the application and the component.
@@ -52,6 +52,8 @@ typedef enum OMX_PORTDOMAINTYPE {
     OMX_PortDomainVideo, 
     OMX_PortDomainImage, 
     OMX_PortDomainOther,
+    OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_PortDomainVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_PortDomainMax = 0x7ffffff
 } OMX_PORTDOMAINTYPE;
 
@@ -95,6 +97,8 @@ typedef struct OMX_PARAM_U32TYPE {
 typedef enum OMX_SUSPENSIONPOLICYTYPE {
     OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
     OMX_SuspensionEnabled,  /**< Suspension allowed */   
+    OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_SuspensionPolicyMax = 0x7fffffff
 } OMX_SUSPENSIONPOLICYTYPE;
 
@@ -109,6 +113,8 @@ typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
 typedef enum OMX_SUSPENSIONTYPE {
     OMX_NotSuspended, /**< component is not suspended */
     OMX_Suspended,    /**< component is suspended */
+    OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_SuspendMax = 0x7FFFFFFF
 } OMX_SUSPENSIONTYPE;
 
@@ -191,6 +197,8 @@ typedef enum OMX_METADATACHARSETTYPE {
     OMX_MetadataCharsetISO2022JP1,
     OMX_MetadataCharsetISOEUCJP,
     OMX_MetadataCharsetSMS7Bit,
+    OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataCharsetVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
 } OMX_METADATACHARSETTYPE;
 
@@ -201,6 +209,8 @@ typedef enum OMX_METADATASCOPETYPE
     OMX_MetadataScopeTopLevel,
     OMX_MetadataScopePortLevel,
     OMX_MetadataScopeNodeLevel,
+    OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataScopeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_MetadataScopeTypeMax = 0x7fffffff
 } OMX_METADATASCOPETYPE;
 
@@ -210,6 +220,8 @@ typedef enum OMX_METADATASEARCHMODETYPE
     OMX_MetadataSearchValueSizeByIndex,
     OMX_MetadataSearchItemByIndex,
     OMX_MetadataSearchNextItemByKey,
+    OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_MetadataSearchTypeMax = 0x7fffffff
 } OMX_METADATASEARCHMODETYPE;
 /** @ingroup metadata */
@@ -448,7 +460,7 @@ typedef struct OMX_COMPONENTTYPE
             provided by the component with the output port.
         @return OMX_ERRORTYPE
             If the command successfully executes, the return code will be
-            OMX_NoError.  Otherwise the appropriate OMX error will be returned.
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
         @ingroup tun
     */
 
@@ -523,7 +535,7 @@ typedef struct OMX_COMPONENTTYPE
             to determine the context of the call
         @return OMX_ERRORTYPE
             If the command successfully executes, the return code will be
-            OMX_NoError.  Otherwise the appropriate OMX error will be returned.
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
      */
     OMX_ERRORTYPE (*SetCallbacks)(
             OMX_IN  OMX_HANDLETYPE hComponent,
@@ -539,7 +551,7 @@ typedef struct OMX_COMPONENTTYPE
             handle returned by the call to the GetHandle function.
         @return OMX_ERRORTYPE
             If the command successfully executes, the return code will be
-            OMX_NoError.  Otherwise the appropriate OMX error will be returned.
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
      */
     OMX_ERRORTYPE (*ComponentDeInit)(
             OMX_IN  OMX_HANDLETYPE hComponent);
diff --git a/omx/headers/OMX_ContentPipe.h b/omx/headers/OMX_ContentPipe.h
index fe7c965..5f6310c 100644
--- a/omx/headers/OMX_ContentPipe.h
+++ b/omx/headers/OMX_ContentPipe.h
@@ -1,202 +1,195 @@
-/*
- * Copyright (c) 2007 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** OMX_ContentPipe.h - OpenMax IL version 1.1.1
- *  The OMX_ContentPipe header file contains the definitions used to define
- *  the public interface for content piples.  This header file is intended to
- *  be used by the component.
- */
-
-#ifndef OMX_CONTENTPIPE_H
-#define OMX_CONTENTPIPE_H
-
-#ifndef KD_EACCES
-/* OpenKODE error codes. CPResult values may be zero (indicating success
-   or one of the following values) */
-#define KD_EACCES (13)
-#define KD_EADDRINUSE (98)
-#define KD_EAGAIN (11)
-#define KD_EBADF (9)
-#define KD_EBUSY (16)
-#define KD_ECANCELED (125)
-#define KD_ECONNABORTED (103)
-#define KD_ECONNREFUSED (111)
-#define KD_ECONNRESET (104)
-#define KD_EDEADLK (35)
-#define KD_EDESTADDRREQ (89)
-#define KD_EDOM (33)
-#define KD_ERANGE (34)
-#define KD_EEXIST (17)
-#define KD_EFAULT (14)
-#define KD_EFBIG (27)
-#define KD_EHOSTUNREACH (113)
-#define KD_EINPROGRESS (115)
-#define KD_EINTR (4)
-#define KD_EINVAL (22)
-#define KD_EIO (5)
-#define KD_EISCONN (106)
-#define KD_EISDIR (21)
-#define KD_EMFILE (24)
-#define KD_ENAMETOOLONG (36)
-#define KD_ENETDOWN (100)
-#define KD_ENETRESET (102)
-#define KD_ENETUNREACH (101)
-#define KD_ENOBUFS (105)
-#define KD_ENOENT (2)
-#define KD_ENOMEM (12)
-#define KD_ENOSPC (28)
-#define KD_ENOSYS (28)
-#define KD_ENOTCONN (107)
-#define KD_ENOTDIR (20)
-#define KD_ENOTEMPTY (39)
-#define KD_ENOTSOCK (88)
-#define KD_ENOTSUP (95)
-#define KD_EPERM (1)
-#define KD_EPROTO (71)
-#define KD_ETIMEDOUT (110)
-#define KD_EILSEQ (84)
-#endif
-
-/** Map types from OMX standard types only here so interface is as generic as possible. */
-typedef OMX_U32    CPresult;
-typedef char *     CPstring;  
-typedef void *     CPhandle;
-typedef OMX_U32    CPuint;
-typedef OMX_S32    CPint;  
-typedef char       CPbyte;  
-typedef OMX_BOOL   CPbool;
-
-/** enumeration of origin types used in the CP_PIPETYPE's Seek function 
- * @ingroup cp
- */
-typedef enum CP_ORIGINTYPE {
-    CP_OriginBegin,      
-    CP_OriginCur,      
-    CP_OriginEnd,      
-    CP_OriginMax = 0X7FFFFFFF
-} CP_ORIGINTYPE;
-
-/** enumeration of contact access types used in the CP_PIPETYPE's Open function 
- * @ingroup cp
- */
-typedef enum CP_ACCESSTYPE {
-    CP_AccessRead,      
-    CP_AccessWrite,  
-    CP_AccessReadWrite ,  
-    CP_AccessMax = 0X7FFFFFFF
-} CP_ACCESSTYPE;
-
-/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function 
- * @ingroup cp
- */
-typedef enum CP_CHECKBYTESRESULTTYPE
-{
-    CP_CheckBytesOk,                    /**< There are at least the request number 
-                                              of bytes available */
-    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes 
-                                              and presently lacks sufficient bytes. 
-                                              Client will be called when they are 
-                                              sufficient bytes are available. */
-    CP_CheckBytesInsufficientBytes  ,     /**< The pipe has retrieved all bytes 
-                                              but those available are less than those 
-                                              requested */
-    CP_CheckBytesAtEndOfStream,         /**< The pipe has reached the end of stream
-                                              and no more bytes are available. */
-    CP_CheckBytesOutOfBuffers,          /**< All read/write buffers are currently in use. */
-    CP_CheckBytesMax = 0X7FFFFFFF
-} CP_CHECKBYTESRESULTTYPE;
-
-/** enumeration of content pipe events sent to the client callback. 
- * @ingroup cp
- */
-typedef enum CP_EVENTTYPE{
-    CP_BytesAvailable,      	    /** bytes requested in a CheckAvailableBytes call are now available*/
-    CP_Overflow,  		           /** enumeration of content pipe events sent to the client callback*/
-    CP_PipeDisconnected  ,  		    /** enumeration of content pipe events sent to the client callback*/
-    CP_EventMax = 0X7FFFFFFF
-} CP_EVENTTYPE;
-
-/** content pipe definition 
- * @ingroup cp
- */
-typedef struct CP_PIPETYPE
-{
-    /** Open a content stream for reading or writing. */ 
-    CPresult (*Open)( CPhandle* hContent, CPstring szURI, CP_ACCESSTYPE eAccess );
-
-    /** Close a content stream. */ 
-    CPresult (*Close)( CPhandle hContent );
-
-    /** Create a content source and open it for writing. */ 
-    CPresult (*Create)( CPhandle *hContent, CPstring szURI );
-
-    /** Check the that specified number of bytes are available for reading or writing (depending on access type).*/
-    CPresult (*CheckAvailableBytes)( CPhandle hContent, CPuint nBytesRequested, CP_CHECKBYTESRESULTTYPE *eResult );
-
-    /** Seek to certain position in the content relative to the specified origin. */
-    CPresult (*SetPosition)( CPhandle  hContent, CPint nOffset, CP_ORIGINTYPE eOrigin);
-
-    /** Retrieve the current position relative to the start of the content. */
-    CPresult (*GetPosition)( CPhandle hContent, CPuint *pPosition);
-
-    /** Retrieve data of the specified size from the content stream (advance content pointer by size of data).
-       Note: pipe client provides pointer. This function is appropriate for small high frequency reads. */
-    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize); 
-
-    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes. 
-       Buffer contains the next block of bytes, as specified by nSize, of the content. nSize also
-       returns the size of the block actually read. Content pointer advances the by the returned size. 
-       Note: pipe provides pointer. This function is appropriate for large reads. The client must call 
-       ReleaseReadBuffer when done with buffer. 
-
-       In some cases the requested block may not reside in contiguous memory within the
-       pipe implementation. For instance if the pipe leverages a circular buffer then the requested 
-       block may straddle the boundary of the circular buffer. By default a pipe implementation 
-       performs a copy in this case to provide the block to the pipe client in one contiguous buffer.
-       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory 
-       boundary. Here the client may retrieve the data in segments over successive calls. */
-    CPresult (*ReadBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint *nSize, CPbool bForbidCopy);
-
-    /** Release a buffer obtained by ReadBuffer back to the pipe. */
-    CPresult (*ReleaseReadBuffer)(CPhandle hContent, CPbyte *pBuffer);
-
-    /** Write data of the specified size to the content (advance content pointer by size of data).
-       Note: pipe client provides pointer. This function is appropriate for small high frequency writes. */
-    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize); 
-
-    /** Retrieve a buffer allocated by the pipe used to write data to the content. 
-       Client will fill buffer with output data. Note: pipe provides pointer. This function is appropriate
-       for large writes. The client must call WriteBuffer when done it has filled the buffer with data.*/
-    CPresult (*GetWriteBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint nSize);
-
-    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the 
-       the contents of the buffer to content and advance content pointer by the size of the buffer */
-    CPresult (*WriteBuffer)( CPhandle hContent, CPbyte *pBuffer, CPuint nFilledSize);
-
-    /** Register a per-handle client callback with the content pipe. */
-    CPresult (*RegisterCallback)( CPhandle hContent, CPresult (*ClientCallback)(CP_EVENTTYPE eEvent, CPuint iParam));
-
-} CP_PIPETYPE;
-
-#endif
-
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_ContentPipe.h - OpenMax IL version 1.1.2
+ *  The OMX_ContentPipe header file contains the definitions used to define
+ *  the public interface for content piples.  This header file is intended to
+ *  be used by the component.
+ */
+
+#ifndef OMX_CONTENTPIPE_H
+#define OMX_CONTENTPIPE_H
+
+#ifndef KD_EACCES
+/* OpenKODE error codes. CPResult values may be zero (indicating success
+   or one of the following values) */
+#define KD_EACCES (1)
+#define KD_EADDRINUSE (2)
+#define KD_EAGAIN (5)
+#define KD_EBADF (7)
+#define KD_EBUSY (8)
+#define KD_ECONNREFUSED (9)
+#define KD_ECONNRESET (10)
+#define KD_EDEADLK (11)
+#define KD_EDESTADDRREQ (12)
+#define KD_ERANGE (35)
+#define KD_EEXIST (13)
+#define KD_EFBIG (14)
+#define KD_EHOSTUNREACH (15)
+#define KD_EINVAL (17)
+#define KD_EIO (18)
+#define KD_EISCONN (20)
+#define KD_EISDIR (21)
+#define KD_EMFILE (22)
+#define KD_ENAMETOOLONG (23)
+#define KD_ENOENT (24)
+#define KD_ENOMEM (25)
+#define KD_ENOSPC (26)
+#define KD_ENOSYS (27)
+#define KD_ENOTCONN (28)
+#define KD_EPERM (33)
+#define KD_ETIMEDOUT (36)
+#define KD_EILSEQ (19)
+#endif
+
+/** Map types from OMX standard types only here so interface is as generic as possible. */
+typedef OMX_U32    CPresult;
+typedef char *     CPstring;  
+typedef void *     CPhandle;
+typedef OMX_U32    CPuint;
+typedef OMX_S32    CPint;  
+typedef char       CPbyte;  
+typedef OMX_BOOL   CPbool;
+
+/** enumeration of origin types used in the CP_PIPETYPE's Seek function 
+ * @ingroup cp
+ */
+typedef enum CP_ORIGINTYPE {
+    CP_OriginBegin,      
+    CP_OriginCur,      
+    CP_OriginEnd,      
+    CP_OriginKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_OriginVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_OriginMax = 0X7FFFFFFF
+} CP_ORIGINTYPE;
+
+/** enumeration of contact access types used in the CP_PIPETYPE's Open function 
+ * @ingroup cp
+ */
+typedef enum CP_ACCESSTYPE {
+    CP_AccessRead,      
+    CP_AccessWrite,  
+    CP_AccessReadWrite ,  
+    CP_AccessKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_AccessVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_AccessMax = 0X7FFFFFFF
+} CP_ACCESSTYPE;
+
+/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function 
+ * @ingroup cp
+ */
+typedef enum CP_CHECKBYTESRESULTTYPE
+{
+    CP_CheckBytesOk,                    /**< There are at least the request number 
+                                              of bytes available */
+    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes 
+                                              and presently lacks sufficient bytes. 
+                                              Client will be called when they are 
+                                              sufficient bytes are available. */
+    CP_CheckBytesInsufficientBytes  ,     /**< The pipe has retrieved all bytes 
+                                              but those available are less than those 
+                                              requested */
+    CP_CheckBytesAtEndOfStream,         /**< The pipe has reached the end of stream
+                                              and no more bytes are available. */
+    CP_CheckBytesOutOfBuffers,          /**< All read/write buffers are currently in use. */
+    CP_CheckBytesKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_CheckBytesVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_CheckBytesMax = 0X7FFFFFFF
+} CP_CHECKBYTESRESULTTYPE;
+
+/** enumeration of content pipe events sent to the client callback. 
+ * @ingroup cp
+ */
+typedef enum CP_EVENTTYPE{
+    CP_BytesAvailable,      	    /** bytes requested in a CheckAvailableBytes call are now available*/
+    CP_Overflow,  		           /** enumeration of content pipe events sent to the client callback*/
+    CP_PipeDisconnected  ,  		    /** enumeration of content pipe events sent to the client callback*/
+    CP_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_EventMax = 0X7FFFFFFF
+} CP_EVENTTYPE;
+
+/** content pipe definition 
+ * @ingroup cp
+ */
+typedef struct CP_PIPETYPE
+{
+    /** Open a content stream for reading or writing. */ 
+    CPresult (*Open)( CPhandle* hContent, CPstring szURI, CP_ACCESSTYPE eAccess );
+
+    /** Close a content stream. */ 
+    CPresult (*Close)( CPhandle hContent );
+
+    /** Create a content source and open it for writing. */ 
+    CPresult (*Create)( CPhandle *hContent, CPstring szURI );
+
+    /** Check the that specified number of bytes are available for reading or writing (depending on access type).*/
+    CPresult (*CheckAvailableBytes)( CPhandle hContent, CPuint nBytesRequested, CP_CHECKBYTESRESULTTYPE *eResult );
+
+    /** Seek to certain position in the content relative to the specified origin. */
+    CPresult (*SetPosition)( CPhandle  hContent, CPint nOffset, CP_ORIGINTYPE eOrigin);
+
+    /** Retrieve the current position relative to the start of the content. */
+    CPresult (*GetPosition)( CPhandle hContent, CPuint *pPosition);
+
+    /** Retrieve data of the specified size from the content stream (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency reads. */
+    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize); 
+
+    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes. 
+       Buffer contains the next block of bytes, as specified by nSize, of the content. nSize also
+       returns the size of the block actually read. Content pointer advances the by the returned size. 
+       Note: pipe provides pointer. This function is appropriate for large reads. The client must call 
+       ReleaseReadBuffer when done with buffer. 
+
+       In some cases the requested block may not reside in contiguous memory within the
+       pipe implementation. For instance if the pipe leverages a circular buffer then the requested 
+       block may straddle the boundary of the circular buffer. By default a pipe implementation 
+       performs a copy in this case to provide the block to the pipe client in one contiguous buffer.
+       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory 
+       boundary. Here the client may retrieve the data in segments over successive calls. */
+    CPresult (*ReadBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint *nSize, CPbool bForbidCopy);
+
+    /** Release a buffer obtained by ReadBuffer back to the pipe. */
+    CPresult (*ReleaseReadBuffer)(CPhandle hContent, CPbyte *pBuffer);
+
+    /** Write data of the specified size to the content (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency writes. */
+    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize); 
+
+    /** Retrieve a buffer allocated by the pipe used to write data to the content. 
+       Client will fill buffer with output data. Note: pipe provides pointer. This function is appropriate
+       for large writes. The client must call WriteBuffer when done it has filled the buffer with data.*/
+    CPresult (*GetWriteBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint nSize);
+
+    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the 
+       the contents of the buffer to content and advance content pointer by the size of the buffer */
+    CPresult (*WriteBuffer)( CPhandle hContent, CPbyte *pBuffer, CPuint nFilledSize);
+
+    /** Register a per-handle client callback with the content pipe. */
+    CPresult (*RegisterCallback)( CPhandle hContent, CPresult (*ClientCallback)(CP_EVENTTYPE eEvent, CPuint iParam));
+
+} CP_PIPETYPE;
+
+#endif
+
diff --git a/omx/headers/OMX_Core.h b/omx/headers/OMX_Core.h
index 3306efe..a076f2f 100644
--- a/omx/headers/OMX_Core.h
+++ b/omx/headers/OMX_Core.h
@@ -1,1390 +1,1431 @@
-/*
- * Copyright (c) 2007 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** OMX_Core.h - OpenMax IL version 1.1.1
- *  The OMX_Core header file contains the definitions used by both the
- *  application and the component to access common items.
- */
-
-#ifndef OMX_Core_h
-#define OMX_Core_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/* Each OMX header shall include all required header files to allow the
- *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully 
- */
-
-#include <OMX_Index.h>
-
-
-/** The OMX_COMMANDTYPE enumeration is used to specify the action in the
- *  OMX_SendCommand macro.  
- *  @ingroup core
- */
-typedef enum OMX_COMMANDTYPE
-{
-    OMX_CommandStateSet,    /**< Change the component state */
-    OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
-    OMX_CommandPortDisable, /**< Disable a port on a component. */
-    OMX_CommandPortEnable,  /**< Enable a port on a component. */
-    OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
-    OMX_CommandMax = 0X7FFFFFFF
-} OMX_COMMANDTYPE;
-
-
-
-/** The OMX_STATETYPE enumeration is used to indicate or change the component
- *  state.  This enumeration reflects the current state of the component when
- *  used with the OMX_GetState macro or becomes the parameter in a state change
- *  command when used with the OMX_SendCommand macro.
- *
- *  The component will be in the Loaded state after the component is initially
- *  loaded into memory.  In the Loaded state, the component is not allowed to
- *  allocate or hold resources other than to build it's internal parameter
- *  and configuration tables.  The application will send one or more
- *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
- *  component and the component will record each of these parameter and
- *  configuration changes for use later.  When the application sends the
- *  Idle command, the component will acquire the resources needed for the
- *  specified configuration and will transition to the idle state if the
- *  allocation is successful.  If the component cannot successfully
- *  transition to the idle state for any reason, the state of the component
- *  shall be fully rolled back to the Loaded state (e.g. all allocated 
- *  resources shall be released).  When the component receives the command
- *  to go to the Executing state, it shall begin processing buffers by
- *  sending all input buffers it holds to the application.  While
- *  the component is in the Idle state, the application may also send the
- *  Pause command.  If the component receives the pause command while in the
- *  Idle state, the component shall send all input buffers it holds to the 
- *  application, but shall not begin processing buffers.  This will allow the
- *  application to prefill buffers.
- * 
- *  @ingroup comp
- */
-
-typedef enum OMX_STATETYPE
-{
-    OMX_StateInvalid,      /**< component has detected that it's internal data 
-                                structures are corrupted to the point that
-                                it cannot determine it's state properly */
-    OMX_StateLoaded,      /**< component has been loaded but has not completed
-                                initialization.  The OMX_SetParameter macro
-                                and the OMX_GetParameter macro are the only 
-                                valid macros allowed to be sent to the 
-                                component in this state. */
-    OMX_StateIdle,        /**< component initialization has been completed
-                                successfully and the component is ready to
-                                to start. */
-    OMX_StateExecuting,   /**< component has accepted the start command and
-                                is processing data (if data is available) */
-    OMX_StatePause,       /**< component has received pause command */
-    OMX_StateWaitForResources, /**< component is waiting for resources, either after 
-                                preemption or before it gets the resources requested.
-                                See specification for complete details. */
-    OMX_StateMax = 0X7FFFFFFF
-} OMX_STATETYPE;
-
-/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These 
- *  errors should cover most of the common failure cases.  However, 
- *  vendors are free to add additional error messages of their own as 
- *  long as they follow these rules:
- *  1.  Vendor error messages shall be in the range of 0x90000000 to
- *      0x9000FFFF.
- *  2.  Vendor error messages shall be defined in a header file provided
- *      with the component.  No error messages are allowed that are
- *      not defined.
- */
-typedef enum OMX_ERRORTYPE
-{
-  OMX_ErrorNone = 0,
-
-  /** There were insufficient resources to perform the requested operation */
-  OMX_ErrorInsufficientResources = 0x80001000,
-
-  /** There was an error, but the cause of the error could not be determined */
-  OMX_ErrorUndefined = 0x80001001,
-
-  /** The component name string was not valid */
-  OMX_ErrorInvalidComponentName = 0x80001002,
-
-  /** No component with the specified name string was found */
-  OMX_ErrorComponentNotFound = 0x80001003,
-
-  /** The component specified did not have a "OMX_ComponentInit" or
-      "OMX_ComponentDeInit entry point */
-  OMX_ErrorInvalidComponent = 0x80001004,
-
-  /** One or more parameters were not valid */
-  OMX_ErrorBadParameter = 0x80001005,
-
-  /** The requested function is not implemented */
-  OMX_ErrorNotImplemented = 0x80001006,
-
-  /** The buffer was emptied before the next buffer was ready */
-  OMX_ErrorUnderflow = 0x80001007,
-
-  /** The buffer was not available when it was needed */
-  OMX_ErrorOverflow = 0x80001008,
-
-  /** The hardware failed to respond as expected */
-  OMX_ErrorHardware = 0x80001009,
-
-  /** The component is in the state OMX_StateInvalid */
-  OMX_ErrorInvalidState = 0x8000100A,
-
-  /** Stream is found to be corrupt */
-  OMX_ErrorStreamCorrupt = 0x8000100B,
-
-  /** Ports being connected are not compatible */
-  OMX_ErrorPortsNotCompatible = 0x8000100C,
-
-  /** Resources allocated to an idle component have been
-      lost resulting in the component returning to the loaded state */
-  OMX_ErrorResourcesLost = 0x8000100D,
-
-  /** No more indicies can be enumerated */
-  OMX_ErrorNoMore = 0x8000100E,
-
-  /** The component detected a version mismatch */
-  OMX_ErrorVersionMismatch = 0x8000100F,
-
-  /** The component is not ready to return data at this time */
-  OMX_ErrorNotReady = 0x80001010,
-
-  /** There was a timeout that occurred */
-  OMX_ErrorTimeout = 0x80001011,
-
-  /** This error occurs when trying to transition into the state you are already in */
-  OMX_ErrorSameState = 0x80001012,
-
-  /** Resources allocated to an executing or paused component have been 
-      preempted, causing the component to return to the idle state */
-  OMX_ErrorResourcesPreempted = 0x80001013, 
-
-  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
-      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
-      on a port restart) when it deems that it has waited an unusually long time for the supplier 
-      to send it an allocated buffer via a UseBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringAllocation = 0x80001014,
-
-  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
-      during the deallocation of buffers (on a transition from the IDLE to LOADED state or 
-      on a port stop) when it deems that it has waited an unusually long time for the supplier 
-      to request the deallocation of a buffer header via a FreeBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringDeallocation = 0x80001015,
-
-  /** A supplier port sends this error to the IL client (via the EventHandler callback) 
-      during the stopping of a port (either on a transition from the IDLE to LOADED 
-      state or a port stop) when it deems that it has waited an unusually long time for 
-      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringStop = 0x80001016,
-
-  /** Attempting a state transtion that is not allowed */
-  OMX_ErrorIncorrectStateTransition = 0x80001017,
-
-  /* Attempting a command that is not allowed during the present state. */
-  OMX_ErrorIncorrectStateOperation = 0x80001018, 
-
-  /** The values encapsulated in the parameter or config structure are not supported. */
-  OMX_ErrorUnsupportedSetting = 0x80001019,
-
-  /** The parameter or config indicated by the given index is not supported. */
-  OMX_ErrorUnsupportedIndex = 0x8000101A,
-
-  /** The port index supplied is incorrect. */
-  OMX_ErrorBadPortIndex = 0x8000101B,
-
-  /** The port has lost one or more of its buffers and it thus unpopulated. */
-  OMX_ErrorPortUnpopulated = 0x8000101C,
-
-  /** Component suspended due to temporary loss of resources */
-  OMX_ErrorComponentSuspended = 0x8000101D,
-
-  /** Component suspended due to an inability to acquire dynamic resources */
-  OMX_ErrorDynamicResourcesUnavailable = 0x8000101E,
-
-  /** When the macroblock error reporting is enabled the component returns new error 
-  for every frame that has errors */
-  OMX_ErrorMbErrorsInFrame = 0x8000101F,
-
-  /** A component reports this error when it cannot parse or determine the format of an input stream. */
-  OMX_ErrorFormatNotDetected = 0x80001020, 
-
-  /** The content open operation failed. */
-  OMX_ErrorContentPipeOpenFailed = 0x80001021,
-
-  /** The content creation operation failed. */
-  OMX_ErrorContentPipeCreationFailed = 0x80001022,
-
-  /** Separate table information is being used */
-  OMX_ErrorSeperateTablesUsed = 0x80001023,
-
-  /** Tunneling is unsupported by the component*/
-  OMX_ErrorTunnelingUnsupported = 0x80001024,
-
-  OMX_ErrorMax = 0x7FFFFFFF,
-} OMX_ERRORTYPE;
-
-/** @ingroup core */
-typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);
-
-/** @ingroup core */
-typedef struct OMX_COMPONENTREGISTERTYPE
-{
-  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
-  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
-} OMX_COMPONENTREGISTERTYPE;
-
-/** @ingroup core */
-extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];
-
-/** @ingroup rpm */
-typedef struct OMX_PRIORITYMGMTTYPE {
- OMX_U32 nSize;             /**< size of the structure in bytes */
- OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
- OMX_U32 nGroupPriority;            /**< Priority of the component group */
- OMX_U32 nGroupID;                  /**< ID of the component group */
-} OMX_PRIORITYMGMTTYPE;
-
-/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
-#define OMX_MAX_STRINGNAME_SIZE 128
-
-/** @ingroup comp */
-typedef struct OMX_PARAM_COMPONENTROLETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
-} OMX_PARAM_COMPONENTROLETYPE;
-
-/** End of Stream Buffer Flag: 
-  *
-  * A component sets EOS when it has no more data to emit on a particular 
-  * output port. Thus an output port shall set EOS on the last buffer it 
-  * emits. A component's determination of when an output port should 
-  * cease sending data is implemenation specific.
-  * @ingroup buf
-  */
-
-#define OMX_BUFFERFLAG_EOS 0x00000001 
-
-/** Start Time Buffer Flag: 
- *
- * The source of a stream (e.g. a demux component) sets the STARTTIME
- * flag on the buffer that contains the starting timestamp for the
- * stream. The starting timestamp corresponds to the first data that
- * should be displayed at startup or after a seek.
- * The first timestamp of the stream is not necessarily the start time.
- * For instance, in the case of a seek to a particular video frame, 
- * the target frame may be an interframe. Thus the first buffer of 
- * the stream will be the intra-frame preceding the target frame and
- * the starttime will occur with the target frame (with any other
- * required frames required to reconstruct the target intervening).
- *
- * The STARTTIME flag is directly associated with the buffer's 
- * timestamp ' thus its association to buffer data and its 
- * propagation is identical to the timestamp's.
- *
- * When a Sync Component client receives a buffer with the 
- * STARTTIME flag it shall perform a SetConfig on its sync port 
- * using OMX_ConfigTimeClientStartTime and passing the buffer's
- * timestamp.
- * 
- * @ingroup buf
- */
-
-#define OMX_BUFFERFLAG_STARTTIME 0x00000002
-
- 
-
-/** Decode Only Buffer Flag: 
- *
- * The source of a stream (e.g. a demux component) sets the DECODEONLY
- * flag on any buffer that should shall be decoded but should not be
- * displayed. This flag is used, for instance, when a source seeks to 
- * a target interframe that requires the decode of frames preceding the 
- * target to facilitate the target's reconstruction. In this case the 
- * source would emit the frames preceding the target downstream 
- * but mark them as decode only.
- *
- * The DECODEONLY is associated with buffer data and propagated in a 
- * manner identical to the buffer timestamp.
- *
- * A component that renders data should ignore all buffers with 
- * the DECODEONLY flag set.
- * 
- * @ingroup buf
- */
-
-#define OMX_BUFFERFLAG_DECODEONLY 0x00000004
-
-
-/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt 
- * @ingroup buf
- */
-
-#define OMX_BUFFERFLAG_DATACORRUPT 0x00000008
-
-/* End of Frame: The buffer contains exactly one end of frame and no data
- *  occurs after the end of frame. This flag is an optional hint. The absence
- *  of this flag does not imply the absence of an end of frame within the buffer. 
- * @ingroup buf
-*/
-#define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
-
-/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame ' 
- *  a frame that has no dependency on any other frame information 
- *  @ingroup buf
- */
-#define OMX_BUFFERFLAG_SYNCFRAME 0x00000020
-
-/* Extra data present flag: there is extra data appended to the data stream
- * residing in the buffer 
- * @ingroup buf  
- */
-#define OMX_BUFFERFLAG_EXTRADATA 0x00000040
-
-/** @ingroup buf */
-typedef struct OMX_BUFFERHEADERTYPE
-{
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U8* pBuffer;            /**< Pointer to actual block of memory 
-                                     that is acting as the buffer */
-    OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
-    OMX_U32 nFilledLen;         /**< number of bytes currently in the 
-                                     buffer */
-    OMX_U32 nOffset;            /**< start offset of valid data in bytes from
-                                     the start of the buffer */
-    OMX_PTR pAppPrivate;        /**< pointer to any data the application
-                                     wants to associate with this buffer */
-    OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
-                                     wants to associate with this buffer */ 
-    OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
-                                     wants to associate with this buffer */
-    OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
-                                     wants to associate with this buffer */
-    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a 
-                                              mark event upon processing this buffer. */
-    OMX_PTR pMarkData;          /**< Application specific data associated with 
-                                     the mark sent on a mark event to disambiguate 
-                                     this mark from others. */
-    OMX_U32 nTickCount;         /**< Optional entry that the component and
-                                     application can update with a tick count
-                                     when they access the component.  This
-                                     value should be in microseconds.  Since
-                                     this is a value relative to an arbitrary
-                                     starting point, this value cannot be used 
-                                     to determine absolute time.  This is an
-                                     optional entry and not all components
-                                     will update it.*/
- OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample 
-                                     starting at the first logical sample 
-                                     boundary in the buffer. Timestamps of 
-                                     successive samples within the buffer may
-                                     be inferred by adding the duration of the 
-                                     of the preceding buffer to the timestamp
-                                     of the preceding buffer.*/
-  OMX_U32     nFlags;           /**< buffer specific flags */
-  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using 
-                                     this buffer */
-  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
-                                     this buffer */
-} OMX_BUFFERHEADERTYPE;
-
-/* Extra Data flags */
-
-/* Quant Data Flag: This flag is set when the extra data is appended to the buffer containing quantization information */
-#define OMX_EXTRADATAFLAG_QUANT 0x00000001
-
-typedef struct OMX_OTHER_EXTRADATATYPE  {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;               
-    OMX_U32 nPortIndex;
-    OMX_U32 nFlags;       /* Extra Data flags */
-    OMX_U32 nDataSize;   /* Size of the supporting data to follow */
-    OMX_U8  data[1];     /* Supporting data hint  */
-} OMX_OTHER_EXTRADATATYPE;
-
-/** @ingroup comp */
-typedef struct OMX_PORT_PARAM_TYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPorts;             /**< The number of ports for this component */
-    OMX_U32 nStartPortNumber;   /** first port number for this type of port */
-} OMX_PORT_PARAM_TYPE; 
-
-/** @ingroup comp */
-typedef enum OMX_EVENTTYPE
-{
-    OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
-    OMX_EventError,               /**< component has detected an error condition */
-    OMX_EventMark,                /**< component has detected a buffer mark */
-    OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
-    OMX_EventBufferFlag,          /**< component has detected an EOS */ 
-    OMX_EventResourcesAcquired,   /**< component has been granted resources and is
-                                       automatically starting the state change from
-                                       OMX_StateWaitForResources to OMX_StateIdle. */
-   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
-   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
-   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
-   OMX_EventMax = 0x7FFFFFFF
-} OMX_EVENTTYPE;
-
-typedef struct OMX_CALLBACKTYPE
-{
-    /** The EventHandler method is used to notify the application when an
-        event of interest occurs.  Events are defined in the OMX_EVENTTYPE
-        enumeration.  Please see that enumeration for details of what will
-        be returned for each type of event. Callbacks should not return
-        an error to the component, so if an error occurs, the application 
-        shall handle it internally.  This is a blocking call.
-
-        The application should return from this call within 5 msec to avoid
-        blocking the component for an excessively long period of time.
-
-        @param hComponent
-            handle of the component to access.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param pAppData
-            pointer to an application defined value that was provided in the 
-            pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application 
-            can have a component specific context when receiving the callback.
-        @param eEvent
-            Event that the component wants to notify the application about.
-        @param nData1
-            nData will be the OMX_ERRORTYPE for an error event and will be 
-            an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
-         @param nData2
-            nData2 will hold further information related to the event. Can be OMX_STATETYPE for
-            a OMX_StateChange command or port index for a OMX_PortSettingsCHanged event.
-            Default value is 0 if not used. )
-        @param pEventData
-            Pointer to additional event-specific data (see spec for meaning).
-      */
-
-   OMX_ERRORTYPE (*EventHandler)(
-        OMX_IN OMX_HANDLETYPE hComponent,
-        OMX_IN OMX_PTR pAppData,
-        OMX_IN OMX_EVENTTYPE eEvent,
-        OMX_IN OMX_U32 nData1,
-        OMX_IN OMX_U32 nData2,
-        OMX_IN OMX_PTR pEventData);
-
-    /** The EmptyBufferDone method is used to return emptied buffers from an
-        input port back to the application for reuse.  This is a blocking call 
-        so the application should not attempt to refill the buffers during this
-        call, but should queue them and refill them in another thread.  There
-        is no error return, so the application shall handle any errors generated
-        internally.  
-        
-        The application should return from this call within 5 msec.
-        
-        @param hComponent
-            handle of the component to access.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param pAppData
-            pointer to an application defined value that was provided in the 
-            pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application 
-            can have a component specific context when receiving the callback.
-        @param pBuffer
-            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-            or AllocateBuffer indicating the buffer that was emptied.
-        @ingroup buf
-     */
-    OMX_ERRORTYPE (*EmptyBufferDone)(
-        OMX_IN OMX_HANDLETYPE hComponent,
-        OMX_IN OMX_PTR pAppData,
-        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
-
-    /** The FillBufferDone method is used to return filled buffers from an
-        output port back to the application for emptying and then reuse.  
-        This is a blocking call so the application should not attempt to 
-        empty the buffers during this call, but should queue the buffers 
-        and empty them in another thread.  There is no error return, so 
-        the application shall handle any errors generated internally.  The 
-        application shall also update the buffer header to indicate the
-        number of bytes placed into the buffer.  
-
-        The application should return from this call within 5 msec.
-        
-        @param hComponent
-            handle of the component to access.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param pAppData
-            pointer to an application defined value that was provided in the 
-            pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application 
-            can have a component specific context when receiving the callback.
-        @param pBuffer
-            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-            or AllocateBuffer indicating the buffer that was filled.
-        @ingroup buf
-     */
-    OMX_ERRORTYPE (*FillBufferDone)(
-        OMX_OUT OMX_HANDLETYPE hComponent,
-        OMX_OUT OMX_PTR pAppData,
-        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
-
-} OMX_CALLBACKTYPE;
-
-/** The OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
-    preference when tunneling between two ports.
-    @ingroup tun buf
-*/
-typedef enum OMX_BUFFERSUPPLIERTYPE
-{
-    OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
-                                              or don't care */
-    OMX_BufferSupplyInput,             /**< input port supplies the buffers */
-    OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
-    OMX_BufferSupplyMax = 0x7FFFFFFF
-} OMX_BUFFERSUPPLIERTYPE;
-
-
-/** buffer supplier parameter 
- * @ingroup tun
- */
-typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
-    OMX_U32 nSize; /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex; /**< port that this structure applies to */
-    OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
-} OMX_PARAM_BUFFERSUPPLIERTYPE;
-
-
-/**< indicates that buffers received by an input port of a tunnel 
-     may not modify the data in the buffers 
-     @ingroup tun
- */
-#define OMX_PORTTUNNELFLAG_READONLY 0x00000001 
-
-
-/** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
-    port to an input port as part the two ComponentTunnelRequest calls
-    resulting from a OMX_SetupTunnel call from the IL Client. 
-    @ingroup tun
- */   
-typedef struct OMX_TUNNELSETUPTYPE
-{
-    OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
-    OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
-} OMX_TUNNELSETUPTYPE; 
-
-/* OMX Component headers is included to enable the core to use
-   macros for functions into the component for OMX release 1.0.  
-   Developers should not access any structures or data from within
-   the component header directly */
-/* TO BE REMOVED - #include <OMX_Component.h> */
-
-/** GetComponentVersion will return information about the component.  
-    This is a blocking call.  This macro will go directly from the
-    application to the component (via a core macro).  The
-    component will return from this call within 5 msec.
-    @param [in] hComponent
-        handle of component to execute the command
-    @param [out] pComponentName
-        pointer to an empty string of length 128 bytes.  The component 
-        will write its name into this string.  The name will be 
-        terminated by a single zero byte.  The name of a component will 
-        be 127 bytes or less to leave room for the trailing zero byte.  
-        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
-    @param [out] pComponentVersion
-        pointer to an OMX Version structure that the component will fill 
-        in.  The component will fill in a value that indicates the 
-        component version.  NOTE: the component version is NOT the same 
-        as the OMX Specification version (found in all structures).  The 
-        component version is defined by the vendor of the component and 
-        its value is entirely up to the component vendor.
-    @param [out] pSpecVersion
-        pointer to an OMX Version structure that the component will fill 
-        in.  The SpecVersion is the version of the specification that the 
-        component was built against.  Please note that this value may or 
-        may not match the structure's version.  For example, if the 
-        component was built against the 2.0 specification, but the 
-        application (which creates the structure is built against the 
-        1.0 specification the versions would be different.
-    @param [out] pComponentUUID
-        pointer to the UUID of the component which will be filled in by 
-        the component.  The UUID is a unique identifier that is set at 
-        RUN time for the component and is unique to each instantion of 
-        the component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_GetComponentVersion(                            \
-        hComponent,                                         \
-        pComponentName,                                     \
-        pComponentVersion,                                  \
-        pSpecVersion,                                       \
-        pComponentUUID)                                     \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetComponentVersion(  \
-        hComponent,                                         \
-        pComponentName,                                     \
-        pComponentVersion,                                  \
-        pSpecVersion,                                       \
-        pComponentUUID)                 /* Macro End */
-
-
-/** Send a command to the component.  This call is a non-blocking call.
-    The component should check the parameters and then queue the command
-    to the component thread to be executed.  The component thread shall 
-    send the EventHandler() callback at the conclusion of the command. 
-    This macro will go directly from the application to the component (via
-    a core macro).  The component will return from this call within 5 msec.
-    
-    When the command is "OMX_CommandStateSet" the component will queue a
-    state transition to the new state idenfied in nParam.
-    
-    When the command is "OMX_CommandFlush", to flush a port's buffer queues,
-    the command will force the component to return all buffers NOT CURRENTLY 
-    BEING PROCESSED to the application, in the order in which the buffers 
-    were received.
-    
-    When the command is "OMX_CommandPortDisable" or 
-    "OMX_CommandPortEnable", the component's port (given by the value of
-    nParam) will be stopped or restarted. 
-    
-    When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
-    pCmdData will point to a OMX_MARKTYPE structure containing the component
-    handle of the component to examine the buffer chain for the mark.  nParam1
-    contains the index of the port on which the buffer mark is applied.
-
-    Specification text for more details. 
-    
-    @param [in] hComponent
-        handle of component to execute the command
-    @param [in] Cmd
-        Command for the component to execute
-    @param [in] nParam
-        Parameter for the command to be executed.  When Cmd has the value 
-        OMX_SetStateCmd, value is a member of OMX_StateType.  When Cmd has 
-        the value OMX_FlushCmd, value of nParam indicates which port(s) 
-        to flush. -1 is used to flush all ports a single port index will 
-        only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
-        or "OMX_CommandPortEnable", the component's port is given by 
-        the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
-        the components pot is given by the value of nParam.
-    @param [in] pCmdData
-        Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
-        "OMX_CommandMarkBuffer".     
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_SendCommand(                                    \
-         hComponent,                                        \
-         Cmd,                                               \
-         nParam,                                            \
-         pCmdData)                                          \
-     ((OMX_COMPONENTTYPE*)hComponent)->SendCommand(         \
-         hComponent,                                        \
-         Cmd,                                               \
-         nParam,                                            \
-         pCmdData)                          /* Macro End */
-
-
-/** The OMX_GetParameter macro will get one of the current parameter 
-    settings from the component.  This macro cannot only be invoked when 
-    the component is in the OMX_IndalidState state.  The nParamIndex
-    parameter is used to indicate which structure is being requested from
-    the component.  The application shall allocate the correct structure 
-    and shall fill in the structure size and version information before 
-    invoking this macro.  When the parameter applies to a port, the
-    caller shall fill in the appropriate nPortIndex value indicating the
-    port on which the parameter applies. If the component has not had 
-    any settings changed, then the component should return a set of 
-    valid DEFAULT  parameters for the component.  This is a blocking 
-    call.  
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nParamIndex
-        Index of the structure to be filled.  This value is from the
-        OMX_INDEXTYPE enumeration.
-    @param [in,out] pComponentParameterStructure
-        Pointer to application allocated structure to be filled by the 
-        component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_GetParameter(                                   \
-        hComponent,                                         \
-        nParamIndex,                                        \
-        pComponentParameterStructure)                        \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetParameter(         \
-        hComponent,                                         \
-        nParamIndex,                                        \
-        pComponentParameterStructure)    /* Macro End */
-
-
-/** The OMX_SetParameter macro will send an initialization parameter
-    structure to a component.  Each structure shall be sent one at a time,
-    in a separate invocation of the macro.  This macro can only be
-    invoked when the component is in the OMX_LoadedState state, or the
-    port is disabled (when the parameter applies to a port). The 
-    nParamIndex parameter is used to indicate which structure is being
-    passed to the component.  The application shall allocate the 
-    correct structure and shall fill in the structure size and version 
-    information (as well as the actual data) before invoking this macro.
-    The application is free to dispose of this structure after the call
-    as the component is required to copy any data it shall retain.  This 
-    is a blocking call.  
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nIndex
-        Index of the structure to be sent.  This value is from the
-        OMX_INDEXTYPE enumeration.
-    @param [in] pComponentParameterStructure
-        pointer to application allocated structure to be used for
-        initialization by the component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_SetParameter(                                   \
-        hComponent,                                         \
-        nParamIndex,                                        \
-        pComponentParameterStructure)                        \
-    ((OMX_COMPONENTTYPE*)hComponent)->SetParameter(         \
-        hComponent,                                         \
-        nParamIndex,                                        \
-        pComponentParameterStructure)    /* Macro End */
-
-
-/** The OMX_GetConfig macro will get one of the configuration structures 
-    from a component.  This macro can be invoked anytime after the 
-    component has been loaded.  The nParamIndex call parameter is used to 
-    indicate which structure is being requested from the component.  The 
-    application shall allocate the correct structure and shall fill in the 
-    structure size and version information before invoking this macro.  
-    If the component has not had this configuration parameter sent before, 
-    then the component should return a set of valid DEFAULT values for the 
-    component.  This is a blocking call.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nIndex
-        Index of the structure to be filled.  This value is from the
-        OMX_INDEXTYPE enumeration.
-    @param [in,out] pComponentConfigStructure
-        pointer to application allocated structure to be filled by the 
-        component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
-*/        
-#define OMX_GetConfig(                                      \
-        hComponent,                                         \
-        nConfigIndex,                                       \
-        pComponentConfigStructure)                           \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetConfig(            \
-        hComponent,                                         \
-        nConfigIndex,                                       \
-        pComponentConfigStructure)       /* Macro End */
-
-
-/** The OMX_SetConfig macro will send one of the configuration 
-    structures to a component.  Each structure shall be sent one at a time,
-    each in a separate invocation of the macro.  This macro can be invoked 
-    anytime after the component has been loaded.  The application shall 
-    allocate the correct structure and shall fill in the structure size 
-    and version information (as well as the actual data) before invoking 
-    this macro.  The application is free to dispose of this structure after 
-    the call as the component is required to copy any data it shall retain.  
-    This is a blocking call.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nConfigIndex
-        Index of the structure to be sent.  This value is from the
-        OMX_INDEXTYPE enumeration above.
-    @param [in] pComponentConfigStructure
-        pointer to application allocated structure to be used for
-        initialization by the component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_SetConfig(                                      \
-        hComponent,                                         \
-        nConfigIndex,                                       \
-        pComponentConfigStructure)                           \
-    ((OMX_COMPONENTTYPE*)hComponent)->SetConfig(            \
-        hComponent,                                         \
-        nConfigIndex,                                       \
-        pComponentConfigStructure)       /* Macro End */
-
-
-/** The OMX_GetExtensionIndex macro will invoke a component to translate 
-    a vendor specific configuration or parameter string into an OMX 
-    structure index.  There is no requirement for the vendor to support 
-    this command for the indexes already found in the OMX_INDEXTYPE 
-    enumeration (this is done to save space in small components).  The 
-    component shall support all vendor supplied extension indexes not found
-    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the GetHandle function.
-    @param [in] cParameterName
-        OMX_STRING that shall be less than 128 characters long including
-        the trailing null byte.  This is the string that will get 
-        translated by the component into a configuration index.
-    @param [out] pIndexType
-        a pointer to a OMX_INDEXTYPE to receive the index value.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_GetExtensionIndex(                              \
-        hComponent,                                         \
-        cParameterName,                                     \
-        pIndexType)                                         \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex(    \
-        hComponent,                                         \
-        cParameterName,                                     \
-        pIndexType)                     /* Macro End */
-
-
-/** The OMX_GetState macro will invoke the component to get the current 
-    state of the component and place the state value into the location
-    pointed to by pState.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] pState
-        pointer to the location to receive the state.  The value returned
-        is one of the OMX_STATETYPE members 
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_GetState(                                       \
-        hComponent,                                         \
-        pState)                                             \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetState(             \
-        hComponent,                                         \
-        pState)                         /* Macro End */
-
-
-/** The OMX_UseBuffer macro will request that the component use
-    a buffer (and allocate its own buffer header) already allocated 
-    by another component, or by the IL Client. This is a blocking 
-    call.
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
-        pointer to the buffer header
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-
-#define OMX_UseBuffer(                                      \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           nSizeBytes,                                      \
-           pBuffer)                                         \
-    ((OMX_COMPONENTTYPE*)hComponent)->UseBuffer(            \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           nSizeBytes,                                      \
-           pBuffer)
-
-
-/** The OMX_AllocateBuffer macro will request that the component allocate 
-    a new buffer and buffer header.  The component will allocate the 
-    buffer and the buffer header and return a pointer to the buffer 
-    header.  This is a blocking call.
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive 
-        the pointer to the buffer header
-    @param [in] nPortIndex
-        nPortIndex is used to select the port on the component the buffer will
-        be used with.  The port can be found by using the nPortIndex
-        value as an index into the Port Definition array of the component.
-    @param [in] pAppPrivate
-        pAppPrivate is used to initialize the pAppPrivate member of the 
-        buffer header structure.
-    @param [in] nSizeBytes
-        size of the buffer to allocate.  Used when bAllocateNew is true.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */    
-#define OMX_AllocateBuffer(                                 \
-        hComponent,                                         \
-        ppBuffer,                                           \
-        nPortIndex,                                         \
-        pAppPrivate,                                        \
-        nSizeBytes)                                         \
-    ((OMX_COMPONENTTYPE*)hComponent)->AllocateBuffer(       \
-        hComponent,                                         \
-        ppBuffer,                                           \
-        nPortIndex,                                         \
-        pAppPrivate,                                        \
-        nSizeBytes)                     /* Macro End */
-
-
-/** The OMX_FreeBuffer macro will release a buffer header from the component
-    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If  
-    the component allocated the buffer (see the OMX_UseBuffer macro) then 
-    the component shall free the buffer and buffer header. This is a 
-    blocking call. 
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nPortIndex
-        nPortIndex is used to select the port on the component the buffer will
-        be used with.
-    @param [in] pBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-        or AllocateBuffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-#define OMX_FreeBuffer(                                     \
-        hComponent,                                         \
-        nPortIndex,                                         \
-        pBuffer)                                            \
-    ((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer(           \
-        hComponent,                                         \
-        nPortIndex,                                         \
-        pBuffer)                        /* Macro End */
-
-
-/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an 
-    input port of a component.  The buffer will be emptied by the component
-    and returned to the application via the EmptyBufferDone call back.
-    This is a non-blocking call in that the component will record the buffer
-    and return immediately and then empty the buffer, later, at the proper 
-    time.  As expected, this macro may be invoked only while the component 
-    is in the OMX_ExecutingState.  If nPortIndex does not specify an input
-    port, the component shall return an error.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] pBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-        or AllocateBuffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-#define OMX_EmptyThisBuffer(                                \
-        hComponent,                                         \
-        pBuffer)                                            \
-    ((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer(      \
-        hComponent,                                         \
-        pBuffer)                        /* Macro End */
-
-
-/** The OMX_FillThisBuffer macro will send an empty buffer to an 
-    output port of a component.  The buffer will be filled by the component
-    and returned to the application via the FillBufferDone call back.
-    This is a non-blocking call in that the component will record the buffer
-    and return immediately and then fill the buffer, later, at the proper 
-    time.  As expected, this macro may be invoked only while the component 
-    is in the OMX_ExecutingState.  If nPortIndex does not specify an output
-    port, the component shall return an error.  
-    
-    The component should return from this call within 5 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] pBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-        or AllocateBuffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-#define OMX_FillThisBuffer(                                 \
-        hComponent,                                         \
-        pBuffer)                                            \
-    ((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer(       \
-        hComponent,                                         \
-        pBuffer)                        /* Macro End */
-
-
-
-/** The OMX_UseEGLImage macro will request that the component use
-    a EGLImage provided by EGL (and allocate its own buffer header)
-    This is a blocking call.
-    
-    The component should return from this call within 20 msec.
-    
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
-        pointer to the buffer header.  Note that the memory location used
-        for this buffer is NOT visible to the IL Client.
-    @param [in] nPortIndex
-        nPortIndex is used to select the port on the component the buffer will
-        be used with.  The port can be found by using the nPortIndex
-        value as an index into the Port Definition array of the component.
-    @param [in] pAppPrivate
-        pAppPrivate is used to initialize the pAppPrivate member of the 
-        buffer header structure.
-    @param [in] eglImage
-        eglImage contains the handle of the EGLImage to use as a buffer on the
-        specified port.  The component is expected to validate properties of 
-        the EGLImage against the configuration of the port to ensure the component
-        can use the EGLImage as a buffer.          
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-#define OMX_UseEGLImage(                                    \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           eglImage)                                        \
-    ((OMX_COMPONENTTYPE*)hComponent)->UseEGLImage(          \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           eglImage)
-
-/** The OMX_Init method is used to initialize the OMX core.  It shall be the
-    first call made into OMX and it should only be executed one time without
-    an interviening OMX_Deinit call.  
-    
-    The core should return from this call within 20 msec.
-
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);
-
-
-/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be 
-    the last call made into OMX. In the event that the core determines that 
-    thare are components loaded when this call is made, the core may return 
-    with an error rather than try to unload the components.
-        
-    The core should return from this call within 20 msec.
-    
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void);
-
-
-/** The OMX_ComponentNameEnum method will enumerate through all the names of
-    recognised valid components in the system. This function is provided
-    as a means to detect all the components in the system run-time. There is
-    no strict ordering to the enumeration order of component names, although
-    each name will only be enumerated once.  If the OMX core supports run-time
-    installation of new components, it is only requried to detect newly
-    installed components when the first call to enumerate component names
-    is made (i.e. when nIndex is 0x0).
-    
-    The core should return from this call in 20 msec.
-    
-    @param [out] cComponentName
-        pointer to a null terminated string with the component name.  The
-        names of the components are strings less than 127 bytes in length
-        plus the trailing null for a maximum size of 128 bytes.  An example 
-        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
-        assigned by the vendor, but shall start with "OMX." and then have 
-        the Vendor designation next.
-    @param [in] nNameLength
-        number of characters in the cComponentName string.  With all 
-        component name strings restricted to less than 128 characters 
-        (including the trailing null) it is recomended that the caller
-        provide a input string for the cComponentName of 128 characters.
-    @param [in] nIndex
-        number containing the enumeration index for the component. 
-        Multiple calls to OMX_ComponentNameEnum with increasing values
-        of nIndex will enumerate through the component names in the
-        system until OMX_ErrorNoMore is returned.  The value of nIndex
-        is 0 to (N-1), where N is the number of valid installed components
-        in the system.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  When the value of nIndex exceeds the number of 
-        components in the system minus 1, OMX_ErrorNoMore will be
-        returned. Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
-    OMX_OUT OMX_STRING cComponentName,
-    OMX_IN  OMX_U32 nNameLength,
-    OMX_IN  OMX_U32 nIndex);
-
-
-/** The OMX_GetHandle method will locate the component specified by the
-    component name given, load that component into memory and then invoke
-    the component's methods to create an instance of the component.  
-    
-    The core should return from this call within 20 msec.
-    
-    @param [out] pHandle
-        pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
-    @param [in] cComponentName
-        pointer to a null terminated string with the component name.  The
-        names of the components are strings less than 127 bytes in length
-        plus the trailing null for a maximum size of 128 bytes.  An example 
-        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
-        assigned by the vendor, but shall start with "OMX." and then have 
-        the Vendor designation next.
-    @param [in] pAppData
-        pointer to an application defined value that will be returned
-        during callbacks so that the application can identify the source
-        of the callback.
-    @param [in] pCallBacks
-        pointer to a OMX_CALLBACKTYPE structure that will be passed to the
-        component to initialize it with.  
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
-    OMX_OUT OMX_HANDLETYPE* pHandle, 
-    OMX_IN  OMX_STRING cComponentName,
-    OMX_IN  OMX_PTR pAppData,
-    OMX_IN  OMX_CALLBACKTYPE* pCallBacks);
-
-
-/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle 
-    method.  If the component reference count goes to zero, the component will
-    be unloaded from memory.  
-    
-    The core should return from this call within 20 msec when the component is 
-    in the OMX_StateLoaded state.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the GetHandle function.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
-    OMX_IN  OMX_HANDLETYPE hComponent);
-
-
-
-/** The OMX_SetupTunnel method will handle the necessary calls to the components
-    to setup the specified tunnel the two components.  NOTE: This is
-    an actual method (not a #define macro).  This method will make calls into
-    the component ComponentTunnelRequest method to do the actual tunnel 
-    connection.  
-
-    The ComponentTunnelRequest method on both components will be called. 
-    This method shall not be called unless the component is in the 
-    OMX_StateLoaded state except when the ports used for the tunnel are
-    disabled. In this case, the component may be in the OMX_StateExecuting,
-    OMX_StatePause, or OMX_StateIdle states. 
-
-    The core should return from this call within 20 msec.
-    
-    @param [in] hOutput
-        Handle of the component to be accessed.  Also this is the handle
-        of the component whose port, specified in the nPortOutput parameter
-        will be used the source for the tunnel. This is the component handle
-        returned by the call to the OMX_GetHandle function.  There is a 
-        requirement that hOutput be the source for the data when
-        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
-        specified in hInput will have it's port specified in nPortInput
-        setup for communication with the application / IL client.
-    @param [in] nPortOutput
-        nPortOutput is used to select the source port on component to be
-        used in the tunnel. 
-    @param [in] hInput
-        This is the component to setup the tunnel with. This is the handle
-        of the component whose port, specified in the nPortInput parameter
-        will be used the destination for the tunnel. This is the component handle
-        returned by the call to the OMX_GetHandle function.  There is a 
-        requirement that hInput be the destination for the data when
-        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
-        specified in hOutput will have it's port specified in nPortPOutput
-        setup for communication with the application / IL client.
-    @param [in] nPortInput
-        nPortInput is used to select the destination port on component to be
-        used in the tunnel.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_NoError.  Otherwise the appropriate OMX error will be returned.
-        When OMX_ErrorNotImplemented is returned, one or both components is 
-        a non-interop component and does not support tunneling.
-        
-        On failure, the ports of both components are setup for communication
-        with the application / IL Client.
-    @ingroup core tun
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
-    OMX_IN  OMX_HANDLETYPE hOutput,
-    OMX_IN  OMX_U32 nPortOutput,
-    OMX_IN  OMX_HANDLETYPE hInput,
-    OMX_IN  OMX_U32 nPortInput);
-    
-/** @ingroup cp */
-OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
-    OMX_OUT OMX_HANDLETYPE *hPipe,
-    OMX_IN OMX_STRING szURI);
-
-/** The OMX_GetComponentsOfRole method will return the number of components that support the given
-    role and (if the compNames field is non-NULL) the names of those components. The call will fail if 
-    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
-    client should:
-        * first call this function with the compNames field NULL to determine the number of component names
-        * second call this function with the compNames field pointing to an array of names allocated 
-          according to the number returned by the first call.
-
-    The core should return from this call within 5 msec.
-    
-    @param [in] role
-        This is generic standard component name consisting only of component class 
-        name and the type within that class (e.g. 'audio_decoder.aac').
-    @param [inout] pNumComps
-        This is used both as input and output. 
- 
-        If compNames is NULL, the input is ignored and the output specifies how many components support
-        the given role.
-     
-        If compNames is not NULL, on input it bounds the size of the input structure and 
-        on output, it specifies the number of components string names listed within the compNames parameter.
-    @param [inout] compNames
-        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts 
-        a list of the names of all physical components that implement the specified standard component name. 
-        Each name is NULL terminated. numComps indicates the number of names.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole ( 
-	OMX_IN      OMX_STRING role,
-    OMX_INOUT   OMX_U32 *pNumComps,
-    OMX_INOUT   OMX_U8  **compNames);
-
-/** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
-    component and (if the roles field is non-NULL) the names of those roles. The call will fail if 
-    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
-    client should:
-        * first call this function with the roles field NULL to determine the number of role names
-        * second call this function with the roles field pointing to an array of names allocated 
-          according to the number returned by the first call.
-
-    The core should return from this call within 5 msec.
-
-    @param [in] compName
-        This is the name of the component being queried about.
-    @param [inout] pNumRoles
-        This is used both as input and output. 
- 
-        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
-     
-        If compNames is not NULL, on input it bounds the size of the input structure and 
-        on output, it specifies the number of roles string names listed within the roles parameter.
-    @param [out] roles
-        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings 
-        which accepts a list of the names of all standard components roles implemented on the 
-        specified component name. numComps indicates the number of names.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent ( 
-	OMX_IN      OMX_STRING compName, 
-    OMX_INOUT   OMX_U32 *pNumRoles,
-    OMX_OUT     OMX_U8 **roles);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
-
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_Core.h - OpenMax IL version 1.1.2
+ *  The OMX_Core header file contains the definitions used by both the
+ *  application and the component to access common items.
+ */
+
+#ifndef OMX_Core_h
+#define OMX_Core_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header shall include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Index.h>
+
+
+/** The OMX_COMMANDTYPE enumeration is used to specify the action in the
+ *  OMX_SendCommand macro.  
+ *  @ingroup core
+ */
+typedef enum OMX_COMMANDTYPE
+{
+    OMX_CommandStateSet,    /**< Change the component state */
+    OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
+    OMX_CommandPortDisable, /**< Disable a port on a component. */
+    OMX_CommandPortEnable,  /**< Enable a port on a component. */
+    OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
+    OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_CommandMax = 0X7FFFFFFF
+} OMX_COMMANDTYPE;
+
+
+
+/** The OMX_STATETYPE enumeration is used to indicate or change the component
+ *  state.  This enumeration reflects the current state of the component when
+ *  used with the OMX_GetState macro or becomes the parameter in a state change
+ *  command when used with the OMX_SendCommand macro.
+ *
+ *  The component will be in the Loaded state after the component is initially
+ *  loaded into memory.  In the Loaded state, the component is not allowed to
+ *  allocate or hold resources other than to build it's internal parameter
+ *  and configuration tables.  The application will send one or more
+ *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
+ *  component and the component will record each of these parameter and
+ *  configuration changes for use later.  When the application sends the
+ *  Idle command, the component will acquire the resources needed for the
+ *  specified configuration and will transition to the idle state if the
+ *  allocation is successful.  If the component cannot successfully
+ *  transition to the idle state for any reason, the state of the component
+ *  shall be fully rolled back to the Loaded state (e.g. all allocated 
+ *  resources shall be released).  When the component receives the command
+ *  to go to the Executing state, it shall begin processing buffers by
+ *  sending all input buffers it holds to the application.  While
+ *  the component is in the Idle state, the application may also send the
+ *  Pause command.  If the component receives the pause command while in the
+ *  Idle state, the component shall send all input buffers it holds to the 
+ *  application, but shall not begin processing buffers.  This will allow the
+ *  application to prefill buffers.
+ * 
+ *  @ingroup comp
+ */
+
+typedef enum OMX_STATETYPE
+{
+    OMX_StateInvalid,      /**< component has detected that it's internal data 
+                                structures are corrupted to the point that
+                                it cannot determine it's state properly */
+    OMX_StateLoaded,      /**< component has been loaded but has not completed
+                                initialization.  The OMX_SetParameter macro
+                                and the OMX_GetParameter macro are the only 
+                                valid macros allowed to be sent to the 
+                                component in this state. */
+    OMX_StateIdle,        /**< component initialization has been completed
+                                successfully and the component is ready to
+                                to start. */
+    OMX_StateExecuting,   /**< component has accepted the start command and
+                                is processing data (if data is available) */
+    OMX_StatePause,       /**< component has received pause command */
+    OMX_StateWaitForResources, /**< component is waiting for resources, either after 
+                                preemption or before it gets the resources requested.
+                                See specification for complete details. */
+    OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_StateMax = 0X7FFFFFFF
+} OMX_STATETYPE;
+
+/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These 
+ *  errors should cover most of the common failure cases.  However, 
+ *  vendors are free to add additional error messages of their own as 
+ *  long as they follow these rules:
+ *  1.  Vendor error messages shall be in the range of 0x90000000 to
+ *      0x9000FFFF.
+ *  2.  Vendor error messages shall be defined in a header file provided
+ *      with the component.  No error messages are allowed that are
+ *      not defined.
+ */
+typedef enum OMX_ERRORTYPE
+{
+  OMX_ErrorNone = 0,
+
+  /** There were insufficient resources to perform the requested operation */
+  OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,
+
+  /** There was an error, but the cause of the error could not be determined */
+  OMX_ErrorUndefined = (OMX_S32) 0x80001001,
+
+  /** The component name string was not valid */
+  OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,
+
+  /** No component with the specified name string was found */
+  OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,
+
+  /** The component specified did not have a "OMX_ComponentInit" or
+      "OMX_ComponentDeInit entry point */
+  OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,
+
+  /** One or more parameters were not valid */
+  OMX_ErrorBadParameter = (OMX_S32) 0x80001005,
+
+  /** The requested function is not implemented */
+  OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,
+
+  /** The buffer was emptied before the next buffer was ready */
+  OMX_ErrorUnderflow = (OMX_S32) 0x80001007,
+
+  /** The buffer was not available when it was needed */
+  OMX_ErrorOverflow = (OMX_S32) 0x80001008,
+
+  /** The hardware failed to respond as expected */
+  OMX_ErrorHardware = (OMX_S32) 0x80001009,
+
+  /** The component is in the state OMX_StateInvalid */
+  OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,
+
+  /** Stream is found to be corrupt */
+  OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,
+
+  /** Ports being connected are not compatible */
+  OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,
+
+  /** Resources allocated to an idle component have been
+      lost resulting in the component returning to the loaded state */
+  OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,
+
+  /** No more indicies can be enumerated */
+  OMX_ErrorNoMore = (OMX_S32) 0x8000100E,
+
+  /** The component detected a version mismatch */
+  OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,
+
+  /** The component is not ready to return data at this time */
+  OMX_ErrorNotReady = (OMX_S32) 0x80001010,
+
+  /** There was a timeout that occurred */
+  OMX_ErrorTimeout = (OMX_S32) 0x80001011,
+
+  /** This error occurs when trying to transition into the state you are already in */
+  OMX_ErrorSameState = (OMX_S32) 0x80001012,
+
+  /** Resources allocated to an executing or paused component have been 
+      preempted, causing the component to return to the idle state */
+  OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013, 
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
+      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
+      on a port restart) when it deems that it has waited an unusually long time for the supplier 
+      to send it an allocated buffer via a UseBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
+      during the deallocation of buffers (on a transition from the IDLE to LOADED state or 
+      on a port stop) when it deems that it has waited an unusually long time for the supplier 
+      to request the deallocation of a buffer header via a FreeBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,
+
+  /** A supplier port sends this error to the IL client (via the EventHandler callback) 
+      during the stopping of a port (either on a transition from the IDLE to LOADED 
+      state or a port stop) when it deems that it has waited an unusually long time for 
+      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,
+
+  /** Attempting a state transtion that is not allowed */
+  OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,
+
+  /* Attempting a command that is not allowed during the present state. */
+  OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018, 
+
+  /** The values encapsulated in the parameter or config structure are not supported. */
+  OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,
+
+  /** The parameter or config indicated by the given index is not supported. */
+  OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,
+
+  /** The port index supplied is incorrect. */
+  OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,
+
+  /** The port has lost one or more of its buffers and it thus unpopulated. */
+  OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,
+
+  /** Component suspended due to temporary loss of resources */
+  OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,
+
+  /** Component suspended due to an inability to acquire dynamic resources */
+  OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,
+
+  /** When the macroblock error reporting is enabled the component returns new error 
+  for every frame that has errors */
+  OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,
+
+  /** A component reports this error when it cannot parse or determine the format of an input stream. */
+  OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020, 
+
+  /** The content open operation failed. */
+  OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,
+
+  /** The content creation operation failed. */
+  OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,
+
+  /** Separate table information is being used */
+  OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,
+
+  /** Tunneling is unsupported by the component*/
+  OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,
+
+  OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_ErrorMax = 0x7FFFFFFF
+} OMX_ERRORTYPE;
+
+/** @ingroup core */
+typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);
+
+/** @ingroup core */
+typedef struct OMX_COMPONENTREGISTERTYPE
+{
+  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
+  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
+} OMX_COMPONENTREGISTERTYPE;
+
+/** @ingroup core */
+extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];
+
+/** @ingroup rpm */
+typedef struct OMX_PRIORITYMGMTTYPE {
+ OMX_U32 nSize;             /**< size of the structure in bytes */
+ OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+ OMX_U32 nGroupPriority;            /**< Priority of the component group */
+ OMX_U32 nGroupID;                  /**< ID of the component group */
+} OMX_PRIORITYMGMTTYPE;
+
+/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
+#define OMX_MAX_STRINGNAME_SIZE 128
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_COMPONENTROLETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
+} OMX_PARAM_COMPONENTROLETYPE;
+
+/** End of Stream Buffer Flag: 
+  *
+  * A component sets EOS when it has no more data to emit on a particular 
+  * output port. Thus an output port shall set EOS on the last buffer it 
+  * emits. A component's determination of when an output port should 
+  * cease sending data is implemenation specific.
+  * @ingroup buf
+  */
+
+#define OMX_BUFFERFLAG_EOS 0x00000001 
+
+/** Start Time Buffer Flag: 
+ *
+ * The source of a stream (e.g. a demux component) sets the STARTTIME
+ * flag on the buffer that contains the starting timestamp for the
+ * stream. The starting timestamp corresponds to the first data that
+ * should be displayed at startup or after a seek.
+ * The first timestamp of the stream is not necessarily the start time.
+ * For instance, in the case of a seek to a particular video frame, 
+ * the target frame may be an interframe. Thus the first buffer of 
+ * the stream will be the intra-frame preceding the target frame and
+ * the starttime will occur with the target frame (with any other
+ * required frames required to reconstruct the target intervening).
+ *
+ * The STARTTIME flag is directly associated with the buffer's 
+ * timestamp ' thus its association to buffer data and its 
+ * propagation is identical to the timestamp's.
+ *
+ * When a Sync Component client receives a buffer with the 
+ * STARTTIME flag it shall perform a SetConfig on its sync port 
+ * using OMX_ConfigTimeClientStartTime and passing the buffer's
+ * timestamp.
+ * 
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_STARTTIME 0x00000002
+
+ 
+
+/** Decode Only Buffer Flag: 
+ *
+ * The source of a stream (e.g. a demux component) sets the DECODEONLY
+ * flag on any buffer that should shall be decoded but should not be
+ * displayed. This flag is used, for instance, when a source seeks to 
+ * a target interframe that requires the decode of frames preceding the 
+ * target to facilitate the target's reconstruction. In this case the 
+ * source would emit the frames preceding the target downstream 
+ * but mark them as decode only.
+ *
+ * The DECODEONLY is associated with buffer data and propagated in a 
+ * manner identical to the buffer timestamp.
+ *
+ * A component that renders data should ignore all buffers with 
+ * the DECODEONLY flag set.
+ * 
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_DECODEONLY 0x00000004
+
+
+/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt 
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_DATACORRUPT 0x00000008
+
+/* End of Frame: The buffer contains exactly one end of frame and no data
+ *  occurs after the end of frame. This flag is an optional hint. The absence
+ *  of this flag does not imply the absence of an end of frame within the buffer. 
+ * @ingroup buf
+*/
+#define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
+
+/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame ' 
+ *  a frame that has no dependency on any other frame information 
+ *  @ingroup buf
+ */
+#define OMX_BUFFERFLAG_SYNCFRAME 0x00000020
+
+/* Extra data present flag: there is extra data appended to the data stream
+ * residing in the buffer 
+ * @ingroup buf  
+ */
+#define OMX_BUFFERFLAG_EXTRADATA 0x00000040
+
+/** Codec Config Buffer Flag: 
+* OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
+* output port when all bytes in the buffer form part or all of a set of
+* codec specific configuration data.  Examples include SPS/PPS nal units
+* for OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
+* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets 
+* OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
+* with frame data in the same buffer, and shall send all buffers
+* containing codec configuration bytes before any buffers containing
+* frame data that those configurations bytes describe.
+* If the stream format for a particular codec has a frame specific
+* header at the start of each frame, for example OMX_AUDIO_CodingMP3 or
+* OMX_AUDIO_CodingAAC in ADTS mode, then these shall be presented as
+* normal without setting OMX_BUFFERFLAG_CODECCONFIG.
+ * @ingroup buf
+ */
+#define OMX_BUFFERFLAG_CODECCONFIG 0x00000080
+
+
+
+/** @ingroup buf */
+typedef struct OMX_BUFFERHEADERTYPE
+{
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U8* pBuffer;            /**< Pointer to actual block of memory 
+                                     that is acting as the buffer */
+    OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
+    OMX_U32 nFilledLen;         /**< number of bytes currently in the 
+                                     buffer */
+    OMX_U32 nOffset;            /**< start offset of valid data in bytes from
+                                     the start of the buffer */
+    OMX_PTR pAppPrivate;        /**< pointer to any data the application
+                                     wants to associate with this buffer */
+    OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
+                                     wants to associate with this buffer */ 
+    OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
+                                     wants to associate with this buffer */
+    OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
+                                     wants to associate with this buffer */
+    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a 
+                                              mark event upon processing this buffer. */
+    OMX_PTR pMarkData;          /**< Application specific data associated with 
+                                     the mark sent on a mark event to disambiguate 
+                                     this mark from others. */
+    OMX_U32 nTickCount;         /**< Optional entry that the component and
+                                     application can update with a tick count
+                                     when they access the component.  This
+                                     value should be in microseconds.  Since
+                                     this is a value relative to an arbitrary
+                                     starting point, this value cannot be used 
+                                     to determine absolute time.  This is an
+                                     optional entry and not all components
+                                     will update it.*/
+ OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample 
+                                     starting at the first logical sample 
+                                     boundary in the buffer. Timestamps of 
+                                     successive samples within the buffer may
+                                     be inferred by adding the duration of the 
+                                     of the preceding buffer to the timestamp
+                                     of the preceding buffer.*/
+  OMX_U32     nFlags;           /**< buffer specific flags */
+  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using 
+                                     this buffer */
+  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
+                                     this buffer */
+} OMX_BUFFERHEADERTYPE;
+
+/** The OMX_EXTRADATATYPE enumeration is used to define the 
+ * possible extra data payload types.
+ * NB: this enum is binary backwards compatible with the previous
+ * OMX_EXTRADATA_QUANT define.  This should be replaced with
+ * OMX_ExtraDataQuantization.
+ */
+typedef enum OMX_EXTRADATATYPE
+{
+   OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */        
+   OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
+   OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_ExtraDataMax = 0x7FFFFFFF
+} OMX_EXTRADATATYPE;
+
+
+typedef struct OMX_OTHER_EXTRADATATYPE  {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;               
+    OMX_U32 nPortIndex;
+    OMX_EXTRADATATYPE eType;       /* Extra Data type */
+    OMX_U32 nDataSize;   /* Size of the supporting data to follow */
+    OMX_U8  data[1];     /* Supporting data hint  */
+} OMX_OTHER_EXTRADATATYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PORT_PARAM_TYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPorts;             /**< The number of ports for this component */
+    OMX_U32 nStartPortNumber;   /** first port number for this type of port */
+} OMX_PORT_PARAM_TYPE; 
+
+/** @ingroup comp */
+typedef enum OMX_EVENTTYPE
+{
+    OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
+    OMX_EventError,               /**< component has detected an error condition */
+    OMX_EventMark,                /**< component has detected a buffer mark */
+    OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
+    OMX_EventBufferFlag,          /**< component has detected an EOS */ 
+    OMX_EventResourcesAcquired,   /**< component has been granted resources and is
+                                       automatically starting the state change from
+                                       OMX_StateWaitForResources to OMX_StateIdle. */
+   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
+   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
+   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
+   OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_EventMax = 0x7FFFFFFF
+} OMX_EVENTTYPE;
+
+typedef struct OMX_CALLBACKTYPE
+{
+    /** The EventHandler method is used to notify the application when an
+        event of interest occurs.  Events are defined in the OMX_EVENTTYPE
+        enumeration.  Please see that enumeration for details of what will
+        be returned for each type of event. Callbacks should not return
+        an error to the component, so if an error occurs, the application 
+        shall handle it internally.  This is a blocking call.
+
+        The application should return from this call within 5 msec to avoid
+        blocking the component for an excessively long period of time.
+
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the 
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application 
+            can have a component specific context when receiving the callback.
+        @param eEvent
+            Event that the component wants to notify the application about.
+        @param nData1
+            nData will be the OMX_ERRORTYPE for an error event and will be 
+            an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
+         @param nData2
+            nData2 will hold further information related to the event. Can be OMX_STATETYPE for
+            a OMX_CommandStateSet command or port index for a OMX_PortSettingsChanged event.
+            Default value is 0 if not used. )
+        @param pEventData
+            Pointer to additional event-specific data (see spec for meaning).
+      */
+
+   OMX_ERRORTYPE (*EventHandler)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_EVENTTYPE eEvent,
+        OMX_IN OMX_U32 nData1,
+        OMX_IN OMX_U32 nData2,
+        OMX_IN OMX_PTR pEventData);
+
+    /** The EmptyBufferDone method is used to return emptied buffers from an
+        input port back to the application for reuse.  This is a blocking call 
+        so the application should not attempt to refill the buffers during this
+        call, but should queue them and refill them in another thread.  There
+        is no error return, so the application shall handle any errors generated
+        internally.  
+        
+        The application should return from this call within 5 msec.
+        
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the 
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application 
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was emptied.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*EmptyBufferDone)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** The FillBufferDone method is used to return filled buffers from an
+        output port back to the application for emptying and then reuse.  
+        This is a blocking call so the application should not attempt to 
+        empty the buffers during this call, but should queue the buffers 
+        and empty them in another thread.  There is no error return, so 
+        the application shall handle any errors generated internally.  The 
+        application shall also update the buffer header to indicate the
+        number of bytes placed into the buffer.  
+
+        The application should return from this call within 5 msec.
+        
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the 
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application 
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was filled.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FillBufferDone)(
+        OMX_OUT OMX_HANDLETYPE hComponent,
+        OMX_OUT OMX_PTR pAppData,
+        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
+
+} OMX_CALLBACKTYPE;
+
+/** The OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
+    preference when tunneling between two ports.
+    @ingroup tun buf
+*/
+typedef enum OMX_BUFFERSUPPLIERTYPE
+{
+    OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
+                                              or don't care */
+    OMX_BufferSupplyInput,             /**< input port supplies the buffers */
+    OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
+    OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_BufferSupplyMax = 0x7FFFFFFF
+} OMX_BUFFERSUPPLIERTYPE;
+
+
+/** buffer supplier parameter 
+ * @ingroup tun
+ */
+typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
+    OMX_U32 nSize; /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex; /**< port that this structure applies to */
+    OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
+} OMX_PARAM_BUFFERSUPPLIERTYPE;
+
+
+/**< indicates that buffers received by an input port of a tunnel 
+     may not modify the data in the buffers 
+     @ingroup tun
+ */
+#define OMX_PORTTUNNELFLAG_READONLY 0x00000001 
+
+
+/** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
+    port to an input port as part the two ComponentTunnelRequest calls
+    resulting from a OMX_SetupTunnel call from the IL Client. 
+    @ingroup tun
+ */   
+typedef struct OMX_TUNNELSETUPTYPE
+{
+    OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
+    OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
+} OMX_TUNNELSETUPTYPE; 
+
+/* OMX Component headers is included to enable the core to use
+   macros for functions into the component for OMX release 1.0.  
+   Developers should not access any structures or data from within
+   the component header directly */
+/* TO BE REMOVED - #include <OMX_Component.h> */
+
+/** GetComponentVersion will return information about the component.  
+    This is a blocking call.  This macro will go directly from the
+    application to the component (via a core macro).  The
+    component will return from this call within 5 msec.
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [out] pComponentName
+        pointer to an empty string of length 128 bytes.  The component 
+        will write its name into this string.  The name will be 
+        terminated by a single zero byte.  The name of a component will 
+        be 127 bytes or less to leave room for the trailing zero byte.  
+        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
+    @param [out] pComponentVersion
+        pointer to an OMX Version structure that the component will fill 
+        in.  The component will fill in a value that indicates the 
+        component version.  NOTE: the component version is NOT the same 
+        as the OMX Specification version (found in all structures).  The 
+        component version is defined by the vendor of the component and 
+        its value is entirely up to the component vendor.
+    @param [out] pSpecVersion
+        pointer to an OMX Version structure that the component will fill 
+        in.  The SpecVersion is the version of the specification that the 
+        component was built against.  Please note that this value may or 
+        may not match the structure's version.  For example, if the 
+        component was built against the 2.0 specification, but the 
+        application (which creates the structure is built against the 
+        1.0 specification the versions would be different.
+    @param [out] pComponentUUID
+        pointer to the UUID of the component which will be filled in by 
+        the component.  The UUID is a unique identifier that is set at 
+        RUN time for the component and is unique to each instantion of 
+        the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetComponentVersion(                            \
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                                     \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetComponentVersion(  \
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                 /* Macro End */
+
+
+/** Send a command to the component.  This call is a non-blocking call.
+    The component should check the parameters and then queue the command
+    to the component thread to be executed.  The component thread shall 
+    send the EventHandler() callback at the conclusion of the command. 
+    This macro will go directly from the application to the component (via
+    a core macro).  The component will return from this call within 5 msec.
+    
+    When the command is "OMX_CommandStateSet" the component will queue a
+    state transition to the new state idenfied in nParam.
+    
+    When the command is "OMX_CommandFlush", to flush a port's buffer queues,
+    the command will force the component to return all buffers NOT CURRENTLY 
+    BEING PROCESSED to the application, in the order in which the buffers 
+    were received.
+    
+    When the command is "OMX_CommandPortDisable" or 
+    "OMX_CommandPortEnable", the component's port (given by the value of
+    nParam) will be stopped or restarted. 
+    
+    When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
+    pCmdData will point to a OMX_MARKTYPE structure containing the component
+    handle of the component to examine the buffer chain for the mark.  nParam1
+    contains the index of the port on which the buffer mark is applied.
+
+    Specification text for more details. 
+    
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [in] Cmd
+        Command for the component to execute
+    @param [in] nParam
+        Parameter for the command to be executed.  When Cmd has the value 
+        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has 
+        the value OMX_CommandFlush, value of nParam indicates which port(s) 
+        to flush. -1 is used to flush all ports a single port index will 
+        only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
+        or "OMX_CommandPortEnable", the component's port is given by 
+        the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
+        the components pot is given by the value of nParam.
+    @param [in] pCmdData
+        Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
+        "OMX_CommandMarkBuffer".     
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SendCommand(                                    \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                                          \
+     ((OMX_COMPONENTTYPE*)hComponent)->SendCommand(         \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                          /* Macro End */
+
+
+/** The OMX_GetParameter macro will get one of the current parameter 
+    settings from the component.  This macro cannot only be invoked when 
+    the component is in the OMX_StateInvalid state.  The nParamIndex
+    parameter is used to indicate which structure is being requested from
+    the component.  The application shall allocate the correct structure 
+    and shall fill in the structure size and version information before 
+    invoking this macro.  When the parameter applies to a port, the
+    caller shall fill in the appropriate nPortIndex value indicating the
+    port on which the parameter applies. If the component has not had 
+    any settings changed, then the component should return a set of 
+    valid DEFAULT  parameters for the component.  This is a blocking 
+    call.  
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nParamIndex
+        Index of the structure to be filled.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentParameterStructure
+        Pointer to application allocated structure to be filled by the 
+        component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetParameter(         \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The OMX_SetParameter macro will send an initialization parameter
+    structure to a component.  Each structure shall be sent one at a time,
+    in a separate invocation of the macro.  This macro can only be
+    invoked when the component is in the OMX_StateLoaded state, or the
+    port is disabled (when the parameter applies to a port). The 
+    nParamIndex parameter is used to indicate which structure is being
+    passed to the component.  The application shall allocate the 
+    correct structure and shall fill in the structure size and version 
+    information (as well as the actual data) before invoking this macro.
+    The application is free to dispose of this structure after the call
+    as the component is required to copy any data it shall retain.  This 
+    is a blocking call.  
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be sent.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in] pComponentParameterStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->SetParameter(         \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The OMX_GetConfig macro will get one of the configuration structures 
+    from a component.  This macro can be invoked anytime after the 
+    component has been loaded.  The nParamIndex call parameter is used to 
+    indicate which structure is being requested from the component.  The 
+    application shall allocate the correct structure and shall fill in the 
+    structure size and version information before invoking this macro.  
+    If the component has not had this configuration parameter sent before, 
+    then the component should return a set of valid DEFAULT values for the 
+    component.  This is a blocking call.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be filled.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentConfigStructure
+        pointer to application allocated structure to be filled by the 
+        component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+*/        
+#define OMX_GetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                           \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetConfig(            \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The OMX_SetConfig macro will send one of the configuration 
+    structures to a component.  Each structure shall be sent one at a time,
+    each in a separate invocation of the macro.  This macro can be invoked 
+    anytime after the component has been loaded.  The application shall 
+    allocate the correct structure and shall fill in the structure size 
+    and version information (as well as the actual data) before invoking 
+    this macro.  The application is free to dispose of this structure after 
+    the call as the component is required to copy any data it shall retain.  
+    This is a blocking call.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nConfigIndex
+        Index of the structure to be sent.  This value is from the
+        OMX_INDEXTYPE enumeration above.
+    @param [in] pComponentConfigStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                           \
+    ((OMX_COMPONENTTYPE*)hComponent)->SetConfig(            \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The OMX_GetExtensionIndex macro will invoke a component to translate 
+    a vendor specific configuration or parameter string into an OMX 
+    structure index.  There is no requirement for the vendor to support 
+    this command for the indexes already found in the OMX_INDEXTYPE 
+    enumeration (this is done to save space in small components).  The 
+    component shall support all vendor supplied extension indexes not found
+    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @param [in] cParameterName
+        OMX_STRING that shall be less than 128 characters long including
+        the trailing null byte.  This is the string that will get 
+        translated by the component into a configuration index.
+    @param [out] pIndexType
+        a pointer to a OMX_INDEXTYPE to receive the index value.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetExtensionIndex(                              \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex(    \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                     /* Macro End */
+
+
+/** The OMX_GetState macro will invoke the component to get the current 
+    state of the component and place the state value into the location
+    pointed to by pState.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] pState
+        pointer to the location to receive the state.  The value returned
+        is one of the OMX_STATETYPE members 
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetState(                                       \
+        hComponent,                                         \
+        pState)                                             \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetState(             \
+        hComponent,                                         \
+        pState)                         /* Macro End */
+
+
+/** The OMX_UseBuffer macro will request that the component use
+    a buffer (and allocate its own buffer header) already allocated 
+    by another component, or by the IL Client. This is a blocking 
+    call.
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
+        pointer to the buffer header
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+
+#define OMX_UseBuffer(                                      \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->UseBuffer(            \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)
+
+
+/** The OMX_AllocateBuffer macro will request that the component allocate 
+    a new buffer and buffer header.  The component will allocate the 
+    buffer and the buffer header and return a pointer to the buffer 
+    header.  This is a blocking call.
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive 
+        the pointer to the buffer header
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the 
+        buffer header structure.
+    @param [in] nSizeBytes
+        size of the buffer to allocate.  Used when bAllocateNew is true.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */    
+#define OMX_AllocateBuffer(                                 \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->AllocateBuffer(       \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                     /* Macro End */
+
+
+/** The OMX_FreeBuffer macro will release a buffer header from the component
+    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If  
+    the component allocated the buffer (see the OMX_UseBuffer macro) then 
+    the component shall free the buffer and buffer header. This is a 
+    blocking call. 
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_FreeBuffer(                                     \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer(           \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an 
+    input port of a component.  The buffer will be emptied by the component
+    and returned to the application via the EmptyBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then empty the buffer, later, at the proper 
+    time.  As expected, this macro may be invoked only while the component 
+    is in the OMX_StateExecuting.  If nPortIndex does not specify an input
+    port, the component shall return an error.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_EmptyThisBuffer(                                \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer(      \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The OMX_FillThisBuffer macro will send an empty buffer to an 
+    output port of a component.  The buffer will be filled by the component
+    and returned to the application via the FillBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then fill the buffer, later, at the proper 
+    time.  As expected, this macro may be invoked only while the component 
+    is in the OMX_ExecutingState.  If nPortIndex does not specify an output
+    port, the component shall return an error.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_FillThisBuffer(                                 \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer(       \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+
+/** The OMX_UseEGLImage macro will request that the component use
+    a EGLImage provided by EGL (and allocate its own buffer header)
+    This is a blocking call.
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
+        pointer to the buffer header.  Note that the memory location used
+        for this buffer is NOT visible to the IL Client.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the 
+        buffer header structure.
+    @param [in] eglImage
+        eglImage contains the handle of the EGLImage to use as a buffer on the
+        specified port.  The component is expected to validate properties of 
+        the EGLImage against the configuration of the port to ensure the component
+        can use the EGLImage as a buffer.          
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_UseEGLImage(                                    \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)                                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->UseEGLImage(          \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)
+
+/** The OMX_Init method is used to initialize the OMX core.  It shall be the
+    first call made into OMX and it should only be executed one time without
+    an interviening OMX_Deinit call.  
+    
+    The core should return from this call within 20 msec.
+
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);
+
+
+/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be 
+    the last call made into OMX. In the event that the core determines that 
+    thare are components loaded when this call is made, the core may return 
+    with an error rather than try to unload the components.
+        
+    The core should return from this call within 20 msec.
+    
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void);
+
+
+/** The OMX_ComponentNameEnum method will enumerate through all the names of
+    recognised valid components in the system. This function is provided
+    as a means to detect all the components in the system run-time. There is
+    no strict ordering to the enumeration order of component names, although
+    each name will only be enumerated once.  If the OMX core supports run-time
+    installation of new components, it is only requried to detect newly
+    installed components when the first call to enumerate component names
+    is made (i.e. when nIndex is 0x0).
+    
+    The core should return from this call in 20 msec.
+    
+    @param [out] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example 
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
+        assigned by the vendor, but shall start with "OMX." and then have 
+        the Vendor designation next.
+    @param [in] nNameLength
+        number of characters in the cComponentName string.  With all 
+        component name strings restricted to less than 128 characters 
+        (including the trailing null) it is recomended that the caller
+        provide a input string for the cComponentName of 128 characters.
+    @param [in] nIndex
+        number containing the enumeration index for the component. 
+        Multiple calls to OMX_ComponentNameEnum with increasing values
+        of nIndex will enumerate through the component names in the
+        system until OMX_ErrorNoMore is returned.  The value of nIndex
+        is 0 to (N-1), where N is the number of valid installed components
+        in the system.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  When the value of nIndex exceeds the number of 
+        components in the system minus 1, OMX_ErrorNoMore will be
+        returned. Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
+    OMX_OUT OMX_STRING cComponentName,
+    OMX_IN  OMX_U32 nNameLength,
+    OMX_IN  OMX_U32 nIndex);
+
+
+/** The OMX_GetHandle method will locate the component specified by the
+    component name given, load that component into memory and then invoke
+    the component's methods to create an instance of the component.  
+    
+    The core should return from this call within 20 msec.
+    
+    @param [out] pHandle
+        pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
+    @param [in] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example 
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
+        assigned by the vendor, but shall start with "OMX." and then have 
+        the Vendor designation next.
+    @param [in] pAppData
+        pointer to an application defined value that will be returned
+        during callbacks so that the application can identify the source
+        of the callback.
+    @param [in] pCallBacks
+        pointer to a OMX_CALLBACKTYPE structure that will be passed to the
+        component to initialize it with.  
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
+    OMX_OUT OMX_HANDLETYPE* pHandle, 
+    OMX_IN  OMX_STRING cComponentName,
+    OMX_IN  OMX_PTR pAppData,
+    OMX_IN  OMX_CALLBACKTYPE* pCallBacks);
+
+
+/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle 
+    method.  If the component reference count goes to zero, the component will
+    be unloaded from memory.  
+    
+    The core should return from this call within 20 msec when the component is 
+    in the OMX_StateLoaded state.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
+    OMX_IN  OMX_HANDLETYPE hComponent);
+
+
+
+/** The OMX_SetupTunnel method will handle the necessary calls to the components
+    to setup the specified tunnel the two components.  NOTE: This is
+    an actual method (not a #define macro).  This method will make calls into
+    the component ComponentTunnelRequest method to do the actual tunnel 
+    connection.  
+
+    The ComponentTunnelRequest method on both components will be called. 
+    This method shall not be called unless the component is in the 
+    OMX_StateLoaded state except when the ports used for the tunnel are
+    disabled. In this case, the component may be in the OMX_StateExecuting,
+    OMX_StatePause, or OMX_StateIdle states. 
+
+    The core should return from this call within 20 msec.
+    
+    @param [in] hOutput
+        Handle of the component to be accessed.  Also this is the handle
+        of the component whose port, specified in the nPortOutput parameter
+        will be used the source for the tunnel. This is the component handle
+        returned by the call to the OMX_GetHandle function.  There is a 
+        requirement that hOutput be the source for the data when
+        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
+        specified in hInput will have it's port specified in nPortInput
+        setup for communication with the application / IL client.
+    @param [in] nPortOutput
+        nPortOutput is used to select the source port on component to be
+        used in the tunnel. 
+    @param [in] hInput
+        This is the component to setup the tunnel with. This is the handle
+        of the component whose port, specified in the nPortInput parameter
+        will be used the destination for the tunnel. This is the component handle
+        returned by the call to the OMX_GetHandle function.  There is a 
+        requirement that hInput be the destination for the data when
+        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
+        specified in hOutput will have it's port specified in nPortPOutput
+        setup for communication with the application / IL client.
+    @param [in] nPortInput
+        nPortInput is used to select the destination port on component to be
+        used in the tunnel.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+        When OMX_ErrorNotImplemented is returned, one or both components is 
+        a non-interop component and does not support tunneling.
+        
+        On failure, the ports of both components are setup for communication
+        with the application / IL Client.
+    @ingroup core tun
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
+    OMX_IN  OMX_HANDLETYPE hOutput,
+    OMX_IN  OMX_U32 nPortOutput,
+    OMX_IN  OMX_HANDLETYPE hInput,
+    OMX_IN  OMX_U32 nPortInput);
+    
+/** @ingroup cp */
+OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
+    OMX_OUT OMX_HANDLETYPE *hPipe,
+    OMX_IN OMX_STRING szURI);
+
+/** The OMX_GetComponentsOfRole method will return the number of components that support the given
+    role and (if the compNames field is non-NULL) the names of those components. The call will fail if 
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the compNames field NULL to determine the number of component names
+        * second call this function with the compNames field pointing to an array of names allocated 
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+    
+    @param [in] role
+        This is generic standard component name consisting only of component class 
+        name and the type within that class (e.g. 'audio_decoder.aac').
+    @param [inout] pNumComps
+        This is used both as input and output. 
+ 
+        If compNames is NULL, the input is ignored and the output specifies how many components support
+        the given role.
+     
+        If compNames is not NULL, on input it bounds the size of the input structure and 
+        on output, it specifies the number of components string names listed within the compNames parameter.
+    @param [inout] compNames
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts 
+        a list of the names of all physical components that implement the specified standard component name. 
+        Each name is NULL terminated. numComps indicates the number of names.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole ( 
+	OMX_IN      OMX_STRING role,
+    OMX_INOUT   OMX_U32 *pNumComps,
+    OMX_INOUT   OMX_U8  **compNames);
+
+/** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
+    component and (if the roles field is non-NULL) the names of those roles. The call will fail if 
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the roles field NULL to determine the number of role names
+        * second call this function with the roles field pointing to an array of names allocated 
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+
+    @param [in] compName
+        This is the name of the component being queried about.
+    @param [inout] pNumRoles
+        This is used both as input and output. 
+ 
+        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
+     
+        If compNames is not NULL, on input it bounds the size of the input structure and 
+        on output, it specifies the number of roles string names listed within the roles parameter.
+    @param [out] roles
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings 
+        which accepts a list of the names of all standard components roles implemented on the 
+        specified component name. numComps indicates the number of names.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent ( 
+	OMX_IN      OMX_STRING compName, 
+    OMX_INOUT   OMX_U32 *pNumRoles,
+    OMX_OUT     OMX_U8 **roles);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/omx/headers/OMX_IVCommon.h b/omx/headers/OMX_IVCommon.h
index 144be87..4c4995c 100644
--- a/omx/headers/OMX_IVCommon.h
+++ b/omx/headers/OMX_IVCommon.h
@@ -1,896 +1,920 @@
-/**
- * Copyright (c) 2007 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** 
- * @file OMX_IVCommon.h - OpenMax IL version 1.1.1
- *  The structures needed by Video and Image components to exchange
- *  parameters and configuration data with the components.
- */
-#ifndef OMX_IVCommon_h
-#define OMX_IVCommon_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/**
- * Each OMX header must include all required header files to allow the header
- * to compile without errors.  The includes below are required for this header
- * file to compile successfully 
- */
-
-#include <OMX_Core.h>
-
-/** @defgroup iv OpenMAX IL Imaging and Video Domain
- * Common structures for OpenMAX IL Imaging and Video domains
- * @{
- */
-
-
-/** 
- * Enumeration defining possible uncompressed image/video formats. 
- *
- * ENUMS:
- *  Unused                 : Placeholder value when format is N/A
- *  Monochrome             : black and white
- *  8bitRGB332             : Red 7:5, Green 4:2, Blue 1:0
- *  12bitRGB444            : Red 11:8, Green 7:4, Blue 3:0
- *  16bitARGB4444          : Alpha 15:12, Red 11:8, Green 7:4, Blue 3:0
- *  16bitARGB1555          : Alpha 15, Red 14:10, Green 9:5, Blue 4:0
- *  16bitRGB565            : Red 15:11, Green 10:5, Blue 4:0
- *  16bitBGR565            : Blue 15:11, Green 10:5, Red 4:0
- *  18bitRGB666            : Red 17:12, Green 11:6, Blue 5:0
- *  18bitARGB1665          : Alpha 17, Red 16:11, Green 10:5, Blue 4:0
- *  19bitARGB1666          : Alpha 18, Red 17:12, Green 11:6, Blue 5:0
- *  24bitRGB888            : Red 24:16, Green 15:8, Blue 7:0
- *  24bitBGR888            : Blue 24:16, Green 15:8, Red 7:0
- *  24bitARGB1887          : Alpha 23, Red 22:15, Green 14:7, Blue 6:0
- *  25bitARGB1888          : Alpha 24, Red 23:16, Green 15:8, Blue 7:0
- *  32bitBGRA8888          : Blue 31:24, Green 23:16, Red 15:8, Alpha 7:0
- *  32bitARGB8888          : Alpha 31:24, Red 23:16, Green 15:8, Blue 7:0
- *  YUV411Planar           : U,Y are subsampled by a factor of 4 horizontally
- *  YUV411PackedPlanar     : packed per payload in planar slices
- *  YUV420Planar           : Three arrays Y,U,V.
- *  YUV420PackedPlanar     : packed per payload in planar slices
- *  YUV420SemiPlanar       : Two arrays, one is all Y, the other is U and V
- *  YUV422Planar           : Three arrays Y,U,V.
- *  YUV422PackedPlanar     : packed per payload in planar slices
- *  YUV422SemiPlanar       : Two arrays, one is all Y, the other is U and V
- *  YCbYCr                 : Organized as 16bit YUYV (i.e. YCbYCr)
- *  YCrYCb                 : Organized as 16bit YVYU (i.e. YCrYCb)
- *  CbYCrY                 : Organized as 16bit UYVY (i.e. CbYCrY)
- *  CrYCbY                 : Organized as 16bit VYUY (i.e. CrYCbY)
- *  YUV444Interleaved      : Each pixel contains equal parts YUV
- *  RawBayer8bit           : SMIA camera output format
- *  RawBayer10bit          : SMIA camera output format
- *  RawBayer8bitcompressed : SMIA camera output format
- */
-typedef enum OMX_COLOR_FORMATTYPE {
-    OMX_COLOR_FormatUnused,
-    OMX_COLOR_FormatMonochrome,
-    OMX_COLOR_Format8bitRGB332,
-    OMX_COLOR_Format12bitRGB444,
-    OMX_COLOR_Format16bitARGB4444,
-    OMX_COLOR_Format16bitARGB1555,
-    OMX_COLOR_Format16bitRGB565,
-    OMX_COLOR_Format16bitBGR565,
-    OMX_COLOR_Format18bitRGB666,
-    OMX_COLOR_Format18bitARGB1665,
-    OMX_COLOR_Format19bitARGB1666, 
-    OMX_COLOR_Format24bitRGB888,
-    OMX_COLOR_Format24bitBGR888,
-    OMX_COLOR_Format24bitARGB1887,
-    OMX_COLOR_Format25bitARGB1888,
-    OMX_COLOR_Format32bitBGRA8888,
-    OMX_COLOR_Format32bitARGB8888,
-    OMX_COLOR_FormatYUV411Planar,
-    OMX_COLOR_FormatYUV411PackedPlanar,
-    OMX_COLOR_FormatYUV420Planar,
-    OMX_COLOR_FormatYUV420PackedPlanar,
-    OMX_COLOR_FormatYUV420SemiPlanar,
-    OMX_COLOR_FormatYUV422Planar,
-    OMX_COLOR_FormatYUV422PackedPlanar,
-    OMX_COLOR_FormatYUV422SemiPlanar,
-    OMX_COLOR_FormatYCbYCr,
-    OMX_COLOR_FormatYCrYCb,
-    OMX_COLOR_FormatCbYCrY,
-    OMX_COLOR_FormatCrYCbY,
-    OMX_COLOR_FormatYUV444Interleaved,
-    OMX_COLOR_FormatRawBayer8bit,
-    OMX_COLOR_FormatRawBayer10bit,
-    OMX_COLOR_FormatRawBayer8bitcompressed,
-    OMX_COLOR_FormatL2, 
-    OMX_COLOR_FormatL4, 
-    OMX_COLOR_FormatL8, 
-    OMX_COLOR_FormatL16, 
-    OMX_COLOR_FormatL24, 
-    OMX_COLOR_FormatL32,
-    OMX_COLOR_FormatYUV420PackedSemiPlanar,
-    OMX_COLOR_FormatYUV422PackedSemiPlanar,
-    OMX_COLOR_Format18BitBGR666,
-    OMX_COLOR_Format24BitARGB6666,
-    OMX_COLOR_Format24BitABGR6666,
-    OMX_COLOR_FormatMax = 0x7FFFFFFF
-} OMX_COLOR_FORMATTYPE;
-
-
-/** 
- * Defines the matrix for conversion from RGB to YUV or vice versa.
- * iColorMatrix should be initialized with the fixed point values 
- * used in converting between formats.
- */
-typedef struct OMX_CONFIG_COLORCONVERSIONTYPE {
-    OMX_U32 nSize;              /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */ 
-    OMX_U32 nPortIndex;         /**< Port that this struct applies to */
-    OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
-    OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
-}OMX_CONFIG_COLORCONVERSIONTYPE;
-
-
-/** 
- * Structure defining percent to scale each frame dimension.  For example:  
- * To make the width 50% larger, use fWidth = 1.5 and to make the width
- * 1/2 the original size, use fWidth = 0.5
- */
-typedef struct OMX_CONFIG_SCALEFACTORTYPE {
-    OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */ 
-    OMX_U32 nPortIndex;       /**< Port that this struct applies to */
-    OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
-    OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
-}OMX_CONFIG_SCALEFACTORTYPE;
-
-
-/** 
- * Enumeration of possible image filter types 
- */
-typedef enum OMX_IMAGEFILTERTYPE {
-    OMX_ImageFilterNone,
-    OMX_ImageFilterNoise,
-    OMX_ImageFilterEmboss,
-    OMX_ImageFilterNegative,
-    OMX_ImageFilterSketch,
-    OMX_ImageFilterOilPaint,
-    OMX_ImageFilterHatch,
-    OMX_ImageFilterGpen,
-    OMX_ImageFilterAntialias, 
-    OMX_ImageFilterDeRing,       
-    OMX_ImageFilterSolarize,
-    OMX_ImageFilterMax = 0x7FFFFFFF
-} OMX_IMAGEFILTERTYPE;
-
-
-/** 
- * Image filter configuration 
- *
- * STRUCT MEMBERS:
- *  nSize        : Size of the structure in bytes       
- *  nVersion     : OMX specification version information
- *  nPortIndex   : Port that this structure applies to 
- *  eImageFilter : Image filter type enumeration      
- */
-typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGEFILTERTYPE eImageFilter;
-} OMX_CONFIG_IMAGEFILTERTYPE;
-
-
-/** 
- * Customized U and V for color enhancement 
- *
- * STRUCT MEMBERS:
- *  nSize             : Size of the structure in bytes
- *  nVersion          : OMX specification version information 
- *  nPortIndex        : Port that this structure applies to
- *  bColorEnhancement : Enable/disable color enhancement
- *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for 
- *                      U component
- *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for 
- *                      V component
- */
-typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion; 
-    OMX_U32 nPortIndex;
-    OMX_BOOL bColorEnhancement;
-    OMX_U8 nCustomizedU;
-    OMX_U8 nCustomizedV;
-} OMX_CONFIG_COLORENHANCEMENTTYPE;
-
-
-/** 
- * Define color key and color key mask 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to
- *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
- *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
- */
-typedef struct OMX_CONFIG_COLORKEYTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nARGBColor;
-    OMX_U32 nARGBMask;
-} OMX_CONFIG_COLORKEYTYPE;
-
-
-/** 
- * List of color blend types for pre/post processing 
- *
- * ENUMS:
- *  None          : No color blending present
- *  AlphaConstant : Function is (alpha_constant * src) + 
- *                  (1 - alpha_constant) * dst)
- *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
- *  Alternate     : Function is alternating pixels from src and dst
- *  And           : Function is (src & dst)
- *  Or            : Function is (src | dst)
- *  Invert        : Function is ~src
- */
-typedef enum OMX_COLORBLENDTYPE {
-    OMX_ColorBlendNone,
-    OMX_ColorBlendAlphaConstant,
-    OMX_ColorBlendAlphaPerPixel,
-    OMX_ColorBlendAlternate,
-    OMX_ColorBlendAnd,
-    OMX_ColorBlendOr,
-    OMX_ColorBlendInvert,
-    OMX_ColorBlendMax = 0x7FFFFFFF
-} OMX_COLORBLENDTYPE;
-
-
-/** 
- * Color blend configuration 
- *
- * STRUCT MEMBERS:
- *  nSize             : Size of the structure in bytes                        
- *  nVersion          : OMX specification version information                
- *  nPortIndex        : Port that this structure applies to                   
- *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
- *  eColorBlend       : Color blend type enumeration                         
- */
-typedef struct OMX_CONFIG_COLORBLENDTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nRGBAlphaConstant;
-    OMX_COLORBLENDTYPE  eColorBlend;
-} OMX_CONFIG_COLORBLENDTYPE;
-
-
-/** 
- * Hold frame dimension
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes      
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to     
- *  nWidth     : Frame width in pixels                 
- *  nHeight    : Frame height in pixels                
- */
-typedef struct OMX_FRAMESIZETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nWidth;
-    OMX_U32 nHeight;
-} OMX_FRAMESIZETYPE;
-
-
-/**
- * Rotation configuration 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes             
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nRotation  : +/- integer rotation value               
- */
-typedef struct OMX_CONFIG_ROTATIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nRotation; 
-} OMX_CONFIG_ROTATIONTYPE;
-
-
-/** 
- * Possible mirroring directions for pre/post processing 
- *
- * ENUMS:
- *  None       : No mirroring                         
- *  Vertical   : Vertical mirroring, flip on X axis   
- *  Horizontal : Horizontal mirroring, flip on Y axis  
- *  Both       : Both vertical and horizontal mirroring
- */
-typedef enum OMX_MIRRORTYPE {
-    OMX_MirrorNone = 0,
-    OMX_MirrorVertical,
-    OMX_MirrorHorizontal,
-    OMX_MirrorBoth, 
-    OMX_MirrorMax = 0x7FFFFFFF   
-} OMX_MIRRORTYPE;
-
-
-/** 
- * Mirroring configuration 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes      
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to  
- *  eMirror    : Mirror type enumeration              
- */
-typedef struct OMX_CONFIG_MIRRORTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion; 
-    OMX_U32 nPortIndex;
-    OMX_MIRRORTYPE  eMirror;
-} OMX_CONFIG_MIRRORTYPE;
-
-
-/** 
- * Position information only 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes               
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nX         : X coordinate for the point                     
- *  nY         : Y coordinate for the point 
- */                      
-typedef struct OMX_CONFIG_POINTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nX;
-    OMX_S32 nY;
-} OMX_CONFIG_POINTTYPE;
-
-
-/** 
- * Frame size plus position 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes                    
- *  nVersion   : OMX specification version information      
- *  nPortIndex : Port that this structure applies to    
- *  nLeft      : X Coordinate of the top left corner of the rectangle
- *  nTop       : Y Coordinate of the top left corner of the rectangle
- *  nWidth     : Width of the rectangle                              
- *  nHeight    : Height of the rectangle                             
- */
-typedef struct OMX_CONFIG_RECTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;  
-    OMX_U32 nPortIndex; 
-    OMX_S32 nLeft; 
-    OMX_S32 nTop;
-    OMX_U32 nWidth;
-    OMX_U32 nHeight;
-} OMX_CONFIG_RECTTYPE;
-
-
-/** 
- * Deblocking state; it is required to be set up before starting the codec 
- *
- * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes      
- *  nVersion    : OMX specification version information 
- *  nPortIndex  : Port that this structure applies to
- *  bDeblocking : Enable/disable deblocking mode    
- */
-typedef struct OMX_PARAM_DEBLOCKINGTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bDeblocking;
-} OMX_PARAM_DEBLOCKINGTYPE;
-
-
-/** 
- * Stabilization state 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes          
- *  nVersion   : OMX specification version information    
- *  nPortIndex : Port that this structure applies to   
- *  bStab      : Enable/disable frame stabilization state
- */
-typedef struct OMX_CONFIG_FRAMESTABTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bStab;
-} OMX_CONFIG_FRAMESTABTYPE;
-
-
-/** 
- * White Balance control type 
- *
- * STRUCT MEMBERS:
- *  SunLight : Referenced in JSR-234
- *  Flash    : Optimal for device's integrated flash
- */
-typedef enum OMX_WHITEBALCONTROLTYPE {
-    OMX_WhiteBalControlOff = 0,
-    OMX_WhiteBalControlAuto,
-    OMX_WhiteBalControlSunLight,
-    OMX_WhiteBalControlCloudy,
-    OMX_WhiteBalControlShade,
-    OMX_WhiteBalControlTungsten,
-    OMX_WhiteBalControlFluorescent,
-    OMX_WhiteBalControlIncandescent,
-    OMX_WhiteBalControlFlash,
-    OMX_WhiteBalControlHorizon,
-    OMX_WhiteBalControlMax = 0x7FFFFFFF
-} OMX_WHITEBALCONTROLTYPE;
-
-
-/** 
- * White Balance control configuration 
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes       
- *  nVersion         : OMX specification version information
- *  nPortIndex       : Port that this structure applies to                 
- *  eWhiteBalControl : White balance enumeration            
- */
-typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_WHITEBALCONTROLTYPE eWhiteBalControl;
-} OMX_CONFIG_WHITEBALCONTROLTYPE;
-
-
-/** 
- * Exposure control type 
- */
-typedef enum OMX_EXPOSURECONTROLTYPE {
-    OMX_ExposureControlOff = 0,
-    OMX_ExposureControlAuto,
-    OMX_ExposureControlNight,
-    OMX_ExposureControlBackLight,
-    OMX_ExposureControlSpotLight,
-    OMX_ExposureControlSports,
-    OMX_ExposureControlSnow,
-    OMX_ExposureControlBeach,
-    OMX_ExposureControlLargeAperture,
-    OMX_ExposureControlSmallApperture,
-    OMX_ExposureControlMax = 0x7FFFFFFF
-} OMX_EXPOSURECONTROLTYPE;
-
-
-/** 
- * White Balance control configuration 
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes      
- *  nVersion         : OMX specification version information
- *  nPortIndex       : Port that this structure applies to                
- *  eExposureControl : Exposure control enumeration         
- */
-typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_EXPOSURECONTROLTYPE eExposureControl;
-} OMX_CONFIG_EXPOSURECONTROLTYPE;
-
-
-/** 
- * Defines sensor supported mode. 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes           
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to 
- *  nFrameRate : Single shot mode is indicated by a 0     
- *  bOneShot   : Enable for single shot, disable for streaming
- *  sFrameSize : Framesize                                          
- */
-typedef struct OMX_PARAM_SENSORMODETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nFrameRate;
-    OMX_BOOL bOneShot;
-    OMX_FRAMESIZETYPE sFrameSize;
-} OMX_PARAM_SENSORMODETYPE;
-
-
-/** 
- * Defines contrast level 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes                              
- *  nVersion   : OMX specification version information                
- *  nPortIndex : Port that this structure applies to                 
- *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
- */
-typedef struct OMX_CONFIG_CONTRASTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nContrast;
-} OMX_CONFIG_CONTRASTTYPE;
-
-
-/** 
- * Defines brightness level 
- *
- * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes          
- *  nVersion    : OMX specification version information 
- *  nPortIndex  : Port that this structure applies to 
- *  nBrightness : 0-100%        
- */
-typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nBrightness;
-} OMX_CONFIG_BRIGHTNESSTYPE;
-
-
-/** 
- * Defines backlight level configuration for a video sink, e.g. LCD panel 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to
- *  nBacklight : Values allowed for backlight 0-100%
- *  nTimeout   : Number of milliseconds before backlight automatically turns 
- *               off.  A value of 0x0 disables backight timeout 
- */
-typedef struct OMX_CONFIG_BACKLIGHTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nBacklight;
-    OMX_U32 nTimeout;
-} OMX_CONFIG_BACKLIGHTTYPE;
-
-
-/** 
- * Defines setting for Gamma 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to
- *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
- */
-typedef struct OMX_CONFIG_GAMMATYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nGamma;
-} OMX_CONFIG_GAMMATYPE;
-
-
-/** 
- * Define for setting saturation 
- * 
- * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes
- *  nVersion    : OMX specification version information
- *  nPortIndex  : Port that this structure applies to
- *  nSaturation : Values allowed for saturation -100 to 100, zero means 
- *                no change
- */
-typedef struct OMX_CONFIG_SATURATIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nSaturation;
-} OMX_CONFIG_SATURATIONTYPE;
-
-
-/** 
- * Define for setting Lightness 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nLightness : Values allowed for lightness -100 to 100, zero means no 
- *               change
- */
-typedef struct OMX_CONFIG_LIGHTNESSTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nLightness;
-} OMX_CONFIG_LIGHTNESSTYPE;
-
-
-/** 
- * Plane blend configuration 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes 
- *  nVersion   : OMX specification version information
- *  nPortIndex : Index of input port associated with the plane.
- *  nDepth     : Depth of the plane in relation to the screen. Higher 
- *               numbered depths are "behind" lower number depths.  
- *               This number defaults to the Port Index number.
- *  nAlpha     : Transparency blending component for the entire plane.  
- *               See blending modes for more detail.
- */
-typedef struct OMX_CONFIG_PLANEBLENDTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nDepth;
-    OMX_U32 nAlpha;
-} OMX_CONFIG_PLANEBLENDTYPE;
-
-
-/** 
- * Define interlace type
- *
- * STRUCT MEMBERS:
- *  nSize                 : Size of the structure in bytes 
- *  nVersion              : OMX specification version information 
- *  nPortIndex            : Port that this structure applies to
- *  bEnable               : Enable control variable for this functionality 
- *                          (see below)
- *  nInterleavePortIndex  : Index of input or output port associated with  
- *                          the interleaved plane. 
- *  pPlanarPortIndexes[4] : Index of input or output planar ports.
- */
-typedef struct OMX_PARAM_INTERLEAVETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bEnable;
-    OMX_U32 nInterleavePortIndex;
-} OMX_PARAM_INTERLEAVETYPE;
-
-
-/** 
- * Defines the picture effect used for an input picture 
- */
-typedef enum OMX_TRANSITIONEFFECTTYPE {
-    OMX_EffectNone,
-    OMX_EffectFadeFromBlack,
-    OMX_EffectFadeToBlack,
-    OMX_EffectUnspecifiedThroughConstantColor,
-    OMX_EffectDissolve,
-    OMX_EffectWipe,
-    OMX_EffectUnspecifiedMixOfTwoScenes,
-    OMX_EffectMax = 0x7FFFFFFF
-} OMX_TRANSITIONEFFECTTYPE;
-
-
-/** 
- * Structure used to configure current transition effect 
- *
- * STRUCT MEMBERS:
- * nSize      : Size of the structure in bytes
- * nVersion   : OMX specification version information 
- * nPortIndex : Port that this structure applies to
- * eEffect    : Effect to enable
- */
-typedef struct OMX_CONFIG_TRANSITIONEFFECTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_TRANSITIONEFFECTTYPE eEffect;
-} OMX_CONFIG_TRANSITIONEFFECTTYPE;
-
-
-/** 
- * Defines possible data unit types for encoded video data. The data unit 
- * types are used both for encoded video input for playback as well as
- * encoded video output from recording. 
- */
-typedef enum OMX_DATAUNITTYPE {
-    OMX_DataUnitCodedPicture,
-    OMX_DataUnitVideoSegment,
-    OMX_DataUnitSeveralSegments,
-    OMX_DataUnitArbitraryStreamSection,
-    OMX_DataUnitMax = 0x7FFFFFFF
-} OMX_DATAUNITTYPE;
-
-
-/** 
- * Defines possible encapsulation types for coded video data unit. The 
- * encapsulation information is used both for encoded video input for 
- * playback as well as encoded video output from recording. 
- */
-typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
-    OMX_DataEncapsulationElementaryStream,
-    OMX_DataEncapsulationGenericPayload,
-    OMX_DataEncapsulationRtpPayload,
-    OMX_DataEncapsulationMax = 0x7FFFFFFF
-} OMX_DATAUNITENCAPSULATIONTYPE;
-
-
-/** 
- * Structure used to configure the type of being decoded/encoded 
- */
-typedef struct OMX_PARAM_DATAUNITTYPE {
-    OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
-    OMX_DATAUNITTYPE eUnitType;
-    OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
-} OMX_PARAM_DATAUNITTYPE;
-
-
-/**
- * Defines dither types 
- */
-typedef enum OMX_DITHERTYPE {
-    OMX_DitherNone,
-    OMX_DitherOrdered,
-    OMX_DitherErrorDiffusion,
-    OMX_DitherOther,
-    OMX_DitherMax = 0x7FFFFFFF
-} OMX_DITHERTYPE;
-
-
-/** 
- * Structure used to configure current type of dithering 
- */
-typedef struct OMX_CONFIG_DITHERTYPE {
-    OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
-    OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
-} OMX_CONFIG_DITHERTYPE;
-
-typedef struct OMX_CONFIG_CAPTUREMODETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;     /**< Port that this structure applies to */
-    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture 
-                             *   data as fast as possible (otherwise obey port's frame rate). */
-    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the 
-                             *   specified number of frames (otherwise the port does not 
-                             *   terminate the capture until instructed to do so by the client). 
-                             *   Even if set, the client may manually terminate the capture prior 
-                             *   to reaching the limit. */
-    OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
-                               *   valid if bFrameLimited is set). */
-} OMX_CONFIG_CAPTUREMODETYPE;
-
-typedef enum OMX_METERINGTYPE {
- 
-    OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
-    OMX_MeteringModeSpot,  	      /**< Spot (partial) metering. */
-    OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
- 
-    OMX_EVModeMax = 0x7ffffff
-} OMX_METERINGTYPE;
- 
-typedef struct OMX_CONFIG_EXPOSUREVALUETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_METERINGTYPE eMetering;
-    OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
-    OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
-    OMX_BOOL bAutoAperture;		/**< Whether aperture number is defined automatically */
-    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */ 
-    OMX_BOOL bAutoShutterSpeed;	/**< Whether shutter speed is defined automatically */ 
-    OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
-    OMX_BOOL bAutoSensitivity;	/**< Whether sensitivity is defined automatically */
-} OMX_CONFIG_EXPOSUREVALUETYPE;
-
-/** 
- * Focus region configuration 
- *
- * STRUCT MEMBERS:
- *  nSize           : Size of the structure in bytes
- *  nVersion        : OMX specification version information
- *  nPortIndex      : Port that this structure applies to
- *  bCenter         : Use center region as focus region of interest
- *  bLeft           : Use left region as focus region of interest
- *  bRight          : Use right region as focus region of interest
- *  bTop            : Use top region as focus region of interest
- *  bBottom         : Use bottom region as focus region of interest
- *  bTopLeft        : Use top left region as focus region of interest
- *  bTopRight       : Use top right region as focus region of interest
- *  bBottomLeft     : Use bottom left region as focus region of interest
- *  bBottomRight    : Use bottom right region as focus region of interest
- */
-typedef struct OMX_CONFIG_FOCUSREGIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bCenter;
-    OMX_BOOL bLeft;
-    OMX_BOOL bRight;
-    OMX_BOOL bTop;
-    OMX_BOOL bBottom;
-    OMX_BOOL bTopLeft;
-    OMX_BOOL bTopRight;
-    OMX_BOOL bBottomLeft;
-    OMX_BOOL bBottomRight;
-} OMX_CONFIG_FOCUSREGIONTYPE;
-
-/** 
- * Focus Status type 
- */
-typedef enum OMX_FOCUSSTATUSTYPE {
-    OMX_FocusStatusOff = 0,
-    OMX_FocusStatusRequest,
-    OMX_FocusStatusReached,
-    OMX_FocusStatusUnableToReach,
-    OMX_FocusStatusLost,
-    OMX_FocusStatusMax = 0x7FFFFFFF
-} OMX_FOCUSSTATUSTYPE;
-
-/** 
- * Focus status configuration 
- *
- * STRUCT MEMBERS:
- *  nSize               : Size of the structure in bytes
- *  nVersion            : OMX specification version information
- *  nPortIndex          : Port that this structure applies to
- *  eFocusStatus        : Specifies the focus status
- *  bCenterStatus       : Use center region as focus region of interest
- *  bLeftStatus         : Use left region as focus region of interest
- *  bRightStatus        : Use right region as focus region of interest
- *  bTopStatus          : Use top region as focus region of interest
- *  bBottomStatus       : Use bottom region as focus region of interest
- *  bTopLeftStatus      : Use top left region as focus region of interest
- *  bTopRightStatus     : Use top right region as focus region of interest
- *  bBottomLeftStatus   : Use bottom left region as focus region of interest
- *  bBottomRightStatus  : Use bottom right region as focus region of interest
- */
-typedef struct OMX_PARAM_FOCUSSTATUSTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_FOCUSSTATUSTYPE eFocusStatus;
-    OMX_BOOL bCenterStatus;
-    OMX_BOOL bLeftStatus;
-    OMX_BOOL bRightStatus;
-    OMX_BOOL bTopStatus;
-    OMX_BOOL bBottomStatus;
-    OMX_BOOL bTopLeftStatus;
-    OMX_BOOL bTopRightStatus;
-    OMX_BOOL bBottomLeftStatus;
-    OMX_BOOL bBottomRightStatus;
-} OMX_PARAM_FOCUSSTATUSTYPE;
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
+/**
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** 
+ * @file OMX_IVCommon.h - OpenMax IL version 1.1.2
+ *  The structures needed by Video and Image components to exchange
+ *  parameters and configuration data with the components.
+ */
+#ifndef OMX_IVCommon_h
+#define OMX_IVCommon_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/**
+ * Each OMX header must include all required header files to allow the header
+ * to compile without errors.  The includes below are required for this header
+ * file to compile successfully 
+ */
+
+#include <OMX_Core.h>
+
+/** @defgroup iv OpenMAX IL Imaging and Video Domain
+ * Common structures for OpenMAX IL Imaging and Video domains
+ * @{
+ */
+
+
+/** 
+ * Enumeration defining possible uncompressed image/video formats. 
+ *
+ * ENUMS:
+ *  Unused                 : Placeholder value when format is N/A
+ *  Monochrome             : black and white
+ *  8bitRGB332             : Red 7:5, Green 4:2, Blue 1:0
+ *  12bitRGB444            : Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB4444          : Alpha 15:12, Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB1555          : Alpha 15, Red 14:10, Green 9:5, Blue 4:0
+ *  16bitRGB565            : Red 15:11, Green 10:5, Blue 4:0
+ *  16bitBGR565            : Blue 15:11, Green 10:5, Red 4:0
+ *  18bitRGB666            : Red 17:12, Green 11:6, Blue 5:0
+ *  18bitARGB1665          : Alpha 17, Red 16:11, Green 10:5, Blue 4:0
+ *  19bitARGB1666          : Alpha 18, Red 17:12, Green 11:6, Blue 5:0
+ *  24bitRGB888            : Red 24:16, Green 15:8, Blue 7:0
+ *  24bitBGR888            : Blue 24:16, Green 15:8, Red 7:0
+ *  24bitARGB1887          : Alpha 23, Red 22:15, Green 14:7, Blue 6:0
+ *  25bitARGB1888          : Alpha 24, Red 23:16, Green 15:8, Blue 7:0
+ *  32bitBGRA8888          : Blue 31:24, Green 23:16, Red 15:8, Alpha 7:0
+ *  32bitARGB8888          : Alpha 31:24, Red 23:16, Green 15:8, Blue 7:0
+ *  YUV411Planar           : U,Y are subsampled by a factor of 4 horizontally
+ *  YUV411PackedPlanar     : packed per payload in planar slices
+ *  YUV420Planar           : Three arrays Y,U,V.
+ *  YUV420PackedPlanar     : packed per payload in planar slices
+ *  YUV420SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YUV422Planar           : Three arrays Y,U,V.
+ *  YUV422PackedPlanar     : packed per payload in planar slices
+ *  YUV422SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YCbYCr                 : Organized as 16bit YUYV (i.e. YCbYCr)
+ *  YCrYCb                 : Organized as 16bit YVYU (i.e. YCrYCb)
+ *  CbYCrY                 : Organized as 16bit UYVY (i.e. CbYCrY)
+ *  CrYCbY                 : Organized as 16bit VYUY (i.e. CrYCbY)
+ *  YUV444Interleaved      : Each pixel contains equal parts YUV
+ *  RawBayer8bit           : SMIA camera output format
+ *  RawBayer10bit          : SMIA camera output format
+ *  RawBayer8bitcompressed : SMIA camera output format
+ */
+typedef enum OMX_COLOR_FORMATTYPE {
+    OMX_COLOR_FormatUnused,
+    OMX_COLOR_FormatMonochrome,
+    OMX_COLOR_Format8bitRGB332,
+    OMX_COLOR_Format12bitRGB444,
+    OMX_COLOR_Format16bitARGB4444,
+    OMX_COLOR_Format16bitARGB1555,
+    OMX_COLOR_Format16bitRGB565,
+    OMX_COLOR_Format16bitBGR565,
+    OMX_COLOR_Format18bitRGB666,
+    OMX_COLOR_Format18bitARGB1665,
+    OMX_COLOR_Format19bitARGB1666, 
+    OMX_COLOR_Format24bitRGB888,
+    OMX_COLOR_Format24bitBGR888,
+    OMX_COLOR_Format24bitARGB1887,
+    OMX_COLOR_Format25bitARGB1888,
+    OMX_COLOR_Format32bitBGRA8888,
+    OMX_COLOR_Format32bitARGB8888,
+    OMX_COLOR_FormatYUV411Planar,
+    OMX_COLOR_FormatYUV411PackedPlanar,
+    OMX_COLOR_FormatYUV420Planar,
+    OMX_COLOR_FormatYUV420PackedPlanar,
+    OMX_COLOR_FormatYUV420SemiPlanar,
+    OMX_COLOR_FormatYUV422Planar,
+    OMX_COLOR_FormatYUV422PackedPlanar,
+    OMX_COLOR_FormatYUV422SemiPlanar,
+    OMX_COLOR_FormatYCbYCr,
+    OMX_COLOR_FormatYCrYCb,
+    OMX_COLOR_FormatCbYCrY,
+    OMX_COLOR_FormatCrYCbY,
+    OMX_COLOR_FormatYUV444Interleaved,
+    OMX_COLOR_FormatRawBayer8bit,
+    OMX_COLOR_FormatRawBayer10bit,
+    OMX_COLOR_FormatRawBayer8bitcompressed,
+    OMX_COLOR_FormatL2, 
+    OMX_COLOR_FormatL4, 
+    OMX_COLOR_FormatL8, 
+    OMX_COLOR_FormatL16, 
+    OMX_COLOR_FormatL24, 
+    OMX_COLOR_FormatL32,
+    OMX_COLOR_FormatYUV420PackedSemiPlanar,
+    OMX_COLOR_FormatYUV422PackedSemiPlanar,
+    OMX_COLOR_Format18BitBGR666,
+    OMX_COLOR_Format24BitARGB6666,
+    OMX_COLOR_Format24BitABGR6666,
+    OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_COLOR_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_COLOR_FormatMax = 0x7FFFFFFF
+} OMX_COLOR_FORMATTYPE;
+
+
+/** 
+ * Defines the matrix for conversion from RGB to YUV or vice versa.
+ * iColorMatrix should be initialized with the fixed point values 
+ * used in converting between formats.
+ */
+typedef struct OMX_CONFIG_COLORCONVERSIONTYPE {
+    OMX_U32 nSize;              /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */ 
+    OMX_U32 nPortIndex;         /**< Port that this struct applies to */
+    OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
+    OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
+}OMX_CONFIG_COLORCONVERSIONTYPE;
+
+
+/** 
+ * Structure defining percent to scale each frame dimension.  For example:  
+ * To make the width 50% larger, use fWidth = 1.5 and to make the width
+ * 1/2 the original size, use fWidth = 0.5
+ */
+typedef struct OMX_CONFIG_SCALEFACTORTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */ 
+    OMX_U32 nPortIndex;       /**< Port that this struct applies to */
+    OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
+    OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
+}OMX_CONFIG_SCALEFACTORTYPE;
+
+
+/** 
+ * Enumeration of possible image filter types 
+ */
+typedef enum OMX_IMAGEFILTERTYPE {
+    OMX_ImageFilterNone,
+    OMX_ImageFilterNoise,
+    OMX_ImageFilterEmboss,
+    OMX_ImageFilterNegative,
+    OMX_ImageFilterSketch,
+    OMX_ImageFilterOilPaint,
+    OMX_ImageFilterHatch,
+    OMX_ImageFilterGpen,
+    OMX_ImageFilterAntialias, 
+    OMX_ImageFilterDeRing,       
+    OMX_ImageFilterSolarize,
+    OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ImageFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ImageFilterMax = 0x7FFFFFFF
+} OMX_IMAGEFILTERTYPE;
+
+
+/** 
+ * Image filter configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes       
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to 
+ *  eImageFilter : Image filter type enumeration      
+ */
+typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGEFILTERTYPE eImageFilter;
+} OMX_CONFIG_IMAGEFILTERTYPE;
+
+
+/** 
+ * Customized U and V for color enhancement 
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes
+ *  nVersion          : OMX specification version information 
+ *  nPortIndex        : Port that this structure applies to
+ *  bColorEnhancement : Enable/disable color enhancement
+ *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for 
+ *                      U component
+ *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for 
+ *                      V component
+ */
+typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;
+    OMX_BOOL bColorEnhancement;
+    OMX_U8 nCustomizedU;
+    OMX_U8 nCustomizedV;
+} OMX_CONFIG_COLORENHANCEMENTTYPE;
+
+
+/** 
+ * Define color key and color key mask 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
+ *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
+ */
+typedef struct OMX_CONFIG_COLORKEYTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nARGBColor;
+    OMX_U32 nARGBMask;
+} OMX_CONFIG_COLORKEYTYPE;
+
+
+/** 
+ * List of color blend types for pre/post processing 
+ *
+ * ENUMS:
+ *  None          : No color blending present
+ *  AlphaConstant : Function is (alpha_constant * src) + 
+ *                  (1 - alpha_constant) * dst)
+ *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
+ *  Alternate     : Function is alternating pixels from src and dst
+ *  And           : Function is (src & dst)
+ *  Or            : Function is (src | dst)
+ *  Invert        : Function is ~src
+ */
+typedef enum OMX_COLORBLENDTYPE {
+    OMX_ColorBlendNone,
+    OMX_ColorBlendAlphaConstant,
+    OMX_ColorBlendAlphaPerPixel,
+    OMX_ColorBlendAlternate,
+    OMX_ColorBlendAnd,
+    OMX_ColorBlendOr,
+    OMX_ColorBlendInvert,
+    OMX_ColorBlendKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ColorBlendVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ColorBlendMax = 0x7FFFFFFF
+} OMX_COLORBLENDTYPE;
+
+
+/** 
+ * Color blend configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes                        
+ *  nVersion          : OMX specification version information                
+ *  nPortIndex        : Port that this structure applies to                   
+ *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
+ *  eColorBlend       : Color blend type enumeration                         
+ */
+typedef struct OMX_CONFIG_COLORBLENDTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nRGBAlphaConstant;
+    OMX_COLORBLENDTYPE  eColorBlend;
+} OMX_CONFIG_COLORBLENDTYPE;
+
+
+/** 
+ * Hold frame dimension
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes      
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to     
+ *  nWidth     : Frame width in pixels                 
+ *  nHeight    : Frame height in pixels                
+ */
+typedef struct OMX_FRAMESIZETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nWidth;
+    OMX_U32 nHeight;
+} OMX_FRAMESIZETYPE;
+
+
+/**
+ * Rotation configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes             
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nRotation  : +/- integer rotation value               
+ */
+typedef struct OMX_CONFIG_ROTATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nRotation; 
+} OMX_CONFIG_ROTATIONTYPE;
+
+
+/** 
+ * Possible mirroring directions for pre/post processing 
+ *
+ * ENUMS:
+ *  None       : No mirroring                         
+ *  Vertical   : Vertical mirroring, flip on X axis   
+ *  Horizontal : Horizontal mirroring, flip on Y axis  
+ *  Both       : Both vertical and horizontal mirroring
+ */
+typedef enum OMX_MIRRORTYPE {
+    OMX_MirrorNone = 0,
+    OMX_MirrorVertical,
+    OMX_MirrorHorizontal,
+    OMX_MirrorBoth, 
+    OMX_MirrorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MirrorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MirrorMax = 0x7FFFFFFF   
+} OMX_MIRRORTYPE;
+
+
+/** 
+ * Mirroring configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes      
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to  
+ *  eMirror    : Mirror type enumeration              
+ */
+typedef struct OMX_CONFIG_MIRRORTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;
+    OMX_MIRRORTYPE  eMirror;
+} OMX_CONFIG_MIRRORTYPE;
+
+
+/** 
+ * Position information only 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes               
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nX         : X coordinate for the point                     
+ *  nY         : Y coordinate for the point 
+ */                      
+typedef struct OMX_CONFIG_POINTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nX;
+    OMX_S32 nY;
+} OMX_CONFIG_POINTTYPE;
+
+
+/** 
+ * Frame size plus position 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes                    
+ *  nVersion   : OMX specification version information      
+ *  nPortIndex : Port that this structure applies to    
+ *  nLeft      : X Coordinate of the top left corner of the rectangle
+ *  nTop       : Y Coordinate of the top left corner of the rectangle
+ *  nWidth     : Width of the rectangle                              
+ *  nHeight    : Height of the rectangle                             
+ */
+typedef struct OMX_CONFIG_RECTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;  
+    OMX_U32 nPortIndex; 
+    OMX_S32 nLeft; 
+    OMX_S32 nTop;
+    OMX_U32 nWidth;
+    OMX_U32 nHeight;
+} OMX_CONFIG_RECTTYPE;
+
+
+/** 
+ * Deblocking state; it is required to be set up before starting the codec 
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes      
+ *  nVersion    : OMX specification version information 
+ *  nPortIndex  : Port that this structure applies to
+ *  bDeblocking : Enable/disable deblocking mode    
+ */
+typedef struct OMX_PARAM_DEBLOCKINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bDeblocking;
+} OMX_PARAM_DEBLOCKINGTYPE;
+
+
+/** 
+ * Stabilization state 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes          
+ *  nVersion   : OMX specification version information    
+ *  nPortIndex : Port that this structure applies to   
+ *  bStab      : Enable/disable frame stabilization state
+ */
+typedef struct OMX_CONFIG_FRAMESTABTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bStab;
+} OMX_CONFIG_FRAMESTABTYPE;
+
+
+/** 
+ * White Balance control type 
+ *
+ * STRUCT MEMBERS:
+ *  SunLight : Referenced in JSR-234
+ *  Flash    : Optimal for device's integrated flash
+ */
+typedef enum OMX_WHITEBALCONTROLTYPE {
+    OMX_WhiteBalControlOff = 0,
+    OMX_WhiteBalControlAuto,
+    OMX_WhiteBalControlSunLight,
+    OMX_WhiteBalControlCloudy,
+    OMX_WhiteBalControlShade,
+    OMX_WhiteBalControlTungsten,
+    OMX_WhiteBalControlFluorescent,
+    OMX_WhiteBalControlIncandescent,
+    OMX_WhiteBalControlFlash,
+    OMX_WhiteBalControlHorizon,
+    OMX_WhiteBalControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_WhiteBalControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_WhiteBalControlMax = 0x7FFFFFFF
+} OMX_WHITEBALCONTROLTYPE;
+
+
+/** 
+ * White Balance control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes       
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to                 
+ *  eWhiteBalControl : White balance enumeration            
+ */
+typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_WHITEBALCONTROLTYPE eWhiteBalControl;
+} OMX_CONFIG_WHITEBALCONTROLTYPE;
+
+
+/** 
+ * Exposure control type 
+ */
+typedef enum OMX_EXPOSURECONTROLTYPE {
+    OMX_ExposureControlOff = 0,
+    OMX_ExposureControlAuto,
+    OMX_ExposureControlNight,
+    OMX_ExposureControlBackLight,
+    OMX_ExposureControlSpotLight,
+    OMX_ExposureControlSports,
+    OMX_ExposureControlSnow,
+    OMX_ExposureControlBeach,
+    OMX_ExposureControlLargeAperture,
+    OMX_ExposureControlSmallApperture,
+    OMX_ExposureControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ExposureControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ExposureControlMax = 0x7FFFFFFF
+} OMX_EXPOSURECONTROLTYPE;
+
+
+/** 
+ * White Balance control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes      
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to                
+ *  eExposureControl : Exposure control enumeration         
+ */
+typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_EXPOSURECONTROLTYPE eExposureControl;
+} OMX_CONFIG_EXPOSURECONTROLTYPE;
+
+
+/** 
+ * Defines sensor supported mode. 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes           
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to 
+ *  nFrameRate : Single shot mode is indicated by a 0     
+ *  bOneShot   : Enable for single shot, disable for streaming
+ *  sFrameSize : Framesize                                          
+ */
+typedef struct OMX_PARAM_SENSORMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nFrameRate;
+    OMX_BOOL bOneShot;
+    OMX_FRAMESIZETYPE sFrameSize;
+} OMX_PARAM_SENSORMODETYPE;
+
+
+/** 
+ * Defines contrast level 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes                              
+ *  nVersion   : OMX specification version information                
+ *  nPortIndex : Port that this structure applies to                 
+ *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
+ */
+typedef struct OMX_CONFIG_CONTRASTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nContrast;
+} OMX_CONFIG_CONTRASTTYPE;
+
+
+/** 
+ * Defines brightness level 
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes          
+ *  nVersion    : OMX specification version information 
+ *  nPortIndex  : Port that this structure applies to 
+ *  nBrightness : 0-100%        
+ */
+typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBrightness;
+} OMX_CONFIG_BRIGHTNESSTYPE;
+
+
+/** 
+ * Defines backlight level configuration for a video sink, e.g. LCD panel 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  nBacklight : Values allowed for backlight 0-100%
+ *  nTimeout   : Number of milliseconds before backlight automatically turns 
+ *               off.  A value of 0x0 disables backight timeout 
+ */
+typedef struct OMX_CONFIG_BACKLIGHTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBacklight;
+    OMX_U32 nTimeout;
+} OMX_CONFIG_BACKLIGHTTYPE;
+
+
+/** 
+ * Defines setting for Gamma 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
+ */
+typedef struct OMX_CONFIG_GAMMATYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nGamma;
+} OMX_CONFIG_GAMMATYPE;
+
+
+/** 
+ * Define for setting saturation 
+ * 
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  nSaturation : Values allowed for saturation -100 to 100, zero means 
+ *                no change
+ */
+typedef struct OMX_CONFIG_SATURATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nSaturation;
+} OMX_CONFIG_SATURATIONTYPE;
+
+
+/** 
+ * Define for setting Lightness 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nLightness : Values allowed for lightness -100 to 100, zero means no 
+ *               change
+ */
+typedef struct OMX_CONFIG_LIGHTNESSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nLightness;
+} OMX_CONFIG_LIGHTNESSTYPE;
+
+
+/** 
+ * Plane blend configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes 
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Index of input port associated with the plane.
+ *  nDepth     : Depth of the plane in relation to the screen. Higher 
+ *               numbered depths are "behind" lower number depths.  
+ *               This number defaults to the Port Index number.
+ *  nAlpha     : Transparency blending component for the entire plane.  
+ *               See blending modes for more detail.
+ */
+typedef struct OMX_CONFIG_PLANEBLENDTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nDepth;
+    OMX_U32 nAlpha;
+} OMX_CONFIG_PLANEBLENDTYPE;
+
+
+/** 
+ * Define interlace type
+ *
+ * STRUCT MEMBERS:
+ *  nSize                 : Size of the structure in bytes 
+ *  nVersion              : OMX specification version information 
+ *  nPortIndex            : Port that this structure applies to
+ *  bEnable               : Enable control variable for this functionality 
+ *                          (see below)
+ *  nInterleavePortIndex  : Index of input or output port associated with  
+ *                          the interleaved plane. 
+ *  pPlanarPortIndexes[4] : Index of input or output planar ports.
+ */
+typedef struct OMX_PARAM_INTERLEAVETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_U32 nInterleavePortIndex;
+} OMX_PARAM_INTERLEAVETYPE;
+
+
+/** 
+ * Defines the picture effect used for an input picture 
+ */
+typedef enum OMX_TRANSITIONEFFECTTYPE {
+    OMX_EffectNone,
+    OMX_EffectFadeFromBlack,
+    OMX_EffectFadeToBlack,
+    OMX_EffectUnspecifiedThroughConstantColor,
+    OMX_EffectDissolve,
+    OMX_EffectWipe,
+    OMX_EffectUnspecifiedMixOfTwoScenes,
+    OMX_EffectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_EffectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EffectMax = 0x7FFFFFFF
+} OMX_TRANSITIONEFFECTTYPE;
+
+
+/** 
+ * Structure used to configure current transition effect 
+ *
+ * STRUCT MEMBERS:
+ * nSize      : Size of the structure in bytes
+ * nVersion   : OMX specification version information 
+ * nPortIndex : Port that this structure applies to
+ * eEffect    : Effect to enable
+ */
+typedef struct OMX_CONFIG_TRANSITIONEFFECTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_TRANSITIONEFFECTTYPE eEffect;
+} OMX_CONFIG_TRANSITIONEFFECTTYPE;
+
+
+/** 
+ * Defines possible data unit types for encoded video data. The data unit 
+ * types are used both for encoded video input for playback as well as
+ * encoded video output from recording. 
+ */
+typedef enum OMX_DATAUNITTYPE {
+    OMX_DataUnitCodedPicture,
+    OMX_DataUnitVideoSegment,
+    OMX_DataUnitSeveralSegments,
+    OMX_DataUnitArbitraryStreamSection,
+    OMX_DataUnitKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DataUnitVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DataUnitMax = 0x7FFFFFFF
+} OMX_DATAUNITTYPE;
+
+
+/** 
+ * Defines possible encapsulation types for coded video data unit. The 
+ * encapsulation information is used both for encoded video input for 
+ * playback as well as encoded video output from recording. 
+ */
+typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
+    OMX_DataEncapsulationElementaryStream,
+    OMX_DataEncapsulationGenericPayload,
+    OMX_DataEncapsulationRtpPayload,
+    OMX_DataEncapsulationKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DataEncapsulationVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DataEncapsulationMax = 0x7FFFFFFF
+} OMX_DATAUNITENCAPSULATIONTYPE;
+
+
+/** 
+ * Structure used to configure the type of being decoded/encoded 
+ */
+typedef struct OMX_PARAM_DATAUNITTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_DATAUNITTYPE eUnitType;
+    OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
+} OMX_PARAM_DATAUNITTYPE;
+
+
+/**
+ * Defines dither types 
+ */
+typedef enum OMX_DITHERTYPE {
+    OMX_DitherNone,
+    OMX_DitherOrdered,
+    OMX_DitherErrorDiffusion,
+    OMX_DitherOther,
+    OMX_DitherKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DitherVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DitherMax = 0x7FFFFFFF
+} OMX_DITHERTYPE;
+
+
+/** 
+ * Structure used to configure current type of dithering 
+ */
+typedef struct OMX_CONFIG_DITHERTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
+} OMX_CONFIG_DITHERTYPE;
+
+typedef struct OMX_CONFIG_CAPTUREMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;     /**< Port that this structure applies to */
+    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture 
+                             *   data as fast as possible (otherwise obey port's frame rate). */
+    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the 
+                             *   specified number of frames (otherwise the port does not 
+                             *   terminate the capture until instructed to do so by the client). 
+                             *   Even if set, the client may manually terminate the capture prior 
+                             *   to reaching the limit. */
+    OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
+                               *   valid if bFrameLimited is set). */
+} OMX_CONFIG_CAPTUREMODETYPE;
+
+typedef enum OMX_METERINGTYPE {
+ 
+    OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
+    OMX_MeteringModeSpot,  	      /**< Spot (partial) metering. */
+    OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
+ 
+    OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MeteringVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EVModeMax = 0x7fffffff
+} OMX_METERINGTYPE;
+ 
+typedef struct OMX_CONFIG_EXPOSUREVALUETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_METERINGTYPE eMetering;
+    OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
+    OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
+    OMX_BOOL bAutoAperture;		/**< Whether aperture number is defined automatically */
+    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */ 
+    OMX_BOOL bAutoShutterSpeed;	/**< Whether shutter speed is defined automatically */ 
+    OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
+    OMX_BOOL bAutoSensitivity;	/**< Whether sensitivity is defined automatically */
+} OMX_CONFIG_EXPOSUREVALUETYPE;
+
+/** 
+ * Focus region configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  bCenter         : Use center region as focus region of interest
+ *  bLeft           : Use left region as focus region of interest
+ *  bRight          : Use right region as focus region of interest
+ *  bTop            : Use top region as focus region of interest
+ *  bBottom         : Use bottom region as focus region of interest
+ *  bTopLeft        : Use top left region as focus region of interest
+ *  bTopRight       : Use top right region as focus region of interest
+ *  bBottomLeft     : Use bottom left region as focus region of interest
+ *  bBottomRight    : Use bottom right region as focus region of interest
+ */
+typedef struct OMX_CONFIG_FOCUSREGIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bCenter;
+    OMX_BOOL bLeft;
+    OMX_BOOL bRight;
+    OMX_BOOL bTop;
+    OMX_BOOL bBottom;
+    OMX_BOOL bTopLeft;
+    OMX_BOOL bTopRight;
+    OMX_BOOL bBottomLeft;
+    OMX_BOOL bBottomRight;
+} OMX_CONFIG_FOCUSREGIONTYPE;
+
+/** 
+ * Focus Status type 
+ */
+typedef enum OMX_FOCUSSTATUSTYPE {
+    OMX_FocusStatusOff = 0,
+    OMX_FocusStatusRequest,
+    OMX_FocusStatusReached,
+    OMX_FocusStatusUnableToReach,
+    OMX_FocusStatusLost,
+    OMX_FocusStatusKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_FocusStatusVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_FocusStatusMax = 0x7FFFFFFF
+} OMX_FOCUSSTATUSTYPE;
+
+/** 
+ * Focus status configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize               : Size of the structure in bytes
+ *  nVersion            : OMX specification version information
+ *  nPortIndex          : Port that this structure applies to
+ *  eFocusStatus        : Specifies the focus status
+ *  bCenterStatus       : Use center region as focus region of interest
+ *  bLeftStatus         : Use left region as focus region of interest
+ *  bRightStatus        : Use right region as focus region of interest
+ *  bTopStatus          : Use top region as focus region of interest
+ *  bBottomStatus       : Use bottom region as focus region of interest
+ *  bTopLeftStatus      : Use top left region as focus region of interest
+ *  bTopRightStatus     : Use top right region as focus region of interest
+ *  bBottomLeftStatus   : Use bottom left region as focus region of interest
+ *  bBottomRightStatus  : Use bottom right region as focus region of interest
+ */
+typedef struct OMX_PARAM_FOCUSSTATUSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_FOCUSSTATUSTYPE eFocusStatus;
+    OMX_BOOL bCenterStatus;
+    OMX_BOOL bLeftStatus;
+    OMX_BOOL bRightStatus;
+    OMX_BOOL bTopStatus;
+    OMX_BOOL bBottomStatus;
+    OMX_BOOL bTopLeftStatus;
+    OMX_BOOL bTopRightStatus;
+    OMX_BOOL bBottomLeftStatus;
+    OMX_BOOL bBottomRightStatus;
+} OMX_PARAM_FOCUSSTATUSTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/omx/headers/OMX_Image.h b/omx/headers/OMX_Image.h
index a34c1b2..a6d4666 100644
--- a/omx/headers/OMX_Image.h
+++ b/omx/headers/OMX_Image.h
@@ -1,318 +1,328 @@
-/**
- * Copyright (c) 2007 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- */
-
-/** 
- * @file OMX_Image.h - OpenMax IL version 1.1.1
- * The structures needed by Image components to exchange parameters and 
- * configuration data with the components.
- */
-#ifndef OMX_Image_h
-#define OMX_Image_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/**
- * Each OMX header must include all required header files to allow the 
- * header to compile without errors.  The includes below are required  
- * for this header file to compile successfully 
- */
-
-#include <OMX_IVCommon.h>
-
-/** @defgroup imaging OpenMAX IL Imaging Domain
- * @ingroup iv
- * Structures for OpenMAX IL Imaging domain
- * @{
- */
-
-/** 
- * Enumeration used to define the possible image compression coding. 
- */
-typedef enum OMX_IMAGE_CODINGTYPE {
-    OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
-    OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
-    OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
-    OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
-    OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
-    OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
-    OMX_IMAGE_CodingGIF,         /**< Graphics image format */
-    OMX_IMAGE_CodingPNG,         /**< PNG image format */
-    OMX_IMAGE_CodingLZW,         /**< LZW image format */
-    OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
-    OMX_IMAGE_CodingMax = 0x7FFFFFFF
-} OMX_IMAGE_CODINGTYPE;
-
-
-/**
- * Data structure used to define an image path. The number of image paths 
- * for input and output will vary by type of the image component.  
- * 
- *  Input (aka Source) : Zero Inputs, one Output,
- *  Splitter           : One Input, 2 or more Outputs,
- *  Processing Element : One Input, one output,
- *  Mixer              : 2 or more inputs, one output,
- *  Output (aka Sink)  : One Input, zero outputs.
- * 
- * The PortDefinition structure is used to define all of the parameters 
- * necessary for the compliant component to setup an input or an output  
- * image path.  If additional vendor specific data is required, it should  
- * be transmitted to the component using the CustomCommand function.   
- * Compliant components will prepopulate this structure with optimal  
- * values during the OMX_GetParameter() command.
- *
- * STRUCT MEMBERS:
- *  cMIMEType             : MIME type of data for the port
- *  pNativeRender         : Platform specific reference for a display if a 
- *                          sync, otherwise this field is 0
- *  nFrameWidth           : Width of frame to be used on port if 
- *                          uncompressed format is used.  Use 0 for 
- *                          unknown, don't care or variable
- *  nFrameHeight          : Height of frame to be used on port if 
- *                          uncompressed format is used. Use 0 for 
- *                          unknown, don't care or variable
- *  nStride               : Number of bytes per span of an image (i.e. 
- *                          indicates the number of bytes to get from
- *                          span N to span N+1, where negative stride 
- *                          indicates the image is bottom up
- *  nSliceHeight          : Height used when encoding in slices
- *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
- *                          the OMX component
- *  eCompressionFormat    : Compression format used in this instance of  
- *                          the component. When OMX_IMAGE_CodingUnused is 
- *                          specified, eColorFormat is valid
- *  eColorFormat          : Decompressed format used by this component
- *  pNativeWindow         : Platform specific reference for a window object if a 
- *                          display sink , otherwise this field is 0x0. 
- */
-typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
-    OMX_STRING cMIMEType;
-    OMX_NATIVE_DEVICETYPE pNativeRender;
-    OMX_U32 nFrameWidth; 
-    OMX_U32 nFrameHeight;
-    OMX_S32 nStride;     
-    OMX_U32 nSliceHeight;
-    OMX_BOOL bFlagErrorConcealment;
-    OMX_IMAGE_CODINGTYPE eCompressionFormat;
-    OMX_COLOR_FORMATTYPE eColorFormat;
-    OMX_NATIVE_WINDOWTYPE pNativeWindow;
-} OMX_IMAGE_PORTDEFINITIONTYPE;
-
-
-/**  
- * Port format parameter.  This structure is used to enumerate the various 
- * data input/output format supported by the port.
- * 
- * STRUCT MEMBERS:
- *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information
- *  nPortIndex         : Indicates which port to set
- *  nIndex             : Indicates the enumeration index for the format from 
- *                       0x0 to N-1
- *  eCompressionFormat : Compression format used in this instance of the 
- *                       component. When OMX_IMAGE_CodingUnused is specified, 
- *                       eColorFormat is valid
- *  eColorFormat       : Decompressed format used by this component
- */
-typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nIndex;
-    OMX_IMAGE_CODINGTYPE eCompressionFormat;
-    OMX_COLOR_FORMATTYPE eColorFormat;
-} OMX_IMAGE_PARAM_PORTFORMATTYPE;
-
-
-/** 
- * Flash control type 
- *
- * ENUMS
- *  Torch : Flash forced constantly on
- */
-typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
-    OMX_IMAGE_FlashControlOn = 0,
-    OMX_IMAGE_FlashControlOff,
-    OMX_IMAGE_FlashControlAuto,
-    OMX_IMAGE_FlashControlRedEyeReduction,
-    OMX_IMAGE_FlashControlFillin,
-    OMX_IMAGE_FlashControlTorch,
-    OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
-} OMX_IMAGE_FLASHCONTROLTYPE;
-
-
-/** 
- * Flash control configuration 
- *
- * STRUCT MEMBERS:
- *  nSize         : Size of the structure in bytes
- *  nVersion      : OMX specification version information
- *  nPortIndex    : Port that this structure applies to
- *  eFlashControl : Flash control type
- */
-typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
-} OMX_IMAGE_PARAM_FLASHCONTROLTYPE;
-
-
-/** 
- * Focus control type 
- */
-typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
-    OMX_IMAGE_FocusControlOn = 0,
-    OMX_IMAGE_FocusControlOff,
-    OMX_IMAGE_FocusControlAuto,
-    OMX_IMAGE_FocusControlAutoLock,
-    OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
-} OMX_IMAGE_FOCUSCONTROLTYPE;
-
- 
-/** 
- * Focus control configuration 
- *
- * STRUCT MEMBERS:
- *  nSize           : Size of the structure in bytes
- *  nVersion        : OMX specification version information
- *  nPortIndex      : Port that this structure applies to
- *  eFocusControl   : Focus control
- *  nFocusSteps     : Focus can take on values from 0 mm to infinity. 
- *                    Interest is only in number of steps over this range.
- *  nFocusStepIndex : Current focus step index
- */
-typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGE_FOCUSCONTROLTYPE eFocusControl;
-    OMX_U32 nFocusSteps;
-    OMX_U32 nFocusStepIndex;
-} OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;
-
-
-/** 
- * Q Factor for JPEG compression, which controls the tradeoff between image
- * quality and size.  Q Factor provides a more simple means of controlling
- * JPEG compression quality, without directly programming Quantization
- * tables for chroma and luma 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes         
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to 
- *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1 
- *               produces the smallest, worst quality images, and a factor 
- *               of 100 produces the largest, best quality images.  A 
- *               typical default is 75 for small good quality images               
- */
-typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
-    OMX_U32 nSize;            
-    OMX_VERSIONTYPE nVersion; 
-    OMX_U32 nPortIndex;       
-    OMX_U32 nQFactor;                                        
-} OMX_IMAGE_PARAM_QFACTORTYPE;
-
-/** 
- * Quantization table type 
- */
-
-typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
-    OMX_IMAGE_QuantizationTableLuma = 0,
-    OMX_IMAGE_QuantizationTableChroma,
-    OMX_IMAGE_QuantizationTableChromaCb,
-    OMX_IMAGE_QuantizationTableChromaCr,
-    OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
-} OMX_IMAGE_QUANTIZATIONTABLETYPE;
-
-/** 
- * JPEG quantization tables are used to determine DCT compression for
- * YUV data, as an alternative to specifying Q factor, providing exact 
- * control of compression 
- *
- * STRUCT MEMBERS:
- *  nSize                   : Size of the structure in bytes
- *  nVersion                : OMX specification version information 
- *  nPortIndex              : Port that this structure applies to
- *  eQuantizationTable      : Quantization table type
- *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored 
- *                            in increasing columns then by rows of data (i.e. 
- *                            row 1, ... row 8). Quantization values are in 
- *                            the range 0-255 and stored in linear order
- *                            (i.e. the component will zig-zag the 
- *                            quantization table data if required internally) 
- */
-typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGE_QUANTIZATIONTABLETYPE eQuantizationTable;
-    OMX_U8 nQuantizationMatrix[64];
-} OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;
-
-
-/** 
- * Huffman table type, the same Huffman table is applied for chroma and 
- * luma component 
- */
-typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
-    OMX_IMAGE_HuffmanTableAC = 0,
-    OMX_IMAGE_HuffmanTableDC,
-    OMX_IMAGE_HuffmanTableACLuma,
-    OMX_IMAGE_HuffmanTableACChroma,
-    OMX_IMAGE_HuffmanTableDCLuma,
-    OMX_IMAGE_HuffmanTableDCChroma,
-    OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
-} OMX_IMAGE_HUFFMANTABLETYPE;
-
-/** 
- * JPEG Huffman table 
- *
- * STRUCT MEMBERS:
- *  nSize                            : Size of the structure in bytes
- *  nVersion                         : OMX specification version information
- *  nPortIndex                       : Port that this structure applies to
- *  eHuffmanTable                    : Huffman table type
- *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each 
- *                                     possible length
- *  nHuffmanTable[256]               : 0-255, the size used for AC and DC 
- *                                     HuffmanTable are 16 and 162 
- */
-typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
-    OMX_U8 nNumberOfHuffmanCodeOfLength[16];
-    OMX_U8 nHuffmanTable[256];
-}OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
-
-/** @} */
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
+/**
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ */
+
+/** 
+ * @file OMX_Image.h - OpenMax IL version 1.1.2
+ * The structures needed by Image components to exchange parameters and 
+ * configuration data with the components.
+ */
+#ifndef OMX_Image_h
+#define OMX_Image_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the 
+ * header to compile without errors.  The includes below are required  
+ * for this header file to compile successfully 
+ */
+
+#include <OMX_IVCommon.h>
+
+/** @defgroup imaging OpenMAX IL Imaging Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Imaging domain
+ * @{
+ */
+
+/** 
+ * Enumeration used to define the possible image compression coding. 
+ */
+typedef enum OMX_IMAGE_CODINGTYPE {
+    OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
+    OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
+    OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
+    OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
+    OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
+    OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
+    OMX_IMAGE_CodingGIF,         /**< Graphics image format */
+    OMX_IMAGE_CodingPNG,         /**< PNG image format */
+    OMX_IMAGE_CodingLZW,         /**< LZW image format */
+    OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
+    OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_CodingMax = 0x7FFFFFFF
+} OMX_IMAGE_CODINGTYPE;
+
+
+/**
+ * Data structure used to define an image path. The number of image paths 
+ * for input and output will vary by type of the image component.  
+ * 
+ *  Input (aka Source) : Zero Inputs, one Output,
+ *  Splitter           : One Input, 2 or more Outputs,
+ *  Processing Element : One Input, one output,
+ *  Mixer              : 2 or more inputs, one output,
+ *  Output (aka Sink)  : One Input, zero outputs.
+ * 
+ * The PortDefinition structure is used to define all of the parameters 
+ * necessary for the compliant component to setup an input or an output  
+ * image path.  If additional vendor specific data is required, it should  
+ * be transmitted to the component using the CustomCommand function.   
+ * Compliant components will prepopulate this structure with optimal  
+ * values during the OMX_GetParameter() command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a 
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on port if 
+ *                          uncompressed format is used.  Use 0 for 
+ *                          unknown, don't care or variable
+ *  nFrameHeight          : Height of frame to be used on port if 
+ *                          uncompressed format is used. Use 0 for 
+ *                          unknown, don't care or variable
+ *  nStride               : Number of bytes per span of an image (i.e. 
+ *                          indicates the number of bytes to get from
+ *                          span N to span N+1, where negative stride 
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of  
+ *                          the component. When OMX_IMAGE_CodingUnused is 
+ *                          specified, eColorFormat is valid
+ *  eColorFormat          : Decompressed format used by this component
+ *  pNativeWindow         : Platform specific reference for a window object if a 
+ *                          display sink , otherwise this field is 0x0. 
+ */
+typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;
+    OMX_NATIVE_DEVICETYPE pNativeRender;
+    OMX_U32 nFrameWidth; 
+    OMX_U32 nFrameHeight;
+    OMX_S32 nStride;     
+    OMX_U32 nSliceHeight;
+    OMX_BOOL bFlagErrorConcealment;
+    OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} OMX_IMAGE_PORTDEFINITIONTYPE;
+
+
+/**  
+ * Port format parameter.  This structure is used to enumerate the various 
+ * data input/output format supported by the port.
+ * 
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from 
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the 
+ *                       component. When OMX_IMAGE_CodingUnused is specified, 
+ *                       eColorFormat is valid
+ *  eColorFormat       : Decompressed format used by this component
+ */
+typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+} OMX_IMAGE_PARAM_PORTFORMATTYPE;
+
+
+/** 
+ * Flash control type 
+ *
+ * ENUMS
+ *  Torch : Flash forced constantly on
+ */
+typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
+    OMX_IMAGE_FlashControlOn = 0,
+    OMX_IMAGE_FlashControlOff,
+    OMX_IMAGE_FlashControlAuto,
+    OMX_IMAGE_FlashControlRedEyeReduction,
+    OMX_IMAGE_FlashControlFillin,
+    OMX_IMAGE_FlashControlTorch,
+    OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_FlashControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
+} OMX_IMAGE_FLASHCONTROLTYPE;
+
+
+/** 
+ * Flash control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize         : Size of the structure in bytes
+ *  nVersion      : OMX specification version information
+ *  nPortIndex    : Port that this structure applies to
+ *  eFlashControl : Flash control type
+ */
+typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
+} OMX_IMAGE_PARAM_FLASHCONTROLTYPE;
+
+
+/** 
+ * Focus control type 
+ */
+typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
+    OMX_IMAGE_FocusControlOn = 0,
+    OMX_IMAGE_FocusControlOff,
+    OMX_IMAGE_FocusControlAuto,
+    OMX_IMAGE_FocusControlAutoLock,
+    OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_FocusControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
+} OMX_IMAGE_FOCUSCONTROLTYPE;
+
+ 
+/** 
+ * Focus control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  eFocusControl   : Focus control
+ *  nFocusSteps     : Focus can take on values from 0 mm to infinity. 
+ *                    Interest is only in number of steps over this range.
+ *  nFocusStepIndex : Current focus step index
+ */
+typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_FOCUSCONTROLTYPE eFocusControl;
+    OMX_U32 nFocusSteps;
+    OMX_U32 nFocusStepIndex;
+} OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;
+
+
+/** 
+ * Q Factor for JPEG compression, which controls the tradeoff between image
+ * quality and size.  Q Factor provides a more simple means of controlling
+ * JPEG compression quality, without directly programming Quantization
+ * tables for chroma and luma 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes         
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to 
+ *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1 
+ *               produces the smallest, worst quality images, and a factor 
+ *               of 100 produces the largest, best quality images.  A 
+ *               typical default is 75 for small good quality images               
+ */
+typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
+    OMX_U32 nSize;            
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;       
+    OMX_U32 nQFactor;                                        
+} OMX_IMAGE_PARAM_QFACTORTYPE;
+
+/** 
+ * Quantization table type 
+ */
+
+typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
+    OMX_IMAGE_QuantizationTableLuma = 0,
+    OMX_IMAGE_QuantizationTableChroma,
+    OMX_IMAGE_QuantizationTableChromaCb,
+    OMX_IMAGE_QuantizationTableChromaCr,
+    OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_QuantizationTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
+} OMX_IMAGE_QUANTIZATIONTABLETYPE;
+
+/** 
+ * JPEG quantization tables are used to determine DCT compression for
+ * YUV data, as an alternative to specifying Q factor, providing exact 
+ * control of compression 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information 
+ *  nPortIndex              : Port that this structure applies to
+ *  eQuantizationTable      : Quantization table type
+ *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored 
+ *                            in increasing columns then by rows of data (i.e. 
+ *                            row 1, ... row 8). Quantization values are in 
+ *                            the range 0-255 and stored in linear order
+ *                            (i.e. the component will zig-zag the 
+ *                            quantization table data if required internally) 
+ */
+typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_QUANTIZATIONTABLETYPE eQuantizationTable;
+    OMX_U8 nQuantizationMatrix[64];
+} OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;
+
+
+/** 
+ * Huffman table type, the same Huffman table is applied for chroma and 
+ * luma component 
+ */
+typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
+    OMX_IMAGE_HuffmanTableAC = 0,
+    OMX_IMAGE_HuffmanTableDC,
+    OMX_IMAGE_HuffmanTableACLuma,
+    OMX_IMAGE_HuffmanTableACChroma,
+    OMX_IMAGE_HuffmanTableDCLuma,
+    OMX_IMAGE_HuffmanTableDCChroma,
+    OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_HuffmanTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
+} OMX_IMAGE_HUFFMANTABLETYPE;
+
+/** 
+ * JPEG Huffman table 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                            : Size of the structure in bytes
+ *  nVersion                         : OMX specification version information
+ *  nPortIndex                       : Port that this structure applies to
+ *  eHuffmanTable                    : Huffman table type
+ *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each 
+ *                                     possible length
+ *  nHuffmanTable[256]               : 0-255, the size used for AC and DC 
+ *                                     HuffmanTable are 16 and 162 
+ */
+typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
+    OMX_U8 nNumberOfHuffmanCodeOfLength[16];
+    OMX_U8 nHuffmanTable[256];
+}OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
+
+/** @} */
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/omx/headers/OMX_Index.h b/omx/headers/OMX_Index.h
index 08ebefc..44d4ea7 100644
--- a/omx/headers/OMX_Index.h
+++ b/omx/headers/OMX_Index.h
@@ -1,256 +1,258 @@
-/*
- * Copyright (c) 2007 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** @file OMX_Index.h - OpenMax IL version 1.1.1
- *  The OMX_Index header file contains the definitions for both applications
- *  and components .
- */
-
-
-#ifndef OMX_Index_h
-#define OMX_Index_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/* Each OMX header must include all required header files to allow the
- *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully 
- */
-#include <OMX_Types.h>
-
-
-/** The OMX_INDEXTYPE enumeration is used to select a structure when either
- *  getting or setting parameters and/or configuration data.  Each entry in 
- *  this enumeration maps to an OMX specified structure.  When the 
- *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
- *  are used, the second parameter will always be an entry from this enumeration
- *  and the third entry will be the structure shown in the comments for the entry.
- *  For example, if the application is initializing a cropping function, the 
- *  OMX_SetConfig command would have OMX_ConfigInputCrop as the second parameter 
- *  and would send a pointer to an initialized OMX_RECTTYPE structure as the 
- *  third parameter.
- *  
- *  The enumeration entries named with the OMX_Config prefix are sent using
- *  the OMX_SetConfig command and the enumeration entries named with the
- *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
- */
-typedef enum OMX_INDEXTYPE {
-
-    OMX_IndexComponentStartUnused = 0x01000000,
-    OMX_IndexParamPriorityMgmt, /**< reference: OMX_PRIORITYMGMTTYPE */
-    OMX_IndexParamAudioInit, /**< reference: OMX_PORT_PARAM_TYPE  */
-    OMX_IndexParamImageInit, /**< reference: OMX_PORT_PARAM_TYPE  */
-    OMX_IndexParamVideoInit, /**< reference: OMX_PORT_PARAM_TYPE  */
-    OMX_IndexParamOtherInit, /**< reference: OMX_PORT_PARAM_TYPE  */
-    OMX_IndexParamNumAvailableStreams, /**< reference: OMX_PARAM_U32TYPE */
-    OMX_IndexParamActiveStream,        /**< reference: OMX_PARAM_U32TYPE */
-    OMX_IndexParamSuspensionPolicy,    /**< reference: OMX_PARAM_SUSPENSIONPOLICYTYPE */
-    OMX_IndexParamComponentSuspended,  /**< reference: OMX_PARAM_SUSPENSIONTYPE */
-    OMX_IndexConfigCapturing, /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
-    OMX_IndexConfigCaptureMode, /**< reference: OMX_CONFIG_CAPTUREMODETYPE */ 
-    OMX_IndexAutoPauseAfterCapture, /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
-    OMX_IndexParamContentURI,  /**< reference: OMX_PARAM_CONTENTURITYPE */
-    OMX_IndexParamCustomContentPipe, /**< reference: OMX_PARAM_CONTENTPIPETYPE */ 
-    OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
-    OMX_IndexConfigMetadataItemCount,        /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
-    OMX_IndexConfigContainerNodeCount,       /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
-    OMX_IndexConfigMetadataItem,             /**< reference: OMX_CONFIG_METADATAITEMTYPE */
-    OMX_IndexConfigCounterNodeID,            /**< reference: OMX_CONFIG_CONTAINERNODEIDTYPE */
-    OMX_IndexParamMetadataFilterType,        /** < reference: OMX_PARAM_METADATAFILTERTYPE */
-    OMX_IndexParamMetadataKeyFilter,         /**< reference: OMX_PARAM_METADATAFILTERTYPE */
-    OMX_IndexConfigPriorityMgmt,             /**< reference: OMX_PRIORITYMGMTTYPE */
-    OMX_IndexParamStandardComponentRole,     /**< reference: OMX_PARAM_COMPONENTROLETYPE */
-
-    OMX_IndexPortStartUnused = 0x02000000,
-    OMX_IndexParamPortDefinition, /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
-    OMX_IndexParamCompBufferSupplier, /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE (*/ 
-    OMX_IndexReservedStartUnused = 0x03000000,
-
-    /* Audio parameters and configurations */
-    OMX_IndexAudioStartUnused = 0x04000000,
-    OMX_IndexParamAudioPortFormat, /**< reference: OMX_AUDIO_PARAM_PORTFORMATTYPE */
-    OMX_IndexParamAudioPcm,    /**< reference: OMX_AUDIO_PARAM_PCMMODETYPE */
-    OMX_IndexParamAudioAac,    /**< reference: OMX_AUDIO_PARAM_AACPROFILETYPE */
-    OMX_IndexParamAudioRa,     /**< reference: OMX_AUDIO_PARAM_RATYPE */
-    OMX_IndexParamAudioMp3,    /**< reference: OMX_AUDIO_PARAM_MP3TYPE */
-    OMX_IndexParamAudioAdpcm,  /**< reference: OMX_AUDIO_PARAM_ADPCMTYPE */
-    OMX_IndexParamAudioG723,   /**< reference: OMX_AUDIO_PARAM_G723TYPE */
-    OMX_IndexParamAudioG729,   /**< reference: OMX_AUDIO_PARAM_G729TYPE */
-    OMX_IndexParamAudioAmr,    /**< reference: OMX_AUDIO_PARAM_AMRTYPE */
-    OMX_IndexParamAudioWma,    /**< reference: OMX_AUDIO_PARAM_WMATYPE */
-    OMX_IndexParamAudioSbc,    /**< reference: OMX_AUDIO_PARAM_SBCTYPE */
-    OMX_IndexParamAudioMidi,   /**< reference: OMX_AUDIO_PARAM_MIDITYPE */
-    OMX_IndexParamAudioGsm_FR, /**< reference: OMX_AUDIO_PARAM__GSMFRTYPE */
-    OMX_IndexParamAudioMidiLoadUserSound, /**< reference: OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE */
-    OMX_IndexParamAudioG726,     /**< reference: OMX_AUDIO_PARAM_G726TYPE */
-    OMX_IndexParamAudioGsm_EFR,  /**< reference: OMX_AUDIO_PARAM_GSMEFRTYPE */
-    OMX_IndexParamAudioGsm_HR,   /**< reference: OMX_AUDIO_PARAM_GSMHRTYPE */
-    OMX_IndexParamAudioPdc_FR,   /**< reference: OMX_AUDIO_PARAM_PDCFRTYPE */
-    OMX_IndexParamAudioPdc_EFR,  /**< reference: OMX_AUDIO_PARAM_PDCEFRTYPE */
-    OMX_IndexParamAudioPdc_HR,   /**< reference: OMX_AUDIO_PARAM_PDCHRTYPE */
-    OMX_IndexParamAudioTdma_FR,  /**< reference: OMX_AUDIO_PARAM_TDMAFRTYPE */
-    OMX_IndexParamAudioTdma_EFR, /**< reference: OMX_AUDIO_PARAM_TDMAEFRTYPE */
-    OMX_IndexParamAudioQcelp8,   /**< reference: OMX_AUDIO_PARAM_QCELP8TYPE */
-    OMX_IndexParamAudioQcelp13,  /**< reference: OMX_AUDIO_PARAM_QCELP13TYPE */
-    OMX_IndexParamAudioEvrc,     /**< reference: OMX_AUDIO_PARAM_EVRCTYPE */
-    OMX_IndexParamAudioSmv,      /**< reference: OMX_AUDIO_PARAM_SMVTYPE */
-    OMX_IndexParamAudioVorbis,   /**< reference: OMX_AUDIO_PARAM_VORBISTYPE */
-
-    OMX_IndexConfigAudioMidiImmediateEvent, /**< OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE */
-    OMX_IndexConfigAudioMidiControl, /**< reference: OMX_AUDIO_CONFIG_MIDICONTROLTYPE */
-    OMX_IndexConfigAudioMidiSoundBankProgram, /**< reference: OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE */
-    OMX_IndexConfigAudioMidiStatus,  /**< reference: OMX_AUDIO_CONFIG_MIDISTATUSTYPE */
-    OMX_IndexConfigAudioMidiMetaEvent, /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE */
-    OMX_IndexConfigAudioMidiMetaEventData, /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE */
-    OMX_IndexConfigAudioVolume,      /**< reference: OMX_AUDIO_CONFIG_VOLUMETYPE */
-    OMX_IndexConfigAudioBalance,     /**< reference: OMX_AUDIO_CONFIG_BALANCETYPE */
-    OMX_IndexConfigAudioChannelMute, /**< reference: OMX_AUDIO_CONFIG_CHANNELMUTETYPE */
-    OMX_IndexConfigAudioMute,        /**< reference: OMX_AUDIO_CONFIG_MUTETYPE */
-    OMX_IndexConfigAudioLoudness,    /**< reference: OMX_AUDIO_CONFIG_LOUDNESSTYPE */
-    OMX_IndexConfigAudioEchoCancelation, /**< reference: OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE */
-    OMX_IndexConfigAudioNoiseReduction,  /**< reference: OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE */
-    OMX_IndexConfigAudioBass,        /**< reference: OMX_AUDIO_CONFIG_BASSTYPE */
-    OMX_IndexConfigAudioTreble,      /**< reference: OMX_AUDIO_CONFIG_TREBLETYPE */
-    OMX_IndexConfigAudioStereoWidening, /**< reference: OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE */
-    OMX_IndexConfigAudioChorus,      /**< reference: OMX_AUDIO_CONFIG_CHORUSTYPE */
-    OMX_IndexConfigAudioEqualizer,   /**< reference: OMX_AUDIO_CONFIG_EQUALIZERTYPE */
-    OMX_IndexConfigAudioReverberation, /**< reference: OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
-    OMX_IndexConfigAudioChannelVolume, /**< reference: OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */
-
-    /* Image specific parameters and configurations */
-    OMX_IndexImageStartUnused = 0x05000000,
-    OMX_IndexParamImagePortFormat,   /**< reference: OMX_IMAGE_PARAM_PORTFORMATTYPE */
-    OMX_IndexParamFlashControl,      /**< refer to OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
-    OMX_IndexConfigFocusControl,     /**< refer to OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE */
-    OMX_IndexParamQFactor,           /**< refer to OMX_IMAGE_PARAM_QFACTORTYPE */
-    OMX_IndexParamQuantizationTable, /**< refer to OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
-    OMX_IndexParamHuffmanTable,      /**< For jpeg, refer to OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
-    OMX_IndexConfigFlashControl,      /**< refer to OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
-
-    /* Video specific parameters and configurations */
-    OMX_IndexVideoStartUnused = 0x06000000,
-    OMX_IndexParamVideoPortFormat,   /**< reference: OMX_VIDEO_PARAM_PORTFORMATTYPE */
-    OMX_IndexParamVideoQuantization, /**< reference: OMX_VIDEO_PARAM_QUANTIZATIONPARAMTYPE */
-    OMX_IndexParamVideoFastUpdate,   /**< reference: OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE */
-    OMX_IndexParamVideoBitrate,      /**< reference: OMX_VIDEO_PARAM_BITRATETYPE */
-    OMX_IndexParamVideoMotionVector,    /**< reference: OMX_VIDEO_PARAM_MOTIONVECTORTYPE */
-    OMX_IndexParamVideoIntraRefresh,    /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
-    OMX_IndexParamVideoErrorCorrection, /**< reference: OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE */
-    OMX_IndexParamVideoVBSMC, /**< reference:OMX_VIDEO_PARAM_VBSMCTYPE */
-    OMX_IndexParamVideoMpeg2, /**< reference:OMX_VIDEO_PARAM_MPEG2TYPE */
-    OMX_IndexParamVideoMpeg4, /**< reference: OMX_VIDEO_CONFIG_MPEG4TYPE */
-    OMX_IndexParamVideoWmv,   /**< reference:OMX_VIDEO_PARAM_WMVTYPE */
-    OMX_IndexParamVideoRv,    /**< reference:OMX_VIDEO_PARAM_RVTYPE */
-    OMX_IndexParamVideoAvc,   /**< reference:OMX_VIDEO_PARAM_AVCTYPE */
-    OMX_IndexParamVideoH263,  /**< reference:OMX_VIDEO_PARAM_H263TYPE */
-    OMX_IndexParamVideoProfileLevelQuerySupported, /**< reference:OMX_VIDEO_PARAM_PROFILELEVEL */
-    OMX_IndexParamVideoProfileLevelCurrent, /**< reference:OMX_VIDEO_PARAM_PROFILELEVEL */
-    OMX_IndexConfigVideoBitrate, /**< reference: OMX_VIDEO_CONFIG_BITRATETYPE */
-    OMX_IndexConfigVideoFramerate, /**< reference:OMX_VIDEO_CONFIG_FRAMERATETYPE */
-    OMX_IndexConfigVideoIntraVOPRefresh, /**< reference: OMX_CONFIG_INTRAREFRESHVOPTYPE */
-    OMX_IndexConfigVideoIntraMBRefresh, /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
-    OMX_IndexConfigVideoMBErrorReporting, /**< reference: OMX_CONFIG_MBERRORREPORTINGTYPE */
-    OMX_IndexParamVideoMacroblocksPerFrame, /**< reference: OMX_PARAM_MACROBLOCKSTYPE */
-    OMX_IndexConfigVideoMacroBlockErrorMap, /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
-    OMX_IndexParamVideoSliceFMO, /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
-    OMX_IndexConfigVideoAVCIntraPeriod, /** reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
-    OMX_IndexConfigVideoNalSize, /** reference: OMX_VIDEO_CONFIG_NALSIZE */
-
-    /* Image & Video common Configurations */
-    OMX_IndexCommonStartUnused = 0x07000000,
-    OMX_IndexParamCommonDeblocking, /**< reference: OMX_PARAM_DEBLOCKINGTYPE */
-    OMX_IndexParamCommonSensorMode, /**< reference: OMX_PARAM_SENSORMODETYPE */
-    OMX_IndexParamCommonInterleave, /** reference: OMX_PARAM_INTERLEAVETYPE */
-    OMX_IndexConfigCommonColorFormatConversion,   /**< reference: OMX_CONFIG_COLORCONVERSIONTYPE */
-    OMX_IndexConfigCommonScale,  /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
-    OMX_IndexConfigCommonImageFilter, /**< reference: OMX_CONFIG_IMAGEFILTERTYPE */
-    OMX_IndexConfigCommonColorEnhancement, /**< reference: OMX_CONFIG_COLORENHANCEMENTTYPE */
-    OMX_IndexConfigCommonColorKey, /**< reference: OMX_CONFIG_COLORKEYTYPE */
-    OMX_IndexConfigCommonColorBlend, /**< reference: OMX_CONFIG_COLORBLENDTYPE */
-    OMX_IndexConfigCommonFrameStabilisation, /**< reference: OMX_CONFIG_FRAMESTABTYPE */
-    OMX_IndexConfigCommonRotate, /**< reference: OMX_CONFIG_ROTATIONTYPE */
-    OMX_IndexConfigCommonMirror, /**< reference: OMX_CONFIG_MIRRORTYPE */
-    OMX_IndexConfigCommonOutputPosition, /**< reference: OMX_CONFIG_POINTTYPE */
-    OMX_IndexConfigCommonInputCrop, /**< reference: OMX_CONFIG_RECTTYPE */
-    OMX_IndexConfigCommonOutputCrop, /**< reference: OMX_CONFIG_RECTTYPE */
-    OMX_IndexConfigCommonDigitalZoom,  /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
-    OMX_IndexConfigCommonOpticalZoom, /**< reference: OMX_CONFIG_SCALEFACTORTYPE*/
-    OMX_IndexConfigCommonWhiteBalance, /**< reference: OMX_CONFIG_WHITEBALCONTROLTYPE */
-    OMX_IndexConfigCommonExposure, /**< reference: OMX_CONFIG_EXPOSURECONTROLTYPE */
-    OMX_IndexConfigCommonContrast, /**< reference to OMX_CONFIG_CONTRASTTYPE */
-    OMX_IndexConfigCommonBrightness, /**< reference to OMX_CONFIG_BRIGHTNESSTYPE */
-    OMX_IndexConfigCommonBacklight, /**< reference to OMX_CONFIG_BACKLIGHTTYPE */
-    OMX_IndexConfigCommonGamma, /**< reference to OMX_CONFIG_GAMMATYPE */
-    OMX_IndexConfigCommonSaturation, /**< reference to OMX_CONFIG_SATURATIONTYPE */
-    OMX_IndexConfigCommonLightness, /**< reference to OMX_CONFIG_LIGHTNESSTYPE */
-    OMX_IndexConfigCommonExclusionRect, /** reference: OMX_CONFIG_RECTTYPE */
-    OMX_IndexConfigCommonDithering, /**< reference: OMX_TIME_CONFIG_DITHERTYPE */
-    OMX_IndexConfigCommonPlaneBlend, /** reference: OMX_CONFIG_PLANEBLENDTYPE */
-    OMX_IndexConfigCommonExposureValue,  /**< reference: OMX_CONFIG_EXPOSUREVALUETYPE */
-    OMX_IndexConfigCommonOutputSize, /**< reference: OMX_FRAMESIZETYPE */
-    OMX_IndexParamCommonExtraQuantData, /**< reference: OMX_OTHER_EXTRADATATYPE */
-    OMX_IndexConfigCommonFocusRegion,      /**< refer to OMX_PARAM_FOCUSREGIONTYPE */
-    OMX_IndexConfigCommonFocusStatus,      /**< refer to OMX_IMAGE_CONFIG_FOCUSSTATUSTYPE */
-
-    /* Reserved Configuration range */
-    OMX_IndexOtherStartUnused = 0x08000000,
-    OMX_IndexParamOtherPortFormat, /**< reference: OMX_OTHER_PARAM_PORTFORMATTYPE */
-    OMX_IndexConfigOtherPower, /**< reference: OMX_OTHER_CONFIG_POWERTYPE */
-    OMX_IndexConfigOtherStats, /**< reference: OMX_OTHER_CONFIG_STATSTYPE */
-
-
-    /* Reserved Time range */
-    OMX_IndexTimeStartUnused = 0x09000000,
-    OMX_IndexConfigTimeScale, /**< reference: OMX_TIME_CONFIG_SCALETYPE */
-    OMX_IndexConfigTimeClockState,  /**< reference: OMX_TIME_CONFIG_CLOCKSTATETYPE */
-    OMX_IndexConfigTimeActiveRefClock, /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
-    OMX_IndexConfigTimeCurrentMediaTime, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only)*/
-    OMX_IndexConfigTimeCurrentWallTime, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only)*/
-    OMX_IndexConfigTimeCurrentAudioReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
-    OMX_IndexConfigTimeCurrentVideoReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
-    OMX_IndexConfigTimeMediaTimeRequest, /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
-    OMX_IndexConfigTimeClientStartTime,  /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
-    OMX_IndexConfigTimePosition,  /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
-    OMX_IndexConfigTimeSeekMode,  /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */
-
-
-    /* Vendor specific area */
-    OMX_IndexVendorStartUnused = 0x7F000000,
-    /* Vendor specific structures should be in the range of 0x7F000000 
-       to 0x7FFFFFFE.  This range is not broken out by vendor, so
-       private indexes are not guaranteed unique and therefore should
-       only be sent to the appropriate component. */
-
-    OMX_IndexMax = 0x7FFFFFFF
-
-} OMX_INDEXTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_Index.h - OpenMax IL version 1.1.2
+ *  The OMX_Index header file contains the definitions for both applications
+ *  and components .
+ */
+
+
+#ifndef OMX_Index_h
+#define OMX_Index_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+#include <OMX_Types.h>
+
+
+/** The OMX_INDEXTYPE enumeration is used to select a structure when either
+ *  getting or setting parameters and/or configuration data.  Each entry in 
+ *  this enumeration maps to an OMX specified structure.  When the 
+ *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
+ *  are used, the second parameter will always be an entry from this enumeration
+ *  and the third entry will be the structure shown in the comments for the entry.
+ *  For example, if the application is initializing a cropping function, the 
+ *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter 
+ *  and would send a pointer to an initialized OMX_RECTTYPE structure as the 
+ *  third parameter.
+ *  
+ *  The enumeration entries named with the OMX_Config prefix are sent using
+ *  the OMX_SetConfig command and the enumeration entries named with the
+ *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
+ */
+typedef enum OMX_INDEXTYPE {
+
+    OMX_IndexComponentStartUnused = 0x01000000,
+    OMX_IndexParamPriorityMgmt,             /**< reference: OMX_PRIORITYMGMTTYPE */
+    OMX_IndexParamAudioInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamImageInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamVideoInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamOtherInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamNumAvailableStreams,      /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexParamActiveStream,             /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexParamSuspensionPolicy,         /**< reference: OMX_PARAM_SUSPENSIONPOLICYTYPE */
+    OMX_IndexParamComponentSuspended,       /**< reference: OMX_PARAM_SUSPENSIONTYPE */
+    OMX_IndexConfigCapturing,               /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
+    OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */ 
+    OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
+    OMX_IndexParamContentURI,               /**< reference: OMX_PARAM_CONTENTURITYPE */
+    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */ 
+    OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
+    OMX_IndexConfigMetadataItemCount,       /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
+    OMX_IndexConfigContainerNodeCount,      /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
+    OMX_IndexConfigMetadataItem,            /**< reference: OMX_CONFIG_METADATAITEMTYPE */
+    OMX_IndexConfigCounterNodeID,           /**< reference: OMX_CONFIG_CONTAINERNODEIDTYPE */
+    OMX_IndexParamMetadataFilterType,       /**< reference: OMX_PARAM_METADATAFILTERTYPE */
+    OMX_IndexParamMetadataKeyFilter,        /**< reference: OMX_PARAM_METADATAFILTERTYPE */
+    OMX_IndexConfigPriorityMgmt,            /**< reference: OMX_PRIORITYMGMTTYPE */
+    OMX_IndexParamStandardComponentRole,    /**< reference: OMX_PARAM_COMPONENTROLETYPE */
+
+    OMX_IndexPortStartUnused = 0x02000000,
+    OMX_IndexParamPortDefinition,           /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
+    OMX_IndexParamCompBufferSupplier,       /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE */ 
+    OMX_IndexReservedStartUnused = 0x03000000,
+
+    /* Audio parameters and configurations */
+    OMX_IndexAudioStartUnused = 0x04000000,
+    OMX_IndexParamAudioPortFormat,          /**< reference: OMX_AUDIO_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamAudioPcm,                 /**< reference: OMX_AUDIO_PARAM_PCMMODETYPE */
+    OMX_IndexParamAudioAac,                 /**< reference: OMX_AUDIO_PARAM_AACPROFILETYPE */
+    OMX_IndexParamAudioRa,                  /**< reference: OMX_AUDIO_PARAM_RATYPE */
+    OMX_IndexParamAudioMp3,                 /**< reference: OMX_AUDIO_PARAM_MP3TYPE */
+    OMX_IndexParamAudioAdpcm,               /**< reference: OMX_AUDIO_PARAM_ADPCMTYPE */
+    OMX_IndexParamAudioG723,                /**< reference: OMX_AUDIO_PARAM_G723TYPE */
+    OMX_IndexParamAudioG729,                /**< reference: OMX_AUDIO_PARAM_G729TYPE */
+    OMX_IndexParamAudioAmr,                 /**< reference: OMX_AUDIO_PARAM_AMRTYPE */
+    OMX_IndexParamAudioWma,                 /**< reference: OMX_AUDIO_PARAM_WMATYPE */
+    OMX_IndexParamAudioSbc,                 /**< reference: OMX_AUDIO_PARAM_SBCTYPE */
+    OMX_IndexParamAudioMidi,                /**< reference: OMX_AUDIO_PARAM_MIDITYPE */
+    OMX_IndexParamAudioGsm_FR,              /**< reference: OMX_AUDIO_PARAM_GSMFRTYPE */
+    OMX_IndexParamAudioMidiLoadUserSound,   /**< reference: OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE */
+    OMX_IndexParamAudioG726,                /**< reference: OMX_AUDIO_PARAM_G726TYPE */
+    OMX_IndexParamAudioGsm_EFR,             /**< reference: OMX_AUDIO_PARAM_GSMEFRTYPE */
+    OMX_IndexParamAudioGsm_HR,              /**< reference: OMX_AUDIO_PARAM_GSMHRTYPE */
+    OMX_IndexParamAudioPdc_FR,              /**< reference: OMX_AUDIO_PARAM_PDCFRTYPE */
+    OMX_IndexParamAudioPdc_EFR,             /**< reference: OMX_AUDIO_PARAM_PDCEFRTYPE */
+    OMX_IndexParamAudioPdc_HR,              /**< reference: OMX_AUDIO_PARAM_PDCHRTYPE */
+    OMX_IndexParamAudioTdma_FR,             /**< reference: OMX_AUDIO_PARAM_TDMAFRTYPE */
+    OMX_IndexParamAudioTdma_EFR,            /**< reference: OMX_AUDIO_PARAM_TDMAEFRTYPE */
+    OMX_IndexParamAudioQcelp8,              /**< reference: OMX_AUDIO_PARAM_QCELP8TYPE */
+    OMX_IndexParamAudioQcelp13,             /**< reference: OMX_AUDIO_PARAM_QCELP13TYPE */
+    OMX_IndexParamAudioEvrc,                /**< reference: OMX_AUDIO_PARAM_EVRCTYPE */
+    OMX_IndexParamAudioSmv,                 /**< reference: OMX_AUDIO_PARAM_SMVTYPE */
+    OMX_IndexParamAudioVorbis,              /**< reference: OMX_AUDIO_PARAM_VORBISTYPE */
+
+    OMX_IndexConfigAudioMidiImmediateEvent, /**< reference: OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE */
+    OMX_IndexConfigAudioMidiControl,        /**< reference: OMX_AUDIO_CONFIG_MIDICONTROLTYPE */
+    OMX_IndexConfigAudioMidiSoundBankProgram, /**< reference: OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE */
+    OMX_IndexConfigAudioMidiStatus,         /**< reference: OMX_AUDIO_CONFIG_MIDISTATUSTYPE */
+    OMX_IndexConfigAudioMidiMetaEvent,      /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE */
+    OMX_IndexConfigAudioMidiMetaEventData,  /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE */
+    OMX_IndexConfigAudioVolume,             /**< reference: OMX_AUDIO_CONFIG_VOLUMETYPE */
+    OMX_IndexConfigAudioBalance,            /**< reference: OMX_AUDIO_CONFIG_BALANCETYPE */
+    OMX_IndexConfigAudioChannelMute,        /**< reference: OMX_AUDIO_CONFIG_CHANNELMUTETYPE */
+    OMX_IndexConfigAudioMute,               /**< reference: OMX_AUDIO_CONFIG_MUTETYPE */
+    OMX_IndexConfigAudioLoudness,           /**< reference: OMX_AUDIO_CONFIG_LOUDNESSTYPE */
+    OMX_IndexConfigAudioEchoCancelation,    /**< reference: OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE */
+    OMX_IndexConfigAudioNoiseReduction,     /**< reference: OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE */
+    OMX_IndexConfigAudioBass,               /**< reference: OMX_AUDIO_CONFIG_BASSTYPE */
+    OMX_IndexConfigAudioTreble,             /**< reference: OMX_AUDIO_CONFIG_TREBLETYPE */
+    OMX_IndexConfigAudioStereoWidening,     /**< reference: OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE */
+    OMX_IndexConfigAudioChorus,             /**< reference: OMX_AUDIO_CONFIG_CHORUSTYPE */
+    OMX_IndexConfigAudioEqualizer,          /**< reference: OMX_AUDIO_CONFIG_EQUALIZERTYPE */
+    OMX_IndexConfigAudioReverberation,      /**< reference: OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
+    OMX_IndexConfigAudioChannelVolume,      /**< reference: OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */
+
+    /* Image specific parameters and configurations */
+    OMX_IndexImageStartUnused = 0x05000000,
+    OMX_IndexParamImagePortFormat,          /**< reference: OMX_IMAGE_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamFlashControl,             /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+    OMX_IndexConfigFocusControl,            /**< reference: OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE */
+    OMX_IndexParamQFactor,                  /**< reference: OMX_IMAGE_PARAM_QFACTORTYPE */
+    OMX_IndexParamQuantizationTable,        /**< reference: OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
+    OMX_IndexParamHuffmanTable,             /**< reference: OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
+    OMX_IndexConfigFlashControl,            /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+
+    /* Video specific parameters and configurations */
+    OMX_IndexVideoStartUnused = 0x06000000,
+    OMX_IndexParamVideoPortFormat,          /**< reference: OMX_VIDEO_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamVideoQuantization,        /**< reference: OMX_VIDEO_PARAM_QUANTIZATIONTYPE */
+    OMX_IndexParamVideoFastUpdate,          /**< reference: OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE */
+    OMX_IndexParamVideoBitrate,             /**< reference: OMX_VIDEO_PARAM_BITRATETYPE */
+    OMX_IndexParamVideoMotionVector,        /**< reference: OMX_VIDEO_PARAM_MOTIONVECTORTYPE */
+    OMX_IndexParamVideoIntraRefresh,        /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
+    OMX_IndexParamVideoErrorCorrection,     /**< reference: OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE */
+    OMX_IndexParamVideoVBSMC,               /**< reference: OMX_VIDEO_PARAM_VBSMCTYPE */
+    OMX_IndexParamVideoMpeg2,               /**< reference: OMX_VIDEO_PARAM_MPEG2TYPE */
+    OMX_IndexParamVideoMpeg4,               /**< reference: OMX_VIDEO_PARAM_MPEG4TYPE */
+    OMX_IndexParamVideoWmv,                 /**< reference: OMX_VIDEO_PARAM_WMVTYPE */
+    OMX_IndexParamVideoRv,                  /**< reference: OMX_VIDEO_PARAM_RVTYPE */
+    OMX_IndexParamVideoAvc,                 /**< reference: OMX_VIDEO_PARAM_AVCTYPE */
+    OMX_IndexParamVideoH263,                /**< reference: OMX_VIDEO_PARAM_H263TYPE */
+    OMX_IndexParamVideoProfileLevelQuerySupported, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    OMX_IndexParamVideoProfileLevelCurrent, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    OMX_IndexConfigVideoBitrate,            /**< reference: OMX_VIDEO_CONFIG_BITRATETYPE */
+    OMX_IndexConfigVideoFramerate,          /**< reference: OMX_CONFIG_FRAMERATETYPE */
+    OMX_IndexConfigVideoIntraVOPRefresh,    /**< reference: OMX_CONFIG_INTRAREFRESHVOPTYPE */
+    OMX_IndexConfigVideoIntraMBRefresh,     /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    OMX_IndexConfigVideoMBErrorReporting,   /**< reference: OMX_CONFIG_MBERRORREPORTINGTYPE */
+    OMX_IndexParamVideoMacroblocksPerFrame, /**< reference: OMX_PARAM_MACROBLOCKSTYPE */
+    OMX_IndexConfigVideoMacroBlockErrorMap, /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
+    OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
+    OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */
+
+    /* Image & Video common Configurations */
+    OMX_IndexCommonStartUnused = 0x07000000,
+    OMX_IndexParamCommonDeblocking,         /**< reference: OMX_PARAM_DEBLOCKINGTYPE */
+    OMX_IndexParamCommonSensorMode,         /**< reference: OMX_PARAM_SENSORMODETYPE */
+    OMX_IndexParamCommonInterleave,         /**< reference: OMX_PARAM_INTERLEAVETYPE */
+    OMX_IndexConfigCommonColorFormatConversion, /**< reference: OMX_CONFIG_COLORCONVERSIONTYPE */
+    OMX_IndexConfigCommonScale,             /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
+    OMX_IndexConfigCommonImageFilter,       /**< reference: OMX_CONFIG_IMAGEFILTERTYPE */
+    OMX_IndexConfigCommonColorEnhancement,  /**< reference: OMX_CONFIG_COLORENHANCEMENTTYPE */
+    OMX_IndexConfigCommonColorKey,          /**< reference: OMX_CONFIG_COLORKEYTYPE */
+    OMX_IndexConfigCommonColorBlend,        /**< reference: OMX_CONFIG_COLORBLENDTYPE */
+    OMX_IndexConfigCommonFrameStabilisation,/**< reference: OMX_CONFIG_FRAMESTABTYPE */
+    OMX_IndexConfigCommonRotate,            /**< reference: OMX_CONFIG_ROTATIONTYPE */
+    OMX_IndexConfigCommonMirror,            /**< reference: OMX_CONFIG_MIRRORTYPE */
+    OMX_IndexConfigCommonOutputPosition,    /**< reference: OMX_CONFIG_POINTTYPE */
+    OMX_IndexConfigCommonInputCrop,         /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonOutputCrop,        /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonDigitalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
+    OMX_IndexConfigCommonOpticalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE*/
+    OMX_IndexConfigCommonWhiteBalance,      /**< reference: OMX_CONFIG_WHITEBALCONTROLTYPE */
+    OMX_IndexConfigCommonExposure,          /**< reference: OMX_CONFIG_EXPOSURECONTROLTYPE */
+    OMX_IndexConfigCommonContrast,          /**< reference: OMX_CONFIG_CONTRASTTYPE */
+    OMX_IndexConfigCommonBrightness,        /**< reference: OMX_CONFIG_BRIGHTNESSTYPE */
+    OMX_IndexConfigCommonBacklight,         /**< reference: OMX_CONFIG_BACKLIGHTTYPE */
+    OMX_IndexConfigCommonGamma,             /**< reference: OMX_CONFIG_GAMMATYPE */
+    OMX_IndexConfigCommonSaturation,        /**< reference: OMX_CONFIG_SATURATIONTYPE */
+    OMX_IndexConfigCommonLightness,         /**< reference: OMX_CONFIG_LIGHTNESSTYPE */
+    OMX_IndexConfigCommonExclusionRect,     /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonDithering,         /**< reference: OMX_CONFIG_DITHERTYPE */
+    OMX_IndexConfigCommonPlaneBlend,        /**< reference: OMX_CONFIG_PLANEBLENDTYPE */
+    OMX_IndexConfigCommonExposureValue,     /**< reference: OMX_CONFIG_EXPOSUREVALUETYPE */
+    OMX_IndexConfigCommonOutputSize,        /**< reference: OMX_FRAMESIZETYPE */
+    OMX_IndexParamCommonExtraQuantData,     /**< reference: OMX_OTHER_EXTRADATATYPE */
+    OMX_IndexConfigCommonFocusRegion,       /**< reference: OMX_CONFIG_FOCUSREGIONTYPE */
+    OMX_IndexConfigCommonFocusStatus,       /**< reference: OMX_PARAM_FOCUSSTATUSTYPE */
+    OMX_IndexConfigCommonTransitionEffect,  /**< reference: OMX_CONFIG_TRANSITIONEFFECTTYPE */
+
+    /* Reserved Configuration range */
+    OMX_IndexOtherStartUnused = 0x08000000,
+    OMX_IndexParamOtherPortFormat,          /**< reference: OMX_OTHER_PARAM_PORTFORMATTYPE */
+    OMX_IndexConfigOtherPower,              /**< reference: OMX_OTHER_CONFIG_POWERTYPE */
+    OMX_IndexConfigOtherStats,              /**< reference: OMX_OTHER_CONFIG_STATSTYPE */
+
+
+    /* Reserved Time range */
+    OMX_IndexTimeStartUnused = 0x09000000,
+    OMX_IndexConfigTimeScale,               /**< reference: OMX_TIME_CONFIG_SCALETYPE */
+    OMX_IndexConfigTimeClockState,          /**< reference: OMX_TIME_CONFIG_CLOCKSTATETYPE */
+    OMX_IndexConfigTimeActiveRefClock,      /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
+    OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    OMX_IndexConfigTimeCurrentWallTime,     /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    OMX_IndexConfigTimeCurrentAudioReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimeCurrentVideoReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
+    OMX_IndexConfigTimeClientStartTime,     /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimePosition,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
+    OMX_IndexConfigTimeSeekMode,            /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */
+
+
+    OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    /* Vendor specific area */
+    OMX_IndexVendorStartUnused = 0x7F000000,
+    /* Vendor specific structures should be in the range of 0x7F000000 
+       to 0x7FFFFFFE.  This range is not broken out by vendor, so
+       private indexes are not guaranteed unique and therefore should
+       only be sent to the appropriate component. */
+
+    OMX_IndexMax = 0x7FFFFFFF
+
+} OMX_INDEXTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/omx/headers/OMX_Other.h b/omx/headers/OMX_Other.h
index a4b5bd9..cbaa98f 100644
--- a/omx/headers/OMX_Other.h
+++ b/omx/headers/OMX_Other.h
@@ -1,325 +1,337 @@
-/*
- * Copyright (c) 2007 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** @file OMX_Other.h - OpenMax IL version 1.1.1
- *  The structures needed by Other components to exchange
- *  parameters and configuration data with the components.
- */
-
-#ifndef OMX_Other_h
-#define OMX_Other_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/* Each OMX header must include all required header files to allow the
- *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully 
- */
-
-#include <OMX_Core.h>
-
-
-/** 
- * Enumeration of possible data types which match to multiple domains or no
- * domain at all.  For types which are vendor specific, a value above
- * OMX_OTHER_VENDORTSTART should be used.
- */
-typedef enum OMX_OTHER_FORMATTYPE {
-    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time, 
-                                   time deltas, etc */
-    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power 
-                                   management, setting clocks? */
-    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames 
-                                   dropped, etc */
-    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
-    OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific 
-                                                formats */
-
-    OMX_OTHER_FormatMax = 0x7FFFFFFF
-} OMX_OTHER_FORMATTYPE;
-
-/** 
- * Enumeration of seek modes.
- */
-typedef enum OMX_TIME_SEEKMODETYPE {
-    OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
-                                * of the requested seek position over   
-                                * the actual seek position if it
-                                * results in a faster seek. */
-    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek 
-                                * position over an approximation
-                                * of the requested seek position even
-                                * if it results in a slower seek. */
-    OMX_TIME_SeekModeMax = 0x7FFFFFFF
-} OMX_TIME_SEEKMODETYPE;
-
-/* Structure representing the seekmode of the component */
-typedef struct OMX_TIME_CONFIG_SEEKMODETYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
-} OMX_TIME_CONFIG_SEEKMODETYPE;
-
-/** Structure representing a time stamp used with the following configs 
- * on the Clock Component (CC):
- * 
- * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall  
- *     time
- * OMX_IndexConfigTimeCurrentMediaTime: query of the CCs current media
- *     time
- * OMX_IndexConfigTimeAudioReferenceTime and  
- * OMX_IndexConfigTimeVideoReferenceTime: audio/video reference 
- *     clock sending SC its reference time
- * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends 
- *     this structure to the Clock Component via a SetConfig on its 
- *     client port when it receives a buffer with
- *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
- *     specified by that buffer for nStartTimestamp. 
- *
- * Its also used with the following config on components in general:
- *
- * OMX_IndexConfigTimePosition: IL client querying component position 
- * (GetConfig) or commanding a component to seek to the given location
- * (SetConfig)
- */	
-typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
-    OMX_U32 nSize;               /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;    /**< OMX specification version
-                                  *   information */
-    OMX_U32 nPortIndex;     /**< port that this structure applies to */
-    OMX_TICKS nTimestamp;  	     /**< timestamp .*/ 
-} OMX_TIME_CONFIG_TIMESTAMPTYPE;  
-
-/** Enumeration of possible reference clocks to the media time. */
-typedef enum OMX_TIME_UPDATETYPE {
-      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
-      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
-      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
-      OMX_TIME_UpdateMax = 0x7FFFFFFF
-} OMX_TIME_UPDATETYPE;
-
-/** Enumeration of possible reference clocks to the media time. */
-typedef enum OMX_TIME_REFCLOCKTYPE {
-      OMX_TIME_RefClockNone,    /**< Use no references. */
-      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
-      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
-      OMX_TIME_RefClockMax = 0x7FFFFFFF
-} OMX_TIME_REFCLOCKTYPE;
-
-/** Enumeration of clock states. */
-typedef enum OMX_TIME_CLOCKSTATE {
-      OMX_TIME_ClockStateRunning,             /**< Clock running. */
-      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the 
-                                               *   prescribed clients emit their
-                                               *   start time. */
-      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
-      OMX_TIME_ClockStateMax = 0x7FFFFFFF
-} OMX_TIME_CLOCKSTATE;
-
-/** Structure representing a media time request to the clock component.
- *
- *  A client component sends this structure to the Clock Component via a SetConfig
- *  on its client port to specify a media timestamp the Clock Component
- *  should emit.  The Clock Component should fulfill the request by sending a
- *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested 
- *  timestamp.
- *
- *  The client may require a media time request be fulfilled slightly
- *  earlier than the media time specified. In this case the client specifies 
- *  an offset which is equal to the difference between wall time corresponding 
- *  to the requested media time and the wall time when it will be 
- *  fulfilled. 
- *
- *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
- *  time events according to timestamps. If a client must perform an operation O at
- *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a 
- *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
- *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
- *  structure back to the client component, the client may perform operation O (perhaps having
- *  to wait a slight amount more time itself as specified by the return values).
- */
-
-typedef struct OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time 
-                                 *   from others (e.g. the number of the frame to deliver). 
-                                 *   Duplicated in the media time structure that fulfills 
-                                 *   this request. A value of zero is reserved for time scale 
-                                 *   updates. */
-    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/ 
-    OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
-                                 *   request should be fulfilled early */
-} OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;
-
-/**< Structure sent from the clock component client either when fulfilling 
- *   a media time request or when the time scale has changed. 
- *
- *   In the former case the Clock Component fills this structure and times its emission 
- *   to a client component (via the client port) according to the corresponding media 
- *   time request sent by the client. The Clock Component should time the emission to occur
- *   when the requested timestamp matches the Clock Component's media time but also the 
- *   prescribed offset early. 
- *
- *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
- *   media time and sets the nScale to the new scale via the client port. It emits a 
- *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to 
- *   alter processing to accomodate scaling. For instance a video component might skip inter-frames 
- *   in the case of extreme fastforward. Likewise an audio component might add or remove samples 
- *   from an audio frame to scale audio data. 
- *
- *   It is expected that some clock components may not be able to fulfill requests
- *   at exactly the prescribed time. This is acceptable so long as the request is 
- *   fulfilled at least as early as described and not later. This structure provides 
- *   fields the client may use to wait for the remaining time.
- *
- *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the 
- *   wall time until the nMediaTimestamp actually occurs. In the latter case the
- *   client can get a more accurate value for offset by getting the current wall
- *   from the cloc component and subtracting it from nWallTimeAtMedia. 
- */
-
-typedef struct OMX_TIME_MEDIATIMETYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time 
-                                     *   from others. Copied from the media time request. 
-                                     *   A value of zero is reserved for time scale updates. */
-    OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
-    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was 
-                                     *   requested then this is the current media time. */ 
-    OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
-                                     *   request was actually fulfilled early */
-
-    OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
-                                     *   A client may compare this value to current
-                                     *   media time obtained from the Clock Component to determine
-                                     *   the wall time until the media timestamp is really
-                                     *   current. */
-    OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
-    OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
-                                    /**< State of the media time. */
-} OMX_TIME_MEDIATIMETYPE;  
-
-/** Structure representing the current media time scale factor. Applicable only to clock 
- *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
- *  the clock component client ports. Upon recieving this config the clock component changes 
- *  the rate by which the media time increases or decreases effectively implementing trick modes. 
- */ 
-typedef struct OMX_TIME_CONFIG_SCALETYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
-                                     * scaling the media time */
-} OMX_TIME_CONFIG_SCALETYPE;
- 
-/** Bits used to identify a clock port. Used in OMX_TIME_CONFIGs nWaitMask field */
-#define OMX_CLOCKPORT0 0x00000001
-#define OMX_CLOCKPORT1 0x00000002
-#define OMX_CLOCKPORT2 0x00000004
-#define OMX_CLOCKPORT3 0x00000008
-#define OMX_CLOCKPORT4 0x00000010
-#define OMX_CLOCKPORT5 0x00000020
-#define OMX_CLOCKPORT6 0x00000040
-#define OMX_CLOCKPORT7 0x00000080
-
-/** Structure representing the current mode of the media clock. 
- *  IL Client uses this config to change or query the mode of the 
- *  media clock of the clock component. Applicable only to clock
- *  component. 
- *  
- *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
- *  starts immediately at the prescribed start time. If
- *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
- *  the given nStartTime and waits for all clients specified in the 
- *  nWaitMask to send starttimes (via 
- *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts 
- *  the media clock using the earliest start time supplied. */    
-typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version 
-                                 *   information */
-    OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
-    OMX_TICKS nStartTime;       /**< Start time of the media time. */
-    OMX_TICKS nOffset;          /**< Time to offset the media time by 
-                                 * (e.g. preroll). Media time will be
-                                 * reported to be nOffset ticks earlier.     
-                                 */
-    OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
-} OMX_TIME_CONFIG_CLOCKSTATETYPE;
-
-/** Structure representing the reference clock currently being used to
- *  compute media time. IL client uses this config to change or query the 
- *  clock component's active reference clock */
-typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */                        
-} OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;
-
-/** Descriptor for setting specifics of power type. */
-typedef struct OMX_OTHER_CONFIG_POWERTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
-} OMX_OTHER_CONFIG_POWERTYPE;
-
-
-/** Descriptor for setting specifics of stats type. */
-typedef struct OMX_OTHER_CONFIG_STATSTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    /* what goes here */
-} OMX_OTHER_CONFIG_STATSTYPE;
-
-
-/**
- * The PortDefinition structure is used to define all of the parameters 
- * necessary for the compliant component to setup an input or an output other 
- * path.
- */
-typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
-    OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
-} OMX_OTHER_PORTDEFINITIONTYPE;
-
-/**  Port format parameter.  This structure is used to enumerate
-  *  the various data input/output format supported by the port.
-  */
-typedef struct OMX_OTHER_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize; /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex; /**< Indicates which port to set */
-    OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
-    OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
-} OMX_OTHER_PARAM_PORTFORMATTYPE; 
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_Other.h - OpenMax IL version 1.1.2
+ *  The structures needed by Other components to exchange
+ *  parameters and configuration data with the components.
+ */
+
+#ifndef OMX_Other_h
+#define OMX_Other_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Core.h>
+
+
+/** 
+ * Enumeration of possible data types which match to multiple domains or no
+ * domain at all.  For types which are vendor specific, a value above
+ * OMX_OTHER_VENDORTSTART should be used.
+ */
+typedef enum OMX_OTHER_FORMATTYPE {
+    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time, 
+                                   time deltas, etc */
+    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power 
+                                   management, setting clocks? */
+    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames 
+                                   dropped, etc */
+    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
+    OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific 
+                                                formats */
+
+    OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_OTHER_FormatMax = 0x7FFFFFFF
+} OMX_OTHER_FORMATTYPE;
+
+/** 
+ * Enumeration of seek modes.
+ */
+typedef enum OMX_TIME_SEEKMODETYPE {
+    OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
+                                * of the requested seek position over   
+                                * the actual seek position if it
+                                * results in a faster seek. */
+    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek 
+                                * position over an approximation
+                                * of the requested seek position even
+                                * if it results in a slower seek. */
+    OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_TIME_SeekModeMax = 0x7FFFFFFF
+} OMX_TIME_SEEKMODETYPE;
+
+/* Structure representing the seekmode of the component */
+typedef struct OMX_TIME_CONFIG_SEEKMODETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
+} OMX_TIME_CONFIG_SEEKMODETYPE;
+
+/** Structure representing a time stamp used with the following configs 
+ * on the Clock Component (CC):
+ * 
+ * OMX_IndexConfigTimeCurrentWallTime: query of the CC$BCT(B current wall  
+ *     time
+ * OMX_IndexConfigTimeCurrentMediaTime: query of the CC$BCT(B current media
+ *     time
+ * OMX_IndexConfigTimeCurrentAudioReference and  
+ * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference 
+ *     clock sending SC its reference time
+ * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends 
+ *     this structure to the Clock Component via a SetConfig on its 
+ *     client port when it receives a buffer with
+ *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
+ *     specified by that buffer for nStartTimestamp. 
+ *
+ * It$BCT(B also used with the following config on components in general:
+ *
+ * OMX_IndexConfigTimePosition: IL client querying component position 
+ * (GetConfig) or commanding a component to seek to the given location
+ * (SetConfig)
+ */	
+typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
+    OMX_U32 nSize;               /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;    /**< OMX specification version
+                                  *   information */
+    OMX_U32 nPortIndex;     /**< port that this structure applies to */
+    OMX_TICKS nTimestamp;  	     /**< timestamp .*/ 
+} OMX_TIME_CONFIG_TIMESTAMPTYPE;  
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum OMX_TIME_UPDATETYPE {
+      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
+      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
+      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
+      OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+      OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_UpdateMax = 0x7FFFFFFF
+} OMX_TIME_UPDATETYPE;
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum OMX_TIME_REFCLOCKTYPE {
+      OMX_TIME_RefClockNone,    /**< Use no references. */
+      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
+      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
+      OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+      OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_RefClockMax = 0x7FFFFFFF
+} OMX_TIME_REFCLOCKTYPE;
+
+/** Enumeration of clock states. */
+typedef enum OMX_TIME_CLOCKSTATE {
+      OMX_TIME_ClockStateRunning,             /**< Clock running. */
+      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the 
+                                               *   prescribed clients emit their
+                                               *   start time. */
+      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
+      OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+      OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_ClockStateMax = 0x7FFFFFFF
+} OMX_TIME_CLOCKSTATE;
+
+/** Structure representing a media time request to the clock component.
+ *
+ *  A client component sends this structure to the Clock Component via a SetConfig
+ *  on its client port to specify a media timestamp the Clock Component
+ *  should emit.  The Clock Component should fulfill the request by sending a
+ *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested 
+ *  timestamp.
+ *
+ *  The client may require a media time request be fulfilled slightly
+ *  earlier than the media time specified. In this case the client specifies 
+ *  an offset which is equal to the difference between wall time corresponding 
+ *  to the requested media time and the wall time when it will be 
+ *  fulfilled. 
+ *
+ *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
+ *  time events according to timestamps. If a client must perform an operation O at
+ *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a 
+ *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
+ *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
+ *  structure back to the client component, the client may perform operation O (perhaps having
+ *  to wait a slight amount more time itself as specified by the return values).
+ */
+
+typedef struct OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time 
+                                 *   from others (e.g. the number of the frame to deliver). 
+                                 *   Duplicated in the media time structure that fulfills 
+                                 *   this request. A value of zero is reserved for time scale 
+                                 *   updates. */
+    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/ 
+    OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
+                                 *   request should be fulfilled early */
+} OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;
+
+/**< Structure sent from the clock component client either when fulfilling 
+ *   a media time request or when the time scale has changed. 
+ *
+ *   In the former case the Clock Component fills this structure and times its emission 
+ *   to a client component (via the client port) according to the corresponding media 
+ *   time request sent by the client. The Clock Component should time the emission to occur
+ *   when the requested timestamp matches the Clock Component's media time but also the 
+ *   prescribed offset early. 
+ *
+ *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
+ *   media time and sets the nScale to the new scale via the client port. It emits a 
+ *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to 
+ *   alter processing to accomodate scaling. For instance a video component might skip inter-frames 
+ *   in the case of extreme fastforward. Likewise an audio component might add or remove samples 
+ *   from an audio frame to scale audio data. 
+ *
+ *   It is expected that some clock components may not be able to fulfill requests
+ *   at exactly the prescribed time. This is acceptable so long as the request is 
+ *   fulfilled at least as early as described and not later. This structure provides 
+ *   fields the client may use to wait for the remaining time.
+ *
+ *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the 
+ *   wall time until the nMediaTimestamp actually occurs. In the latter case the
+ *   client can get a more accurate value for offset by getting the current wall
+ *   from the cloc component and subtracting it from nWallTimeAtMedia. 
+ */
+
+typedef struct OMX_TIME_MEDIATIMETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time 
+                                     *   from others. Copied from the media time request. 
+                                     *   A value of zero is reserved for time scale updates. */
+    OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
+    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was 
+                                     *   requested then this is the current media time. */ 
+    OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
+                                     *   request was actually fulfilled early */
+
+    OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
+                                     *   A client may compare this value to current
+                                     *   media time obtained from the Clock Component to determine
+                                     *   the wall time until the media timestamp is really
+                                     *   current. */
+    OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
+    OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
+                                    /**< State of the media time. */
+} OMX_TIME_MEDIATIMETYPE;  
+
+/** Structure representing the current media time scale factor. Applicable only to clock 
+ *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
+ *  the clock component client ports. Upon recieving this config the clock component changes 
+ *  the rate by which the media time increases or decreases effectively implementing trick modes. 
+ */ 
+typedef struct OMX_TIME_CONFIG_SCALETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
+                                     * scaling the media time */
+} OMX_TIME_CONFIG_SCALETYPE;
+ 
+/** Bits used to identify a clock port. Used in OMX_TIME_CONFIG_CLOCKSTATETYPE$BCT(B nWaitMask field */
+#define OMX_CLOCKPORT0 0x00000001
+#define OMX_CLOCKPORT1 0x00000002
+#define OMX_CLOCKPORT2 0x00000004
+#define OMX_CLOCKPORT3 0x00000008
+#define OMX_CLOCKPORT4 0x00000010
+#define OMX_CLOCKPORT5 0x00000020
+#define OMX_CLOCKPORT6 0x00000040
+#define OMX_CLOCKPORT7 0x00000080
+
+/** Structure representing the current mode of the media clock. 
+ *  IL Client uses this config to change or query the mode of the 
+ *  media clock of the clock component. Applicable only to clock
+ *  component. 
+ *  
+ *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
+ *  starts immediately at the prescribed start time. If
+ *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
+ *  the given nStartTime and waits for all clients specified in the 
+ *  nWaitMask to send starttimes (via 
+ *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts 
+ *  the media clock using the earliest start time supplied. */    
+typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version 
+                                 *   information */
+    OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
+    OMX_TICKS nStartTime;       /**< Start time of the media time. */
+    OMX_TICKS nOffset;          /**< Time to offset the media time by 
+                                 * (e.g. preroll). Media time will be
+                                 * reported to be nOffset ticks earlier.     
+                                 */
+    OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
+} OMX_TIME_CONFIG_CLOCKSTATETYPE;
+
+/** Structure representing the reference clock currently being used to
+ *  compute media time. IL client uses this config to change or query the 
+ *  clock component's active reference clock */
+typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */                        
+} OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;
+
+/** Descriptor for setting specifics of power type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct OMX_OTHER_CONFIG_POWERTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
+} OMX_OTHER_CONFIG_POWERTYPE;
+
+
+/** Descriptor for setting specifics of stats type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct OMX_OTHER_CONFIG_STATSTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    /* what goes here */
+} OMX_OTHER_CONFIG_STATSTYPE;
+
+
+/**
+ * The PortDefinition structure is used to define all of the parameters 
+ * necessary for the compliant component to setup an input or an output other 
+ * path.
+ */
+typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
+    OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
+} OMX_OTHER_PORTDEFINITIONTYPE;
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct OMX_OTHER_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize; /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex; /**< Indicates which port to set */
+    OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
+} OMX_OTHER_PARAM_PORTFORMATTYPE; 
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/omx/headers/OMX_Types.h b/omx/headers/OMX_Types.h
index a6ad31e..31be916 100644
--- a/omx/headers/OMX_Types.h
+++ b/omx/headers/OMX_Types.h
@@ -1,355 +1,347 @@
-/*
- * Copyright (c) 2007 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** OMX_Types.h - OpenMax IL version 1.1.1
- *  The OMX_Types header file contains the primitive type definitions used by 
- *  the core, the application and the component.  This file may need to be
- *  modified to be used on systems that do not have "char" set to 8 bits, 
- *  "short" set to 16 bits and "long" set to 32 bits.
- */
-
-#ifndef OMX_Types_h
-#define OMX_Types_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/** The OMX_API and OMX_APIENTRY are platform specific definitions used
- *  to declare OMX function prototypes.  They are modified to meet the
- *  requirements for a particular platform */
-#ifdef _WIN32
-#   ifdef __OMX_EXPORTS
-#       define OMX_API __declspec(dllexport)
-#   else
-#       define OMX_API __declspec(dllimport)
-#   endif
-#else
-#   ifdef __OMX_EXPORTS
-#       define OMX_API
-#   else
-#       define OMX_API extern
-#   endif
-#endif
-
-#ifdef __SYMBIAN32__
-#   ifdef __OMX_EXPORTS
-#       define OMX_API EXPORT_C
-#   else
-#       define OMX_API IMPORT_C
-#   endif
-#elif defined(_WIN32)
-#   ifdef __OMX_EXPORTS
-#       define OMX_API __declspec(dllexport)
-#   else
-#       define OMX_API __declspec(dllimport)
-#   endif
-#else
-#   ifdef __OMX_EXPORTS
-#       define OMX_API
-#   else
-#       define OMX_API extern
-#   endif
-#endif
-
-#ifndef OMX_APIENTRY
-#define OMX_APIENTRY 
-#endif 
-
-/** OMX_IN is used to identify inputs to an OMX function.  This designation 
-    will also be used in the case of a pointer that points to a parameter 
-    that is used as an output. */
-#ifndef OMX_IN
-#define OMX_IN
-#endif
-
-/** OMX_OUT is used to identify outputs from an OMX function.  This 
-    designation will also be used in the case of a pointer that points 
-    to a parameter that is used as an input. */
-#ifndef OMX_OUT
-#define OMX_OUT
-#endif
-
-
-/** OMX_INOUT is used to identify parameters that may be either inputs or
-    outputs from an OMX function at the same time.  This designation will 
-    also be used in the case of a pointer that  points to a parameter that 
-    is used both as an input and an output. */
-#ifndef OMX_INOUT
-#define OMX_INOUT
-#endif
-
-/** OMX_ALL is used to as a wildcard to select all entities of the same type
- *  when specifying the index, or referring to a object by an index.  (i.e.
- *  use OMX_ALL to indicate all N channels). When used as a port index
- *  for a config or parameter this OMX_ALL denotes that the config or
- *  parameter applies to the entire component not just one port. */
-#define OMX_ALL 0xFFFFFFFF
-
-/** In the following we define groups that help building doxygen documentation */
-
-/** @defgroup core OpenMAX IL core
- * Functions and structure related to the OMX IL core
- */
- 
- /** @defgroup comp OpenMAX IL component
- * Functions and structure related to the OMX IL component
- */
- 
-/** @defgroup rpm Resource and Policy Management 
- * Structures for resource and policy management of components
- */
-
-/** @defgroup buf Buffer Management
- * Buffer handling functions and structures
- */
-  
-/** @defgroup tun Tunneling
- * @ingroup core comp
- * Structures and functions to manage tunnels among component ports
- */
- 
-/** @defgroup cp Content Pipes
- *  @ingroup core
- */
- 
- /** @defgroup metadata Metadata handling
-  * 
-  */ 
-
-/** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
-typedef unsigned char OMX_U8;
-
-/** OMX_S8 is an 8 bit signed quantity that is byte aligned */
-typedef signed char OMX_S8;
-
-/** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
-typedef unsigned short OMX_U16;
-
-/** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
-typedef signed short OMX_S16;
-
-/** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
-typedef unsigned long OMX_U32;
-
-/** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
-typedef signed long OMX_S32;
-
-
-/* Users with compilers that cannot accept the "long long" designation should
-   define the OMX_SKIP64BIT macro.  It should be noted that this may cause 
-   some components to fail to compile if the component was written to require
-   64 bit integral types.  However, these components would NOT compile anyway
-   since the compiler does not support the way the component was written.
-*/
-#ifndef OMX_SKIP64BIT
-#ifdef __SYMBIAN32__
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
-typedef unsigned long long OMX_U64;
-
-/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
-typedef signed long long OMX_S64;
-
-#elif defined(WIN32)
-
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */   
-typedef unsigned __int64  OMX_U64;
-
-/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
-typedef signed   __int64  OMX_S64;
-
-#else /* WIN32 */
-
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
-typedef unsigned long long OMX_U64;
-
-/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
-typedef signed long long OMX_S64;
-
-#endif /* WIN32 */
-#endif
-
-
-/** The OMX_BOOL type is intended to be used to represent a true or a false 
-    value when passing parameters to and from the OMX core and components.  The
-    OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
- */
-typedef enum OMX_BOOL {
-    OMX_FALSE = 0,
-    OMX_TRUE = !OMX_FALSE,
-    OMX_BOOL_MAX = 0x7FFFFFFF
-} OMX_BOOL; 
- 
-/** The OMX_PTR type is intended to be used to pass pointers between the OMX
-    applications and the OMX Core and components.  This is a 32 bit pointer and
-    is aligned on a 32 bit boundary.
- */
-typedef void* OMX_PTR;
-
-/** The OMX_STRING type is intended to be used to pass "C" type strings between
-    the application and the core and component.  The OMX_STRING type is a 32 
-    bit pointer to a zero terminated string.  The  pointer is word aligned and 
-    the string is byte aligned.  
- */
-typedef char* OMX_STRING;
-
-/** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
-    buffers between the application and the component and core.  The OMX_BYTE 
-    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
-    aligned and the string is byte aligned.
- */
-typedef unsigned char* OMX_BYTE;
-
-/** OMX_UUIDTYPE is a very long unique identifier to uniquely identify
-    at runtime.  This identifier should be generated by a component in a way
-    that guarantees that every instance of the identifier running on the system
-    is unique. */
-typedef unsigned char OMX_UUIDTYPE[128];
-
-/** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
-    an output port.  This enumeration is common across all component types.    
- */
-typedef enum OMX_DIRTYPE
-{
-    OMX_DirInput,              /**< Port is an input port */
-    OMX_DirOutput,             /**< Port is an output port */
-    OMX_DirMax = 0x7FFFFFFF
-} OMX_DIRTYPE;
-
-/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering 
-    for numerical data (i.e. big endian, or little endian).    
- */
-typedef enum OMX_ENDIANTYPE
-{
-    OMX_EndianBig, /**< big endian */
-    OMX_EndianLittle, /**< little endian */
-    OMX_EndianMax = 0x7FFFFFFF
-} OMX_ENDIANTYPE;
-
-
-/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data 
-    is signed or unsigned
- */
-typedef enum OMX_NUMERICALDATATYPE
-{
-    OMX_NumericalDataSigned, /**< signed data */
-    OMX_NumericalDataUnsigned, /**< unsigned data */
-    OMX_NumercialDataMax = 0x7FFFFFFF
-} OMX_NUMERICALDATATYPE;
-
-
-/** Unsigned bounded value type */
-typedef struct OMX_BU32 {
-    OMX_U32 nValue; /**< actual value */
-    OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
-    OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
-} OMX_BU32;
-
-
-/** Signed bounded value type */
-typedef struct OMX_BS32 {
-    OMX_S32 nValue; /**< actual value */
-    OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
-    OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
-} OMX_BS32;
-
-
-/** Structure representing some time or duration in microseconds. This structure
-  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate 
-  *  negative deltas and preroll scenarios. The quantity is represented in microseconds 
-  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
-  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g. 
-  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to 
-  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
-  *  or minus 35 minutes).
-  *
-  *  Implementations with limited precision may convert the signed 64 bit value to 
-  *  a signed 32 bit value internally but risk loss of precision.  
-  */
-#ifndef OMX_SKIP64BIT
-typedef OMX_S64 OMX_TICKS;
-#else
-typedef struct OMX_TICKS
-{
-    OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
-    OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
-} OMX_TICKS;
-#endif
-#define OMX_TICKS_PER_SECOND 1000000
-
-/** Define the public interface for the OMX Handle.  The core will not use
-    this value internally, but the application should only use this value.
- */
-typedef void* OMX_HANDLETYPE;
-
-typedef struct OMX_MARKTYPE
-{
-    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will 
-                                                generate a mark event upon 
-                                                processing the mark. */
-    OMX_PTR pMarkData;   /**< Application specific data associated with 
-                              the mark sent on a mark event to disambiguate 
-                              this mark from others. */
-} OMX_MARKTYPE;
-
-
-/** OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
- *  platform & operating specific object used to reference the display 
- *  or can be used by a audio port for native audio rendering */
-typedef void* OMX_NATIVE_DEVICETYPE;
-
-/** OMX_NATIVE_WINDOWTYPE is used to map a OMX video port to the
- *  platform & operating specific object used to reference the window */
-typedef void* OMX_NATIVE_WINDOWTYPE;
-
-/** The OMX_VERSIONTYPE union is used to specify the version for
-    a structure or component.  For a component, the version is entirely
-    specified by the component vendor.  Components doing the same function
-    from different vendors may or may not have the same version.  For 
-    structures, the version shall be set by the entity that allocates the
-    structure.  For structures specified in the OMX 1.1 specification, the
-    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
-    OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
-    by accessing one of the structure elements to, for example, check only
-    the Major revision.
- */
-typedef union OMX_VERSIONTYPE
-{
-    struct
-    {
-        OMX_U8 nVersionMajor;   /**< Major version accessor element */
-        OMX_U8 nVersionMinor;   /**< Minor version accessor element */
-        OMX_U8 nRevision;       /**< Revision version accessor element */
-        OMX_U8 nStep;           /**< Step version accessor element */
-    } s;
-    OMX_U32 nVersion;           /**< 32 bit value to make accessing the
-                                    version easily done in a single word
-                                    size copy/compare operation */
-} OMX_VERSIONTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_Types.h - OpenMax IL version 1.1.2
+ *  The OMX_Types header file contains the primitive type definitions used by 
+ *  the core, the application and the component.  This file may need to be
+ *  modified to be used on systems that do not have "char" set to 8 bits, 
+ *  "short" set to 16 bits and "long" set to 32 bits.
+ */
+
+#ifndef OMX_Types_h
+#define OMX_Types_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/** The OMX_API and OMX_APIENTRY are platform specific definitions used
+ *  to declare OMX function prototypes.  They are modified to meet the
+ *  requirements for a particular platform */
+#ifdef __SYMBIAN32__   
+#   ifdef __OMX_EXPORTS
+#       define OMX_API __declspec(dllexport)
+#   else
+#       ifdef _WIN32
+#           define OMX_API __declspec(dllexport) 
+#       else
+#           define OMX_API __declspec(dllimport)
+#       endif
+#   endif
+#else
+#   ifdef _WIN32
+#      ifdef __OMX_EXPORTS
+#          define OMX_API __declspec(dllexport)
+#      else
+#          define OMX_API __declspec(dllimport)
+#      endif
+#   else
+#      ifdef __OMX_EXPORTS
+#          define OMX_API
+#      else
+#          define OMX_API extern
+#      endif
+#   endif
+#endif
+
+#ifndef OMX_APIENTRY
+#define OMX_APIENTRY 
+#endif 
+
+/** OMX_IN is used to identify inputs to an OMX function.  This designation 
+    will also be used in the case of a pointer that points to a parameter 
+    that is used as an output. */
+#ifndef OMX_IN
+#define OMX_IN
+#endif
+
+/** OMX_OUT is used to identify outputs from an OMX function.  This 
+    designation will also be used in the case of a pointer that points 
+    to a parameter that is used as an input. */
+#ifndef OMX_OUT
+#define OMX_OUT
+#endif
+
+
+/** OMX_INOUT is used to identify parameters that may be either inputs or
+    outputs from an OMX function at the same time.  This designation will 
+    also be used in the case of a pointer that  points to a parameter that 
+    is used both as an input and an output. */
+#ifndef OMX_INOUT
+#define OMX_INOUT
+#endif
+
+/** OMX_ALL is used to as a wildcard to select all entities of the same type
+ *  when specifying the index, or referring to a object by an index.  (i.e.
+ *  use OMX_ALL to indicate all N channels). When used as a port index
+ *  for a config or parameter this OMX_ALL denotes that the config or
+ *  parameter applies to the entire component not just one port. */
+#define OMX_ALL 0xFFFFFFFF
+
+/** In the following we define groups that help building doxygen documentation */
+
+/** @defgroup core OpenMAX IL core
+ * Functions and structure related to the OMX IL core
+ */
+ 
+ /** @defgroup comp OpenMAX IL component
+ * Functions and structure related to the OMX IL component
+ */
+ 
+/** @defgroup rpm Resource and Policy Management 
+ * Structures for resource and policy management of components
+ */
+
+/** @defgroup buf Buffer Management
+ * Buffer handling functions and structures
+ */
+  
+/** @defgroup tun Tunneling
+ * @ingroup core comp
+ * Structures and functions to manage tunnels among component ports
+ */
+ 
+/** @defgroup cp Content Pipes
+ *  @ingroup core
+ */
+ 
+ /** @defgroup metadata Metadata handling
+  * 
+  */ 
+
+/** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
+typedef unsigned char OMX_U8;
+
+/** OMX_S8 is an 8 bit signed quantity that is byte aligned */
+typedef signed char OMX_S8;
+
+/** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
+typedef unsigned short OMX_U16;
+
+/** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
+typedef signed short OMX_S16;
+
+/** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
+typedef unsigned long OMX_U32;
+
+/** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
+typedef signed long OMX_S32;
+
+
+/* Users with compilers that cannot accept the "long long" designation should
+   define the OMX_SKIP64BIT macro.  It should be noted that this may cause 
+   some components to fail to compile if the component was written to require
+   64 bit integral types.  However, these components would NOT compile anyway
+   since the compiler does not support the way the component was written.
+*/
+#ifndef OMX_SKIP64BIT
+#ifdef __SYMBIAN32__
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long OMX_S64;
+
+#elif defined(WIN32)
+
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */   
+typedef unsigned __int64  OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed   __int64  OMX_S64;
+
+#else /* WIN32 */
+
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long OMX_S64;
+
+#endif /* WIN32 */
+#endif
+
+
+/** The OMX_BOOL type is intended to be used to represent a true or a false 
+    value when passing parameters to and from the OMX core and components.  The
+    OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
+ */
+typedef enum OMX_BOOL {
+    OMX_FALSE = 0,
+    OMX_TRUE = !OMX_FALSE,
+    OMX_BOOL_MAX = 0x7FFFFFFF
+} OMX_BOOL; 
+ 
+/** The OMX_PTR type is intended to be used to pass pointers between the OMX
+    applications and the OMX Core and components.  This is a 32 bit pointer and
+    is aligned on a 32 bit boundary.
+ */
+typedef void* OMX_PTR;
+
+/** The OMX_STRING type is intended to be used to pass "C" type strings between
+    the application and the core and component.  The OMX_STRING type is a 32 
+    bit pointer to a zero terminated string.  The  pointer is word aligned and 
+    the string is byte aligned.  
+ */
+typedef char* OMX_STRING;
+
+/** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
+    buffers between the application and the component and core.  The OMX_BYTE 
+    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
+    aligned and the string is byte aligned.
+ */
+typedef unsigned char* OMX_BYTE;
+
+/** OMX_UUIDTYPE is a very long unique identifier to uniquely identify
+    at runtime.  This identifier should be generated by a component in a way
+    that guarantees that every instance of the identifier running on the system
+    is unique. */
+typedef unsigned char OMX_UUIDTYPE[128];
+
+/** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
+    an output port.  This enumeration is common across all component types.    
+ */
+typedef enum OMX_DIRTYPE
+{
+    OMX_DirInput,              /**< Port is an input port */
+    OMX_DirOutput,             /**< Port is an output port */
+    OMX_DirMax = 0x7FFFFFFF
+} OMX_DIRTYPE;
+
+/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering 
+    for numerical data (i.e. big endian, or little endian).    
+ */
+typedef enum OMX_ENDIANTYPE
+{
+    OMX_EndianBig, /**< big endian */
+    OMX_EndianLittle, /**< little endian */
+    OMX_EndianMax = 0x7FFFFFFF
+} OMX_ENDIANTYPE;
+
+
+/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data 
+    is signed or unsigned
+ */
+typedef enum OMX_NUMERICALDATATYPE
+{
+    OMX_NumericalDataSigned, /**< signed data */
+    OMX_NumericalDataUnsigned, /**< unsigned data */
+    OMX_NumercialDataMax = 0x7FFFFFFF
+} OMX_NUMERICALDATATYPE;
+
+
+/** Unsigned bounded value type */
+typedef struct OMX_BU32 {
+    OMX_U32 nValue; /**< actual value */
+    OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} OMX_BU32;
+
+
+/** Signed bounded value type */
+typedef struct OMX_BS32 {
+    OMX_S32 nValue; /**< actual value */
+    OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} OMX_BS32;
+
+
+/** Structure representing some time or duration in microseconds. This structure
+  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate 
+  *  negative deltas and preroll scenarios. The quantity is represented in microseconds 
+  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
+  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g. 
+  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to 
+  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
+  *  or minus 35 minutes).
+  *
+  *  Implementations with limited precision may convert the signed 64 bit value to 
+  *  a signed 32 bit value internally but risk loss of precision.  
+  */
+#ifndef OMX_SKIP64BIT
+typedef OMX_S64 OMX_TICKS;
+#else
+typedef struct OMX_TICKS
+{
+    OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
+    OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
+} OMX_TICKS;
+#endif
+#define OMX_TICKS_PER_SECOND 1000000
+
+/** Define the public interface for the OMX Handle.  The core will not use
+    this value internally, but the application should only use this value.
+ */
+typedef void* OMX_HANDLETYPE;
+
+typedef struct OMX_MARKTYPE
+{
+    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will 
+                                                generate a mark event upon 
+                                                processing the mark. */
+    OMX_PTR pMarkData;   /**< Application specific data associated with 
+                              the mark sent on a mark event to disambiguate 
+                              this mark from others. */
+} OMX_MARKTYPE;
+
+
+/** OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the display 
+ *  or can be used by a audio port for native audio rendering */
+typedef void* OMX_NATIVE_DEVICETYPE;
+
+/** OMX_NATIVE_WINDOWTYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the window */
+typedef void* OMX_NATIVE_WINDOWTYPE;
+
+/** The OMX_VERSIONTYPE union is used to specify the version for
+    a structure or component.  For a component, the version is entirely
+    specified by the component vendor.  Components doing the same function
+    from different vendors may or may not have the same version.  For 
+    structures, the version shall be set by the entity that allocates the
+    structure.  For structures specified in the OMX 1.1 specification, the
+    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
+    OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
+    by accessing one of the structure elements to, for example, check only
+    the Major revision.
+ */
+typedef union OMX_VERSIONTYPE
+{
+    struct
+    {
+        OMX_U8 nVersionMajor;   /**< Major version accessor element */
+        OMX_U8 nVersionMinor;   /**< Minor version accessor element */
+        OMX_U8 nRevision;       /**< Revision version accessor element */
+        OMX_U8 nStep;           /**< Step version accessor element */
+    } s;
+    OMX_U32 nVersion;           /**< 32 bit value to make accessing the
+                                    version easily done in a single word
+                                    size copy/compare operation */
+} OMX_VERSIONTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/omx/headers/OMX_Video.h b/omx/headers/OMX_Video.h
index 21ce5be..163e450 100644
--- a/omx/headers/OMX_Video.h
+++ b/omx/headers/OMX_Video.h
@@ -1,1025 +1,1060 @@
-/**
- * Copyright (c) 2007 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** 
- *  @file OMX_Video.h - OpenMax IL version 1.1.1
- *  The structures is needed by Video components to exchange parameters 
- *  and configuration data with OMX components.
- */
-#ifndef OMX_Video_h
-#define OMX_Video_h
-
-/** @defgroup video OpenMAX IL Video Domain
- * @ingroup iv
- * Structures for OpenMAX IL Video domain
- * @{
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/**
- * Each OMX header must include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully 
- */
-
-#include <OMX_IVCommon.h>
-
-
-/**
- * Enumeration used to define the possible video compression codings.  
- * NOTE:  This essentially refers to file extensions. If the coding is 
- *        being used to specify the ENCODE type, then additional work 
- *        must be done to configure the exact flavor of the compression 
- *        to be used.  For decode cases where the user application can 
- *        not differentiate between MPEG-4 and H.264 bit streams, it is 
- *        up to the codec to handle this.
- */
-typedef enum OMX_VIDEO_CODINGTYPE {
-    OMX_VIDEO_CodingUnused,     /**< Value when coding is N/A */
-    OMX_VIDEO_CodingAutoDetect, /**< Autodetection of coding type */
-    OMX_VIDEO_CodingMPEG2,      /**< AKA: H.262 */
-    OMX_VIDEO_CodingH263,       /**< H.263 */
-    OMX_VIDEO_CodingMPEG4,      /**< MPEG-4 */
-    OMX_VIDEO_CodingWMV,        /**< all versions of Windows Media Video */
-    OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
-    OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
-    OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
-    OMX_VIDEO_CodingMax = 0x7FFFFFFF
-} OMX_VIDEO_CODINGTYPE;
-
-
-/**
- * Data structure used to define a video path.  The number of Video paths for 
- * input and output will vary by type of the Video component.  
- * 
- *    Input (aka Source) : zero Inputs, one Output,
- *    Splitter           : one Input, 2 or more Outputs,
- *    Processing Element : one Input, one output,
- *    Mixer              : 2 or more inputs, one output,
- *    Output (aka Sink)  : one Input, zero outputs.
- * 
- * The PortDefinition structure is used to define all of the parameters 
- * necessary for the compliant component to setup an input or an output video 
- * path.  If additional vendor specific data is required, it should be 
- * transmitted to the component using the CustomCommand function.  Compliant 
- * components will prepopulate this structure with optimal values during the 
- * GetDefaultInitParams command.
- *
- * STRUCT MEMBERS:
- *  cMIMEType             : MIME type of data for the port
- *  pNativeRender         : Platform specific reference for a display if a 
- *                          sync, otherwise this field is 0
- *  nFrameWidth           : Width of frame to be used on channel if 
- *                          uncompressed format is used.  Use 0 for unknown,
- *                          don't care or variable
- *  nFrameHeight          : Height of frame to be used on channel if 
- *                          uncompressed format is used. Use 0 for unknown,
- *                          don't care or variable
- *  nStride               : Number of bytes per span of an image 
- *                          (i.e. indicates the number of bytes to get
- *                          from span N to span N+1, where negative stride
- *                          indicates the image is bottom up
- *  nSliceHeight          : Height used when encoding in slices
- *  nBitrate              : Bit rate of frame to be used on channel if 
- *                          compressed format is used. Use 0 for unknown, 
- *                          don't care or variable
- *  xFramerate            : Frame rate to be used on channel if uncompressed 
- *                          format is used. Use 0 for unknown, don't care or 
- *                          variable.  Units are Q16 frames per second.
- *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
- *                          the OMX component
- *  eCompressionFormat    : Compression format used in this instance of the 
- *                          component. When OMX_VIDEO_CodingUnused is 
- *                          specified, eColorFormat is used
- *  eColorFormat : Decompressed format used by this component
- *  pNativeWindow : Platform specific reference for a window object if a 
- *                          display sink , otherwise this field is 0x0. 
- */
-typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
-    OMX_STRING cMIMEType;
-    OMX_NATIVE_DEVICETYPE pNativeRender;
-    OMX_U32 nFrameWidth;
-    OMX_U32 nFrameHeight;
-    OMX_S32 nStride;
-    OMX_U32 nSliceHeight;
-    OMX_U32 nBitrate;
-    OMX_U32 xFramerate;
-    OMX_BOOL bFlagErrorConcealment;
-    OMX_VIDEO_CODINGTYPE eCompressionFormat;
-    OMX_COLOR_FORMATTYPE eColorFormat;
-    OMX_NATIVE_WINDOWTYPE pNativeWindow;
-} OMX_VIDEO_PORTDEFINITIONTYPE;
-
-/**  
- * Port format parameter.  This structure is used to enumerate the various 
- * data input/output format supported by the port.
- * 
- * STRUCT MEMBERS:
- *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information
- *  nPortIndex         : Indicates which port to set
- *  nIndex             : Indicates the enumeration index for the format from 
- *                       0x0 to N-1
- *  eCompressionFormat : Compression format used in this instance of the 
- *                       component. When OMX_VIDEO_CodingUnused is specified, 
- *                       eColorFormat is used 
- *  eColorFormat       : Decompressed format used by this component
- *  xFrameRate         : Indicates the video frame rate in Q16 format
- */
-typedef struct OMX_VIDEO_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nIndex;
-    OMX_VIDEO_CODINGTYPE eCompressionFormat; 
-    OMX_COLOR_FORMATTYPE eColorFormat;
-    OMX_U32 xFramerate;
-} OMX_VIDEO_PARAM_PORTFORMATTYPE;
-
-
-/**
- * This is a structure for configuring video compression quantization 
- * parameter values.  Codecs may support different QP values for different
- * frame types.
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version info
- *  nPortIndex : Port that this structure applies to
- *  nQpI       : QP value to use for index frames
- *  nQpP       : QP value to use for P frames
- *  nQpB       : QP values to use for bidirectional frames 
- */
-typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
-    OMX_U32 nSize;            
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nQpI;
-    OMX_U32 nQpP;
-    OMX_U32 nQpB;
-} OMX_VIDEO_PARAM_QUANTIZATIONTYPE;
-
-
-/** 
- * Structure for configuration of video fast update parameters. 
- *  
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version info 
- *  nPortIndex : Port that this structure applies to
- *  bEnableVFU : Enable/Disable video fast update
- *  nFirstGOB  : Specifies the number of the first macroblock row
- *  nFirstMB   : specifies the first MB relative to the specified first GOB
- *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB 
- *               and nFirstMB
- */
-typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
-    OMX_U32 nSize;            
-    OMX_VERSIONTYPE nVersion; 
-    OMX_U32 nPortIndex;       
-    OMX_BOOL bEnableVFU;      
-    OMX_U32 nFirstGOB;                            
-    OMX_U32 nFirstMB;                            
-    OMX_U32 nNumMBs;                                  
-} OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;
-
-
-/** 
- * Enumeration of possible bitrate control types 
- */
-typedef enum OMX_VIDEO_CONTROLRATETYPE {
-    OMX_Video_ControlRateDisable,
-    OMX_Video_ControlRateVariable,
-    OMX_Video_ControlRateConstant,
-    OMX_Video_ControlRateVariableSkipFrames,
-    OMX_Video_ControlRateConstantSkipFrames,
-    OMX_Video_ControlRateMax = 0x7FFFFFFF
-} OMX_VIDEO_CONTROLRATETYPE;
-
-
-/** 
- * Structure for configuring bitrate mode of a codec. 
- *
- * STRUCT MEMBERS:
- *  nSize          : Size of the struct in bytes
- *  nVersion       : OMX spec version info
- *  nPortIndex     : Port that this struct applies to
- *  eControlRate   : Control rate type enum
- *  nTargetBitrate : Target bitrate to encode with
- */
-typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
-    OMX_U32 nSize;                          
-    OMX_VERSIONTYPE nVersion;               
-    OMX_U32 nPortIndex;                     
-    OMX_VIDEO_CONTROLRATETYPE eControlRate; 
-    OMX_U32 nTargetBitrate;                 
-} OMX_VIDEO_PARAM_BITRATETYPE;
-
-
-/** 
- * Enumeration of possible motion vector (MV) types 
- */
-typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
-    OMX_Video_MotionVectorPixel,
-    OMX_Video_MotionVectorHalfPel,
-    OMX_Video_MotionVectorQuarterPel,
-    OMX_Video_MotionVectorEighthPel,
-    OMX_Video_MotionVectorMax = 0x7FFFFFFF
-} OMX_VIDEO_MOTIONVECTORTYPE;
-
-
-/**
- * Structure for configuring the number of motion vectors used as well
- * as their accuracy.
- * 
- * STRUCT MEMBERS:
- *  nSize            : Size of the struct in bytes
- *  nVersion         : OMX spec version info
- *  nPortIndex       : port that this structure applies to
- *  eAccuracy        : Enumerated MV accuracy
- *  bUnrestrictedMVs : Allow unrestricted MVs
- *  bFourMV          : Allow use of 4 MVs
- *  sXSearchRange    : Search range in horizontal direction for MVs
- *  sYSearchRange    : Search range in vertical direction for MVs
- */
-typedef struct OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_MOTIONVECTORTYPE eAccuracy;
-    OMX_BOOL bUnrestrictedMVs;
-    OMX_BOOL bFourMV;
-    OMX_S32 sXSearchRange;
-    OMX_S32 sYSearchRange;
-} OMX_VIDEO_PARAM_MOTIONVECTORTYPE;
-
-
-/** 
- * Enumeration of possible methods to use for Intra Refresh 
- */
-typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
-    OMX_VIDEO_IntraRefreshCyclic,
-    OMX_VIDEO_IntraRefreshAdaptive,
-    OMX_VIDEO_IntraRefreshBoth,
-    OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
-} OMX_VIDEO_INTRAREFRESHTYPE;
-
-
-/**
- * Structure for configuring intra refresh mode 
- * 
- * STRUCT MEMBERS:
- *  nSize        : Size of the structure in bytes
- *  nVersion     : OMX specification version information
- *  nPortIndex   : Port that this structure applies to
- *  eRefreshMode : Cyclic, Adaptive, or Both
- *  nAirMBs      : Number of intra macroblocks to refresh in a frame when 
- *                 AIR is enabled
- *  nAirRef      : Number of times a motion marked macroblock has to be  
- *                 intra coded
- *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"  
- *                 when CIR is enabled
- */
-typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_INTRAREFRESHTYPE eRefreshMode;
-    OMX_U32 nAirMBs;
-    OMX_U32 nAirRef;
-    OMX_U32 nCirMBs;
-} OMX_VIDEO_PARAM_INTRAREFRESHTYPE;
-
-
-/**
- * Structure for enabling various error correction methods for video 
- * compression.
- *
- * STRUCT MEMBERS:
- *  nSize                   : Size of the structure in bytes
- *  nVersion                : OMX specification version information 
- *  nPortIndex              : Port that this structure applies to 
- *  bEnableHEC              : Enable/disable header extension codes (HEC)
- *  bEnableResync           : Enable/disable resynchronization markers
- *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be 
- *                            applied in the stream 
- *  bEnableDataPartitioning : Enable/disable data partitioning 
- *  bEnableRVLC             : Enable/disable reversible variable length 
- *                            coding
- */
-typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bEnableHEC;
-    OMX_BOOL bEnableResync;
-    OMX_U32  nResynchMarkerSpacing;
-    OMX_BOOL bEnableDataPartitioning;
-    OMX_BOOL bEnableRVLC;
-} OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;
-
-
-/** 
- * Configuration of variable block-size motion compensation (VBSMC) 
- * 
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to
- *  b16x16     : Enable inter block search 16x16
- *  b16x8      : Enable inter block search 16x8
- *  b8x16      : Enable inter block search 8x16
- *  b8x8       : Enable inter block search 8x8
- *  b8x4       : Enable inter block search 8x4
- *  b4x8       : Enable inter block search 4x8
- *  b4x4       : Enable inter block search 4x4
- */
-typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
-    OMX_U32 nSize; 
-    OMX_VERSIONTYPE nVersion; 
-    OMX_U32 nPortIndex;       
-    OMX_BOOL b16x16; 
-    OMX_BOOL b16x8; 
-    OMX_BOOL b8x16;
-    OMX_BOOL b8x8;
-    OMX_BOOL b8x4;
-    OMX_BOOL b4x8;
-    OMX_BOOL b4x4;
-} OMX_VIDEO_PARAM_VBSMCTYPE;
-
-
-/** 
- * H.263 profile types, each profile indicates support for various 
- * performance bounds and different annexes.
- *
- * ENUMS:
- *  Baseline           : Baseline Profile: H.263 (V1), no optional modes                                                    
- *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility 
- *                       Profile: H.263+ (V2), includes annexes I, J, L.4
- *                       and T
- *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1), 
- *                       includes annex F                                    
- *  ISWV2              : Interactive Streaming Wireless Profile: H.263+ 
- *                       (V2), includes annexes I, J, K and T                 
- *  ISWV3              : Interactive Streaming Wireless Profile: H.263++  
- *                       (V3), includes profile 3 and annexes V and W.6.3.8   
- *  HighCompression    : Conversational High Compression Profile: H.263++  
- *                       (V3), includes profiles 1 & 2 and annexes D and U   
- *  Internet           : Conversational Internet Profile: H.263++ (V3),  
- *                       includes profile 5 and annex K                       
- *  Interlace          : Conversational Interlace Profile: H.263++ (V3),  
- *                       includes profile 5 and annex W.6.3.11               
- *  HighLatency        : High Latency Profile: H.263++ (V3), includes  
- *                       profile 6 and annexes O.1 and P.5                       
- */
-typedef enum OMX_VIDEO_H263PROFILETYPE {
-    OMX_VIDEO_H263ProfileBaseline            = 0x01,        
-    OMX_VIDEO_H263ProfileH320Coding          = 0x02,          
-    OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,  
-    OMX_VIDEO_H263ProfileISWV2               = 0x08,               
-    OMX_VIDEO_H263ProfileISWV3               = 0x10,               
-    OMX_VIDEO_H263ProfileHighCompression     = 0x20,     
-    OMX_VIDEO_H263ProfileInternet            = 0x40,            
-    OMX_VIDEO_H263ProfileInterlace           = 0x80,           
-    OMX_VIDEO_H263ProfileHighLatency         = 0x100,         
-    OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF  
-} OMX_VIDEO_H263PROFILETYPE;
-
-
-/** 
- * H.263 level types, each level indicates support for various frame sizes, 
- * bit rates, decoder frame rates.
- */
-typedef enum OMX_VIDEO_H263LEVELTYPE {
-    OMX_VIDEO_H263Level10  = 0x01,  
-    OMX_VIDEO_H263Level20  = 0x02,      
-    OMX_VIDEO_H263Level30  = 0x04,      
-    OMX_VIDEO_H263Level40  = 0x08,      
-    OMX_VIDEO_H263Level45  = 0x10,      
-    OMX_VIDEO_H263Level50  = 0x20,      
-    OMX_VIDEO_H263Level60  = 0x40,      
-    OMX_VIDEO_H263Level70  = 0x80, 
-    OMX_VIDEO_H263LevelMax = 0x7FFFFFFF  
-} OMX_VIDEO_H263LEVELTYPE;
-
-
-/** 
- * Specifies the picture type. These values should be OR'd to signal all 
- * pictures types which are allowed.
- *
- * ENUMS:
- *  Generic Picture Types:          I, P and B
- *  H.263 Specific Picture Types:   SI and SP
- *  H.264 Specific Picture Types:   EI and EP
- *  MPEG-4 Specific Picture Types:  S
- */
-typedef enum OMX_VIDEO_PICTURETYPE {
-    OMX_VIDEO_PictureTypeI   = 0x01,
-    OMX_VIDEO_PictureTypeP   = 0x02,
-    OMX_VIDEO_PictureTypeB   = 0x04,
-    OMX_VIDEO_PictureTypeSI  = 0x08,
-    OMX_VIDEO_PictureTypeSP  = 0x10,
-    OMX_VIDEO_PictureTypeEI  = 0x11,
-    OMX_VIDEO_PictureTypeEP  = 0x12,
-    OMX_VIDEO_PictureTypeS   = 0x14,
-    OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
-} OMX_VIDEO_PICTURETYPE;
-
-
-/** 
- * H.263 Params 
- *
- * STRUCT MEMBERS:
- *  nSize                    : Size of the structure in bytes
- *  nVersion                 : OMX specification version information 
- *  nPortIndex               : Port that this structure applies to
- *  nPFrames                 : Number of P frames between each I frame
- *  nBFrames                 : Number of B frames between each I frame
- *  eProfile                 : H.263 profile(s) to use
- *  eLevel                   : H.263 level(s) to use
- *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE 
- *                             (specified in the 1998 version of H.263) to 
- *                             indicate custom picture sizes or clock 
- *                             frequencies 
- *  nAllowedPictureTypes     : Specifies the picture types allowed in the 
- *                             bitstream
- *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is 
- *                             not constrained. It is recommended to change 
- *                             the value of the RTYPE bit for each reference 
- *                             picture in error-free communication
- *  nPictureHeaderRepetition : Specifies the frequency of picture header 
- *                             repetition
- *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB  
- *                             headers in units of GOBs
- */
-typedef struct OMX_VIDEO_PARAM_H263TYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nPFrames;
-    OMX_U32 nBFrames;
-    OMX_VIDEO_H263PROFILETYPE eProfile;
-	OMX_VIDEO_H263LEVELTYPE eLevel;
-    OMX_BOOL bPLUSPTYPEAllowed;
-    OMX_U32 nAllowedPictureTypes;
-    OMX_BOOL bForceRoundingTypeToZero;
-    OMX_U32 nPictureHeaderRepetition;
-    OMX_U32 nGOBHeaderInterval;
-} OMX_VIDEO_PARAM_H263TYPE;
-
-
-/** 
- * MPEG-2 profile types, each profile indicates support for various 
- * performance bounds and different annexes.
- */
-typedef enum OMX_VIDEO_MPEG2PROFILETYPE {
-    OMX_VIDEO_MPEG2ProfileSimple = 0,  /**< Simple Profile */
-    OMX_VIDEO_MPEG2ProfileMain,        /**< Main Profile */
-    OMX_VIDEO_MPEG2Profile422,         /**< 4:2:2 Profile */
-    OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
-    OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
-    OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
-    OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF  
-} OMX_VIDEO_MPEG2PROFILETYPE;
-
-
-/** 
- * MPEG-2 level types, each level indicates support for various frame 
- * sizes, bit rates, decoder frame rates.  No need 
- */
-typedef enum OMX_VIDEO_MPEG2LEVELTYPE {
-    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */ 
-    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */ 
-    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */ 
-    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */   
-    OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF  
-} OMX_VIDEO_MPEG2LEVELTYPE;
-
-
-/** 
- * MPEG-2 params 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nPFrames   : Number of P frames between each I frame
- *  nBFrames   : Number of B frames between each I frame
- *  eProfile   : MPEG-2 profile(s) to use
- *  eLevel     : MPEG-2 levels(s) to use
- */
-typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
-    OMX_U32 nSize;           
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;      
-    OMX_U32 nPFrames;        
-    OMX_U32 nBFrames;        
-    OMX_VIDEO_MPEG2PROFILETYPE eProfile;
-	OMX_VIDEO_MPEG2LEVELTYPE eLevel;   
-} OMX_VIDEO_PARAM_MPEG2TYPE;
-
-
-/** 
- * MPEG-4 profile types, each profile indicates support for various 
- * performance bounds and different annexes.
- * 
- * ENUMS:
- *  - Simple Profile, Levels 1-3
- *  - Simple Scalable Profile, Levels 1-2
- *  - Core Profile, Levels 1-2
- *  - Main Profile, Levels 2-4
- *  - N-bit Profile, Level 2
- *  - Scalable Texture Profile, Level 1
- *  - Simple Face Animation Profile, Levels 1-2
- *  - Simple Face and Body Animation (FBA) Profile, Levels 1-2
- *  - Basic Animated Texture Profile, Levels 1-2
- *  - Hybrid Profile, Levels 1-2
- *  - Advanced Real Time Simple Profiles, Levels 1-4
- *  - Core Scalable Profile, Levels 1-3
- *  - Advanced Coding Efficiency Profile, Levels 1-4
- *  - Advanced Core Profile, Levels 1-2
- *  - Advanced Scalable Texture, Levels 2-3
- */
-typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
-    OMX_VIDEO_MPEG4ProfileSimple           = 0x01,        
-    OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,    
-    OMX_VIDEO_MPEG4ProfileCore             = 0x04,              
-    OMX_VIDEO_MPEG4ProfileMain             = 0x08,             
-    OMX_VIDEO_MPEG4ProfileNbit             = 0x10,              
-    OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,   
-    OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,        
-    OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,         
-    OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,     
-    OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,            
-    OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,  
-    OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,      
-    OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,    
-    OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,      
-    OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,  
-    OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF  
-} OMX_VIDEO_MPEG4PROFILETYPE;
-
-
-/** 
- * MPEG-4 level types, each level indicates support for various frame 
- * sizes, bit rates, decoder frame rates.  No need 
- */
-typedef enum OMX_VIDEO_MPEG4LEVELTYPE {
-    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */   
-    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */   
-    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */ 
-    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */ 
-    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */ 
-    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */  
-    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */  
-    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */  
-    OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF  
-} OMX_VIDEO_MPEG4LEVELTYPE;
-
-
-/** 
- * MPEG-4 configuration.  This structure handles configuration options
- * which are specific to MPEG4 algorithms
- *
- * STRUCT MEMBERS:
- *  nSize                : Size of the structure in bytes
- *  nVersion             : OMX specification version information
- *  nPortIndex           : Port that this structure applies to
- *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+ 
- *                         Annex K). Put zero if not used
- *  bSVH                 : Enable Short Video Header mode
- *  bGov                 : Flag to enable GOV
- *  nPFrames             : Number of P frames between each I frame (also called 
- *                         GOV period)
- *  nBFrames             : Number of B frames between each I frame
- *  nIDCVLCThreshold     : Value of intra DC VLC threshold
- *  bACPred              : Flag to use ac prediction
- *  nMaxPacketSize       : Maximum size of packet in bytes.
- *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4. 
- *                         Interpreted as described in MPEG4 standard.
- *  eProfile             : MPEG-4 profile(s) to use.
- *  eLevel               : MPEG-4 level(s) to use.
- *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
- *  nHeaderExtension     : Specifies the number of consecutive video packet
- *                         headers within a VOP
- *  bReversibleVLC       : Specifies whether reversible variable length coding 
- *                         is in use
- */
-typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nSliceHeaderSpacing;
-    OMX_BOOL bSVH;
-    OMX_BOOL bGov;
-    OMX_U32 nPFrames;
-    OMX_U32 nBFrames;
-    OMX_U32 nIDCVLCThreshold;
-    OMX_BOOL bACPred;
-    OMX_U32 nMaxPacketSize;
-    OMX_U32 nTimeIncRes;
-    OMX_VIDEO_MPEG4PROFILETYPE eProfile;
-    OMX_VIDEO_MPEG4LEVELTYPE eLevel;
-    OMX_U32 nAllowedPictureTypes;
-    OMX_U32 nHeaderExtension;
-    OMX_BOOL bReversibleVLC;
-} OMX_VIDEO_PARAM_MPEG4TYPE;
-
-
-/** 
- * WMV Versions 
- */
-typedef enum OMX_VIDEO_WMVFORMATTYPE {
-    OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
-    OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
-    OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
-    OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
-    OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
-} OMX_VIDEO_WMVFORMATTYPE;
-
-
-/** 
- * WMV Params 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  eFormat    : Version of WMV stream / data
- */
-typedef struct OMX_VIDEO_PARAM_WMVTYPE {
-    OMX_U32 nSize; 
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_WMVFORMATTYPE eFormat;
-} OMX_VIDEO_PARAM_WMVTYPE;
-
-
-/** 
- * Real Video Version 
- */
-typedef enum OMX_VIDEO_RVFORMATTYPE {
-    OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
-    OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
-    OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
-    OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
-    OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
-} OMX_VIDEO_RVFORMATTYPE;
-
-
-/** 
- * Real Video Params 
- *
- * STUCT MEMBERS:
- *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information 
- *  nPortIndex         : Port that this structure applies to
- *  eFormat            : Version of RV stream / data
- *  nBitsPerPixel      : Bits per pixel coded in the frame
- *  nPaddedWidth       : Padded width in pixel of a video frame
- *  nPaddedHeight      : Padded Height in pixels of a video frame
- *  nFrameRate         : Rate of video in frames per second
- *  nBitstreamFlags    : Flags which internal information about the bitstream
- *  nBitstreamVersion  : Bitstream version
- *  nMaxEncodeFrameSize: Max encoded frame size
- *  bEnablePostFilter  : Turn on/off post filter
- *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
- *  bEnableLatencyMode : When enabled, the decoder does not display a decoded 
- *                       frame until it has detected that no enhancement layer 
- *  					 frames or dependent B frames will be coming. This 
- *  					 detection usually occurs when a subsequent non-B 
- *  					 frame is encountered 
- */
-typedef struct OMX_VIDEO_PARAM_RVTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_RVFORMATTYPE eFormat;
-    OMX_U16 nBitsPerPixel;
-    OMX_U16 nPaddedWidth;
-    OMX_U16 nPaddedHeight;
-    OMX_U32 nFrameRate;
-    OMX_U32 nBitstreamFlags;
-    OMX_U32 nBitstreamVersion;
-    OMX_U32 nMaxEncodeFrameSize;
-    OMX_BOOL bEnablePostFilter;
-    OMX_BOOL bEnableTemporalInterpolation;
-    OMX_BOOL bEnableLatencyMode;
-} OMX_VIDEO_PARAM_RVTYPE;
-
-
-/** 
- * AVC profile types, each profile indicates support for various 
- * performance bounds and different annexes.
- */
-typedef enum OMX_VIDEO_AVCPROFILETYPE {
-    OMX_VIDEO_AVCProfileBaseline = 0x01,   /**< Baseline profile */
-    OMX_VIDEO_AVCProfileMain     = 0x02,   /**< Main profile */
-    OMX_VIDEO_AVCProfileExtended = 0x04,   /**< Extended profile */
-    OMX_VIDEO_AVCProfileHigh     = 0x08,   /**< High profile */
-    OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
-    OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
-    OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
-    OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF  
-} OMX_VIDEO_AVCPROFILETYPE;
-
-
-/** 
- * AVC level types, each level indicates support for various frame sizes, 
- * bit rates, decoder frame rates.  No need 
- */
-typedef enum OMX_VIDEO_AVCLEVELTYPE {
-    OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
-    OMX_VIDEO_AVCLevel1b  = 0x02,     /**< Level 1b */
-    OMX_VIDEO_AVCLevel11  = 0x04,     /**< Level 1.1 */
-    OMX_VIDEO_AVCLevel12  = 0x08,     /**< Level 1.2 */
-    OMX_VIDEO_AVCLevel13  = 0x10,     /**< Level 1.3 */
-    OMX_VIDEO_AVCLevel2   = 0x20,     /**< Level 2 */
-    OMX_VIDEO_AVCLevel21  = 0x40,     /**< Level 2.1 */
-    OMX_VIDEO_AVCLevel22  = 0x80,     /**< Level 2.2 */
-    OMX_VIDEO_AVCLevel3   = 0x100,    /**< Level 3 */
-    OMX_VIDEO_AVCLevel31  = 0x200,    /**< Level 3.1 */
-    OMX_VIDEO_AVCLevel32  = 0x400,    /**< Level 3.2 */
-    OMX_VIDEO_AVCLevel4   = 0x800,    /**< Level 4 */
-    OMX_VIDEO_AVCLevel41  = 0x1000,   /**< Level 4.1 */
-    OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
-    OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
-    OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
-    OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF  
-} OMX_VIDEO_AVCLEVELTYPE;
-
-
-/** 
- * AVC loop filter modes 
- *
- * OMX_VIDEO_AVCLoopFilterEnable               : Enable
- * OMX_VIDEO_AVCLoopFilterDisable              : Disable
- * OMX_VIDEO_AVCLoopFilterDisableSliceBoundary : Disabled on slice boundaries
- */
-typedef enum OMX_VIDEO_AVCLOOPFILTERTYPE {
-    OMX_VIDEO_AVCLoopFilterEnable = 0,
-    OMX_VIDEO_AVCLoopFilterDisable,
-    OMX_VIDEO_AVCLoopFilterDisableSliceBoundary,
-    OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
-} OMX_VIDEO_AVCLOOPFILTERTYPE;
-
-
-/** 
- * AVC params 
- *
- * STRUCT MEMBERS:
- *  nSize                     : Size of the structure in bytes
- *  nVersion                  : OMX specification version information
- *  nPortIndex                : Port that this structure applies to
- *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put  
- *                              zero if not used
- *  nPFrames                  : Number of P frames between each I frame
- *  nBFrames                  : Number of B frames between each I frame
- *  bUseHadamard              : Enable/disable Hadamard transform
- *  nRefFrames                : Max number of reference frames to use for inter
- *                              motion search (1-16)
- *  nRefIdxTrailing           : Pic param set ref frame index (index into ref
- *                              frame buffer of trailing frames list), B frame
- *                              support
- *  nRefIdxForward            : Pic param set ref frame index (index into ref
- *                              frame buffer of forward frames list), B frame
- *                              support
- *  bEnableUEP                : Enable/disable unequal error protection. This 
- *                              is only valid of data partitioning is enabled.
- *  bEnableFMO                : Enable/disable flexible macroblock ordering
- *  bEnableASO                : Enable/disable arbitrary slice ordering
- *  bEnableRS                 : Enable/disable sending of redundant slices
- *  eProfile                  : AVC profile(s) to use
- *  eLevel                    : AVC level(s) to use
- *  nAllowedPictureTypes      : Specifies the picture types allowed in the 
- *                              bitstream
- *  bFrameMBsOnly             : specifies that every coded picture of the 
- *                              coded video sequence is a coded frame 
- *                              containing only frame macroblocks
- *  bMBAFF                    : Enable/disable switching between frame and 
- *                              field macroblocks within a picture
- *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the 
- *                              syntax elements for which two descriptors appear 
- *                              in the syntax tables
- *  bWeightedPPrediction      : Enable/disable weighted prediction shall not 
- *                              be applied to P and SP slices
- *  nWeightedBipredicitonMode : Default weighted prediction is applied to B 
- *                              slices 
- *  bConstIpred               : Enable/disable intra prediction
- *  bDirect8x8Inference       : Specifies the method used in the derivation 
- *                              process for luma motion vectors for B_Skip, 
- *                              B_Direct_16x16 and B_Direct_8x8 as specified 
- *                              in subclause 8.4.1.2 of the AVC spec 
- *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
- *                              mode used in B slice coding (related to 
- *                              bDirect8x8Inference) . Spatial direct mode is 
- *                              more common and should be the default.
- *  nCabacInitIdx             : Index used to init CABAC contexts
- *  eLoopFilterMode           : Enable/disable loop filter
- */
-typedef struct OMX_VIDEO_PARAM_AVCTYPE {
-    OMX_U32 nSize;                 
-    OMX_VERSIONTYPE nVersion;      
-    OMX_U32 nPortIndex;            
-    OMX_U32 nSliceHeaderSpacing;  
-    OMX_U32 nPFrames;     
-    OMX_U32 nBFrames;     
-    OMX_BOOL bUseHadamard;
-    OMX_U32 nRefFrames;  
-	OMX_U32 nRefIdx10ActiveMinus1;
-	OMX_U32 nRefIdx11ActiveMinus1;
-    OMX_BOOL bEnableUEP;  
-    OMX_BOOL bEnableFMO;  
-    OMX_BOOL bEnableASO;  
-    OMX_BOOL bEnableRS;   
-    OMX_VIDEO_AVCPROFILETYPE eProfile;
-	OMX_VIDEO_AVCLEVELTYPE eLevel; 
-    OMX_U32 nAllowedPictureTypes;  
-	OMX_BOOL bFrameMBsOnly;        									
-    OMX_BOOL bMBAFF;               
-    OMX_BOOL bEntropyCodingCABAC;  
-    OMX_BOOL bWeightedPPrediction; 
-    OMX_U32 nWeightedBipredicitonMode; 
-    OMX_BOOL bconstIpred ;
-    OMX_BOOL bDirect8x8Inference;  
-	OMX_BOOL bDirectSpatialTemporal;
-	OMX_U32 nCabacInitIdc;
-	OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
-} OMX_VIDEO_PARAM_AVCTYPE;
-
-typedef struct OMX_VIDEO_PARAM_PROFILELEVELTYPE {
-   OMX_U32 nSize;                 
-   OMX_VERSIONTYPE nVersion;      
-   OMX_U32 nPortIndex;            
-   OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE, 
-                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
-   OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE, 
-                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
-   OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
-                               This parameter is valid only for 
-                               OMX_IndexParamVideoProfileLevelQuerySupported index,
-                               For all other indices this parameter is to be ignored. */
-} OMX_VIDEO_PARAM_PROFILELEVELTYPE;
-
-/** 
- * Structure for dynamically configuring bitrate mode of a codec. 
- *
- * STRUCT MEMBERS:
- *  nSize          : Size of the struct in bytes
- *  nVersion       : OMX spec version info
- *  nPortIndex     : Port that this struct applies to
- *  nEncodeBitrate : Target average bitrate to be generated in bps
- */
-typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
-    OMX_U32 nSize;                          
-    OMX_VERSIONTYPE nVersion;               
-    OMX_U32 nPortIndex;                     
-    OMX_U32 nEncodeBitrate;                 
-} OMX_VIDEO_CONFIG_BITRATETYPE;
-
-/** 
- * Defines Encoder Frame Rate setting
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes
- *  nVersion         : OMX specification version information 
- *  nPortIndex       : Port that this structure applies to
- *  xEncodeFramerate : Encoding framerate represented in Q16 format
- */
-typedef struct OMX_CONFIG_FRAMERATETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 xEncodeFramerate; /* Q16 format */
-} OMX_CONFIG_FRAMERATETYPE;
-
-typedef struct OMX_CONFIG_INTRAREFRESHVOPTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL IntraRefreshVOP;
-} OMX_CONFIG_INTRAREFRESHVOPTYPE;
-
-typedef struct OMX_CONFIG_MACROBLOCKERRORMAPTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nErrMapSize;           /* Size of the Error Map in bytes */
-    OMX_U8  ErrMap[1];             /* Error map hint */
-} OMX_CONFIG_MACROBLOCKERRORMAPTYPE;
-
-typedef struct OMX_CONFIG_MBERRORREPORTINGTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bEnabled;
-} OMX_CONFIG_MBERRORREPORTINGTYPE;
-
-typedef struct OMX_PARAM_MACROBLOCKSTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nMacroblocks;
-} OMX_PARAM_MACROBLOCKSTYPE;
-
-/** 
- * AVC Slice Mode modes 
- *
- * OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
- * OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
- * OMX_VIDEO_SLICEMODE_AVCByteSlice : NAL mode, number of bytes per frame
- */
-typedef enum OMX_VIDEO_AVCSLICEMODETYPE {
-    OMX_VIDEO_SLICEMODE_AVCDefault = 0,
-    OMX_VIDEO_SLICEMODE_AVCMBSlice,
-    OMX_VIDEO_SLICEMODE_AVCByteSlice,
-    OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
-} OMX_VIDEO_AVCSLICEMODETYPE;
-
-/** 
- * AVC FMO Slice Mode Params 
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nNumSliceGroups : Specifies the number of slice groups
- *  nSliceGroupMapType : Specifies the type of slice groups
- *  eSliceMode : Specifies the type of slice
- */
-typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
-    OMX_U32 nSize; 
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U8 nNumSliceGroups;
-    OMX_U8 nSliceGroupMapType;
-    OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
-} OMX_VIDEO_PARAM_AVCSLICEFMO;
-
-/** 
- * AVC IDR Period Configs
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nIDRPeriod : Specifies periodicity of IDR frames
- *  nPFrames : Specifies internal of coding Intra frames
- */
-typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
-    OMX_U32 nSize; 
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nIDRPeriod;
-    OMX_U32 nPFrames;
-} OMX_VIDEO_CONFIG_AVCINTRAPERIOD;
-
-/** 
- * AVC NAL Size Configs
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nNaluBytes : Specifies the NAL unit size
- */
-typedef struct OMX_VIDEO_CONFIG_NALSIZE {
-    OMX_U32 nSize; 
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nNaluBytes;
-} OMX_VIDEO_CONFIG_NALSIZE;
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
-
+/**
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** 
+ *  @file OMX_Video.h - OpenMax IL version 1.1.2
+ *  The structures is needed by Video components to exchange parameters 
+ *  and configuration data with OMX components.
+ */
+#ifndef OMX_Video_h
+#define OMX_Video_h
+
+/** @defgroup video OpenMAX IL Video Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Video domain
+ * @{
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully 
+ */
+
+#include <OMX_IVCommon.h>
+
+
+/**
+ * Enumeration used to define the possible video compression codings.  
+ * NOTE:  This essentially refers to file extensions. If the coding is 
+ *        being used to specify the ENCODE type, then additional work 
+ *        must be done to configure the exact flavor of the compression 
+ *        to be used.  For decode cases where the user application can 
+ *        not differentiate between MPEG-4 and H.264 bit streams, it is 
+ *        up to the codec to handle this.
+ */
+typedef enum OMX_VIDEO_CODINGTYPE {
+    OMX_VIDEO_CodingUnused,     /**< Value when coding is N/A */
+    OMX_VIDEO_CodingAutoDetect, /**< Autodetection of coding type */
+    OMX_VIDEO_CodingMPEG2,      /**< AKA: H.262 */
+    OMX_VIDEO_CodingH263,       /**< H.263 */
+    OMX_VIDEO_CodingMPEG4,      /**< MPEG-4 */
+    OMX_VIDEO_CodingWMV,        /**< all versions of Windows Media Video */
+    OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
+    OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
+    OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
+    OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_CodingMax = 0x7FFFFFFF
+} OMX_VIDEO_CODINGTYPE;
+
+
+/**
+ * Data structure used to define a video path.  The number of Video paths for 
+ * input and output will vary by type of the Video component.  
+ * 
+ *    Input (aka Source) : zero Inputs, one Output,
+ *    Splitter           : one Input, 2 or more Outputs,
+ *    Processing Element : one Input, one output,
+ *    Mixer              : 2 or more inputs, one output,
+ *    Output (aka Sink)  : one Input, zero outputs.
+ * 
+ * The PortDefinition structure is used to define all of the parameters 
+ * necessary for the compliant component to setup an input or an output video 
+ * path.  If additional vendor specific data is required, it should be 
+ * transmitted to the component using the CustomCommand function.  Compliant 
+ * components will prepopulate this structure with optimal values during the 
+ * GetDefaultInitParams command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a 
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on channel if 
+ *                          uncompressed format is used.  Use 0 for unknown,
+ *                          don't care or variable
+ *  nFrameHeight          : Height of frame to be used on channel if 
+ *                          uncompressed format is used. Use 0 for unknown,
+ *                          don't care or variable
+ *  nStride               : Number of bytes per span of an image 
+ *                          (i.e. indicates the number of bytes to get
+ *                          from span N to span N+1, where negative stride
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  nBitrate              : Bit rate of frame to be used on channel if 
+ *                          compressed format is used. Use 0 for unknown, 
+ *                          don't care or variable
+ *  xFramerate            : Frame rate to be used on channel if uncompressed 
+ *                          format is used. Use 0 for unknown, don't care or 
+ *                          variable.  Units are Q16 frames per second.
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of the 
+ *                          component. When OMX_VIDEO_CodingUnused is 
+ *                          specified, eColorFormat is used
+ *  eColorFormat : Decompressed format used by this component
+ *  pNativeWindow : Platform specific reference for a window object if a 
+ *                          display sink , otherwise this field is 0x0. 
+ */
+typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;
+    OMX_NATIVE_DEVICETYPE pNativeRender;
+    OMX_U32 nFrameWidth;
+    OMX_U32 nFrameHeight;
+    OMX_S32 nStride;
+    OMX_U32 nSliceHeight;
+    OMX_U32 nBitrate;
+    OMX_U32 xFramerate;
+    OMX_BOOL bFlagErrorConcealment;
+    OMX_VIDEO_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} OMX_VIDEO_PORTDEFINITIONTYPE;
+
+/**  
+ * Port format parameter.  This structure is used to enumerate the various 
+ * data input/output format supported by the port.
+ * 
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from 
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the 
+ *                       component. When OMX_VIDEO_CodingUnused is specified, 
+ *                       eColorFormat is used 
+ *  eColorFormat       : Decompressed format used by this component
+ *  xFrameRate         : Indicates the video frame rate in Q16 format
+ */
+typedef struct OMX_VIDEO_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_VIDEO_CODINGTYPE eCompressionFormat; 
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_U32 xFramerate;
+} OMX_VIDEO_PARAM_PORTFORMATTYPE;
+
+
+/**
+ * This is a structure for configuring video compression quantization 
+ * parameter values.  Codecs may support different QP values for different
+ * frame types.
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info
+ *  nPortIndex : Port that this structure applies to
+ *  nQpI       : QP value to use for index frames
+ *  nQpP       : QP value to use for P frames
+ *  nQpB       : QP values to use for bidirectional frames 
+ */
+typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
+    OMX_U32 nSize;            
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nQpI;
+    OMX_U32 nQpP;
+    OMX_U32 nQpB;
+} OMX_VIDEO_PARAM_QUANTIZATIONTYPE;
+
+
+/** 
+ * Structure for configuration of video fast update parameters. 
+ *  
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info 
+ *  nPortIndex : Port that this structure applies to
+ *  bEnableVFU : Enable/Disable video fast update
+ *  nFirstGOB  : Specifies the number of the first macroblock row
+ *  nFirstMB   : specifies the first MB relative to the specified first GOB
+ *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB 
+ *               and nFirstMB
+ */
+typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
+    OMX_U32 nSize;            
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;       
+    OMX_BOOL bEnableVFU;      
+    OMX_U32 nFirstGOB;                            
+    OMX_U32 nFirstMB;                            
+    OMX_U32 nNumMBs;                                  
+} OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;
+
+
+/** 
+ * Enumeration of possible bitrate control types 
+ */
+typedef enum OMX_VIDEO_CONTROLRATETYPE {
+    OMX_Video_ControlRateDisable,
+    OMX_Video_ControlRateVariable,
+    OMX_Video_ControlRateConstant,
+    OMX_Video_ControlRateVariableSkipFrames,
+    OMX_Video_ControlRateConstantSkipFrames,
+    OMX_Video_ControlRateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_Video_ControlRateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_Video_ControlRateMax = 0x7FFFFFFF
+} OMX_VIDEO_CONTROLRATETYPE;
+
+
+/** 
+ * Structure for configuring bitrate mode of a codec. 
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  eControlRate   : Control rate type enum
+ *  nTargetBitrate : Target bitrate to encode with
+ */
+typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
+    OMX_U32 nSize;                          
+    OMX_VERSIONTYPE nVersion;               
+    OMX_U32 nPortIndex;                     
+    OMX_VIDEO_CONTROLRATETYPE eControlRate; 
+    OMX_U32 nTargetBitrate;                 
+} OMX_VIDEO_PARAM_BITRATETYPE;
+
+
+/** 
+ * Enumeration of possible motion vector (MV) types 
+ */
+typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
+    OMX_Video_MotionVectorPixel,
+    OMX_Video_MotionVectorHalfPel,
+    OMX_Video_MotionVectorQuarterPel,
+    OMX_Video_MotionVectorEighthPel,
+    OMX_Video_MotionVectorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_Video_MotionVectorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_Video_MotionVectorMax = 0x7FFFFFFF
+} OMX_VIDEO_MOTIONVECTORTYPE;
+
+
+/**
+ * Structure for configuring the number of motion vectors used as well
+ * as their accuracy.
+ * 
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the struct in bytes
+ *  nVersion         : OMX spec version info
+ *  nPortIndex       : port that this structure applies to
+ *  eAccuracy        : Enumerated MV accuracy
+ *  bUnrestrictedMVs : Allow unrestricted MVs
+ *  bFourMV          : Allow use of 4 MVs
+ *  sXSearchRange    : Search range in horizontal direction for MVs
+ *  sYSearchRange    : Search range in vertical direction for MVs
+ */
+typedef struct OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_MOTIONVECTORTYPE eAccuracy;
+    OMX_BOOL bUnrestrictedMVs;
+    OMX_BOOL bFourMV;
+    OMX_S32 sXSearchRange;
+    OMX_S32 sYSearchRange;
+} OMX_VIDEO_PARAM_MOTIONVECTORTYPE;
+
+
+/** 
+ * Enumeration of possible methods to use for Intra Refresh 
+ */
+typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
+    OMX_VIDEO_IntraRefreshCyclic,
+    OMX_VIDEO_IntraRefreshAdaptive,
+    OMX_VIDEO_IntraRefreshBoth,
+    OMX_VIDEO_IntraRefreshKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_IntraRefreshVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
+} OMX_VIDEO_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for configuring intra refresh mode 
+ * 
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to
+ *  eRefreshMode : Cyclic, Adaptive, or Both
+ *  nAirMBs      : Number of intra macroblocks to refresh in a frame when 
+ *                 AIR is enabled
+ *  nAirRef      : Number of times a motion marked macroblock has to be  
+ *                 intra coded
+ *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"  
+ *                 when CIR is enabled
+ */
+typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_INTRAREFRESHTYPE eRefreshMode;
+    OMX_U32 nAirMBs;
+    OMX_U32 nAirRef;
+    OMX_U32 nCirMBs;
+} OMX_VIDEO_PARAM_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for enabling various error correction methods for video 
+ * compression.
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information 
+ *  nPortIndex              : Port that this structure applies to 
+ *  bEnableHEC              : Enable/disable header extension codes (HEC)
+ *  bEnableResync           : Enable/disable resynchronization markers
+ *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be 
+ *                            applied in the stream 
+ *  bEnableDataPartitioning : Enable/disable data partitioning 
+ *  bEnableRVLC             : Enable/disable reversible variable length 
+ *                            coding
+ */
+typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnableHEC;
+    OMX_BOOL bEnableResync;
+    OMX_U32  nResynchMarkerSpacing;
+    OMX_BOOL bEnableDataPartitioning;
+    OMX_BOOL bEnableRVLC;
+} OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;
+
+
+/** 
+ * Configuration of variable block-size motion compensation (VBSMC) 
+ * 
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  b16x16     : Enable inter block search 16x16
+ *  b16x8      : Enable inter block search 16x8
+ *  b8x16      : Enable inter block search 8x16
+ *  b8x8       : Enable inter block search 8x8
+ *  b8x4       : Enable inter block search 8x4
+ *  b4x8       : Enable inter block search 4x8
+ *  b4x4       : Enable inter block search 4x4
+ */
+typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;       
+    OMX_BOOL b16x16; 
+    OMX_BOOL b16x8; 
+    OMX_BOOL b8x16;
+    OMX_BOOL b8x8;
+    OMX_BOOL b8x4;
+    OMX_BOOL b4x8;
+    OMX_BOOL b4x4;
+} OMX_VIDEO_PARAM_VBSMCTYPE;
+
+
+/** 
+ * H.263 profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ *
+ * ENUMS:
+ *  Baseline           : Baseline Profile: H.263 (V1), no optional modes                                                    
+ *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility 
+ *                       Profile: H.263+ (V2), includes annexes I, J, L.4
+ *                       and T
+ *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1), 
+ *                       includes annex F                                    
+ *  ISWV2              : Interactive Streaming Wireless Profile: H.263+ 
+ *                       (V2), includes annexes I, J, K and T                 
+ *  ISWV3              : Interactive Streaming Wireless Profile: H.263++  
+ *                       (V3), includes profile 3 and annexes V and W.6.3.8   
+ *  HighCompression    : Conversational High Compression Profile: H.263++  
+ *                       (V3), includes profiles 1 & 2 and annexes D and U   
+ *  Internet           : Conversational Internet Profile: H.263++ (V3),  
+ *                       includes profile 5 and annex K                       
+ *  Interlace          : Conversational Interlace Profile: H.263++ (V3),  
+ *                       includes profile 5 and annex W.6.3.11               
+ *  HighLatency        : High Latency Profile: H.263++ (V3), includes  
+ *                       profile 6 and annexes O.1 and P.5                       
+ */
+typedef enum OMX_VIDEO_H263PROFILETYPE {
+    OMX_VIDEO_H263ProfileBaseline            = 0x01,        
+    OMX_VIDEO_H263ProfileH320Coding          = 0x02,          
+    OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,  
+    OMX_VIDEO_H263ProfileISWV2               = 0x08,               
+    OMX_VIDEO_H263ProfileISWV3               = 0x10,               
+    OMX_VIDEO_H263ProfileHighCompression     = 0x20,     
+    OMX_VIDEO_H263ProfileInternet            = 0x40,            
+    OMX_VIDEO_H263ProfileInterlace           = 0x80,           
+    OMX_VIDEO_H263ProfileHighLatency         = 0x100,         
+    OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_H263ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF  
+} OMX_VIDEO_H263PROFILETYPE;
+
+
+/** 
+ * H.263 level types, each level indicates support for various frame sizes, 
+ * bit rates, decoder frame rates.
+ */
+typedef enum OMX_VIDEO_H263LEVELTYPE {
+    OMX_VIDEO_H263Level10  = 0x01,  
+    OMX_VIDEO_H263Level20  = 0x02,      
+    OMX_VIDEO_H263Level30  = 0x04,      
+    OMX_VIDEO_H263Level40  = 0x08,      
+    OMX_VIDEO_H263Level45  = 0x10,      
+    OMX_VIDEO_H263Level50  = 0x20,      
+    OMX_VIDEO_H263Level60  = 0x40,      
+    OMX_VIDEO_H263Level70  = 0x80, 
+    OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_H263LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_H263LevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_H263LEVELTYPE;
+
+
+/** 
+ * Specifies the picture type. These values should be OR'd to signal all 
+ * pictures types which are allowed.
+ *
+ * ENUMS:
+ *  Generic Picture Types:          I, P and B
+ *  H.263 Specific Picture Types:   SI and SP
+ *  H.264 Specific Picture Types:   EI and EP
+ *  MPEG-4 Specific Picture Types:  S
+ */
+typedef enum OMX_VIDEO_PICTURETYPE {
+    OMX_VIDEO_PictureTypeI   = 0x01,
+    OMX_VIDEO_PictureTypeP   = 0x02,
+    OMX_VIDEO_PictureTypeB   = 0x04,
+    OMX_VIDEO_PictureTypeSI  = 0x08,
+    OMX_VIDEO_PictureTypeSP  = 0x10,
+    OMX_VIDEO_PictureTypeEI  = 0x11,
+    OMX_VIDEO_PictureTypeEP  = 0x12,
+    OMX_VIDEO_PictureTypeS   = 0x14,
+    OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_PictureTypeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
+} OMX_VIDEO_PICTURETYPE;
+
+
+/** 
+ * H.263 Params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                    : Size of the structure in bytes
+ *  nVersion                 : OMX specification version information 
+ *  nPortIndex               : Port that this structure applies to
+ *  nPFrames                 : Number of P frames between each I frame
+ *  nBFrames                 : Number of B frames between each I frame
+ *  eProfile                 : H.263 profile(s) to use
+ *  eLevel                   : H.263 level(s) to use
+ *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE 
+ *                             (specified in the 1998 version of H.263) to 
+ *                             indicate custom picture sizes or clock 
+ *                             frequencies 
+ *  nAllowedPictureTypes     : Specifies the picture types allowed in the 
+ *                             bitstream
+ *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is 
+ *                             not constrained. It is recommended to change 
+ *                             the value of the RTYPE bit for each reference 
+ *                             picture in error-free communication
+ *  nPictureHeaderRepetition : Specifies the frequency of picture header 
+ *                             repetition
+ *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB  
+ *                             headers in units of GOBs
+ */
+typedef struct OMX_VIDEO_PARAM_H263TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_VIDEO_H263PROFILETYPE eProfile;
+	OMX_VIDEO_H263LEVELTYPE eLevel;
+    OMX_BOOL bPLUSPTYPEAllowed;
+    OMX_U32 nAllowedPictureTypes;
+    OMX_BOOL bForceRoundingTypeToZero;
+    OMX_U32 nPictureHeaderRepetition;
+    OMX_U32 nGOBHeaderInterval;
+} OMX_VIDEO_PARAM_H263TYPE;
+
+
+/** 
+ * MPEG-2 profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ */
+typedef enum OMX_VIDEO_MPEG2PROFILETYPE {
+    OMX_VIDEO_MPEG2ProfileSimple = 0,  /**< Simple Profile */
+    OMX_VIDEO_MPEG2ProfileMain,        /**< Main Profile */
+    OMX_VIDEO_MPEG2Profile422,         /**< 4:2:2 Profile */
+    OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
+    OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
+    OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
+    OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG2ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG2PROFILETYPE;
+
+
+/** 
+ * MPEG-2 level types, each level indicates support for various frame 
+ * sizes, bit rates, decoder frame rates.  No need 
+ */
+typedef enum OMX_VIDEO_MPEG2LEVELTYPE {
+    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */ 
+    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */ 
+    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */ 
+    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */   
+    OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG2LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG2LEVELTYPE;
+
+
+/** 
+ * MPEG-2 params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nPFrames   : Number of P frames between each I frame
+ *  nBFrames   : Number of B frames between each I frame
+ *  eProfile   : MPEG-2 profile(s) to use
+ *  eLevel     : MPEG-2 levels(s) to use
+ */
+typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
+    OMX_U32 nSize;           
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;      
+    OMX_U32 nPFrames;        
+    OMX_U32 nBFrames;        
+    OMX_VIDEO_MPEG2PROFILETYPE eProfile;
+	OMX_VIDEO_MPEG2LEVELTYPE eLevel;   
+} OMX_VIDEO_PARAM_MPEG2TYPE;
+
+
+/** 
+ * MPEG-4 profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ * 
+ * ENUMS:
+ *  - Simple Profile, Levels 1-3
+ *  - Simple Scalable Profile, Levels 1-2
+ *  - Core Profile, Levels 1-2
+ *  - Main Profile, Levels 2-4
+ *  - N-bit Profile, Level 2
+ *  - Scalable Texture Profile, Level 1
+ *  - Simple Face Animation Profile, Levels 1-2
+ *  - Simple Face and Body Animation (FBA) Profile, Levels 1-2
+ *  - Basic Animated Texture Profile, Levels 1-2
+ *  - Hybrid Profile, Levels 1-2
+ *  - Advanced Real Time Simple Profiles, Levels 1-4
+ *  - Core Scalable Profile, Levels 1-3
+ *  - Advanced Coding Efficiency Profile, Levels 1-4
+ *  - Advanced Core Profile, Levels 1-2
+ *  - Advanced Scalable Texture, Levels 2-3
+ */
+typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
+    OMX_VIDEO_MPEG4ProfileSimple           = 0x01,        
+    OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,    
+    OMX_VIDEO_MPEG4ProfileCore             = 0x04,              
+    OMX_VIDEO_MPEG4ProfileMain             = 0x08,             
+    OMX_VIDEO_MPEG4ProfileNbit             = 0x10,              
+    OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,   
+    OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,        
+    OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,         
+    OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,     
+    OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,            
+    OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,  
+    OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,      
+    OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,    
+    OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,      
+    OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,
+    OMX_VIDEO_MPEG4ProfileAdvancedSimple   = 0x8000,
+    OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG4ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG4PROFILETYPE;
+
+
+/** 
+ * MPEG-4 level types, each level indicates support for various frame 
+ * sizes, bit rates, decoder frame rates.  No need 
+ */
+typedef enum OMX_VIDEO_MPEG4LEVELTYPE {
+    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */   
+    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */   
+    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */ 
+    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */ 
+    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */ 
+    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */  
+    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */  
+    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */  
+    OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG4LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG4LEVELTYPE;
+
+
+/** 
+ * MPEG-4 configuration.  This structure handles configuration options
+ * which are specific to MPEG4 algorithms
+ *
+ * STRUCT MEMBERS:
+ *  nSize                : Size of the structure in bytes
+ *  nVersion             : OMX specification version information
+ *  nPortIndex           : Port that this structure applies to
+ *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+ 
+ *                         Annex K). Put zero if not used
+ *  bSVH                 : Enable Short Video Header mode
+ *  bGov                 : Flag to enable GOV
+ *  nPFrames             : Number of P frames between each I frame (also called 
+ *                         GOV period)
+ *  nBFrames             : Number of B frames between each I frame
+ *  nIDCVLCThreshold     : Value of intra DC VLC threshold
+ *  bACPred              : Flag to use ac prediction
+ *  nMaxPacketSize       : Maximum size of packet in bytes.
+ *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4. 
+ *                         Interpreted as described in MPEG4 standard.
+ *  eProfile             : MPEG-4 profile(s) to use.
+ *  eLevel               : MPEG-4 level(s) to use.
+ *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
+ *  nHeaderExtension     : Specifies the number of consecutive video packet
+ *                         headers within a VOP
+ *  bReversibleVLC       : Specifies whether reversible variable length coding 
+ *                         is in use
+ */
+typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nSliceHeaderSpacing;
+    OMX_BOOL bSVH;
+    OMX_BOOL bGov;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_U32 nIDCVLCThreshold;
+    OMX_BOOL bACPred;
+    OMX_U32 nMaxPacketSize;
+    OMX_U32 nTimeIncRes;
+    OMX_VIDEO_MPEG4PROFILETYPE eProfile;
+    OMX_VIDEO_MPEG4LEVELTYPE eLevel;
+    OMX_U32 nAllowedPictureTypes;
+    OMX_U32 nHeaderExtension;
+    OMX_BOOL bReversibleVLC;
+} OMX_VIDEO_PARAM_MPEG4TYPE;
+
+
+/** 
+ * WMV Versions 
+ */
+typedef enum OMX_VIDEO_WMVFORMATTYPE {
+    OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
+    OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
+    OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
+    OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
+    OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_WMFFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
+} OMX_VIDEO_WMVFORMATTYPE;
+
+
+/** 
+ * WMV Params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  eFormat    : Version of WMV stream / data
+ */
+typedef struct OMX_VIDEO_PARAM_WMVTYPE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_WMVFORMATTYPE eFormat;
+} OMX_VIDEO_PARAM_WMVTYPE;
+
+
+/** 
+ * Real Video Version 
+ */
+typedef enum OMX_VIDEO_RVFORMATTYPE {
+    OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
+    OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
+    OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
+    OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
+    OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_RVFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
+} OMX_VIDEO_RVFORMATTYPE;
+
+
+/** 
+ * Real Video Params 
+ *
+ * STUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information 
+ *  nPortIndex         : Port that this structure applies to
+ *  eFormat            : Version of RV stream / data
+ *  nBitsPerPixel      : Bits per pixel coded in the frame
+ *  nPaddedWidth       : Padded width in pixel of a video frame
+ *  nPaddedHeight      : Padded Height in pixels of a video frame
+ *  nFrameRate         : Rate of video in frames per second
+ *  nBitstreamFlags    : Flags which internal information about the bitstream
+ *  nBitstreamVersion  : Bitstream version
+ *  nMaxEncodeFrameSize: Max encoded frame size
+ *  bEnablePostFilter  : Turn on/off post filter
+ *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
+ *  bEnableLatencyMode : When enabled, the decoder does not display a decoded 
+ *                       frame until it has detected that no enhancement layer 
+ *  					 frames or dependent B frames will be coming. This 
+ *  					 detection usually occurs when a subsequent non-B 
+ *  					 frame is encountered 
+ */
+typedef struct OMX_VIDEO_PARAM_RVTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_RVFORMATTYPE eFormat;
+    OMX_U16 nBitsPerPixel;
+    OMX_U16 nPaddedWidth;
+    OMX_U16 nPaddedHeight;
+    OMX_U32 nFrameRate;
+    OMX_U32 nBitstreamFlags;
+    OMX_U32 nBitstreamVersion;
+    OMX_U32 nMaxEncodeFrameSize;
+    OMX_BOOL bEnablePostFilter;
+    OMX_BOOL bEnableTemporalInterpolation;
+    OMX_BOOL bEnableLatencyMode;
+} OMX_VIDEO_PARAM_RVTYPE;
+
+
+/** 
+ * AVC profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ */
+typedef enum OMX_VIDEO_AVCPROFILETYPE {
+    OMX_VIDEO_AVCProfileBaseline = 0x01,   /**< Baseline profile */
+    OMX_VIDEO_AVCProfileMain     = 0x02,   /**< Main profile */
+    OMX_VIDEO_AVCProfileExtended = 0x04,   /**< Extended profile */
+    OMX_VIDEO_AVCProfileHigh     = 0x08,   /**< High profile */
+    OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
+    OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
+    OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
+    OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF  
+} OMX_VIDEO_AVCPROFILETYPE;
+
+
+/** 
+ * AVC level types, each level indicates support for various frame sizes, 
+ * bit rates, decoder frame rates.  No need 
+ */
+typedef enum OMX_VIDEO_AVCLEVELTYPE {
+    OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
+    OMX_VIDEO_AVCLevel1b  = 0x02,     /**< Level 1b */
+    OMX_VIDEO_AVCLevel11  = 0x04,     /**< Level 1.1 */
+    OMX_VIDEO_AVCLevel12  = 0x08,     /**< Level 1.2 */
+    OMX_VIDEO_AVCLevel13  = 0x10,     /**< Level 1.3 */
+    OMX_VIDEO_AVCLevel2   = 0x20,     /**< Level 2 */
+    OMX_VIDEO_AVCLevel21  = 0x40,     /**< Level 2.1 */
+    OMX_VIDEO_AVCLevel22  = 0x80,     /**< Level 2.2 */
+    OMX_VIDEO_AVCLevel3   = 0x100,    /**< Level 3 */
+    OMX_VIDEO_AVCLevel31  = 0x200,    /**< Level 3.1 */
+    OMX_VIDEO_AVCLevel32  = 0x400,    /**< Level 3.2 */
+    OMX_VIDEO_AVCLevel4   = 0x800,    /**< Level 4 */
+    OMX_VIDEO_AVCLevel41  = 0x1000,   /**< Level 4.1 */
+    OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
+    OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
+    OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
+    OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_AVCLEVELTYPE;
+
+
+/** 
+ * AVC loop filter modes 
+ *
+ * OMX_VIDEO_AVCLoopFilterEnable               : Enable
+ * OMX_VIDEO_AVCLoopFilterDisable              : Disable
+ * OMX_VIDEO_AVCLoopFilterDisableSliceBoundary : Disabled on slice boundaries
+ */
+typedef enum OMX_VIDEO_AVCLOOPFILTERTYPE {
+    OMX_VIDEO_AVCLoopFilterEnable = 0,
+    OMX_VIDEO_AVCLoopFilterDisable,
+    OMX_VIDEO_AVCLoopFilterDisableSliceBoundary,
+    OMX_VIDEO_AVCLoopFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCLoopFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
+} OMX_VIDEO_AVCLOOPFILTERTYPE;
+
+
+/** 
+ * AVC params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                     : Size of the structure in bytes
+ *  nVersion                  : OMX specification version information
+ *  nPortIndex                : Port that this structure applies to
+ *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put  
+ *                              zero if not used
+ *  nPFrames                  : Number of P frames between each I frame
+ *  nBFrames                  : Number of B frames between each I frame
+ *  bUseHadamard              : Enable/disable Hadamard transform
+ *  nRefFrames                : Max number of reference frames to use for inter
+ *                              motion search (1-16)
+ *  nRefIdxTrailing           : Pic param set ref frame index (index into ref
+ *                              frame buffer of trailing frames list), B frame
+ *                              support
+ *  nRefIdxForward            : Pic param set ref frame index (index into ref
+ *                              frame buffer of forward frames list), B frame
+ *                              support
+ *  bEnableUEP                : Enable/disable unequal error protection. This 
+ *                              is only valid of data partitioning is enabled.
+ *  bEnableFMO                : Enable/disable flexible macroblock ordering
+ *  bEnableASO                : Enable/disable arbitrary slice ordering
+ *  bEnableRS                 : Enable/disable sending of redundant slices
+ *  eProfile                  : AVC profile(s) to use
+ *  eLevel                    : AVC level(s) to use
+ *  nAllowedPictureTypes      : Specifies the picture types allowed in the 
+ *                              bitstream
+ *  bFrameMBsOnly             : specifies that every coded picture of the 
+ *                              coded video sequence is a coded frame 
+ *                              containing only frame macroblocks
+ *  bMBAFF                    : Enable/disable switching between frame and 
+ *                              field macroblocks within a picture
+ *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the 
+ *                              syntax elements for which two descriptors appear 
+ *                              in the syntax tables
+ *  bWeightedPPrediction      : Enable/disable weighted prediction shall not 
+ *                              be applied to P and SP slices
+ *  nWeightedBipredicitonMode : Default weighted prediction is applied to B 
+ *                              slices 
+ *  bconstIpred               : Enable/disable intra prediction
+ *  bDirect8x8Inference       : Specifies the method used in the derivation 
+ *                              process for luma motion vectors for B_Skip, 
+ *                              B_Direct_16x16 and B_Direct_8x8 as specified 
+ *                              in subclause 8.4.1.2 of the AVC spec 
+ *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
+ *                              mode used in B slice coding (related to 
+ *                              bDirect8x8Inference) . Spatial direct mode is 
+ *                              more common and should be the default.
+ *  nCabacInitIdx             : Index used to init CABAC contexts
+ *  eLoopFilterMode           : Enable/disable loop filter
+ */
+typedef struct OMX_VIDEO_PARAM_AVCTYPE {
+    OMX_U32 nSize;                 
+    OMX_VERSIONTYPE nVersion;      
+    OMX_U32 nPortIndex;            
+    OMX_U32 nSliceHeaderSpacing;  
+    OMX_U32 nPFrames;     
+    OMX_U32 nBFrames;     
+    OMX_BOOL bUseHadamard;
+    OMX_U32 nRefFrames;  
+	OMX_U32 nRefIdx10ActiveMinus1;
+	OMX_U32 nRefIdx11ActiveMinus1;
+    OMX_BOOL bEnableUEP;  
+    OMX_BOOL bEnableFMO;  
+    OMX_BOOL bEnableASO;  
+    OMX_BOOL bEnableRS;   
+    OMX_VIDEO_AVCPROFILETYPE eProfile;
+	OMX_VIDEO_AVCLEVELTYPE eLevel; 
+    OMX_U32 nAllowedPictureTypes;  
+	OMX_BOOL bFrameMBsOnly;        									
+    OMX_BOOL bMBAFF;               
+    OMX_BOOL bEntropyCodingCABAC;  
+    OMX_BOOL bWeightedPPrediction; 
+    OMX_U32 nWeightedBipredicitonMode; 
+    OMX_BOOL bconstIpred ;
+    OMX_BOOL bDirect8x8Inference;  
+	OMX_BOOL bDirectSpatialTemporal;
+	OMX_U32 nCabacInitIdc;
+	OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
+} OMX_VIDEO_PARAM_AVCTYPE;
+
+typedef struct OMX_VIDEO_PARAM_PROFILELEVELTYPE {
+   OMX_U32 nSize;                 
+   OMX_VERSIONTYPE nVersion;      
+   OMX_U32 nPortIndex;            
+   OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE, 
+                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE, 
+                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
+                               This parameter is valid only for 
+                               OMX_IndexParamVideoProfileLevelQuerySupported index,
+                               For all other indices this parameter is to be ignored. */
+} OMX_VIDEO_PARAM_PROFILELEVELTYPE;
+
+/** 
+ * Structure for dynamically configuring bitrate mode of a codec. 
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  nEncodeBitrate : Target average bitrate to be generated in bps
+ */
+typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
+    OMX_U32 nSize;                          
+    OMX_VERSIONTYPE nVersion;               
+    OMX_U32 nPortIndex;                     
+    OMX_U32 nEncodeBitrate;                 
+} OMX_VIDEO_CONFIG_BITRATETYPE;
+
+/** 
+ * Defines Encoder Frame Rate setting
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information 
+ *  nPortIndex       : Port that this structure applies to
+ *  xEncodeFramerate : Encoding framerate represented in Q16 format
+ */
+typedef struct OMX_CONFIG_FRAMERATETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 xEncodeFramerate; /* Q16 format */
+} OMX_CONFIG_FRAMERATETYPE;
+
+typedef struct OMX_CONFIG_INTRAREFRESHVOPTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL IntraRefreshVOP;
+} OMX_CONFIG_INTRAREFRESHVOPTYPE;
+
+typedef struct OMX_CONFIG_MACROBLOCKERRORMAPTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nErrMapSize;           /* Size of the Error Map in bytes */
+    OMX_U8  ErrMap[1];             /* Error map hint */
+} OMX_CONFIG_MACROBLOCKERRORMAPTYPE;
+
+typedef struct OMX_CONFIG_MBERRORREPORTINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnabled;
+} OMX_CONFIG_MBERRORREPORTINGTYPE;
+
+typedef struct OMX_PARAM_MACROBLOCKSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nMacroblocks;
+} OMX_PARAM_MACROBLOCKSTYPE;
+
+/** 
+ * AVC Slice Mode modes 
+ *
+ * OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
+ * OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
+ * OMX_VIDEO_SLICEMODE_AVCByteSlice : NAL mode, number of bytes per frame
+ */
+typedef enum OMX_VIDEO_AVCSLICEMODETYPE {
+    OMX_VIDEO_SLICEMODE_AVCDefault = 0,
+    OMX_VIDEO_SLICEMODE_AVCMBSlice,
+    OMX_VIDEO_SLICEMODE_AVCByteSlice,
+    OMX_VIDEO_SLICEMODE_AVCKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_SLICEMODE_AVCVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
+} OMX_VIDEO_AVCSLICEMODETYPE;
+
+/** 
+ * AVC FMO Slice Mode Params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNumSliceGroups : Specifies the number of slice groups
+ *  nSliceGroupMapType : Specifies the type of slice groups
+ *  eSliceMode : Specifies the type of slice
+ */
+typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U8 nNumSliceGroups;
+    OMX_U8 nSliceGroupMapType;
+    OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
+} OMX_VIDEO_PARAM_AVCSLICEFMO;
+
+/** 
+ * AVC IDR Period Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nIDRPeriod : Specifies periodicity of IDR frames
+ *  nPFrames : Specifies internal of coding Intra frames
+ */
+typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIDRPeriod;
+    OMX_U32 nPFrames;
+} OMX_VIDEO_CONFIG_AVCINTRAPERIOD;
+
+/** 
+ * AVC NAL Size Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNaluBytes : Specifies the NAL unit size
+ */
+typedef struct OMX_VIDEO_CONFIG_NALSIZE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nNaluBytes;
+} OMX_VIDEO_CONFIG_NALSIZE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
-- 
1.7.9.5

