From ec2f5cc28b331b5be5ea117b7228a353b8562433 Mon Sep 17 00:00:00 2001
From: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
Date: Tue, 30 Jul 2013 19:10:01 +0900
Subject: [PATCH 0796/1083] ARM: shmobile: r8a7791: Add power management
 support

Signed-off-by: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
---
 arch/arm/mach-shmobile/Makefile        |   2 +-
 arch/arm/mach-shmobile/pm-r8a7791.c    | 225 +++++++++++++++++++++++++++++++++
 arch/arm/mach-shmobile/setup-r8a7791.c |   2 +
 3 files changed, 228 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/mach-shmobile/pm-r8a7791.c

diff --git a/arch/arm/mach-shmobile/Makefile b/arch/arm/mach-shmobile/Makefile
index 126a378..1486928 100644
--- a/arch/arm/mach-shmobile/Makefile
+++ b/arch/arm/mach-shmobile/Makefile
@@ -35,7 +35,7 @@ obj-$(CONFIG_ARCH_SH7372)	+= pm-sh7372.o sleep-sh7372.o
 obj-$(CONFIG_ARCH_R8A7740)	+= pm-r8a7740.o
 obj-$(CONFIG_ARCH_R8A7779)	+= pm-r8a7779.o
 obj-$(CONFIG_ARCH_R8A7790)	+= pm-r8a7790.o
-obj-$(CONFIG_ARCH_R8A7791)	+= pm-r8a7790.o
+obj-$(CONFIG_ARCH_R8A7791)	+= pm-r8a7791.o
 
 # Board objects
 obj-$(CONFIG_MACH_G3EVM)	+= board-g3evm.o
diff --git a/arch/arm/mach-shmobile/pm-r8a7791.c b/arch/arm/mach-shmobile/pm-r8a7791.c
new file mode 100644
index 0000000..e764b5b
--- /dev/null
+++ b/arch/arm/mach-shmobile/pm-r8a7791.c
@@ -0,0 +1,225 @@
+/*
+ * r8a7791 Power management support
+ *
+ * Copyright (C) 2013  Renesas Electronics Corporation
+ * Copyright (C) 2011  Renesas Solutions Corp.
+ * Copyright (C) 2011  Magnus Damm
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/pm.h>
+#include <linux/suspend.h>
+#include <linux/err.h>
+#include <linux/pm_clock.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <asm/io.h>
+#include <mach/common.h>
+#include <mach/r8a7791.h>
+
+static void __iomem *r8a7791_sysc_base;
+
+/* SYSC */
+#define SYSC_BASE	0xE6180000
+
+#define SYSCSR		0x000
+#define SYSCISR		0x004
+#define SYSCISCR	0x008
+#define SYSCIER		0x00C
+#define SYSCIMR		0x010
+#define PWRSR0		0x040
+#define PWRSR2		0x0C0
+#define PWRSR3		0x100
+#define PWRSR4		0x140
+#define PWRSR5		0x180
+#define PWRSR6		0x1C0
+
+#define PWRSR_OFFS	0x000
+#define PWROFFCR_OFFS	0x004
+#define PWRONCR_OFFS	0x00C
+#define PWRER_OFFS	0x014
+
+#define SYSCSR_RETRIES	100
+#define SYSCSR_DELAY_US	1
+
+#define SYSCISR_RETRIES		1000
+#define SYSCISR_DELAY_US	1
+
+#if defined(CONFIG_PM) || defined(CONFIG_SMP)
+
+static DEFINE_SPINLOCK(r8a7791_sysc_lock); /* SMP CPUs + I/O devices */
+
+static int r8a7791_sysc_pwr_on_off(struct r8a7791_pm_ch *r8a7791_ch,
+				   int sr_bit, int reg_offs)
+{
+	int k;
+
+	for (k = 0; k < SYSCSR_RETRIES; k++) {
+		if (ioread32(r8a7791_sysc_base + SYSCSR) & (1 << sr_bit))
+			break;
+		udelay(SYSCSR_DELAY_US);
+	}
+
+	if (k == SYSCSR_RETRIES)
+		return -EAGAIN;
+
+	iowrite32(1 << r8a7791_ch->chan_bit,
+		  r8a7791_sysc_base + r8a7791_ch->chan_offs + reg_offs);
+
+	return 0;
+}
+
+static int r8a7791_sysc_pwr_off(struct r8a7791_pm_ch *r8a7791_ch)
+{
+	return r8a7791_sysc_pwr_on_off(r8a7791_ch, 0, PWROFFCR_OFFS);
+}
+
+static int r8a7791_sysc_pwr_on(struct r8a7791_pm_ch *r8a7791_ch)
+{
+	return r8a7791_sysc_pwr_on_off(r8a7791_ch, 1, PWRONCR_OFFS);
+}
+
+static int r8a7791_sysc_update(struct r8a7791_pm_ch *r8a7791_ch,
+			       int (*on_off_fn)(struct r8a7791_pm_ch *))
+{
+	unsigned int isr_mask = 1 << r8a7791_ch->isr_bit;
+	unsigned int chan_mask = 1 << r8a7791_ch->chan_bit;
+	unsigned int status;
+	unsigned long flags;
+	int ret = 0;
+	int k;
+
+	spin_lock_irqsave(&r8a7791_sysc_lock, flags);
+
+	iowrite32(isr_mask, r8a7791_sysc_base + SYSCISCR);
+
+	do {
+		ret = on_off_fn(r8a7791_ch);
+		if (ret)
+			goto out;
+
+		status = ioread32(r8a7791_sysc_base +
+				  r8a7791_ch->chan_offs + PWRER_OFFS);
+	} while (status & chan_mask);
+
+	for (k = 0; k < SYSCISR_RETRIES; k++) {
+		if (ioread32(r8a7791_sysc_base + SYSCISR) & isr_mask)
+			break;
+		udelay(SYSCISR_DELAY_US);
+	}
+
+	if (k == SYSCISR_RETRIES)
+		ret = -EIO;
+
+	iowrite32(isr_mask, r8a7791_sysc_base + SYSCISCR);
+
+ out:
+	spin_unlock_irqrestore(&r8a7791_sysc_lock, flags);
+
+	pr_debug("r8a7791 power domain %d: %02x %02x %02x %02x %02x %02x -> %d\n",
+		 r8a7791_ch->isr_bit, ioread32(r8a7791_sysc_base + PWRSR0),
+		 ioread32(r8a7791_sysc_base + PWRSR2),
+		 ioread32(r8a7791_sysc_base + PWRSR3),
+		 ioread32(r8a7791_sysc_base + PWRSR4),
+		 ioread32(r8a7791_sysc_base + PWRSR5),
+		 ioread32(r8a7791_sysc_base + PWRSR6), ret);
+	return ret;
+}
+
+int r8a7791_sysc_power_down(struct r8a7791_pm_ch *r8a7791_ch)
+{
+	return r8a7791_sysc_update(r8a7791_ch, r8a7791_sysc_pwr_off);
+}
+
+int r8a7791_sysc_power_up(struct r8a7791_pm_ch *r8a7791_ch)
+{
+	return r8a7791_sysc_update(r8a7791_ch, r8a7791_sysc_pwr_on);
+}
+
+static void __init r8a7791_sysc_init(void)
+{
+	r8a7791_sysc_base = ioremap_nocache(SYSC_BASE, PAGE_SIZE);
+	if (!r8a7791_sysc_base)
+		panic("unable to ioremap r8a7791 SYSC hardware block\n");
+
+	/* enable all interrupt sources, but do not use interrupt handler */
+	iowrite32(0x0131000e, r8a7791_sysc_base + SYSCIER);
+	iowrite32(0, r8a7791_sysc_base + SYSCIMR);
+}
+
+#else /* CONFIG_PM || CONFIG_SMP */
+
+static inline void r8a7791_sysc_init(void) {}
+
+#endif /* CONFIG_PM || CONFIG_SMP */
+
+#ifdef CONFIG_PM
+
+static int pd_power_down(struct generic_pm_domain *genpd)
+{
+	return r8a7791_sysc_power_down(to_r8a7791_ch(genpd));
+}
+
+static int pd_power_up(struct generic_pm_domain *genpd)
+{
+	return r8a7791_sysc_power_up(to_r8a7791_ch(genpd));
+}
+
+static bool pd_is_off(struct generic_pm_domain *genpd)
+{
+	struct r8a7791_pm_ch *r8a7791_ch = to_r8a7791_ch(genpd);
+	unsigned int st;
+
+	st = ioread32(r8a7791_sysc_base + r8a7791_ch->chan_offs + PWRSR_OFFS);
+	if (st & (1 << r8a7791_ch->chan_bit))
+		return true;
+
+	return false;
+}
+
+static bool pd_active_wakeup(struct device *dev)
+{
+	return true;
+}
+
+void r8a7791_init_pm_domain(struct r8a7791_pm_domain *r8a7791_pd)
+{
+	struct generic_pm_domain *genpd = &r8a7791_pd->genpd;
+
+	pm_genpd_init(genpd, NULL, false);
+	genpd->dev_ops.stop = pm_clk_suspend;
+	genpd->dev_ops.start = pm_clk_resume;
+	genpd->dev_ops.active_wakeup = pd_active_wakeup;
+	genpd->dev_irq_safe = true;
+	genpd->power_off = pd_power_down;
+	genpd->power_on = pd_power_up;
+
+	if (pd_is_off(&r8a7791_pd->genpd))
+		pd_power_up(&r8a7791_pd->genpd);
+}
+
+void r8a7791_add_device_to_domain(struct r8a7791_pm_domain *r8a7791_pd,
+				 struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	pm_genpd_add_device(&r8a7791_pd->genpd, dev);
+	if (pm_clk_no_clocks(dev))
+		pm_clk_add(dev, NULL);
+}
+
+#endif /* CONFIG_PM */
+
+void __init r8a7791_pm_init(void)
+{
+	static int once;
+
+	if (!once++)
+		r8a7791_sysc_init();
+}
diff --git a/arch/arm/mach-shmobile/setup-r8a7791.c b/arch/arm/mach-shmobile/setup-r8a7791.c
index a5c8715..84121ef 100644
--- a/arch/arm/mach-shmobile/setup-r8a7791.c
+++ b/arch/arm/mach-shmobile/setup-r8a7791.c
@@ -1479,6 +1479,8 @@ static struct resource irqc0_resources[] = {
 
 void __init r8a7791_add_standard_devices(void)
 {
+	r8a7791_pm_init();
+
 	r8a7791_register_scif(SCIFA0);
 	r8a7791_register_scif(SCIFA1);
 	r8a7791_register_scif(SCIFB0);
-- 
1.8.3.2

